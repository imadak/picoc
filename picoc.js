/**
 * @license
 * Copyright 2010 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module !== 'undefined' ? Module : {};

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// {{PRE_JSES}}

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
var key;
for (key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = function(status, toThrow) {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

var ENVIRONMENT_IS_WEB = false;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;
ENVIRONMENT_IS_WEB = typeof window === 'object';
ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string';
ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;




// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
    readAsync,
    readBinary,
    setWindowTitle;

var nodeFS;
var nodePath;

if (ENVIRONMENT_IS_NODE) {
  if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = require('path').dirname(scriptDirectory) + '/';
  } else {
    scriptDirectory = __dirname + '/';
  }


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

  read_ = function shell_read(filename, binary) {
    var ret = tryParseAsDataURI(filename);
    if (ret) {
      return binary ? ret : ret.toString();
    }
    if (!nodeFS) nodeFS = require('fs');
    if (!nodePath) nodePath = require('path');
    filename = nodePath['normalize'](filename);
    return nodeFS['readFileSync'](filename, binary ? null : 'utf8');
  };

  readBinary = function readBinary(filename) {
    var ret = read_(filename, true);
    if (!ret.buffer) {
      ret = new Uint8Array(ret);
    }
    assert(ret.buffer);
    return ret;
  };




  if (process['argv'].length > 1) {
    thisProgram = process['argv'][1].replace(/\\/g, '/');
  }

  arguments_ = process['argv'].slice(2);

  if (typeof module !== 'undefined') {
    module['exports'] = Module;
  }

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });

  process['on']('unhandledRejection', abort);

  quit_ = function(status) {
    process['exit'](status);
  };

  Module['inspect'] = function () { return '[Emscripten Module object]'; };



} else
if (ENVIRONMENT_IS_SHELL) {


  if (typeof read != 'undefined') {
    read_ = function shell_read(f) {
      var data = tryParseAsDataURI(f);
      if (data) {
        return intArrayToString(data);
      }
      return read(f);
    };
  }

  readBinary = function readBinary(f) {
    var data;
    data = tryParseAsDataURI(f);
    if (data) {
      return data;
    }
    if (typeof readbuffer === 'function') {
      return new Uint8Array(readbuffer(f));
    }
    data = read(f, 'binary');
    assert(typeof data === 'object');
    return data;
  };

  if (typeof scriptArgs != 'undefined') {
    arguments_ = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    arguments_ = arguments;
  }

  if (typeof quit === 'function') {
    quit_ = function(status) {
      quit(status);
    };
  }

  if (typeof print !== 'undefined') {
    // Prefer to use print/printErr where they exist, as they usually work better.
    if (typeof console === 'undefined') console = /** @type{!Console} */({});
    console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);
    console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (typeof printErr !== 'undefined' ? printErr : print);
  }


} else

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }


  // Differentiate the Web Worker from the Node Worker case, as reading must
  // be done differently.
  {


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

  read_ = function shell_read(url) {
    try {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
    } catch (err) {
      var data = tryParseAsDataURI(url);
      if (data) {
        return intArrayToString(data);
      }
      throw err;
    }
  };

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = function readBinary(url) {
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
      } catch (err) {
        var data = tryParseAsDataURI(url);
        if (data) {
          return data;
        }
        throw err;
      }
    };
  }

  readAsync = function readAsync(url, onload, onerror) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function xhr_onload() {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      var data = tryParseAsDataURI(url);
      if (data) {
        onload(data.buffer);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  };




  }

  setWindowTitle = function(title) { document.title = title };
} else
{
}


// Set up the out() and err() hooks, which are how we can print to stdout or
// stderr, respectively.
var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);

// Merge back in the overrides
for (key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.
if (Module['arguments']) arguments_ = Module['arguments'];
if (Module['thisProgram']) thisProgram = Module['thisProgram'];
if (Module['quit']) quit_ = Module['quit'];

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message



/**
 * @license
 * Copyright 2017 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// {{PREAMBLE_ADDITIONS}}

var STACK_ALIGN = 16;


function dynamicAlloc(size) {
  var ret = HEAP32[DYNAMICTOP_PTR>>2];
  var end = (ret + size + 15) & -16;
  HEAP32[DYNAMICTOP_PTR>>2] = end;
  return ret;
}

function alignMemory(size, factor) {
  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default
  return Math.ceil(size / factor) * factor;
}

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': return 1;
    case 'i16': return 2;
    case 'i32': return 4;
    case 'i64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length-1] === '*') {
        return 4; // A pointer
      } else if (type[0] === 'i') {
        var bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}





/**
 * @license
 * Copyright 2020 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */


// Wraps a JS function as a wasm function with a given signature.
function convertJsFunctionToWasm(func, sig) {
  return func;
}

var freeTableIndexes = [];

// Weak map of functions in the table to their indexes, created on first use.
var functionsInTableMap;

// Add a wasm function to the table.
function addFunctionWasm(func, sig) {
  var table = wasmTable;

  // Check if the function is already in the table, to ensure each function
  // gets a unique index. First, create the map if this is the first use.
  if (!functionsInTableMap) {
    functionsInTableMap = new WeakMap();
    for (var i = 0; i < table.length; i++) {
      var item = table.get(i);
      // Ignore null values.
      if (item) {
        functionsInTableMap.set(item, i);
      }
    }
  }
  if (functionsInTableMap.has(func)) {
    return functionsInTableMap.get(func);
  }

  // It's not in the table, add it now.
  var ret;
  // Reuse a free index if there is one, otherwise grow.
  if (freeTableIndexes.length) {
    ret = freeTableIndexes.pop();
  } else {
    ret = table.length;
    // Grow the table
    try {
      table.grow(1);
    } catch (err) {
      if (!(err instanceof RangeError)) {
        throw err;
      }
      throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
    }
  }

  // Set the new value.
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    table.set(ret, func);
  } catch (err) {
    if (!(err instanceof TypeError)) {
      throw err;
    }
    assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction');
    var wrapped = convertJsFunctionToWasm(func, sig);
    table.set(ret, wrapped);
  }

  functionsInTableMap[func] = ret;

  return ret;
}

function removeFunctionWasm(index) {
  functionsInTableMap.delete(wasmTable.get(index));
  freeTableIndexes.push(index);
}

// 'sig' parameter is required for the llvm backend but only when func is not
// already a WebAssembly function.
function addFunction(func, sig) {

  return addFunctionWasm(func, sig);
}

function removeFunction(index) {
  removeFunctionWasm(index);
}



var funcWrappers = {};

function getFuncWrapper(func, sig) {
  if (!func) return; // on null pointer, return undefined
  assert(sig);
  if (!funcWrappers[sig]) {
    funcWrappers[sig] = {};
  }
  var sigCache = funcWrappers[sig];
  if (!sigCache[func]) {
    // optimize away arguments usage in common cases
    if (sig.length === 1) {
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func);
      };
    } else if (sig.length === 2) {
      sigCache[func] = function dynCall_wrapper(arg) {
        return dynCall(sig, func, [arg]);
      };
    } else {
      // general case
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func, Array.prototype.slice.call(arguments));
      };
    }
  }
  return sigCache[func];
}


/**
 * @license
 * Copyright 2020 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */




function makeBigInt(low, high, unsigned) {
  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));
}

/** @param {Array=} args */
function dynCall(sig, ptr, args) {
  if (args && args.length) {
    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));
  } else {
    return Module['dynCall_' + sig].call(null, ptr);
  }
}

var tempRet0 = 0;

var setTempRet0 = function(value) {
  tempRet0 = value;
};

var getTempRet0 = function() {
  return tempRet0;
};


// The address globals begin at. Very low in memory, for code size and optimization opportunities.
// Above 0 is static memory, starting with globals.
// Then the stack.
// Then 'dynamic' memory for sbrk.
var GLOBAL_BASE = 1024;



/**
 * @license
 * Copyright 2010 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html


var wasmBinary;if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
var noExitRuntime;if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// wasm2js.js - enough of a polyfill for the WebAssembly object so that we can load
// wasm2js code that way.


// Emit "var WebAssembly" if definitely using wasm2js. Otherwise, in MAYBE_WASM2JS
// mode, we can't use a "var" since it would prevent normal wasm from working.
/** @suppress{const} */
var
WebAssembly = {
  Memory: /** @constructor */ function(opts) {
    return {
      buffer: new ArrayBuffer(opts['initial'] * 65536),
      grow: function(amount) {
        var ret = __growWasmMemory(amount);
        return ret;
      }
    };
  },

  Table: function(opts) {
    var ret = new Array(opts['initial']);
    ret.grow = function(by) {
      if (ret.length >= 251 + 0) {
        abort('Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.')
      }
      ret.push(null);
    };
    ret.set = function(i, func) {
      ret[i] = func;
    };
    ret.get = function(i) {
      return ret[i];
    };
    return ret;
  },

  Module: function(binary) {
    // TODO: use the binary and info somehow - right now the wasm2js output is embedded in
    // the main JS
    return {};
  },

  Instance: function(module, info) {
    // TODO: use the module and info somehow - right now the wasm2js output is embedded in
    // the main JS
    // This will be replaced by the actual wasm2js code.
    var exports = (
function instantiate(asmLibraryArg, wasmMemory, wasmTable) {


  var scratchBuffer = new ArrayBuffer(8);
  var i32ScratchView = new Int32Array(scratchBuffer);
  var f32ScratchView = new Float32Array(scratchBuffer);
  var f64ScratchView = new Float64Array(scratchBuffer);
  
  function wasm2js_scratch_load_i32(index) {
    return i32ScratchView[index];
  }
      
  function wasm2js_scratch_store_i32(index, value) {
    i32ScratchView[index] = value;
  }
      
  function wasm2js_scratch_load_f64() {
    return f64ScratchView[0];
  }
      
  function wasm2js_scratch_store_f64(value) {
    f64ScratchView[0] = value;
  }
      
  function legalimport$wasm2js_scratch_store_i64(low, high) {
    i32ScratchView[0] = low;
    i32ScratchView[1] = high;
  }
      
  function wasm2js_scratch_store_f32(value) {
    f32ScratchView[0] = value;
  }
      
  function wasm2js_scratch_load_f32() {
    return f32ScratchView[0];
  }
      
function asmFunc(global, env, buffer) {
 var memory = env.memory;
 var FUNCTION_TABLE = wasmTable;
 var HEAP8 = new global.Int8Array(buffer);
 var HEAP16 = new global.Int16Array(buffer);
 var HEAP32 = new global.Int32Array(buffer);
 var HEAPU8 = new global.Uint8Array(buffer);
 var HEAPU16 = new global.Uint16Array(buffer);
 var HEAPU32 = new global.Uint32Array(buffer);
 var HEAPF32 = new global.Float32Array(buffer);
 var HEAPF64 = new global.Float64Array(buffer);
 var Math_imul = global.Math.imul;
 var Math_fround = global.Math.fround;
 var Math_abs = global.Math.abs;
 var Math_clz32 = global.Math.clz32;
 var Math_min = global.Math.min;
 var Math_max = global.Math.max;
 var Math_floor = global.Math.floor;
 var Math_ceil = global.Math.ceil;
 var Math_sqrt = global.Math.sqrt;
 var abort = env.abort;
 var nan = global.NaN;
 var infinity = global.Infinity;
 var __invoke_i8__i8_ = env.invoke_ii;
 var testSetjmp = env.testSetjmp;
 var emscripten_longjmp = env.emscripten_longjmp;
 var setTempRet0 = env.setTempRet0;
 var getTempRet0 = env.getTempRet0;
 var __invoke_void__struct_Picoc_Struct__i32 = env.invoke_vii;
 var __invoke_i32_i8__i8_ = env.invoke_iii;
 var __invoke_void__struct_Picoc_Struct_ = env.invoke_vi;
 var saveSetjmp = env.saveSetjmp;
 var exit = env.exit;
 var __invoke_void__struct_Picoc_Struct__i32_i8__ = env.invoke_viii;
 var em_exit = env.em_exit;
 var __invoke_void = env.invoke_v;
 var __assert_fail = env.__assert_fail;
 var emscripten_sleep = env.emscripten_sleep;
 var em_stop = env.em_stop;
 var signal = env.signal;
 var em_getchar_sync = env.em_getchar_sync;
 var system = env.system;
 var asctime = env.asctime;
 var clock = env.clock;
 var ctime = env.ctime;
 var difftime = env.difftime;
 var gmtime = env.gmtime;
 var localtime = env.localtime;
 var mktime = env.mktime;
 var time = env.time;
 var strftime = env.strftime;
 var strptime = env.strptime;
 var gmtime_r = env.gmtime_r;
 var timegm = env.timegm;
 var alarm = env.alarm;
 var chroot = env.chroot;
 var confstr = env.confstr;
 var _exit = env._exit;
 var fork = env.fork;
 var fpathconf = env.fpathconf;
 var pathconf = env.pathconf;
 var sysconf = env.sysconf;
 var usleep = env.usleep;
 var vfork = env.vfork;
 var __syscall221 = env.__sys_fcntl64;
 var __wasi_fd_read = env.fd_read;
 var __syscall5 = env.__sys_open;
 var __syscall10 = env.__sys_unlink;
 var __syscall54 = env.__sys_ioctl;
 var __wasi_fd_close = env.fd_close;
 var __syscall40 = env.__sys_rmdir;
 var __wasi_fd_write = env.fd_write;
 var __syscall38 = env.__sys_rename;
 var __syscall3 = env.__sys_read;
 var __syscall132 = env.__sys_getpgid;
 var __syscall34 = env.__sys_nice;
 var __syscall212 = env.__sys_chown32;
 var __syscall12 = env.__sys_chdir;
 var __syscall183 = env.__sys_getcwd;
 var __syscall330 = env.__sys_dup3;
 var __syscall63 = env.__sys_dup2;
 var __syscall57 = env.__sys_setpgid;
 var __syscall41 = env.__sys_dup;
 var __syscall194 = env.__sys_ftruncate64;
 var __syscall29 = env.__sys_pause;
 var __syscall66 = env.__sys_setsid;
 var __syscall207 = env.__sys_fchown32;
 var __syscall133 = env.__sys_fchdir;
 var __syscall198 = env.__sys_lchown32;
 var __syscall83 = env.__sys_symlink;
 var __syscall64 = env.__sys_getppid;
 var __syscall200 = env.__sys_getgid32;
 var __syscall85 = env.__sys_readlink;
 var __syscall201 = env.__sys_geteuid32;
 var __syscall9 = env.__sys_link;
 var __syscall33 = env.__sys_access;
 var __syscall202 = env.__sys_getegid32;
 var __wasi_fd_fdstat_get = env.fd_fdstat_get;
 var __syscall36 = env.__sys_sync;
 var nanosleep = env.nanosleep;
 var __syscall193 = env.__sys_truncate64;
 var __wasi_fd_sync = env.fd_sync;
 var __syscall20 = env.__sys_getpid;
 var __syscall148 = env.__sys_fdatasync;
 var __syscall199 = env.__sys_getuid32;
 var setitimer = env.setitimer;
 var __clock_gettime = env.__clock_gettime;
 var __syscall195 = env.__sys_stat64;
 var __wasi_environ_sizes_get = env.environ_sizes_get;
 var __wasi_environ_get = env.environ_get;
 var abort = env.abort;
 var emscripten_resize_heap = env.emscripten_resize_heap;
 var emscripten_memcpy_big = env.emscripten_memcpy_big;
 var legalimport$__wasi_fd_seek = env.fd_seek;
 var global$0 = 5267440;
 var global$1 = 24556;
 var global$2 = 0;
 var global$3 = 0;
 var i64toi32_i32$HIGH_BITS = 0;
 // EMSCRIPTEN_START_FUNCS
;
 function emscripten_get_sbrk_ptr() {
  return 24560;
 }
 
 function __wasm_call_ctors() {
  __emscripten_environ_constructor();
 }
 
 function main($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -56;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $7 = HEAP32[$5 + 20 >> 2];
   $6 = HEAP32[$5 + 24 >> 2];
   $8 = HEAP32[$5 + 28 >> 2];
   $12 = HEAP32[$5 + 32 >> 2];
   $9 = HEAP32[$5 + 36 >> 2];
   $13 = HEAP32[$5 + 40 >> 2];
   $15 = HEAP32[$5 + 44 >> 2];
   $14 = HEAP32[$5 + 48 >> 2];
   $16 = HEAP32[$5 + 52 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $10 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  folding_inner0 : {
   if (!global$2) {
    $8 = global$0 - 2768 | 0;
    global$0 = $8;
    $7 = dlmalloc(40);
    HEAP32[$7 >> 2] = 0;
    HEAP32[6013] = 0;
    $6 = getenv(1056);
    $2 = HEAP32[6013];
    HEAP32[6013] = 0;
    $4 = -1;
    $12 = 4;
    label$5 : {
     if (!$2) {
      break label$5
     }
     $3 = HEAP32[6014];
     $9 = !$3;
     if ($9) {
      break label$5
     }
     $4 = testSetjmp(HEAP32[$2 >> 2], $7 | 0, 4) | 0;
     $9 = !$4;
     if ($9) {
      break folding_inner0
     }
     setTempRet0($3 | 0);
    }
    $3 = getTempRet0() | 0;
    $2 = ($4 | 0) == 1;
   }
   label$2 : {
    label$7 : {
     label$8 : {
      if (!global$2) {
       if ($2) {
        break label$8
       }
       label$10 : {
        if (!$6) {
         $6 = 131072;
         break label$10;
        }
        HEAP32[6013] = 0;
        $6 = atoi($6);
        $2 = HEAP32[6013];
        HEAP32[6013] = 0;
        $4 = -1;
        label$12 : {
         if (!$2) {
          break label$12
         }
         $3 = HEAP32[6014];
         $9 = !$3;
         if ($9) {
          break label$12
         }
         $4 = testSetjmp(HEAP32[$2 >> 2], $7 | 0, 4) | 0;
         $9 = !$4;
         if ($9) {
          break folding_inner0
         }
         setTempRet0($3 | 0);
        }
        $3 = getTempRet0() | 0;
        $2 = ($4 | 0) == 1;
        if ($2) {
         break label$8
        }
       }
       $2 = ($0 | 0) <= 1;
      }
      label$14 : {
       label$15 : {
        label$16 : {
         label$17 : {
          label$18 : {
           if ((global$2 | 0) == 2 | $2) {
            if (!global$2) {
             HEAP32[6013] = 0
            }
            if (global$2 ? !$10 : 1) {
             $5 = __invoke_i8__i8_(3, 1077) | 0;
             if ((global$2 | 0) == 1) {
              break label$2
             }
             $2 = $5;
            }
            if (!global$2) {
             $2 = HEAP32[6013];
             HEAP32[6013] = 0;
             $4 = -1;
             $3 = !$2;
             if ($3) {
              break label$17
             }
             $3 = HEAP32[6014];
             $6 = !$3;
             if ($6) {
              break label$17
             }
             $4 = testSetjmp(HEAP32[$2 >> 2], $7 | 0, 4) | 0;
             if ($4) {
              break label$18
             }
             break folding_inner0;
            }
           }
           if (!global$2) {
            HEAP32[6013] = 0;
            $2 = $8 + 8 | 0;
           }
           if (global$2 ? ($10 | 0) == 1 : 1) {
            __invoke_void__struct_Picoc_Struct__i32(4, $2 | 0, $6 | 0);
            $11 = 1;
            if ((global$2 | 0) == 1) {
             break label$2
            }
           }
           if (!global$2) {
            $2 = HEAP32[6013];
            HEAP32[6013] = 0;
            $4 = -1;
            $3 = !$2;
            if ($3) {
             break label$15
            }
            $3 = HEAP32[6014];
            $6 = !$3;
            if ($6) {
             break label$15
            }
            $4 = testSetjmp(HEAP32[$2 >> 2], $7 | 0, 4) | 0;
            if ($4) {
             break label$16
            }
            break folding_inner0;
           }
          }
          if (!global$2) {
           setTempRet0($3 | 0)
          }
         }
         if (!global$2) {
          $3 = getTempRet0() | 0;
          $2 = ($4 | 0) != 1;
          if ($2) {
           break label$14
          }
          break label$8;
         }
        }
        if (!global$2) {
         setTempRet0($3 | 0)
        }
       }
       if (!global$2) {
        $3 = getTempRet0() | 0;
        $2 = ($4 | 0) == 1;
        if ($2) {
         break label$8
        }
        $6 = HEAP32[$1 + 4 >> 2];
        HEAP32[6013] = 0;
        $9 = strcmp($6, 1066);
        $2 = HEAP32[6013];
        HEAP32[6013] = 0;
        $4 = -1;
        label$30 : {
         if (!$2) {
          break label$30
         }
         $3 = HEAP32[6014];
         if (!$3) {
          break label$30
         }
         $4 = testSetjmp(HEAP32[$2 >> 2], $7 | 0, 4) | 0;
         if (!$4) {
          break folding_inner0
         }
         setTempRet0($3 | 0);
        }
        $3 = getTempRet0() | 0;
        $2 = ($4 | 0) == 1;
        if ($2) {
         break label$8
        }
       }
       label$32 : {
        if (!global$2) {
         if ($9) {
          HEAP32[6013] = 0;
          $6 = strcmp($6, 1069);
          $2 = HEAP32[6013];
          HEAP32[6013] = 0;
          $4 = -1;
          label$35 : {
           if (!$2) {
            break label$35
           }
           $3 = HEAP32[6014];
           if (!$3) {
            break label$35
           }
           $4 = testSetjmp(HEAP32[$2 >> 2], $7 | 0, 4) | 0;
           if (!$4) {
            break folding_inner0
           }
           setTempRet0($3 | 0);
          }
          $13 = 1;
          $3 = getTempRet0() | 0;
          $2 = ($4 | 0) == 1;
          if ($2) {
           break label$8
          }
          $15 = 0;
          if ($6) {
           break label$32
          }
         }
         HEAP32[6013] = 0;
         $2 = $8 + 8 | 0;
        }
        if (global$2 ? ($10 | 0) == 2 : 1) {
         __invoke_void__struct_Picoc_Struct_(6, $2 | 0);
         $11 = 2;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         $2 = HEAP32[6013];
         HEAP32[6013] = 0;
         $4 = -1;
         label$39 : {
          if (!$2) {
           break label$39
          }
          $3 = HEAP32[6014];
          if (!$3) {
           break label$39
          }
          $4 = testSetjmp(HEAP32[$2 >> 2], $7 | 0, 4) | 0;
          if (!$4) {
           break folding_inner0
          }
          setTempRet0($3 | 0);
         }
         $15 = 1;
         $3 = getTempRet0() | 0;
         $2 = ($4 | 0) == 1;
         if ($2) {
          break label$8
         }
         $13 = 2;
        }
       }
       if (!global$2) {
        $16 = ($13 | 0) < ($0 | 0);
        $2 = ($13 | 0) >= ($0 | 0);
       }
       label$42 : {
        label$43 : {
         label$44 : {
          if (!global$2) {
           if ($2) {
            break label$44
           }
           $2 = HEAP32[($13 << 2) + $1 >> 2];
           HEAP32[6013] = 0;
           $6 = strcmp($2, 1072);
           $2 = HEAP32[6013];
           HEAP32[6013] = 0;
           $4 = -1;
           label$46 : {
            if (!$2) {
             break label$46
            }
            $3 = HEAP32[6014];
            if (!$3) {
             break label$46
            }
            $4 = testSetjmp(HEAP32[$2 >> 2], $7 | 0, 4) | 0;
            if (!$4) {
             break folding_inner0
            }
            setTempRet0($3 | 0);
           }
           $3 = getTempRet0() | 0;
           $2 = ($4 | 0) == 1;
           if ($2) {
            break label$8
           }
           if ($6) {
            break label$44
           }
           HEAP32[6013] = 0;
           $2 = $8 + 8 | 0;
          }
          if (global$2 ? ($10 | 0) == 3 : 1) {
           __invoke_void__struct_Picoc_Struct_(6, $2 | 0);
           $11 = 3;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (!global$2) {
           $2 = HEAP32[6013];
           HEAP32[6013] = 0;
           $4 = -1;
           $3 = !$2;
           if ($3) {
            break label$42
           }
           $3 = HEAP32[6014];
           if (!$3) {
            break label$42
           }
           $4 = testSetjmp(HEAP32[$2 >> 2], $7 | 0, 4) | 0;
           if ($4) {
            break label$43
           }
           break folding_inner0;
          }
         }
         if (!global$2) {
          $3 = 0;
          $2 = $8 + 2212 | 0;
          $7 = saveSetjmp($2 | 0, 1, $7 | 0, 4) | 0;
          $12 = getTempRet0() | 0;
          break label$8;
         }
        }
        if (!global$2) {
         setTempRet0($3 | 0)
        }
       }
       if (!global$2) {
        $3 = getTempRet0() | 0;
        $2 = ($4 | 0) == 1;
        if ($2) {
         break label$8
        }
        HEAP32[6013] = 0;
        $2 = $8 + 8 | 0;
       }
       if (global$2 ? ($10 | 0) == 4 : 1) {
        __invoke_void__struct_Picoc_Struct_(7, $2 | 0);
        $11 = 4;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        $2 = HEAP32[6013];
        HEAP32[6013] = 0;
        $4 = -1;
        label$55 : {
         if (!$2) {
          break label$55
         }
         $3 = HEAP32[6014];
         if (!$3) {
          break label$55
         }
         $4 = testSetjmp(HEAP32[$2 >> 2], $7 | 0, 4) | 0;
         if (!$4) {
          break folding_inner0
         }
         setTempRet0($3 | 0);
        }
        $3 = getTempRet0() | 0;
        $2 = ($4 | 0) == 1;
        if ($2) {
         break label$8
        }
        $2 = 1;
        break label$7;
       }
      }
      if (!global$2) {
       HEAP32[6013] = 0
      }
      if (global$2 ? ($10 | 0) == 5 : 1) {
       __invoke_void__struct_Picoc_Struct_(8, 1);
       $11 = 5;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       $2 = HEAP32[6013];
       HEAP32[6013] = 0;
       label$60 : {
        if (!$2) {
         break label$60
        }
        $4 = HEAP32[6014];
        if (!$4) {
         break label$60
        }
        if (!testSetjmp(HEAP32[$2 >> 2], $7 | 0, 4)) {
         emscripten_longjmp($2 | 0, $4 | 0);
         abort();
        }
        setTempRet0($4 | 0);
       }
       $3 = getTempRet0() | 0;
      }
     }
     $2 = global$2 ? $2 : 0;
    }
    while (1) {
     $2 = global$2 ? $2 : !$2;
     label$63 : {
      if ($2 | (global$2 | 0) == 2) {
       label$65 : {
        if (!global$2) {
         if ($3) {
          break label$65
         }
         $4 = !$16;
         $2 = $13;
        }
        label$67 : {
         if (!global$2) {
          if ($4) {
           break label$67
          }
          $2 = $13;
         }
         while (1) {
          if (!global$2) {
           $4 = HEAP32[($2 << 2) + $1 >> 2];
           HEAP32[6013] = 0;
           $9 = strcmp($4, 1075);
           $3 = HEAP32[6013];
           HEAP32[6013] = 0;
           $6 = -1;
           label$71 : {
            if (!$3) {
             break label$71
            }
            $14 = HEAP32[6014];
            if (!$14) {
             break label$71
            }
            $6 = testSetjmp(HEAP32[$3 >> 2], $7 | 0, $12 | 0) | 0;
            if (!$6) {
             emscripten_longjmp($3 | 0, $14 | 0);
             abort();
            }
            setTempRet0($14 | 0);
           }
           $3 = getTempRet0() | 0;
           if (($6 | 0) == 1) {
            break label$63
           }
           if (!$9) {
            break label$67
           }
           HEAP32[6013] = 0;
           $3 = $8 + 8 | 0;
          }
          if (global$2 ? ($10 | 0) == 6 : 1) {
           __invoke_void__struct_Picoc_Struct__i32(9, $3 | 0, $4 | 0);
           $11 = 6;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (!global$2) {
           $4 = HEAP32[6013];
           HEAP32[6013] = 0;
           $6 = -1;
           label$75 : {
            if (!$4) {
             break label$75
            }
            $3 = HEAP32[6014];
            if (!$3) {
             break label$75
            }
            $6 = testSetjmp(HEAP32[$4 >> 2], $7 | 0, $12 | 0) | 0;
            if (!$6) {
             emscripten_longjmp($4 | 0, $3 | 0);
             abort();
            }
            setTempRet0($3 | 0);
           }
           $3 = getTempRet0() | 0;
           $4 = ($6 | 0) == 1;
           if ($4) {
            break label$63
           }
           $2 = $2 + 1 | 0;
           $4 = ($2 | 0) != ($0 | 0);
           if ($4) {
            continue
           }
          }
          break;
         };
         $2 = global$2 ? $2 : $0;
        }
        if (!global$2) {
         if ($15) {
          break label$65
         }
         HEAP32[6013] = 0;
         $3 = $8 + 8 | 0;
         $4 = $0 - $2 | 0;
         $2 = ($2 << 2) + $1 | 0;
        }
        if (global$2 ? ($10 | 0) == 7 : 1) {
         __invoke_void__struct_Picoc_Struct__i32_i8__(10, $3 | 0, $4 | 0, $2 | 0);
         $11 = 7;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         $2 = HEAP32[6013];
         HEAP32[6013] = 0;
         $4 = -1;
         label$80 : {
          if (!$2) {
           break label$80
          }
          $3 = HEAP32[6014];
          if (!$3) {
           break label$80
          }
          $4 = testSetjmp(HEAP32[$2 >> 2], $7 | 0, $12 | 0) | 0;
          if (!$4) {
           break folding_inner0
          }
          setTempRet0($3 | 0);
         }
         $3 = getTempRet0() | 0;
         $2 = ($4 | 0) == 1;
         if ($2) {
          break label$63
         }
        }
       }
       if (!global$2) {
        $2 = 1;
        continue;
       }
      }
      if (!global$2) {
       HEAP32[6013] = 0;
       $2 = $8 + 8 | 0;
      }
      if (global$2 ? ($10 | 0) == 8 : 1) {
       __invoke_void__struct_Picoc_Struct_(11, $2 | 0);
       $11 = 8;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       $2 = HEAP32[6013];
       HEAP32[6013] = 0;
       $4 = -1;
       label$86 : {
        if (!$2) {
         break label$86
        }
        $3 = HEAP32[6014];
        if (!$3) {
         break label$86
        }
        $4 = testSetjmp(HEAP32[$2 >> 2], $7 | 0, $12 | 0) | 0;
        if (!$4) {
         break folding_inner0
        }
        setTempRet0($3 | 0);
       }
       $3 = getTempRet0() | 0;
       $2 = ($4 | 0) == 1;
       if ($2) {
        break label$63
       }
       HEAP32[6013] = 0;
      }
      if (global$2 ? ($10 | 0) == 9 : 1) {
       $5 = __invoke_i8__i8_(12, 10) | 0;
       $11 = 9;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $2 = $5;
      }
      if (!global$2) {
       $2 = HEAP32[6013];
       HEAP32[6013] = 0;
       $4 = -1;
       label$90 : {
        if (!$2) {
         break label$90
        }
        $3 = HEAP32[6014];
        if (!$3) {
         break label$90
        }
        $4 = testSetjmp(HEAP32[$2 >> 2], $7 | 0, $12 | 0) | 0;
        if (!$4) {
         break folding_inner0
        }
        setTempRet0($3 | 0);
       }
       $3 = getTempRet0() | 0;
       if (($4 | 0) == 1) {
        break label$63
       }
       HEAP32[6013] = 0;
       $2 = HEAP32[3226];
      }
      if (global$2 ? ($10 | 0) == 10 : 1) {
       __invoke_i8__i8_(13, $2 | 0) | 0;
       $11 = 10;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       $2 = HEAP32[6013];
       HEAP32[6013] = 0;
       $4 = -1;
       label$94 : {
        if (!$2) {
         break label$94
        }
        $3 = HEAP32[6014];
        if (!$3) {
         break label$94
        }
        $4 = testSetjmp(HEAP32[$2 >> 2], $7 | 0, $12 | 0) | 0;
        if (!$4) {
         break folding_inner0
        }
        setTempRet0($3 | 0);
       }
       $3 = getTempRet0() | 0;
       if (($4 | 0) == 1) {
        break label$63
       }
       HEAP32[6013] = 0;
      }
      if (global$2 ? ($10 | 0) == 11 : 1) {
       __invoke_void(14);
       $11 = 11;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       $2 = HEAP32[6013];
       HEAP32[6013] = 0;
       $4 = -1;
       label$98 : {
        if (!$2) {
         break label$98
        }
        $3 = HEAP32[6014];
        if (!$3) {
         break label$98
        }
        $4 = testSetjmp(HEAP32[$2 >> 2], $7 | 0, $12 | 0) | 0;
        if (!$4) {
         break folding_inner0
        }
        setTempRet0($3 | 0);
       }
       $3 = getTempRet0() | 0;
       if (($4 | 0) == 1) {
        break label$63
       }
       $2 = HEAP32[$8 + 1316 >> 2];
       dlfree($7);
       global$0 = $8 + 2768 | 0;
       return $2 | 0;
      }
     }
     if (!global$2) {
      $2 = 0;
      continue;
     }
     break;
    };
    abort();
   }
   $5 = $11;
   HEAP32[HEAP32[global$3 >> 2] >> 2] = $5;
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
   $5 = HEAP32[global$3 >> 2];
   HEAP32[$5 >> 2] = $0;
   HEAP32[$5 + 4 >> 2] = $1;
   HEAP32[$5 + 8 >> 2] = $2;
   HEAP32[$5 + 12 >> 2] = $3;
   HEAP32[$5 + 16 >> 2] = $4;
   HEAP32[$5 + 20 >> 2] = $7;
   HEAP32[$5 + 24 >> 2] = $6;
   HEAP32[$5 + 28 >> 2] = $8;
   HEAP32[$5 + 32 >> 2] = $12;
   HEAP32[$5 + 36 >> 2] = $9;
   HEAP32[$5 + 40 >> 2] = $13;
   HEAP32[$5 + 44 >> 2] = $15;
   HEAP32[$5 + 48 >> 2] = $14;
   HEAP32[$5 + 52 >> 2] = $16;
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 56;
   return 0;
  }
  emscripten_longjmp($2 | 0, $3 | 0);
  abort();
 }
 
 function TableInit($0) {
  var $1 = 0, $2 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $1 = $0 + 2360 | 0;
   TableInitTable($1, $0 + 2368 | 0, 97, 1);
  }
  label$2 : {
   if (global$2 ? !$2 : 1) {
    $2 = TableStrRegister($0, 1336);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $2;
   }
   if (!global$2) {
    HEAP32[$0 + 2756 >> 2] = $1
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function TableInitTable($0, $1, $2, $3) {
  HEAP32[$0 + 4 >> 2] = $1;
  HEAP16[$0 + 2 >> 1] = $3;
  HEAP16[$0 >> 1] = $2;
  memset($1, 0, $2 << 2);
 }
 
 function TableStrRegister($0, $1) {
  var $2 = 0, $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $2 = strlen($1)
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    $3 = TableStrRegister2($0, $1, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $3;
   }
   if (!global$2) {
    return $0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
  return 0;
 }
 
 function TableStrRegister2($0, $1, $2) {
  var $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
  } else {
   $3 = 0
  }
  $4 = global$2 ? $3 : $0 + 2360 | 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $3 = 0
  }
  label$1 : {
   if (global$2 ? !$3 : 1) {
    $3 = TableSetIdentifier($0, $4, $1, $2);
    if ((global$2 | 0) == 1) {
     break label$1
    }
    $0 = $3;
   }
   if (!global$2) {
    return $0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function TableSet($0, $1, $2, $3, $4, $5, $6) {
  var $7 = 0, $8 = 0, $9 = 0, $10 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -40;
   $8 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$8 >> 2];
   $1 = HEAP32[$8 + 4 >> 2];
   $2 = HEAP32[$8 + 8 >> 2];
   $3 = HEAP32[$8 + 12 >> 2];
   $4 = HEAP32[$8 + 16 >> 2];
   $5 = HEAP32[$8 + 20 >> 2];
   $6 = HEAP32[$8 + 24 >> 2];
   $7 = HEAP32[$8 + 28 >> 2];
   $10 = HEAP32[$8 + 32 >> 2];
   $8 = HEAP32[$8 + 36 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $9 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $10 = global$0 - 16 | 0;
   global$0 = $10;
   $8 = !TableSearch($1, $2, $10 + 12 | 0);
   $7 = 0;
  }
  label$2 : {
   if ((global$2 | 0) == 2 | $8) {
    $7 = global$2 ? $7 : HEAP16[$1 + 2 >> 1];
    if (global$2 ? !$9 : 1) {
     $9 = VariableAlloc($0, 0, 20, $7);
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $7 = $9;
    }
    if (!global$2) {
     HEAP32[$7 + 16 >> 2] = $3;
     HEAP32[$7 + 12 >> 2] = $2;
     HEAP16[$7 + 10 >> 1] = $6;
     HEAP16[$7 + 8 >> 1] = $5;
     HEAP32[$7 + 4 >> 2] = $4;
     $1 = HEAP32[$1 + 4 >> 2] + (HEAP32[$10 + 12 >> 2] << 2) | 0;
     HEAP32[$7 >> 2] = HEAP32[$1 >> 2];
     HEAP32[$1 >> 2] = $7;
     $7 = 1;
    }
   }
   if (!global$2) {
    global$0 = $10 + 16 | 0;
    return $7;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $9 = HEAP32[global$3 >> 2];
  HEAP32[$9 >> 2] = $0;
  HEAP32[$9 + 4 >> 2] = $1;
  HEAP32[$9 + 8 >> 2] = $2;
  HEAP32[$9 + 12 >> 2] = $3;
  HEAP32[$9 + 16 >> 2] = $4;
  HEAP32[$9 + 20 >> 2] = $5;
  HEAP32[$9 + 24 >> 2] = $6;
  HEAP32[$9 + 28 >> 2] = $7;
  HEAP32[$9 + 32 >> 2] = $10;
  HEAP32[$9 + 36 >> 2] = $8;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 40;
  return 0;
 }
 
 function TableSearch($0, $1, $2) {
  var $3 = 0;
  $3 = ($1 >>> 0) % (HEAP16[$0 >> 1] >>> 0) | 0;
  $0 = HEAP32[HEAP32[$0 + 4 >> 2] + ($3 << 2) >> 2];
  label$1 : {
   if ($0) {
    while (1) {
     if (HEAP32[$0 + 12 >> 2] == ($1 | 0)) {
      break label$1
     }
     $0 = HEAP32[$0 >> 2];
     if ($0) {
      continue
     }
     break;
    }
   }
   HEAP32[$2 >> 2] = $3;
   $0 = 0;
  }
  return $0;
 }
 
 function TableGet($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  $6 = global$0 - 16 | 0;
  global$0 = $6;
  $0 = TableSearch($0, $1, $6 + 12 | 0);
  label$1 : {
   if (!$0) {
    $1 = 0;
    break label$1;
   }
   HEAP32[$2 >> 2] = HEAP32[$0 + 16 >> 2];
   $1 = 1;
   if (!$3) {
    break label$1
   }
   HEAP32[$3 >> 2] = HEAP32[$0 + 4 >> 2];
   HEAP32[$4 >> 2] = HEAPU16[$0 + 8 >> 1];
   HEAP32[$5 >> 2] = HEAPU16[$0 + 10 >> 1];
  }
  global$0 = $6 + 16 | 0;
  return $1;
 }
 
 function TableDelete($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $3 = HEAP32[$1 + 4 >> 2] + (($2 >>> 0) % (HEAP16[$1 >> 1] >>> 0) << 2) | 0;
  $1 = HEAP32[$3 >> 2];
  label$1 : {
   if (!$1) {
    break label$1
   }
   if (HEAP32[$1 + 12 >> 2] != ($2 | 0)) {
    while (1) {
     $3 = $1;
     $1 = HEAP32[$1 >> 2];
     if (!$1) {
      break label$1
     }
     if (HEAP32[$1 + 12 >> 2] != ($2 | 0)) {
      continue
     }
     break;
    }
   }
   $4 = HEAP32[$1 + 16 >> 2];
   HEAP32[$3 >> 2] = HEAP32[$1 >> 2];
   HeapFreeMem($0, $1);
  }
  return $4;
 }
 
 function TableSetIdentifier($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -28;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $7 = HEAP32[$4 + 20 >> 2];
   $4 = HEAP32[$4 + 24 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $7 = global$0 - 16 | 0;
   global$0 = $7;
   $5 = TableSearchIdentifier($1, $2, $3, $7 + 12 | 0);
  }
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($5) {
      $2 = $5 + 12 | 0;
      break label$5;
     }
     $5 = HeapAllocMem($0, $3 + 13 | 0);
     $4 = !$5;
    }
    if ((global$2 | 0) == 2 | $4) {
     if (global$2 ? !$6 : 1) {
      ProgramFailNoParser($0, 1337, 0);
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (!global$2) {
     $2 = strncpy($5 + 12 | 0, $2, $3);
     HEAP8[$3 + $2 | 0] = 0;
     $3 = HEAP32[$1 + 4 >> 2] + (HEAP32[$7 + 12 >> 2] << 2) | 0;
     HEAP32[$5 >> 2] = HEAP32[$3 >> 2];
     HEAP32[$3 >> 2] = $5;
    }
   }
   if (!global$2) {
    global$0 = $7 + 16 | 0;
    return $2;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $5;
  HEAP32[$6 + 20 >> 2] = $7;
  HEAP32[$6 + 24 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 28;
  return 0;
 }
 
 function TableSearchIdentifier($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;
  $4 = HEAP32[$0 + 4 >> 2];
  $5 = (TableHash($1, $2) >>> 0) % (HEAP16[$0 >> 1] >>> 0) | 0;
  $0 = HEAP32[$4 + ($5 << 2) >> 2];
  label$1 : {
   if ($0) {
    while (1) {
     $4 = $0 + 12 | 0;
     if (wasm2js_i32$0 = 0, wasm2js_i32$1 = !strncmp($4, $1, $2), wasm2js_i32$2 = HEAPU8[$2 + $4 | 0], wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1) {
      break label$1
     }
     $0 = HEAP32[$0 >> 2];
     if ($0) {
      continue
     }
     break;
    }
   }
   HEAP32[$3 >> 2] = $5;
   $0 = 0;
  }
  return $0;
 }
 
 function TableHash($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  if (($1 | 0) < 1) {
   return $1
  }
  $2 = 8;
  $3 = $1;
  while (1) {
   $4 = $2 >>> 0 > 25 ? $2 + -26 | 0 : $2;
   $2 = $4 + 7 | 0;
   $3 = HEAP8[$0 | 0] << $4 ^ $3;
   $0 = $0 + 1 | 0;
   $5 = $5 + 1 | 0;
   if (($5 | 0) != ($1 | 0)) {
    continue
   }
   break;
  };
  return $3;
 }
 
 function TableStrFree($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  if (HEAP16[$0 + 2360 >> 1] >= 1) {
   while (1) {
    $1 = HEAP32[HEAP32[$0 + 2364 >> 2] + ($2 << 2) >> 2];
    if ($1) {
     while (1) {
      $3 = HEAP32[$1 >> 2];
      HeapFreeMem($0, $1);
      $1 = $3;
      if ($1) {
       continue
      }
      break;
     }
    }
    $2 = $2 + 1 | 0;
    if (($2 | 0) < HEAP16[$0 + 2360 >> 1]) {
     continue
    }
    break;
   }
  }
 }
 
 function LexInit($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $2 = HEAP32[$1 + 12 >> 2];
   $5 = HEAP32[$1 + 16 >> 2];
   $4 = HEAP32[$1 + 8 >> 2];
   $3 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = $0 + 512 | 0;
   TableInitTable($5, $0 + 520 | 0, 78, 1);
   $3 = 0;
  }
  label$2 : {
   while (1) {
    if (!global$2) {
     $2 = ($3 << 3) + 18464 | 0;
     $4 = HEAP32[$2 >> 2];
    }
    if (global$2 ? !$6 : 1) {
     $1 = TableStrRegister($0, $4);
     $7 = 0;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $4 = $1;
    }
    if (global$2 ? ($6 | 0) == 1 : 1) {
     TableSet($0, $5, $4, $2, 0, 0, 0);
     $7 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (!global$2) {
     $3 = $3 + 1 | 0;
     $2 = ($3 | 0) != 39;
     if ($2) {
      continue
     }
    }
    break;
   };
   if (!global$2) {
    HEAP32[$0 + 488 >> 2] = 0;
    HEAP32[$0 + 496 >> 2] = 0;
    HEAP32[$0 + 500 >> 2] = 0;
    HEAP32[$0 + 492 >> 2] = $0 + 416;
   }
   return;
  }
  $1 = $7;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $3;
  HEAP32[$1 + 8 >> 2] = $4;
  HEAP32[$1 + 12 >> 2] = $2;
  HEAP32[$1 + 16 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function LexCleanup($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $3 = HEAP32[$1 + 8 >> 2];
   $4 = HEAP32[$1 + 12 >> 2];
   $2 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   LexInteractiveClear($0, 0);
   $4 = $0 + 512 | 0;
   $3 = 0;
  }
  label$2 : {
   while (1) {
    $2 = global$2 ? $2 : HEAP32[($3 << 3) + 18464 >> 2];
    if (global$2 ? !$5 : 1) {
     $1 = TableStrRegister($0, $2);
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $2 = $1;
    }
    if (!global$2) {
     TableDelete($0, $4, $2);
     $3 = $3 + 1 | 0;
     $2 = ($3 | 0) != 39;
     if ($2) {
      continue
     }
    }
    break;
   };
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP32[$1 + 8 >> 2] = $3;
  HEAP32[$1 + 12 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function LexInteractiveClear($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0;
  $2 = HEAP32[$0 + 400 >> 2];
  if ($2) {
   while (1) {
    $3 = HEAP32[$2 >> 2];
    HeapFreeMem($0, HEAP32[$2 + 4 >> 2]);
    HeapFreeMem($0, HEAP32[$0 + 400 >> 2]);
    HEAP32[$0 + 400 >> 2] = $3;
    $2 = $3;
    if ($2) {
     continue
    }
    break;
   }
  }
  if ($1) {
   HEAP32[$1 + 4 >> 2] = 0
  }
  HEAP32[$0 + 404 >> 2] = 0;
 }
 
 function LexCheckReservedWord($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = global$0 - 16 | 0;
  global$0 = $2;
  if (TableGet($0 + 512 | 0, $1, $2 + 12 | 0, 0, 0, 0)) {
   $3 = HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2]
  }
  global$0 = $2 + 16 | 0;
  return $3;
 }
 
 function LexGetNumber($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0.0, $10 = 0.0, $11 = 0.0;
  $5 = 10;
  $3 = HEAP32[$1 >> 2];
  label$1 : {
   if (HEAPU8[$3 | 0] != 48) {
    break label$1
   }
   $4 = $3 + 1 | 0;
   HEAP32[$1 >> 2] = $4;
   $6 = HEAP32[$1 + 16 >> 2];
   HEAP32[$1 + 16 >> 2] = $6 + 1;
   if (HEAP32[$1 + 4 >> 2] == ($4 | 0)) {
    break label$1
   }
   label$2 : {
    label$3 : {
     label$4 : {
      $4 = HEAPU8[$4 | 0];
      if (($4 | 0) <= 87) {
       if (($4 | 0) == 46) {
        break label$1
       }
       if (($4 | 0) != 66) {
        break label$4
       }
       break label$2;
      }
      $5 = $4 + -88 | 0;
      if ($5 >>> 0 > 10) {
       if (($4 | 0) != 120) {
        break label$4
       }
       break label$3;
      }
      switch ($5 - 1 | 0) {
      case 9:
       break label$2;
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
       break label$4;
      default:
       break label$3;
      };
     }
     $5 = 8;
     break label$1;
    }
    HEAP32[$1 + 16 >> 2] = $6 + 2;
    HEAP32[$1 >> 2] = $3 + 2;
    $5 = 16;
    break label$1;
   }
   $5 = 2;
   HEAP32[$1 + 16 >> 2] = $6 + 2;
   HEAP32[$1 >> 2] = $3 + 2;
  }
  $4 = HEAP32[$1 >> 2];
  label$7 : {
   if (($4 | 0) == HEAP32[$1 + 4 >> 2]) {
    $6 = 0;
    break label$7;
   }
   $7 = ($5 >>> 0 < 10 ? $5 : 10) | 48;
   $6 = 0;
   $8 = $5 >>> 0 < 11;
   while (1) {
    $3 = HEAP8[$4 | 0];
    if ((($3 & -33) + -65 & 255) >>> 0 > 5 | $8 ? !(($7 | 0) > ($3 | 0) ? ($3 | 0) >= 48 : 0) : 0) {
     break label$7
    }
    $4 = $4 + 1 | 0;
    HEAP32[$1 >> 2] = $4;
    HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
    $6 = (Math_imul($5, $6) + $3 | 0) + (($3 | 0) < 58 ? -48 : ($3 | 0) < 71 ? -55 : -87) | 0;
    if (HEAP32[$1 + 4 >> 2] != ($4 | 0)) {
     continue
    }
    break;
   };
  }
  if ((HEAPU8[$4 | 0] | 32) == 117) {
   HEAP32[$1 >> 2] = $4 + 1;
   HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
  }
  $3 = HEAP32[$1 >> 2];
  if ((HEAPU8[$3 | 0] | 32) == 108) {
   HEAP32[$1 >> 2] = $3 + 1;
   HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
  }
  HEAP32[$2 >> 2] = $0 + 1544;
  HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = $6;
  $3 = HEAP32[$1 >> 2];
  $7 = HEAP32[$1 + 4 >> 2];
  if (($3 | 0) == ($7 | 0)) {
   return 46
  }
  $4 = 46;
  $8 = HEAPU8[$3 | 0];
  label$14 : {
   if (($8 | 0) != 69 ? !(($8 | 0) == 46 | ($8 | 0) == 101) : 0) {
    break label$14
   }
   HEAP32[$2 >> 2] = $0 + 1764;
   $10 = +($6 | 0);
   label$16 : {
    if (HEAPU8[$3 | 0] != 46) {
     break label$16
    }
    $4 = $3 + 1 | 0;
    HEAP32[$1 >> 2] = $4;
    HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
    if (($4 | 0) == ($7 | 0)) {
     break label$16
    }
    $11 = +($5 | 0);
    $6 = ($5 >>> 0 < 10 ? $5 : 10) | 48;
    $9 = 1.0;
    $8 = $5 >>> 0 < 11;
    while (1) {
     $3 = HEAP8[$4 | 0];
     if ((($3 & -33) + -65 & 255) >>> 0 > 5 | $8 ? !(($6 | 0) > ($3 | 0) ? ($3 | 0) >= 48 : 0) : 0) {
      break label$16
     }
     $4 = $4 + 1 | 0;
     HEAP32[$1 >> 2] = $4;
     HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
     $9 = $9 / $11;
     $10 = $10 + $9 * +((($3 | 0) < 58 ? -48 : ($3 | 0) < 71 ? -55 : -87) + $3 | 0);
     if (($4 | 0) != ($7 | 0)) {
      continue
     }
     break;
    };
   }
   $3 = HEAP32[$1 >> 2];
   if (!(($7 | 0) == ($3 | 0) | (HEAPU8[$3 | 0] | 32) != 101)) {
    $4 = $3 + 1 | 0;
    HEAP32[$1 >> 2] = $4;
    $6 = HEAP32[$1 + 16 >> 2];
    HEAP32[$1 + 16 >> 2] = $6 + 1;
    $9 = 1.0;
    if (!(($4 | 0) == ($7 | 0) | HEAPU8[$4 | 0] != 45)) {
     HEAP32[$1 + 16 >> 2] = $6 + 2;
     HEAP32[$1 >> 2] = $3 + 2;
     $9 = -1.0;
    }
    $4 = HEAP32[$1 >> 2];
    label$21 : {
     if (($7 | 0) == ($4 | 0)) {
      $6 = 0;
      break label$21;
     }
     $8 = ($5 >>> 0 < 10 ? $5 : 10) | 48;
     $6 = 0;
     $0 = $5 >>> 0 < 11;
     while (1) {
      $3 = HEAP8[$4 | 0];
      if ((($3 & -33) + -65 & 255) >>> 0 > 5 | $0 ? !(($8 | 0) > ($3 | 0) ? ($3 | 0) >= 48 : 0) : 0) {
       break label$21
      }
      $4 = $4 + 1 | 0;
      HEAP32[$1 >> 2] = $4;
      HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
      $6 = (Math_imul($5, $6) + $3 | 0) + (($3 | 0) < 58 ? -48 : ($3 | 0) < 71 ? -55 : -87) | 0;
      if (($4 | 0) != ($7 | 0)) {
       continue
      }
      break;
     };
    }
    $10 = $10 * pow(+($5 | 0), $9 * +($6 | 0));
   }
   HEAPF64[HEAP32[$2 + 4 >> 2] >> 3] = $10;
   $4 = 47;
   $3 = HEAP32[$1 >> 2];
   if ((HEAPU8[$3 | 0] | 32) != 102) {
    break label$14
   }
   HEAP32[$1 >> 2] = $3 + 1;
   HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
  }
  return $4;
 }
 
 function LexGetWord($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -28;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $6 = HEAP32[$4 + 16 >> 2];
   $7 = HEAP32[$4 + 20 >> 2];
   $4 = HEAP32[$4 + 24 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = HEAP32[$1 + 4 >> 2];
   $4 = HEAP32[$1 >> 2];
   while (1) {
    label$6 : {
     $3 = HEAP32[$1 >> 2] + 1 | 0;
     HEAP32[$1 >> 2] = $3;
     HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
     if (($3 | 0) == ($6 | 0)) {
      break label$6
     }
     $3 = HEAP8[$3 | 0];
     $7 = isalnum($3);
     if ($7 | ($3 | 0) == 95) {
      continue
     }
    }
    break;
   };
   HEAP32[$2 >> 2] = 0;
   $3 = HEAP32[$1 >> 2] - $4 | 0;
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = TableStrRegister2($0, $4, $3);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $5;
   }
   if (!global$2) {
    HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = $3;
    $3 = LexCheckReservedWord($0, HEAP32[HEAP32[$2 + 4 >> 2] >> 2]);
    $6 = $3 + -83 | 0;
    label$9 : {
     label$10 : {
      if ($6 >>> 0 > 1) {
       if (!$3) {
        break label$10
       }
       break label$9;
      }
      HEAP32[$1 + 24 >> 2] = $6 - 1 | 0 ? 2 : 1;
      if ($3) {
       break label$9
      }
     }
     $3 = 45;
     if (HEAP32[$1 + 24 >> 2] != 3) {
      break label$9
     }
     HEAP32[$1 + 24 >> 2] = 4;
    }
    return $3;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $6;
  HEAP32[$5 + 20 >> 2] = $7;
  HEAP32[$5 + 24 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 28;
  return 0;
 }
 
 function LexUnEscapeCharacterConstant($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  $4 = ($2 >>> 0 < 58 ? -48 : $2 >>> 0 < 71 ? -55 : -87) + $2 | 0;
  $7 = (($3 | 0) < 10 ? $3 : 10) + 48 | 0;
  $1 = 0;
  $8 = ($3 | 0) < 11;
  while (1) {
   label$2 : {
    label$3 : {
     label$4 : {
      $5 = HEAP32[$0 >> 2];
      $6 = HEAPU8[$5 | 0];
      $2 = $6 << 24 >> 24;
      if (($7 | 0) > ($2 | 0) ? ($2 | 0) >= 48 : 0) {
       break label$4
      }
      if ($8) {
       break label$2
      }
      if (($2 + -97 & 255) >>> 0 < 6) {
       break label$4
      }
      if ($1 >>> 0 > 1) {
       break label$2
      }
      if (($2 + -65 & 255) >>> 0 < 6) {
       break label$3
      }
      break label$2;
     }
     if ($1 >>> 0 > 1) {
      break label$2
     }
    }
    HEAP32[$0 >> 2] = $5 + 1;
    $4 = (Math_imul($4 & 255, $3) + $6 | 0) + (($2 | 0) < 58 ? 208 : ($2 | 0) < 71 ? 201 : 169) | 0;
    $1 = $1 + 1 | 0;
    continue;
   }
   break;
  };
  return $4 & 255;
 }
 
 function LexUnEscapeCharacter($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $2 = HEAP32[$0 >> 2];
  label$1 : {
   if (($2 | 0) == ($1 | 0)) {
    break label$1
   }
   while (1) {
    if (HEAPU8[$2 | 0] != 92) {
     break label$1
    }
    $3 = $2 + 1 | 0;
    if (($3 | 0) == ($1 | 0) | HEAPU8[$3 | 0] != 10) {
     break label$1
    }
    $2 = $2 + 2 | 0;
    HEAP32[$0 >> 2] = $2;
    if (($1 | 0) != ($2 | 0)) {
     continue
    }
    break;
   };
  }
  $2 = HEAP32[$0 >> 2];
  label$3 : {
   if (($2 | 0) == ($1 | 0)) {
    $2 = 92;
    break label$3;
   }
   label$5 : {
    if (HEAPU8[$2 | 0] != 92) {
     break label$5
    }
    while (1) {
     $3 = $2 + 1 | 0;
     if (($3 | 0) == ($1 | 0)) {
      break label$5
     }
     $4 = $2 + 2 | 0;
     if (($4 | 0) == ($1 | 0) | HEAPU8[$3 | 0] != 13 | HEAPU8[$4 | 0] != 10) {
      break label$5
     }
     $2 = $2 + 3 | 0;
     HEAP32[$0 >> 2] = $2;
     if (($1 | 0) != ($2 | 0)) {
      if (HEAPU8[$2 | 0] != 92) {
       break label$5
      }
      continue;
     }
     break;
    };
    $2 = 92;
    break label$3;
   }
   $3 = HEAPU8[$2 | 0];
   $4 = $2 + 1 | 0;
   HEAP32[$0 >> 2] = $4;
   if (($3 | 0) == 92) {
    if (($1 | 0) == ($4 | 0)) {
     $2 = 92;
     break label$3;
    }
    HEAP32[$0 >> 2] = $2 + 2;
    $2 = HEAPU8[$2 + 1 | 0];
    $1 = $2 + -48 | 0;
    if ($1 >>> 0 > 72) {
     break label$3
    }
    label$10 : {
     switch ($1 - 4 | 0) {
     case 45:
      $2 = 7;
      break label$3;
     case 46:
      $2 = 8;
      break label$3;
     case 50:
      $2 = 12;
      break label$3;
     case 58:
      $2 = 10;
      break label$3;
     case 62:
      $2 = 13;
      break label$3;
     case 64:
      $2 = 9;
      break label$3;
     case 66:
      $2 = 11;
      break label$3;
     default:
      $2 = LexUnEscapeCharacterConstant($0, $2, $2, 8);
      break label$3;
     case 68:
      break label$10;
     case 0:
     case 1:
     case 2:
     case 3:
     case 4:
     case 5:
     case 6:
     case 7:
     case 8:
     case 9:
     case 10:
     case 11:
     case 12:
     case 13:
     case 14:
     case 15:
     case 16:
     case 17:
     case 18:
     case 19:
     case 20:
     case 21:
     case 22:
     case 23:
     case 24:
     case 25:
     case 26:
     case 27:
     case 28:
     case 29:
     case 30:
     case 31:
     case 32:
     case 33:
     case 34:
     case 35:
     case 36:
     case 37:
     case 38:
     case 39:
     case 40:
     case 41:
     case 42:
     case 43:
     case 44:
     case 47:
     case 48:
     case 49:
     case 51:
     case 52:
     case 53:
     case 54:
     case 55:
     case 56:
     case 57:
     case 59:
     case 60:
     case 61:
     case 63:
     case 65:
     case 67:
      break label$3;
     };
    }
    $2 = LexUnEscapeCharacterConstant($0, $2, 48, 16);
    break label$3;
   }
   $2 = HEAPU8[$2 | 0];
  }
  return $2 & 255;
 }
 
 function LexGetStringConstant($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -36;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $6 = HEAP32[$5 + 20 >> 2];
   $8 = HEAP32[$5 + 24 >> 2];
   $7 = HEAP32[$5 + 28 >> 2];
   $9 = HEAP32[$5 + 32 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $10 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $8 = HEAP32[$1 >> 2];
   $4 = $8;
   $9 = HEAP32[$1 + 4 >> 2];
   label$5 : {
    if (($4 | 0) == ($9 | 0)) {
     break label$5
    }
    $6 = 0;
    $4 = $8;
    while (1) {
     $7 = HEAPU8[$4 | 0];
     if (($7 | 0) == ($3 & 255) ? !$6 : 0) {
      break label$5
     }
     label$7 : {
      if ($6) {
       label$9 : {
        if (($7 & 255) != 13) {
         break label$9
        }
        $4 = $4 + 1 | 0;
        if (($9 | 0) == ($4 | 0)) {
         break label$9
        }
        HEAP32[$1 >> 2] = $4;
       }
       $6 = 0;
       $4 = HEAP32[$1 >> 2];
       if (HEAPU8[$4 | 0] != 10) {
        break label$7
       }
       $4 = $4 + 1 | 0;
       if (($9 | 0) == ($4 | 0)) {
        break label$7
       }
       HEAP32[$1 + 16 >> 2] = 0;
       HEAP32[$1 >> 2] = $4;
       HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] + 1;
       HEAP32[$1 + 28 >> 2] = HEAP32[$1 + 28 >> 2] + 1;
       break label$7;
      }
      $6 = ($7 & 255) == 92;
     }
     $4 = HEAP32[$1 >> 2] + 1 | 0;
     HEAP32[$1 >> 2] = $4;
     HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
     $9 = HEAP32[$1 + 4 >> 2];
     if (($9 | 0) != ($4 | 0)) {
      continue
     }
     break;
    };
   }
   $9 = $4 - $8 | 0;
   $7 = HeapAllocStack($0, $9);
   $6 = !$7;
  }
  label$2 : {
   if ((global$2 | 0) == 2 | $6) {
    if (global$2 ? !$10 : 1) {
     LexFail($0, $1, 1351, 0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    HEAP32[$1 >> 2] = $8;
    $6 = $7;
    if (($4 | 0) != ($8 | 0)) {
     while (1) {
      HEAP8[$6 | 0] = LexUnEscapeCharacter($1, $4);
      $6 = $6 + 1 | 0;
      if (HEAP32[$1 >> 2] != ($4 | 0)) {
       continue
      }
      break;
     }
    }
    $8 = $6 - $7 | 0;
   }
   if (global$2 ? ($10 | 0) == 1 : 1) {
    $5 = TableStrRegister2($0, $7, $8);
    $11 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $4 = $5;
   }
   if (!global$2) {
    HeapPopStack($0, $7, $9);
    $8 = !VariableStringLiteralGet($0, $4);
   }
   if ((global$2 | 0) == 2 | $8) {
    if (global$2 ? ($10 | 0) == 2 : 1) {
     $5 = VariableAllocValueAndData($0, 0, 0, 0, 0, 1);
     $11 = 2;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $6 = $5;
    }
    if (!global$2) {
     $7 = HEAP32[$0 + 2080 >> 2];
     HEAP32[$6 + 4 >> 2] = $4;
     HEAP32[$6 >> 2] = $7;
    }
    if (global$2 ? ($10 | 0) == 3 : 1) {
     VariableStringLiteralDefine($0, $4, $6);
     $11 = 3;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    HEAP32[$2 >> 2] = HEAP32[$0 + 2072 >> 2];
    HEAP32[HEAP32[$2 + 4 >> 2] >> 2] = $4;
    $4 = HEAP32[$1 >> 2];
    if (HEAPU8[$4 | 0] == ($3 & 255)) {
     HEAP32[$1 >> 2] = $4 + 1;
     HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
    }
    return 48;
   }
   abort();
  }
  $5 = $11;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[$5 + 20 >> 2] = $6;
  HEAP32[$5 + 24 >> 2] = $8;
  HEAP32[$5 + 28 >> 2] = $7;
  HEAP32[$5 + 32 >> 2] = $9;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 36;
  return 0;
 }
 
 function LexGetCharacterConstant($0, $1, $2) {
  var $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   HEAP32[$2 >> 2] = $0 + 1500;
   $3 = LexUnEscapeCharacter($1, HEAP32[$1 + 4 >> 2]);
   HEAP8[HEAP32[$2 + 4 >> 2]] = $3;
   $2 = HEAP32[$1 >> 2];
   $3 = ($2 | 0) == HEAP32[$1 + 4 >> 2];
  }
  label$2 : {
   if (!(HEAPU8[$2 | 0] == 39 | $3 ? !global$2 : 0)) {
    if (global$2 ? !$4 : 1) {
     LexFail($0, $1, 1365, 0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    HEAP32[$1 >> 2] = HEAP32[$1 >> 2] + 1;
    HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
    return 49;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function LexSkipComment($0, $1, $2) {
  var $3 = 0;
  $3 = HEAP32[$0 + 4 >> 2];
  $2 = HEAP32[$0 >> 2];
  label$1 : {
   if (($1 | 0) != 42) {
    if (($2 | 0) == ($3 | 0)) {
     break label$1
    }
    while (1) {
     if (HEAPU8[$2 | 0] == 10) {
      break label$1
     }
     $2 = $2 + 1 | 0;
     HEAP32[$0 >> 2] = $2;
     HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + 1;
     if (HEAP32[$0 + 4 >> 2] != ($2 | 0)) {
      continue
     }
     break;
    };
    break label$1;
   }
   label$4 : {
    if (($2 | 0) == ($3 | 0)) {
     break label$4
    }
    $1 = 0;
    while (1) {
     if (!(HEAPU8[$2 | 0] == 47 ? HEAPU8[$2 + -1 | 0] == 42 : 0)) {
      if (HEAPU8[$2 | 0] == 10) {
       HEAP32[$0 + 28 >> 2] = HEAP32[$0 + 28 >> 2] + 1
      }
      $2 = $2 + 1 | 0;
      HEAP32[$0 >> 2] = $2;
      HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + 1;
      $1 = HEAP32[$0 + 4 >> 2] == ($2 | 0);
      if (!$1) {
       continue
      }
      break label$4;
     }
     break;
    };
    if ($1 & 1) {
     break label$4
    }
    HEAP32[$0 >> 2] = $2 + 1;
    HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 16 >> 2] + 1;
   }
   HEAP32[$0 + 24 >> 2] = 0;
  }
 }
 
 function LexScanGetToken($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -48;
   $6 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$6 >> 2];
   $2 = HEAP32[$6 + 8 >> 2];
   $3 = HEAP32[$6 + 12 >> 2];
   $4 = HEAP32[$6 + 16 >> 2];
   $5 = HEAP32[$6 + 20 >> 2];
   $7 = HEAP32[$6 + 24 >> 2];
   $8 = HEAP32[$6 + 28 >> 2];
   $9 = HEAP32[$6 + 32 >> 2];
   $10 = HEAP32[$6 + 36 >> 2];
   $13 = HEAP32[$6 + 40 >> 2];
   $14 = HEAP32[$6 + 44 >> 2];
   $1 = HEAP32[$6 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $11 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $10 = global$0 - 16 | 0;
   global$0 = $10;
   $4 = HEAP32[$1 + 28 >> 2];
   $5 = ($4 | 0) <= 0;
   $3 = 0;
  }
  label$2 : {
   label$4 : {
    if ((global$2 | 0) == 2 | $5) {
     $13 = global$2 ? $13 : $0 + 488 | 0;
     while (1) {
      if (!global$2) {
       $14 = $3;
       HEAP32[$2 >> 2] = $13;
       $3 = HEAP32[$1 + 4 >> 2];
       $4 = HEAP32[$1 >> 2];
       if (($3 | 0) == ($4 | 0)) {
        $3 = 93;
        break label$4;
       }
       label$11 : {
        if (!isspace(HEAP8[$4 | 0])) {
         break label$11
        }
        while (1) {
         if (HEAPU8[$4 | 0] == 10) {
          HEAP32[$1 + 24 >> 2] = 0;
          HEAP32[$1 + 16 >> 2] = 0;
          HEAP32[$1 >> 2] = $4 + 1;
          HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] + 1;
          $3 = 94;
          break label$4;
         }
         $3 = HEAP32[$1 + 24 >> 2] + -2 | 0;
         if ($3 >>> 0 <= 2) {
          HEAP32[$1 + 24 >> 2] = HEAP32[($3 << 2) + 1964 >> 2]
         }
         $4 = $4 + 1 | 0;
         HEAP32[$1 >> 2] = $4;
         HEAP32[$1 + 16 >> 2] = HEAP32[$1 + 16 >> 2] + 1;
         $3 = HEAP32[$1 + 4 >> 2];
         if (($4 | 0) != ($3 | 0)) {
          if (!isspace(HEAP8[$4 | 0])) {
           break label$11
          }
          continue;
         }
         break;
        };
        $3 = 93;
        break label$4;
       }
       $8 = HEAP8[$4 | 0];
       $9 = $8 & 255;
       if (!$9) {
        $3 = 93;
        break label$4;
       }
       $5 = isalpha($8);
      }
      label$17 : {
       if (!global$2) {
        label$19 : {
         if ($5) {
          break label$19
         }
         $5 = ($9 | 0) == 95;
         if ($5) {
          break label$19
         }
         $5 = ($9 | 0) != 35;
         if ($5) {
          break label$17
         }
        }
        $2 = HEAP32[$2 >> 2];
       }
       if (global$2 ? !$11 : 1) {
        $6 = LexGetWord($0, $1, $2);
        $12 = 0;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $3 = $6;
       }
       if (!global$2) {
        break label$4
       }
      }
      if (!global$2) {
       if ($8 + -48 >>> 0 <= 9) {
        $3 = LexGetNumber($0, $1, HEAP32[$2 >> 2]);
        break label$4;
       }
       $5 = 0;
       $9 = $4 + 1 | 0;
       if (($9 | 0) != ($3 | 0)) {
        $5 = HEAPU8[$9 | 0]
       }
       HEAP32[$1 >> 2] = $9;
       $7 = HEAP32[$1 + 16 >> 2];
       HEAP32[$1 + 16 >> 2] = $7 + 1;
       $9 = $8 + -33 | 0;
       $3 = $9 >>> 0 > 93;
      }
      label$24 : {
       label$25 : {
        label$26 : {
         if (!global$2) {
          if ($3) {
           break label$26
          }
          $9 = $9 - 1 | 0;
          $3 = 44;
         }
         label$28 : {
          label$29 : {
           label$30 : {
            label$31 : {
             label$32 : {
              label$33 : {
               label$34 : {
                label$35 : {
                 label$36 : {
                  label$37 : {
                   label$38 : {
                    label$39 : {
                     label$40 : {
                      label$41 : {
                       label$42 : {
                        label$43 : {
                         label$44 : {
                          label$45 : {
                           label$46 : {
                            label$47 : {
                             label$48 : {
                              label$49 : {
                               label$50 : {
                                label$51 : {
                                 if (!global$2) {
                                  label$53 : {
                                   switch ($9 | 0) {
                                   case 7:
                                    break label$24;
                                   case 1:
                                   case 2:
                                   case 14:
                                   case 15:
                                   case 16:
                                   case 17:
                                   case 18:
                                   case 19:
                                   case 20:
                                   case 21:
                                   case 22:
                                   case 23:
                                   case 30:
                                   case 31:
                                   case 32:
                                   case 33:
                                   case 34:
                                   case 35:
                                   case 36:
                                   case 37:
                                   case 38:
                                   case 39:
                                   case 40:
                                   case 41:
                                   case 42:
                                   case 43:
                                   case 44:
                                   case 45:
                                   case 46:
                                   case 47:
                                   case 48:
                                   case 49:
                                   case 50:
                                   case 51:
                                   case 52:
                                   case 53:
                                   case 54:
                                   case 55:
                                   case 56:
                                   case 58:
                                   case 61:
                                   case 62:
                                   case 63:
                                   case 64:
                                   case 65:
                                   case 66:
                                   case 67:
                                   case 68:
                                   case 69:
                                   case 70:
                                   case 71:
                                   case 72:
                                   case 73:
                                   case 74:
                                   case 75:
                                   case 76:
                                   case 77:
                                   case 78:
                                   case 79:
                                   case 80:
                                   case 81:
                                   case 82:
                                   case 83:
                                   case 84:
                                   case 85:
                                   case 86:
                                   case 87:
                                   case 88:
                                    break label$26;
                                   case 24:
                                    break label$28;
                                   case 29:
                                    break label$29;
                                   case 12:
                                    break label$30;
                                   case 10:
                                    break label$31;
                                   case 92:
                                    break label$32;
                                   case 60:
                                    break label$33;
                                   case 59:
                                    break label$35;
                                   case 57:
                                    break label$36;
                                   case 91:
                                    break label$37;
                                   case 89:
                                    break label$38;
                                   case 90:
                                    break label$39;
                                   case 4:
                                    break label$40;
                                   case 25:
                                    break label$41;
                                   case 28:
                                    break label$42;
                                   case 26:
                                    break label$43;
                                   case 3:
                                    break label$44;
                                   case 13:
                                    break label$45;
                                   case 8:
                                    break label$46;
                                   case 11:
                                    break label$47;
                                   case 9:
                                    break label$48;
                                   case 27:
                                    break label$49;
                                   case 6:
                                    break label$50;
                                   case 5:
                                    break label$51;
                                   case 0:
                                    break label$53;
                                   default:
                                    break label$34;
                                   };
                                  }
                                  $5 = HEAP32[$2 >> 2];
                                 }
                                 if (global$2 ? ($11 | 0) == 1 : 1) {
                                  $6 = LexGetStringConstant($0, $1, $5, 34);
                                  $12 = 1;
                                  if ((global$2 | 0) == 1) {
                                   break label$2
                                  }
                                  $5 = $6;
                                 }
                                 if (!global$2) {
                                  $3 = 48;
                                  break label$24;
                                 }
                                }
                                $5 = global$2 ? $5 : HEAP32[$2 >> 2];
                                if (global$2 ? ($11 | 0) == 2 : 1) {
                                 $6 = LexGetCharacterConstant($0, $1, $5);
                                 $12 = 2;
                                 if ((global$2 | 0) == 1) {
                                  break label$2
                                 }
                                 $5 = $6;
                                }
                                if (!global$2) {
                                 $3 = 49;
                                 break label$24;
                                }
                               }
                               if (!global$2) {
                                $4 = HEAP32[$1 + 24 >> 2];
                                HEAP32[$1 + 24 >> 2] = 0;
                                $3 = ($4 | 0) == 4 ? 92 : 43;
                                break label$24;
                               }
                              }
                              if (!global$2) {
                               $3 = 2;
                               if (($5 | 0) != 61) {
                                break label$24
                               }
                               HEAP32[$1 + 16 >> 2] = $7 + 2;
                               HEAP32[$1 >> 2] = $4 + 2;
                               $3 = 20;
                               break label$24;
                              }
                             }
                             if (!global$2) {
                              $3 = 28;
                              $8 = $5 + -43 | 0;
                              if ($8 >>> 0 > 18) {
                               break label$24
                              }
                              label$62 : {
                               switch ($8 - 1 | 0) {
                               case 17:
                                HEAP32[$1 + 16 >> 2] = $7 + 2;
                                HEAP32[$1 >> 2] = $4 + 2;
                                $3 = 3;
                                break label$24;
                               case 0:
                               case 1:
                               case 2:
                               case 3:
                               case 4:
                               case 5:
                               case 6:
                               case 7:
                               case 8:
                               case 9:
                               case 10:
                               case 11:
                               case 12:
                               case 13:
                               case 14:
                               case 15:
                               case 16:
                                break label$24;
                               default:
                                break label$62;
                               };
                              }
                              HEAP32[$1 + 16 >> 2] = $7 + 2;
                              HEAP32[$1 >> 2] = $4 + 2;
                              $3 = 33;
                              break label$24;
                             }
                            }
                            if (!global$2) {
                             $3 = 29;
                             $8 = $5 + -45 | 0;
                             if ($8 >>> 0 > 17) {
                              break label$24
                             }
                             label$65 : {
                              switch ($8 - 1 | 0) {
                              case 15:
                               HEAP32[$1 + 16 >> 2] = $7 + 2;
                               HEAP32[$1 >> 2] = $4 + 2;
                               $3 = 4;
                               break label$24;
                              case 16:
                               HEAP32[$1 + 16 >> 2] = $7 + 2;
                               HEAP32[$1 >> 2] = $4 + 2;
                               $3 = 42;
                               break label$24;
                              case 0:
                              case 1:
                              case 2:
                              case 3:
                              case 4:
                              case 5:
                              case 6:
                              case 7:
                              case 8:
                              case 9:
                              case 10:
                              case 11:
                              case 12:
                              case 13:
                              case 14:
                               break label$24;
                              default:
                               break label$65;
                              };
                             }
                             HEAP32[$1 + 16 >> 2] = $7 + 2;
                             HEAP32[$1 >> 2] = $4 + 2;
                             $3 = 34;
                             break label$24;
                            }
                           }
                           if (!global$2) {
                            $3 = 30;
                            if (($5 | 0) != 61) {
                             break label$24
                            }
                            HEAP32[$1 + 16 >> 2] = $7 + 2;
                            HEAP32[$1 >> 2] = $4 + 2;
                            $3 = 5;
                            break label$24;
                           }
                          }
                          if (!global$2) {
                           $3 = 31;
                           $8 = $5 + -42 | 0;
                           $9 = $8 >>> 0 > 19;
                           if ($9) {
                            break label$24
                           }
                           label$70 : {
                            label$71 : {
                             $8 = $8 - 1 | 0;
                             switch ($8 | 0) {
                             case 0:
                             case 1:
                             case 2:
                             case 3:
                             case 5:
                             case 6:
                             case 7:
                             case 8:
                             case 9:
                             case 10:
                             case 11:
                             case 12:
                             case 13:
                             case 14:
                             case 15:
                             case 16:
                             case 17:
                              break label$24;
                             case 18:
                              break label$70;
                             default:
                              break label$71;
                             };
                            }
                            HEAP32[$1 + 16 >> 2] = $7 + 2;
                            $3 = $4 + 2 | 0;
                            HEAP32[$1 >> 2] = $3;
                            LexSkipComment($1, $5 << 24 >> 24, $1);
                            break label$25;
                           }
                           HEAP32[$1 + 16 >> 2] = $7 + 2;
                           HEAP32[$1 >> 2] = $4 + 2;
                           $3 = 6;
                           break label$24;
                          }
                         }
                         if (!global$2) {
                          $3 = 32;
                          if (($5 | 0) != 61) {
                           break label$24
                          }
                          HEAP32[$1 + 16 >> 2] = $7 + 2;
                          HEAP32[$1 >> 2] = $4 + 2;
                          $3 = 7;
                          break label$24;
                         }
                        }
                        $3 = global$2 ? $3 : HEAP32[$1 + 24 >> 2] == 1;
                        if ($3 | (global$2 | 0) == 2) {
                         $5 = global$2 ? $5 : HEAP32[$2 >> 2];
                         if (global$2 ? ($11 | 0) == 3 : 1) {
                          $6 = LexGetStringConstant($0, $1, $5, 62);
                          $12 = 3;
                          if ((global$2 | 0) == 1) {
                           break label$2
                          }
                          $5 = $6;
                         }
                         if (!global$2) {
                          $3 = 48;
                          break label$24;
                         }
                        }
                        if (!global$2) {
                         $3 = $5 + -60 | 0;
                         if ($3 >>> 0 > 1) {
                          $3 = 22;
                          break label$24;
                         }
                         if (!($3 - 1)) {
                          HEAP32[$1 + 16 >> 2] = $7 + 2;
                          HEAP32[$1 >> 2] = $4 + 2;
                          $3 = 24;
                          break label$24;
                         }
                         if (HEAPU8[$4 + 2 | 0] == 61) {
                          HEAP32[$1 + 16 >> 2] = $7 + 3;
                          HEAP32[$1 >> 2] = $4 + 3;
                          $3 = 8;
                          break label$24;
                         }
                         HEAP32[$1 >> 2] = $4 + 2;
                         HEAP32[$1 + 16 >> 2] = $7 + 2;
                         $3 = 26;
                         break label$24;
                        }
                       }
                       if (!global$2) {
                        $3 = $5 + -61 | 0;
                        if ($3 >>> 0 > 1) {
                         $3 = 23;
                         break label$24;
                        }
                        if ($3 - 1) {
                         HEAP32[$1 + 16 >> 2] = $7 + 2;
                         HEAP32[$1 >> 2] = $4 + 2;
                         $3 = 25;
                         break label$24;
                        }
                        if (HEAPU8[$4 + 2 | 0] == 61) {
                         HEAP32[$1 + 16 >> 2] = $7 + 3;
                         HEAP32[$1 >> 2] = $4 + 3;
                         $3 = 9;
                         break label$24;
                        }
                        HEAP32[$1 >> 2] = $4 + 2;
                        HEAP32[$1 + 16 >> 2] = $7 + 2;
                        $3 = 27;
                        break label$24;
                       }
                      }
                      if (!global$2) {
                       $3 = 50;
                       break label$24;
                      }
                     }
                     if (!global$2) {
                      $8 = $5;
                      if (($5 | 0) != 38) {
                       $3 = 19;
                       if (($8 | 0) != 61) {
                        break label$24
                       }
                       HEAP32[$1 + 16 >> 2] = $7 + 2;
                       HEAP32[$1 >> 2] = $4 + 2;
                       $3 = 10;
                       break label$24;
                      }
                      HEAP32[$1 + 16 >> 2] = $7 + 2;
                      HEAP32[$1 >> 2] = $4 + 2;
                      $3 = 16;
                      break label$24;
                     }
                    }
                    if (!global$2) {
                     $8 = $5;
                     if (($5 | 0) != 124) {
                      $3 = 17;
                      if (($8 | 0) != 61) {
                       break label$24
                      }
                      HEAP32[$1 + 16 >> 2] = $7 + 2;
                      HEAP32[$1 >> 2] = $4 + 2;
                      $3 = 11;
                      break label$24;
                     }
                     HEAP32[$1 + 16 >> 2] = $7 + 2;
                     HEAP32[$1 >> 2] = $4 + 2;
                     $3 = 15;
                     break label$24;
                    }
                   }
                   if (!global$2) {
                    $3 = 52;
                    break label$24;
                   }
                  }
                  if (!global$2) {
                   $3 = 53;
                   break label$24;
                  }
                 }
                 if (!global$2) {
                  $3 = 39;
                  break label$24;
                 }
                }
                if (!global$2) {
                 $3 = 40;
                 break label$24;
                }
               }
               if (!global$2) {
                $3 = 35;
                if (($5 | 0) != 61) {
                 break label$24
                }
                HEAP32[$1 + 16 >> 2] = $7 + 2;
                HEAP32[$1 >> 2] = $4 + 2;
                $3 = 21;
                break label$24;
               }
              }
              if (!global$2) {
               $3 = 18;
               if (($5 | 0) != 61) {
                break label$24
               }
               HEAP32[$1 + 16 >> 2] = $7 + 2;
               HEAP32[$1 >> 2] = $4 + 2;
               $3 = 12;
               break label$24;
              }
             }
             if (!global$2) {
              $3 = 36;
              break label$24;
             }
            }
            if (!global$2) {
             $3 = 1;
             break label$24;
            }
           }
           if (!global$2) {
            $3 = 41;
            if (($5 | 0) != 46 | HEAPU8[$4 + 2 | 0] != 46) {
             break label$24
            }
            HEAP32[$1 + 16 >> 2] = $7 + 3;
            HEAP32[$1 >> 2] = $4 + 3;
            $3 = 51;
            break label$24;
           }
          }
          if (!global$2) {
           $3 = 13;
           break label$24;
          }
         }
         if (!global$2) {
          $3 = 14;
          break label$24;
         }
        }
        if (!global$2) {
         HEAP32[$10 >> 2] = $8
        }
        if (global$2 ? ($11 | 0) == 4 : 1) {
         LexFail($0, $1, 1378, $10);
         $12 = 4;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
       }
       $3 = global$2 ? $3 : $14;
      }
      if (!global$2) {
       $5 = !$3;
       if ($5) {
        continue
       }
      }
      break;
     };
     if (!global$2) {
      break label$4
     }
    }
    if (!global$2) {
     HEAP32[$1 + 28 >> 2] = $4 + -1;
     $3 = 94;
    }
   }
   if (!global$2) {
    global$0 = $10 + 16 | 0;
    return $3;
   }
   abort();
  }
  $6 = $12;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $4;
  HEAP32[$6 + 20 >> 2] = $5;
  HEAP32[$6 + 24 >> 2] = $7;
  HEAP32[$6 + 28 >> 2] = $8;
  HEAP32[$6 + 32 >> 2] = $9;
  HEAP32[$6 + 36 >> 2] = $10;
  HEAP32[$6 + 40 >> 2] = $13;
  HEAP32[$6 + 44 >> 2] = $14;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 48;
  return 0;
 }
 
 function LexTokenSize($0) {
  $0 = $0 + -45 | 0;
  if ($0 >>> 0 <= 4) {
   return HEAP32[($0 << 2) + 1976 >> 2]
  }
  return 0;
 }
 
 function LexTokenise($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -44;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $5 = HEAP32[$3 + 16 >> 2];
   $6 = HEAP32[$3 + 20 >> 2];
   $7 = HEAP32[$3 + 24 >> 2];
   $8 = HEAP32[$3 + 28 >> 2];
   $9 = HEAP32[$3 + 32 >> 2];
   $10 = HEAP32[$3 + 36 >> 2];
   $11 = HEAP32[$3 + 40 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $12 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $8 = global$0 - 16 | 0;
   global$0 = $8;
   $11 = (HEAP32[$1 + 4 >> 2] - HEAP32[$1 >> 2] << 2) + 16 | 0;
   $9 = HeapAllocStack($0, $11);
   $4 = !$9;
  }
  label$2 : {
   if ((global$2 | 0) == 2 | $4) {
    if (global$2 ? !$12 : 1) {
     LexFail($0, $1, 1351, 0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $5 = 0;
    $6 = 0;
    $4 = $9;
   }
   while (1) {
    $7 = global$2 ? $7 : $8 + 12 | 0;
    if (global$2 ? ($12 | 0) == 1 : 1) {
     $3 = LexScanGetToken($0, $1, $7);
     $13 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $10 = $3;
    }
    if (!global$2) {
     HEAP8[$4 + 1 | 0] = $6;
     HEAP8[$4 | 0] = $10;
     $5 = $5 + 2 | 0;
     $4 = $4 + 2 | 0;
     $6 = LexTokenSize($10);
     if (($6 | 0) >= 1) {
      $5 = $5 + $6 | 0;
      $4 = memcpy($4, HEAP32[HEAP32[$8 + 12 >> 2] + 4 >> 2], $6) + $6 | 0;
     }
     $6 = HEAP32[$1 + 16 >> 2];
     $7 = ($10 | 0) != 93;
     if ($7) {
      continue
     }
    }
    break;
   };
   if (!global$2) {
    $4 = HeapAllocMem($0, $5);
    $7 = !$4;
   }
   if ((global$2 | 0) == 2 | $7) {
    if (global$2 ? ($12 | 0) == 2 : 1) {
     LexFail($0, $1, 1351, 0);
     $13 = 2;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    if (($11 | 0) >= ($5 | 0)) {
     $4 = memcpy($4, $9, $5);
     HeapPopStack($0, $9, $11);
     if ($2) {
      HEAP32[$2 >> 2] = $5
     }
     global$0 = $8 + 16 | 0;
     return $4;
    }
    __assert_fail(1401, 1425, 574, 1431);
    abort();
   }
   abort();
  }
  $3 = $13;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[$3 + 16 >> 2] = $5;
  HEAP32[$3 + 20 >> 2] = $6;
  HEAP32[$3 + 24 >> 2] = $7;
  HEAP32[$3 + 28 >> 2] = $8;
  HEAP32[$3 + 32 >> 2] = $9;
  HEAP32[$3 + 36 >> 2] = $10;
  HEAP32[$3 + 40 >> 2] = $11;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 44;
  return 0;
 }
 
 function LexAnalyse($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $5 = HEAP32[$5 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = global$0 - 32 | 0;
   global$0 = $5;
   HEAP32[$5 >> 2] = $2;
   HEAP32[$5 + 24 >> 2] = 0;
   HEAP32[$5 + 28 >> 2] = 0;
   HEAP32[$5 + 8 >> 2] = $1;
   HEAP32[$5 + 20 >> 2] = $2;
   HEAP32[$5 + 12 >> 2] = 1;
   HEAP32[$5 + 16 >> 2] = 1;
   HEAP32[$5 + 4 >> 2] = $2 + $3;
  }
  label$2 : {
   if (global$2 ? !$6 : 1) {
    $6 = LexTokenise($0, $5, $4);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $6;
   }
   if (!global$2) {
    global$0 = $5 + 32 | 0;
    return $2;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $4;
  HEAP32[$6 + 20 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  return 0;
 }
 
 function LexInitParser($0, $1, $2, $3, $4, $5, $6) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  $6 = $6 | 0;
  HEAP32[$0 + 4 >> 2] = $3;
  HEAP32[$0 >> 2] = $1;
  HEAP32[$0 + 32 >> 2] = 0;
  HEAP32[$0 + 20 >> 2] = 0;
  HEAP32[$0 + 8 >> 2] = $4;
  HEAP8[$0 + 36 | 0] = $6;
  HEAP32[$0 + 28 >> 2] = $2;
  HEAP32[$0 + 12 >> 2] = 1;
  HEAP32[$0 + 16 >> 2] = !$5;
 }
 
 function LexGetRawToken($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -36;
   $6 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$6 >> 2];
   $2 = HEAP32[$6 + 8 >> 2];
   $3 = HEAP32[$6 + 12 >> 2];
   $4 = HEAP32[$6 + 16 >> 2];
   $5 = HEAP32[$6 + 20 >> 2];
   $7 = HEAP32[$6 + 24 >> 2];
   $8 = HEAP32[$6 + 28 >> 2];
   $9 = HEAP32[$6 + 32 >> 2];
   $1 = HEAP32[$6 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $10 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = global$0;
   $9 = $3 - 272 | 0;
   global$0 = $9;
   $7 = 0;
   $4 = HEAP32[$0 >> 2];
  }
  label$2 : {
   label$5 : {
    label$6 : {
     label$7 : {
      label$8 : {
       while (1) {
        if (!global$2) {
         label$11 : {
          if (HEAP32[$0 + 4 >> 2]) {
           break label$11
          }
          $3 = HEAP32[$4 + 400 >> 2];
          if (!$3) {
           break label$11
          }
          HEAP32[$0 + 4 >> 2] = HEAP32[$3 + 4 >> 2];
         }
         $5 = HEAP32[$4 + 2756 >> 2];
         $8 = ($5 | 0) != HEAP32[$0 + 8 >> 2];
         label$12 : {
          if (!$8) {
           $3 = !HEAP32[$4 + 400 >> 2];
           if ($3) {
            break label$12
           }
          }
          $3 = HEAP32[$0 + 4 >> 2];
          $7 = HEAPU8[$3 | 0];
          $5 = ($7 | 0) != 94;
          if ($5) {
           break label$12
          }
          while (1) {
           $5 = $3 + 2 | 0;
           HEAP32[$0 + 4 >> 2] = $5;
           HEAP16[$0 + 12 >> 1] = HEAPU16[$0 + 12 >> 1] + 1;
           $7 = HEAPU8[$3 + 2 | 0];
           $3 = $5;
           $5 = ($7 | 0) == 94;
           if ($5) {
            continue
           }
           break;
          };
         }
        }
        label$15 : {
         if (!global$2) {
          if ($8) {
           break label$15
          }
          $3 = ($7 | 0) != 93;
          if ($3) {
           $3 = HEAP32[$4 + 400 >> 2];
           if ($3) {
            break label$15
           }
          }
          $5 = HEAP32[$4 + 400 >> 2];
         }
         label$18 : {
          label$19 : {
           label$20 : {
            if (!global$2) {
             if ($5) {
              $3 = HEAP32[$4 + 404 >> 2];
              $8 = HEAP32[$3 + 8 >> 2];
              $3 = ($8 + HEAP32[$3 + 4 >> 2] | 0) + -2 | 0;
              $8 = HEAP32[$0 + 4 >> 2];
              $3 = ($3 | 0) != ($8 | 0);
              if ($3) {
               break label$20
              }
             }
             $5 = $9 + 16 | 0;
             $8 = !HEAP32[$4 + 412 >> 2];
             if ($8) {
              $3 = 1451
             } else {
              HEAP32[$4 + 412 >> 2] = 0;
              $3 = 1443;
             }
            }
            if (global$2 ? !$10 : 1) {
             $6 = PlatformGetLine($5, 256, $3);
             $11 = 0;
             if ((global$2 | 0) == 1) {
              break label$2
             }
             $3 = $6;
            }
            if (!global$2) {
             $5 = !$3;
             $3 = 0;
             if ($5) {
              break label$18
             }
             $3 = HEAP32[$4 + 2756 >> 2];
             $7 = strlen($9 + 16 | 0);
             $8 = $9 + 12 | 0;
             $5 = $9 + 16 | 0;
            }
            if (global$2 ? ($10 | 0) == 1 : 1) {
             $6 = LexAnalyse($4, $3, $5, $7, $8);
             $11 = 1;
             if ((global$2 | 0) == 1) {
              break label$2
             }
             $7 = $6;
            }
            if (global$2 ? ($10 | 0) == 2 : 1) {
             $6 = VariableAlloc($4, $0, 12, 1);
             $11 = 2;
             if ((global$2 | 0) == 1) {
              break label$2
             }
             $3 = $6;
            }
            if (!global$2) {
             HEAP32[$3 + 4 >> 2] = $7;
             HEAP32[$3 + 8 >> 2] = HEAP32[$9 + 12 >> 2];
             $5 = !HEAP32[$4 + 400 >> 2];
             label$30 : {
              if ($5) {
               HEAP32[$4 + 400 >> 2] = $3;
               HEAP32[$0 + 12 >> 2] = 1;
               break label$30;
              }
              $5 = HEAP32[$4 + 404 >> 2];
              HEAP32[$5 >> 2] = $3;
             }
             HEAP32[$4 + 408 >> 2] = $3;
             HEAP32[$4 + 404 >> 2] = $3;
             HEAP32[$0 + 4 >> 2] = $7;
             break label$19;
            }
           }
           if (!global$2) {
            $3 = HEAP32[$4 + 408 >> 2];
            $7 = HEAP32[$3 + 8 >> 2];
            if ((($7 + HEAP32[$3 + 4 >> 2] | 0) + -2 | 0) != ($8 | 0)) {
             label$34 : {
              while (1) {
               $3 = $5;
               $7 = HEAP32[$3 + 4 >> 2];
               if ((($7 + HEAP32[$3 + 8 >> 2] | 0) + -2 | 0) == ($8 | 0)) {
                break label$34
               }
               $5 = HEAP32[$3 >> 2];
               if ($5) {
                continue
               }
               break;
              };
              HEAP32[$4 + 408 >> 2] = $3;
              __assert_fail(1459, 1425, 697, 1500);
              abort();
             }
             HEAP32[$4 + 408 >> 2] = $3;
            }
            $3 = HEAP32[$4 + 408 >> 2];
            if (!$3) {
             break label$7
            }
            $3 = HEAP32[$3 >> 2];
            HEAP32[$4 + 408 >> 2] = $3;
            $5 = !$3;
            if ($5) {
             break label$6
            }
            $3 = HEAP32[$3 + 4 >> 2];
            HEAP32[$0 + 4 >> 2] = $3;
           }
          }
          if (!global$2) {
           $7 = HEAPU8[HEAP32[$0 + 4 >> 2]];
           $3 = 1;
          }
         }
         if (!global$2) {
          if ($3) {
           break label$15
          }
          $7 = 93;
          break label$8;
         }
        }
        if (!global$2) {
         $3 = ($7 | 0) == 94;
         if ($3) {
          continue
         }
         $8 = HEAP32[$4 + 2756 >> 2];
         $5 = ($8 | 0) == HEAP32[$0 + 8 >> 2];
         $3 = $5 & ($7 | 0) == 93;
         if ($3) {
          continue
         }
        }
        break;
       };
       if (!global$2) {
        $5 = HEAP32[$0 + 4 >> 2];
        HEAP16[$0 + 14 >> 1] = HEAPU8[$5 + 1 | 0];
        $3 = LexTokenSize($7);
        label$41 : {
         if (($3 | 0) >= 1) {
          if ($1) {
           $8 = $7 + -45 | 0;
           label$44 : {
            if ($8 >>> 0 > 4) {
             break label$44
            }
            label$45 : {
             switch ($8 - 1 | 0) {
             case 2:
              HEAP32[$4 + 488 >> 2] = HEAP32[$4 + 2072 >> 2];
              break label$44;
             default:
              HEAP32[$4 + 488 >> 2] = 0;
              break label$44;
             case 0:
              HEAP32[$4 + 488 >> 2] = $4 + 1544;
              break label$44;
             case 3:
              HEAP32[$4 + 488 >> 2] = $4 + 1500;
              break label$44;
             case 1:
              break label$45;
             };
            }
            HEAP32[$4 + 488 >> 2] = $4 + 1764;
           }
           memcpy(HEAP32[$4 + 492 >> 2], $5 + 2 | 0, $3);
           HEAP8[$4 + 503 | 0] = 0;
           HEAP16[$4 + 500 >> 1] = 0;
           HEAP32[$4 + 496 >> 2] = 0;
           HEAP32[$1 >> 2] = $4 + 488;
          }
          if (!$2) {
           break label$41
          }
          HEAP32[$0 + 4 >> 2] = (HEAP32[$0 + 4 >> 2] + $3 | 0) + 2;
          break label$41;
         }
         if (!$2 | ($7 | 0) == 93) {
          break label$41
         }
         HEAP32[$0 + 4 >> 2] = $5 + 2;
        }
        if ($7 >>> 0 >= 96) {
         break label$5
        }
       }
      }
      if (!global$2) {
       global$0 = $9 + 272 | 0;
       return $7;
      }
     }
     if (!global$2) {
      __assert_fail(1515, 1425, 700, 1500);
      abort();
     }
    }
    if (!global$2) {
     __assert_fail(1515, 1425, 702, 1500);
     abort();
    }
   }
   if (!global$2) {
    __assert_fail(1550, 1425, 749, 1500);
    abort();
   }
   abort();
  }
  $6 = $11;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $4;
  HEAP32[$6 + 20 >> 2] = $5;
  HEAP32[$6 + 24 >> 2] = $7;
  HEAP32[$6 + 28 >> 2] = $8;
  HEAP32[$6 + 32 >> 2] = $9;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 36;
  return 0;
 }
 
 function LexHashIncPos($0, $1) {
  var $2 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2 | (global$2 ? $1 : !$1)) {
    if (global$2 ? !$2 : 1) {
     LexGetRawToken($0, 0, 1);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function LexHashIfdef($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $3 = HEAP32[$2 + 8 >> 2];
   $4 = HEAP32[$2 + 12 >> 2];
   $6 = HEAP32[$2 + 16 >> 2];
   $5 = HEAP32[$2 + 20 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $7 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $4 = global$0 - 16 | 0;
   global$0 = $4;
   $3 = $4 + 12 | 0;
  }
  label$2 : {
   if (global$2 ? !$7 : 1) {
    $2 = LexGetRawToken($0, $3, 1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $2;
   }
   if ((global$2 | 0) == 2 | (global$2 ? $3 : ($3 | 0) != 45)) {
    if (global$2 ? ($7 | 0) == 1 : 1) {
     ProgramFail($0, 1600, 0);
     $8 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $6 = TableGet(HEAP32[$0 >> 2], HEAP32[HEAP32[HEAP32[$4 + 12 >> 2] + 4 >> 2] >> 2], $4 + 8 | 0, 0, 0, 0);
    $3 = HEAPU16[$0 + 34 >> 1];
    $5 = HEAPU16[$0 + 32 >> 1];
    if (!((($1 | 0) != 0 | 0) == (($6 | 0) != 0 | 0) | ($3 | 0) != ($5 | 0))) {
     HEAP16[$0 + 34 >> 1] = $3 + 1
    }
    HEAP16[$0 + 32 >> 1] = $5 + 1;
    global$0 = $4 + 16 | 0;
   }
   return;
  }
  $2 = $8;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 8 >> 2] = $3;
  HEAP32[$2 + 12 >> 2] = $4;
  HEAP32[$2 + 16 >> 2] = $6;
  HEAP32[$2 + 20 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
 }
 
 function LexHashIf($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $2 = global$0 + -64 | 0;
   global$0 = $2;
   HEAP32[$2 + 56 >> 2] = 0;
   $1 = $2 + 60 | 0;
  }
  label$2 : {
   $7 = $4;
   if (global$2 ? !$5 : 1) {
    $3 = LexGetRawToken($0, $1, 1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $3;
   }
   $4 = global$2 ? $7 : ($1 | 0) == 45;
   if ($4 | (global$2 | 0) == 2) {
    if (!global$2) {
     $4 = HEAP32[HEAP32[HEAP32[$2 + 60 >> 2] + 4 >> 2] >> 2];
     $1 = !TableGet(HEAP32[$0 >> 2], $4, $2 + 56 | 0, 0, 0, 0);
    }
    if ((global$2 | 0) == 2 | $1) {
     if (!global$2) {
      $1 = HEAP32[HEAP32[HEAP32[$2 + 60 >> 2] + 4 >> 2] >> 2];
      HEAP32[$2 >> 2] = $1;
     }
     if (global$2 ? ($5 | 0) == 1 : 1) {
      ProgramFail($0, 1620, $2);
      $6 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    $1 = global$2 ? $1 : HEAP32[HEAP32[HEAP32[$2 + 56 >> 2] >> 2] >> 2] != 11;
    if ($1 | (global$2 | 0) == 2) {
     if (global$2 ? ($5 | 0) == 2 : 1) {
      ProgramFail($0, 1638, 0);
      $6 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (!global$2) {
     ParserCopy($2 + 8 | 0, HEAP32[HEAP32[$2 + 56 >> 2] + 4 >> 2] + 8 | 0);
     $4 = $2 + 60 | 0;
     $1 = $2 + 8 | 0;
    }
    if (global$2 ? ($5 | 0) == 3 : 1) {
     $3 = LexGetRawToken($1, $4, 1);
     $6 = 3;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    } else {
     $3 = $1
    }
    $1 = $3;
   }
   if (!global$2) {
    $1 = $1 + -46 | 0;
    $4 = $1 >>> 0 > 3;
   }
   label$20 : {
    if (!global$2) {
     label$22 : {
      if ($4) {
       break label$22
      }
      switch ($1 - 1 | 0) {
      case 0:
      case 1:
       break label$22;
      default:
       break label$20;
      };
     }
    }
    if (global$2 ? ($5 | 0) == 4 : 1) {
     ProgramFail($0, 1638, 0);
     $6 = 4;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $1 = HEAPU16[$0 + 32 >> 1];
    $4 = HEAPU16[$0 + 34 >> 1];
    if (!(!HEAPU8[HEAP32[HEAP32[$2 + 60 >> 2] + 4 >> 2]] | ($1 | 0) != ($4 | 0))) {
     HEAP16[$0 + 34 >> 1] = $4 + 1
    }
    HEAP16[$0 + 32 >> 1] = $1 + 1;
    global$0 = $2 - -64 | 0;
   }
   return;
  }
  $3 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function LexHashElse($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $4 = HEAP32[$2 + 8 >> 2];
   $5 = HEAP32[$2 + 12 >> 2];
   $2 = HEAP32[$2 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = $0;
   $1 = HEAP16[$0 + 34 >> 1];
   $4 = HEAP16[$0 + 32 >> 1];
   $2 = ($1 | 0) == ($4 + -1 | 0);
  }
  label$2 : {
   label$5 : {
    label$6 : {
     if (!global$2) {
      $6 = $1 + 1 | 0;
      if ($2) {
       break label$6
      }
      if (($1 | 0) != ($4 | 0)) {
       break label$5
      }
      $1 = !$4;
     }
     if ((global$2 | 0) == 2 | $1) {
      if (global$2 ? !$3 : 1) {
       ProgramFail($0, 1653, 0);
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     $6 = global$2 ? $1 : HEAPU16[$0 + 34 >> 1] + -1 | 0;
    }
    $1 = $6;
    if (!global$2) {
     HEAP16[$5 + 34 >> 1] = $1
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $4;
  HEAP32[$3 + 12 >> 2] = $5;
  HEAP32[$3 + 16 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function LexHashEndif($0) {
  var $1 = 0, $2 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2 | (global$2 ? $1 : !HEAPU16[$0 + 32 >> 1])) {
    if (global$2 ? !$2 : 1) {
     ProgramFail($0, 1671, 0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $1 = HEAPU16[$0 + 32 >> 1] + -1 | 0;
    HEAP16[$0 + 32 >> 1] = $1;
    $1 = $1 << 16 >> 16;
    if (HEAP16[$0 + 34 >> 1] > ($1 | 0)) {
     HEAP16[$0 + 34 >> 1] = $1
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function LexGetToken($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -28;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $6 = HEAP32[$3 + 12 >> 2];
   $7 = HEAP32[$3 + 16 >> 2];
   $8 = HEAP32[$3 + 20 >> 2];
   $9 = HEAP32[$3 + 24 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   while (1) {
    $7 = global$2 ? $7 : 0;
    if (global$2 ? !$4 : 1) {
     $3 = LexGetRawToken($0, $1, $2);
     $5 = 0;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $9 = $3;
    }
    if (!global$2) {
     $6 = $9 + -85 | 0;
     $8 = $6 >>> 0 > 4;
    }
    label$7 : {
     if (!global$2) {
      if ($8) {
       break label$7
      }
      $6 = $6 - 1 | 0;
     }
     label$9 : {
      label$10 : {
       label$11 : {
        label$12 : {
         label$13 : {
          if (!global$2) {
           label$15 : {
            switch ($6 | 0) {
            case 3:
             break label$10;
            case 2:
             break label$11;
            case 1:
             break label$13;
            case 0:
             break label$15;
            default:
             break label$12;
            };
           }
          }
          if (global$2 ? ($4 | 0) == 1 : 1) {
           LexHashIncPos($0, $2);
           $5 = 1;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (global$2 ? ($4 | 0) == 2 : 1) {
           LexHashIfdef($0, 0);
           $5 = 2;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (!global$2) {
           break label$9
          }
         }
         if (global$2 ? ($4 | 0) == 3 : 1) {
          LexHashIncPos($0, $2);
          $5 = 3;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         $7 = global$2 ? $7 : 1;
         if (global$2 ? ($4 | 0) == 4 : 1) {
          LexHashIfdef($0, 1);
          $5 = 4;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          break label$7
         }
        }
        if (global$2 ? ($4 | 0) == 5 : 1) {
         LexHashIncPos($0, $2);
         $5 = 5;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (global$2 ? ($4 | 0) == 6 : 1) {
         LexHashIf($0);
         $5 = 6;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         break label$9
        }
       }
       if (global$2 ? ($4 | 0) == 7 : 1) {
        LexHashIncPos($0, $2);
        $5 = 7;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (global$2 ? ($4 | 0) == 8 : 1) {
        LexHashElse($0);
        $5 = 8;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        break label$9
       }
      }
      if (global$2 ? ($4 | 0) == 9 : 1) {
       LexHashIncPos($0, $2);
       $5 = 9;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (global$2 ? ($4 | 0) == 10 : 1) {
       LexHashEndif($0);
       $5 = 10;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     $7 = global$2 ? $7 : 1;
    }
    if (!global$2) {
     label$27 : {
      if (($9 | 0) != 93) {
       $8 = HEAP16[$0 + 34 >> 1] < HEAP16[$0 + 32 >> 1];
       $6 = 1;
       if ($8) {
        break label$27
       }
      }
      $6 = ($7 | 0) != 0;
     }
    }
    label$29 : {
     if (!global$2) {
      if ($2) {
       break label$29
      }
      $8 = !$6;
      if ($8) {
       break label$29
      }
     }
     if (global$2 ? ($4 | 0) == 11 : 1) {
      $3 = LexGetRawToken($0, 0, 1);
      $5 = 11;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $8 = $3;
     }
    }
    if ($6 ? !global$2 : 0) {
     continue
    }
    break;
   };
   if (!global$2) {
    return $9
   }
   abort();
  }
  $3 = $5;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $6;
  HEAP32[$3 + 16 >> 2] = $7;
  HEAP32[$3 + 20 >> 2] = $8;
  HEAP32[$3 + 24 >> 2] = $9;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 28;
  return 0;
 }
 
 function LexRawPeekToken($0) {
  return HEAPU8[HEAP32[$0 + 4 >> 2]];
 }
 
 function LexToEndOfLine($0) {
  var $1 = 0, $2 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2 | (global$2 ? $1 : (HEAPU8[HEAP32[$0 + 4 >> 2]] + -93 & 255) >>> 0 >= 2)) {
    while (1) {
     if (global$2 ? !$2 : 1) {
      LexGetRawToken($0, 0, 1);
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if ((HEAPU8[HEAP32[$0 + 4 >> 2]] + -93 & 255) >>> 0 > 1 ? !global$2 : 0) {
      continue
     }
     break;
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function LexCopyTokens($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -40;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $5 = HEAP32[$3 + 16 >> 2];
   $7 = HEAP32[$3 + 20 >> 2];
   $8 = HEAP32[$3 + 24 >> 2];
   $9 = HEAP32[$3 + 28 >> 2];
   $6 = HEAP32[$3 + 32 >> 2];
   $10 = HEAP32[$3 + 36 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $11 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $7 = HEAP32[$0 + 4 >> 2];
   $8 = HEAP32[$0 >> 2];
   $2 = HEAP32[$8 + 400 >> 2];
   $4 = !$2;
  }
  label$2 : {
   label$4 : {
    if ((global$2 | 0) == 2 | $4) {
     if (!global$2) {
      $6 = HEAP32[$1 + 4 >> 2] - $7 | 0;
      $1 = $6 + 2 | 0;
     }
     if (global$2 ? !$11 : 1) {
      $3 = VariableAlloc($8, $0, $1, 1);
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $9 = $3;
     }
     if (!global$2) {
      memcpy($9, HEAP32[$0 + 4 >> 2], $6);
      break label$4;
     }
    }
    if (!global$2) {
     HEAP32[$8 + 408 >> 2] = $2;
     while (1) {
      $4 = HEAP32[$2 + 4 >> 2];
      if (!($7 >>> 0 < HEAP32[$2 + 8 >> 2] + $4 >>> 0 ? $7 >>> 0 >= $4 >>> 0 : 0)) {
       $2 = HEAP32[$2 >> 2];
       HEAP32[$8 + 408 >> 2] = $2;
       if ($2) {
        continue
       }
      }
      break;
     };
     $5 = HEAP32[$1 + 4 >> 2];
     $4 = $5 >>> 0 < $7 >>> 0;
    }
    label$15 : {
     if (!global$2) {
      if ($4) {
       break label$15
      }
      $6 = HEAP32[$2 + 8 >> 2];
      if ($5 >>> 0 >= $6 + HEAP32[$2 + 4 >> 2] >>> 0) {
       break label$15
      }
      $6 = $5 - $7 | 0;
      $1 = $6 + 2 | 0;
     }
     if (global$2 ? ($11 | 0) == 1 : 1) {
      $3 = VariableAlloc($8, $0, $1, 1);
      $12 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $9 = $3;
     }
     if (!global$2) {
      memcpy($9, HEAP32[$0 + 4 >> 2], $6);
      break label$4;
     }
    }
    if (!global$2) {
     $4 = HEAP32[$2 >> 2];
     label$20 : {
      if ($4) {
       $2 = ((HEAP32[$2 + 4 >> 2] + HEAP32[$2 + 8 >> 2] | 0) - $7 | 0) + -2 | 0;
       while (1) {
        $10 = HEAP32[$4 + 4 >> 2];
        if ($5 >>> 0 < HEAP32[$4 + 8 >> 2] + $10 >>> 0 ? $5 >>> 0 >= $10 >>> 0 : 0) {
         break label$20
        }
        $2 = (HEAP32[$4 + 8 >> 2] + $2 | 0) + -2 | 0;
        $4 = HEAP32[$4 >> 2];
        if ($4) {
         continue
        }
        break;
       };
      }
      __assert_fail(1690, 1425, 972, 1704);
      abort();
     }
     $6 = (HEAP32[$1 + 4 >> 2] - HEAP32[$4 + 4 >> 2] | 0) + $2 | 0;
     $2 = $6 + 2 | 0;
    }
    if (global$2 ? ($11 | 0) == 2 : 1) {
     $3 = VariableAlloc($8, $0, $2, 1);
     $12 = 2;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $9 = $3;
    }
    if (!global$2) {
     $4 = HEAP32[$8 + 408 >> 2];
     $2 = ((HEAP32[$4 + 8 >> 2] + HEAP32[$4 + 4 >> 2] | 0) - $7 | 0) + -2 | 0;
     $5 = memcpy($9, $7, $2);
     $4 = HEAP32[HEAP32[$8 + 408 >> 2] >> 2];
     label$26 : {
      if ($4) {
       $5 = $2 + $5 | 0;
       while (1) {
        $10 = HEAP32[$1 + 4 >> 2];
        $2 = HEAP32[$4 + 4 >> 2];
        if ($10 >>> 0 < HEAP32[$4 + 8 >> 2] + $2 >>> 0 ? $10 >>> 0 >= $2 >>> 0 : 0) {
         break label$26
        }
        $5 = (memcpy($5, $2, HEAP32[$4 + 8 >> 2] + -2 | 0) + HEAP32[$4 + 8 >> 2] | 0) + -2 | 0;
        $4 = HEAP32[$4 >> 2];
        if ($4) {
         continue
        }
        break;
       };
      }
      __assert_fail(1690, 1425, 984, 1704);
      abort();
     }
     memcpy($5, $2, HEAP32[$1 + 4 >> 2] - $2 | 0);
    }
   }
   if (!global$2) {
    HEAP8[$9 + $6 | 0] = 95;
    return $9;
   }
   abort();
  }
  $3 = $12;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[$3 + 16 >> 2] = $5;
  HEAP32[$3 + 20 >> 2] = $7;
  HEAP32[$3 + 24 >> 2] = $8;
  HEAP32[$3 + 28 >> 2] = $9;
  HEAP32[$3 + 32 >> 2] = $6;
  HEAP32[$3 + 36 >> 2] = $10;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 40;
  return 0;
 }
 
 function LexInteractiveCompleted($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0, $4 = 0;
  label$1 : {
   $2 = HEAP32[$0 + 400 >> 2];
   if (!$2) {
    break label$1
   }
   while (1) {
    $4 = HEAP32[$1 + 4 >> 2];
    $3 = HEAP32[$2 + 4 >> 2];
    if ($4 >>> 0 < HEAP32[$2 + 8 >> 2] + $3 >>> 0 ? $4 >>> 0 >= $3 >>> 0 : 0) {
     break label$1
    }
    $2 = HEAP32[$2 >> 2];
    HeapFreeMem($0, $3);
    HeapFreeMem($0, HEAP32[$0 + 400 >> 2]);
    HEAP32[$0 + 400 >> 2] = $2;
    if (!$2) {
     HEAP32[$1 + 4 >> 2] = 0;
     HEAP32[$0 + 404 >> 2] = 0;
    }
    $2 = HEAP32[$0 + 400 >> 2];
    if ($2) {
     continue
    }
    break;
   };
  }
 }
 
 function LexInteractiveStatementPrompt($0) {
  $0 = $0 | 0;
  HEAP32[$0 + 412 >> 2] = 1;
 }
 
 function ParseCleanup($0) {
  var $1 = 0, $2 = 0;
  $1 = HEAP32[$0 + 8 >> 2];
  if ($1) {
   while (1) {
    $2 = HEAP32[$1 + 8 >> 2];
    HeapFreeMem($0, HEAP32[$1 >> 2]);
    $1 = HEAP32[HEAP32[$0 + 8 >> 2] + 4 >> 2];
    if ($1) {
     HeapFreeMem($0, $1)
    }
    HeapFreeMem($0, HEAP32[$0 + 8 >> 2]);
    HEAP32[$0 + 8 >> 2] = $2;
    $1 = $2;
    if ($1) {
     continue
    }
    break;
   }
  }
 }
 
 function ParseStatementMaybeRun($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   label$4 : {
    if (!global$2) {
     if ($1) {
      break label$4
     }
     $1 = HEAP32[$0 + 16 >> 2];
     if (($1 | 0) == 1) {
      break label$4
     }
     HEAP32[$0 + 16 >> 2] = 1;
    }
    if (global$2 ? !$4 : 1) {
     $3 = ParseStatement($0, $2);
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $2 = $3;
    }
    if (!global$2) {
     HEAP32[$0 + 16 >> 2] = $1;
     return $2;
    }
   }
   if (global$2 ? ($4 | 0) == 1 : 1) {
    $3 = ParseStatement($0, $2);
    $5 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $3;
   }
   if (!global$2) {
    return $0
   }
   abort();
  }
  $3 = $5;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
  return 0;
 }
 
 function ParseStatement($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -28;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $5 = HEAP32[$3 + 12 >> 2];
   $7 = HEAP32[$3 + 16 >> 2];
   $8 = HEAP32[$3 + 20 >> 2];
   $9 = HEAP32[$3 + 24 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = global$0 - 112 | 0;
   global$0 = $5;
   $2 = !HEAPU8[$0 + 36 | 0];
  }
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($2) {
      break label$5
     }
     $2 = HEAP32[$0 + 16 >> 2];
     if ($2) {
      break label$5
     }
    }
    if (global$2 ? !$6 : 1) {
     DebugCheckStatement($0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    ParserCopy($5 + 56 | 0, $0);
    $2 = $5 + 108 | 0;
   }
   if (global$2 ? ($6 | 0) == 1 : 1) {
    $3 = LexGetToken($0, $2, 1);
    $4 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $8 = $3;
   }
   if (!global$2) {
    $7 = $8 + -19 | 0;
    $2 = $7 >>> 0 > 74;
   }
   label$11 : {
    label$12 : {
     label$13 : {
      label$14 : {
       label$15 : {
        if (!global$2) {
         if ($2) {
          break label$15
         }
         $7 = $7 - 1 | 0;
         $2 = 0;
        }
        label$17 : {
         label$18 : {
          label$19 : {
           label$20 : {
            label$21 : {
             label$22 : {
              label$23 : {
               label$24 : {
                label$25 : {
                 label$26 : {
                  label$27 : {
                   label$28 : {
                    label$29 : {
                     label$30 : {
                      label$31 : {
                       label$32 : {
                        label$33 : {
                         label$34 : {
                          if (!global$2) {
                           label$36 : {
                            switch ($7 | 0) {
                            case 73:
                             break label$11;
                            case 30:
                             break label$12;
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 11:
                            case 12:
                            case 15:
                            case 16:
                            case 17:
                            case 18:
                            case 19:
                            case 20:
                            case 21:
                            case 22:
                            case 24:
                            case 26:
                            case 27:
                            case 28:
                            case 29:
                            case 31:
                            case 33:
                            case 53:
                            case 65:
                            case 66:
                            case 67:
                            case 68:
                            case 69:
                            case 70:
                            case 72:
                             break label$15;
                            case 71:
                             break label$17;
                            case 55:
                             break label$18;
                            case 50:
                             break label$19;
                            case 62:
                             break label$20;
                            case 51:
                             break label$21;
                            case 58:
                             break label$22;
                            case 61:
                             break label$23;
                            case 60:
                             break label$24;
                            case 59:
                             break label$25;
                            case 64:
                             break label$26;
                            case 63:
                             break label$27;
                            case 34:
                            case 35:
                            case 36:
                            case 37:
                            case 38:
                            case 39:
                            case 40:
                            case 41:
                            case 42:
                            case 43:
                            case 44:
                            case 45:
                            case 46:
                            case 47:
                            case 48:
                            case 49:
                             break label$28;
                            case 54:
                             break label$29;
                            case 52:
                             break label$30;
                            case 57:
                             break label$31;
                            case 56:
                             break label$32;
                            case 32:
                             break label$33;
                            case 25:
                             break label$36;
                            default:
                             break label$34;
                            };
                           }
                           $7 = HEAP32[HEAP32[HEAP32[$5 + 108 >> 2] + 4 >> 2] >> 2];
                           $2 = VariableDefined(HEAP32[$0 >> 2], $7);
                          }
                          if ((global$2 | 0) == 2 | $2) {
                           if (!global$2) {
                            $7 = HEAP32[HEAP32[HEAP32[$5 + 108 >> 2] + 4 >> 2] >> 2];
                            $9 = $5 + 104 | 0;
                            $2 = HEAP32[$0 >> 2];
                           }
                           if (global$2 ? ($6 | 0) == 2 : 1) {
                            VariableGet($2, $0, $7, $9);
                            $4 = 2;
                            if ((global$2 | 0) == 1) {
                             break label$2
                            }
                           }
                           if (!global$2) {
                            $2 = HEAP32[HEAP32[HEAP32[$5 + 104 >> 2] >> 2] >> 2] != 18;
                            if ($2) {
                             break label$34
                            }
                            $4 = HEAP32[$5 + 60 >> 2];
                            $3 = HEAP32[$5 + 56 >> 2];
                            HEAP32[$0 >> 2] = $3;
                            HEAP32[$0 + 4 >> 2] = $4;
                            HEAP32[$0 + 40 >> 2] = HEAP32[$5 + 96 >> 2];
                            $3 = HEAP32[$5 + 92 >> 2];
                            $4 = HEAP32[$5 + 88 >> 2];
                            HEAP32[$0 + 32 >> 2] = $4;
                            HEAP32[$0 + 36 >> 2] = $3;
                            $4 = HEAP32[$5 + 84 >> 2];
                            $3 = HEAP32[$5 + 80 >> 2];
                            HEAP32[$0 + 24 >> 2] = $3;
                            HEAP32[$0 + 28 >> 2] = $4;
                            $3 = HEAP32[$5 + 76 >> 2];
                            $4 = HEAP32[$5 + 72 >> 2];
                            HEAP32[$0 + 16 >> 2] = $4;
                            HEAP32[$0 + 20 >> 2] = $3;
                            $2 = $5 - -64 | 0;
                            $4 = HEAP32[$2 + 4 >> 2];
                            $3 = HEAP32[$2 >> 2];
                            HEAP32[$0 + 8 >> 2] = $3;
                            HEAP32[$0 + 12 >> 2] = $4;
                           }
                           if (global$2 ? ($6 | 0) == 3 : 1) {
                            $3 = ParseDeclaration($0, $8);
                            $4 = 3;
                            if ((global$2 | 0) == 1) {
                             break label$2
                            }
                            $2 = $3;
                           }
                           if (!global$2) {
                            $2 = $1;
                            break label$12;
                           }
                          }
                          $7 = global$2 ? $7 : 1;
                          if (global$2 ? ($6 | 0) == 4 : 1) {
                           $3 = LexGetToken($0, 0, 0);
                           $4 = 4;
                           if ((global$2 | 0) == 1) {
                            break label$2
                           }
                           $2 = $3;
                          }
                          $2 = global$2 ? $2 : ($2 | 0) != 14;
                          label$44 : {
                           if ($2 ? !global$2 : 0) {
                            break label$44
                           }
                           if (global$2 ? ($6 | 0) == 5 : 1) {
                            $3 = LexGetToken($0, 0, 1);
                            $4 = 5;
                            if ((global$2 | 0) == 1) {
                             break label$2
                            }
                            $1 = $3;
                           }
                           if (!global$2) {
                            $7 = 0;
                            $1 = 0;
                            $2 = HEAP32[$0 + 16 >> 2] != 6;
                            if ($2) {
                             break label$44
                            }
                            $8 = HEAP32[$0 + 24 >> 2];
                            $2 = ($8 | 0) != HEAP32[HEAP32[HEAP32[$5 + 108 >> 2] + 4 >> 2] >> 2];
                            if ($2) {
                             break label$44
                            }
                            HEAP32[$0 + 16 >> 2] = 0;
                           }
                          }
                          if (!global$2) {
                           $2 = $1;
                           $7 = !$7;
                           if ($7) {
                            break label$12
                           }
                          }
                         }
                         if (!global$2) {
                          $3 = HEAP32[$5 + 60 >> 2];
                          $4 = HEAP32[$5 + 56 >> 2];
                          HEAP32[$0 >> 2] = $4;
                          HEAP32[$0 + 4 >> 2] = $3;
                          HEAP32[$0 + 40 >> 2] = HEAP32[$5 + 96 >> 2];
                          $4 = HEAP32[$5 + 92 >> 2];
                          $3 = HEAP32[$5 + 88 >> 2];
                          HEAP32[$0 + 32 >> 2] = $3;
                          HEAP32[$0 + 36 >> 2] = $4;
                          $3 = HEAP32[$5 + 84 >> 2];
                          $4 = HEAP32[$5 + 80 >> 2];
                          HEAP32[$0 + 24 >> 2] = $4;
                          HEAP32[$0 + 28 >> 2] = $3;
                          $4 = HEAP32[$5 + 76 >> 2];
                          $3 = HEAP32[$5 + 72 >> 2];
                          $2 = $0 + 16 | 0;
                          HEAP32[$2 >> 2] = $3;
                          HEAP32[$2 + 4 >> 2] = $4;
                          $3 = $5 - -64 | 0;
                          $4 = HEAP32[$3 >> 2];
                          $3 = HEAP32[$3 + 4 >> 2];
                          HEAP32[$0 + 8 >> 2] = $4;
                          HEAP32[$0 + 12 >> 2] = $3;
                          $7 = $5 + 8 | 0;
                         }
                         if (global$2 ? ($6 | 0) == 6 : 1) {
                          $3 = ExpressionParse($0, $7);
                          $4 = 6;
                          if ((global$2 | 0) == 1) {
                           break label$2
                          }
                          $7 = $3;
                         }
                         if (!global$2) {
                          $2 = HEAP32[$2 >> 2];
                          if ($2) {
                           break label$13
                          }
                          $2 = HEAP32[$5 + 8 >> 2];
                         }
                         if (global$2 ? ($6 | 0) == 7 : 1) {
                          VariableStackPop($0, $2);
                          $4 = 7;
                          if ((global$2 | 0) == 1) {
                           break label$2
                          }
                         }
                         if (!global$2) {
                          break label$13
                         }
                        }
                        $2 = global$2 ? $2 : 0;
                        if (global$2 ? ($6 | 0) == 8 : 1) {
                         $3 = ParseBlock($0, 0, 1);
                         $4 = 8;
                         if ((global$2 | 0) == 1) {
                          break label$2
                         }
                         $1 = $3;
                        }
                        if (!global$2) {
                         break label$12
                        }
                       }
                       if (global$2 ? ($6 | 0) == 9 : 1) {
                        $3 = LexGetToken($0, 0, 1);
                        $4 = 9;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                        $1 = $3;
                       }
                       $1 = global$2 ? $1 : ($1 | 0) != 43;
                       if ($1 | (global$2 | 0) == 2) {
                        if (global$2 ? ($6 | 0) == 10 : 1) {
                         ProgramFail($0, 2400, 0);
                         $4 = 10;
                         if ((global$2 | 0) == 1) {
                          break label$2
                         }
                        }
                       }
                       if (global$2 ? ($6 | 0) == 11 : 1) {
                        $3 = ExpressionParseInt($0);
                        $4 = 11;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                        $7 = $3;
                       }
                       if (global$2 ? ($6 | 0) == 12 : 1) {
                        $3 = LexGetToken($0, 0, 1);
                        $4 = 12;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                        $1 = $3;
                       }
                       $1 = global$2 ? $1 : ($1 | 0) != 44;
                       if ($1 | (global$2 | 0) == 2) {
                        if (global$2 ? ($6 | 0) == 13 : 1) {
                         ProgramFail($0, 2445, 0);
                         $4 = 13;
                         if ((global$2 | 0) == 1) {
                          break label$2
                         }
                        }
                       }
                       if (global$2 ? ($6 | 0) == 14 : 1) {
                        $3 = ParseStatementMaybeRun($0, $7, 1);
                        $4 = 14;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                        $1 = $3;
                       }
                       $1 = global$2 ? $1 : ($1 | 0) != 2;
                       if ($1 | (global$2 | 0) == 2) {
                        if (global$2 ? ($6 | 0) == 15 : 1) {
                         ProgramFail($0, 2413, 0);
                         $4 = 15;
                         if ((global$2 | 0) == 1) {
                          break label$2
                         }
                        }
                       }
                       $2 = global$2 ? $2 : 0;
                       if (global$2 ? ($6 | 0) == 16 : 1) {
                        $3 = LexGetToken($0, 0, 0);
                        $4 = 16;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                        $1 = $3;
                       }
                       if (!global$2) {
                        $1 = ($1 | 0) != 73;
                        if ($1) {
                         break label$12
                        }
                        $2 = 0;
                       }
                       if (global$2 ? ($6 | 0) == 17 : 1) {
                        $3 = LexGetToken($0, 0, 1);
                        $4 = 17;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                        $1 = $3;
                       }
                       $1 = global$2 ? $1 : !$7;
                       if (global$2 ? ($6 | 0) == 18 : 1) {
                        $3 = ParseStatementMaybeRun($0, $1, 1);
                        $4 = 18;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                        $1 = $3;
                       }
                       if (!global$2) {
                        $1 = ($1 | 0) == 2;
                        if ($1) {
                         break label$12
                        }
                        $2 = 0;
                       }
                       if (global$2 ? ($6 | 0) == 19 : 1) {
                        ProgramFail($0, 2413, 0);
                        $4 = 19;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                       }
                       if (!global$2) {
                        break label$12
                       }
                      }
                      $8 = global$2 ? $8 : HEAP32[$0 + 16 >> 2];
                      if (global$2 ? ($6 | 0) == 20 : 1) {
                       $3 = LexGetToken($0, 0, 1);
                       $4 = 20;
                       if ((global$2 | 0) == 1) {
                        break label$2
                       }
                       $1 = $3;
                      }
                      $1 = global$2 ? $1 : ($1 | 0) != 43;
                      if ($1 | (global$2 | 0) == 2) {
                       if (global$2 ? ($6 | 0) == 21 : 1) {
                        ProgramFail($0, 2400, 0);
                        $4 = 21;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                       }
                      }
                      if (!global$2) {
                       $1 = $5 + 8 | 0;
                       ParserCopyPos($1, $0);
                      }
                      while (1) {
                       $1 = global$2 ? $1 : HEAP32[$0 >> 2];
                       if (global$2 ? ($6 | 0) == 22 : 1) {
                        emscripten_sleep_pc($1);
                        $4 = 22;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                       }
                       if (!global$2) {
                        $1 = $5 + 8 | 0;
                        ParserCopyPos($0, $1);
                       }
                       if (global$2 ? ($6 | 0) == 23 : 1) {
                        $3 = ExpressionParseInt($0);
                        $4 = 23;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                        $2 = $3;
                       }
                       if (global$2 ? ($6 | 0) == 24 : 1) {
                        $3 = LexGetToken($0, 0, 1);
                        $4 = 24;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                        $1 = $3;
                       }
                       $1 = global$2 ? $1 : ($1 | 0) != 44;
                       if ($1 | (global$2 | 0) == 2) {
                        if (global$2 ? ($6 | 0) == 25 : 1) {
                         ProgramFail($0, 2445, 0);
                         $4 = 25;
                         if ((global$2 | 0) == 1) {
                          break label$2
                         }
                        }
                       }
                       if (global$2 ? ($6 | 0) == 26 : 1) {
                        $3 = ParseStatementMaybeRun($0, $2, 1);
                        $4 = 26;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                        $1 = $3;
                       }
                       $1 = global$2 ? $1 : ($1 | 0) != 2;
                       if ($1 | (global$2 | 0) == 2) {
                        if (global$2 ? ($6 | 0) == 27 : 1) {
                         ProgramFail($0, 2413, 0);
                         $4 = 27;
                         if ((global$2 | 0) == 1) {
                          break label$2
                         }
                        }
                       }
                       if (!global$2) {
                        if (HEAP32[$0 + 16 >> 2] == 5) {
                         HEAP32[$0 + 16 >> 2] = $8
                        }
                        $7 = HEAP32[$0 + 16 >> 2];
                        $1 = $7 ? 0 : $2;
                        if ($1) {
                         continue
                        }
                       }
                       break;
                      };
                      if (!global$2) {
                       $1 = ($7 | 0) == 4;
                       if ($1) {
                        HEAP32[$0 + 16 >> 2] = $8
                       }
                       $2 = 0;
                       break label$12;
                      }
                     }
                     if (!global$2) {
                      $7 = HEAP32[$0 + 16 >> 2];
                      $2 = $5 + 8 | 0;
                      ParserCopyPos($2, $0);
                     }
                     while (1) {
                      $2 = global$2 ? $2 : HEAP32[$0 >> 2];
                      if (global$2 ? ($6 | 0) == 28 : 1) {
                       emscripten_sleep_pc($2);
                       $4 = 28;
                       if ((global$2 | 0) == 1) {
                        break label$2
                       }
                      }
                      if (!global$2) {
                       $2 = $5 + 8 | 0;
                       ParserCopyPos($0, $2);
                      }
                      if (global$2 ? ($6 | 0) == 29 : 1) {
                       $3 = ParseStatement($0, 1);
                       $4 = 29;
                       if ((global$2 | 0) == 1) {
                        break label$2
                       }
                       $2 = $3;
                      }
                      $2 = global$2 ? $2 : ($2 | 0) != 2;
                      if ($2 | (global$2 | 0) == 2) {
                       if (global$2 ? ($6 | 0) == 30 : 1) {
                        ProgramFail($0, 2413, 0);
                        $4 = 30;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                       }
                      }
                      if (!global$2) {
                       $2 = HEAP32[$0 + 16 >> 2] == 5;
                       if ($2) {
                        HEAP32[$0 + 16 >> 2] = $7
                       }
                      }
                      if (global$2 ? ($6 | 0) == 31 : 1) {
                       $3 = LexGetToken($0, 0, 1);
                       $4 = 31;
                       if ((global$2 | 0) == 1) {
                        break label$2
                       }
                       $2 = $3;
                      }
                      $2 = global$2 ? $2 : ($2 | 0) != 77;
                      if ($2 | (global$2 | 0) == 2) {
                       if (global$2 ? ($6 | 0) == 32 : 1) {
                        ProgramFail($0, 2471, 0);
                        $4 = 32;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                       }
                      }
                      if (global$2 ? ($6 | 0) == 33 : 1) {
                       $3 = LexGetToken($0, 0, 1);
                       $4 = 33;
                       if ((global$2 | 0) == 1) {
                        break label$2
                       }
                       $2 = $3;
                      }
                      $2 = global$2 ? $2 : ($2 | 0) != 43;
                      if ($2 | (global$2 | 0) == 2) {
                       if (global$2 ? ($6 | 0) == 34 : 1) {
                        ProgramFail($0, 2400, 0);
                        $4 = 34;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                       }
                      }
                      if (global$2 ? ($6 | 0) == 35 : 1) {
                       $3 = ExpressionParseInt($0);
                       $4 = 35;
                       if ((global$2 | 0) == 1) {
                        break label$2
                       }
                       $2 = $3;
                      }
                      if (global$2 ? ($6 | 0) == 36 : 1) {
                       $3 = LexGetToken($0, 0, 1);
                       $4 = 36;
                       if ((global$2 | 0) == 1) {
                        break label$2
                       }
                       $8 = $3;
                      }
                      $8 = global$2 ? $8 : ($8 | 0) != 44;
                      if ($8 | (global$2 | 0) == 2) {
                       if (global$2 ? ($6 | 0) == 37 : 1) {
                        ProgramFail($0, 2445, 0);
                        $4 = 37;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                       }
                      }
                      if (!global$2) {
                       if ($2) {
                        $2 = !HEAP32[$0 + 16 >> 2];
                        if ($2) {
                         continue
                        }
                       }
                      }
                      break;
                     };
                     if (!global$2) {
                      $2 = HEAP32[$0 + 16 >> 2] != 4;
                      if ($2) {
                       break label$13
                      }
                      HEAP32[$0 + 16 >> 2] = $7;
                      $2 = $1;
                      break label$12;
                     }
                    }
                    if (global$2 ? ($6 | 0) == 38 : 1) {
                     ParseFor($0);
                     $4 = 38;
                     if ((global$2 | 0) == 1) {
                      break label$2
                     }
                    }
                    if (!global$2) {
                     break label$12
                    }
                   }
                   if (!global$2) {
                    $4 = HEAP32[$5 + 60 >> 2];
                    $3 = HEAP32[$5 + 56 >> 2];
                    HEAP32[$0 >> 2] = $3;
                    HEAP32[$0 + 4 >> 2] = $4;
                    HEAP32[$0 + 40 >> 2] = HEAP32[$5 + 96 >> 2];
                    $3 = HEAP32[$5 + 92 >> 2];
                    $4 = HEAP32[$5 + 88 >> 2];
                    HEAP32[$0 + 32 >> 2] = $4;
                    HEAP32[$0 + 36 >> 2] = $3;
                    $4 = HEAP32[$5 + 84 >> 2];
                    $3 = HEAP32[$5 + 80 >> 2];
                    HEAP32[$0 + 24 >> 2] = $3;
                    HEAP32[$0 + 28 >> 2] = $4;
                    $3 = HEAP32[$5 + 76 >> 2];
                    $4 = HEAP32[$5 + 72 >> 2];
                    HEAP32[$0 + 16 >> 2] = $4;
                    HEAP32[$0 + 20 >> 2] = $3;
                    $1 = $5 - -64 | 0;
                    $4 = HEAP32[$1 + 4 >> 2];
                    $3 = HEAP32[$1 >> 2];
                    HEAP32[$0 + 8 >> 2] = $3;
                    HEAP32[$0 + 12 >> 2] = $4;
                   }
                   if (global$2 ? ($6 | 0) == 39 : 1) {
                    $3 = ParseDeclaration($0, $8);
                    $4 = 39;
                    if ((global$2 | 0) == 1) {
                     break label$2
                    }
                    $2 = $3;
                   }
                   if (!global$2) {
                    break label$12
                   }
                  }
                  if (global$2 ? ($6 | 0) == 40 : 1) {
                   ParseMacroDefinition($0);
                   $4 = 40;
                   if ((global$2 | 0) == 1) {
                    break label$2
                   }
                  }
                  if (!global$2) {
                   break label$12
                  }
                 }
                 $1 = global$2 ? $1 : $5 + 108 | 0;
                 if (global$2 ? ($6 | 0) == 41 : 1) {
                  $3 = LexGetToken($0, $1, 1);
                  $4 = 41;
                  if ((global$2 | 0) == 1) {
                   break label$2
                  }
                  $1 = $3;
                 }
                 $1 = global$2 ? $1 : ($1 | 0) != 48;
                 if ($1 | (global$2 | 0) == 2) {
                  if (global$2 ? ($6 | 0) == 42 : 1) {
                   ProgramFail($0, 2488, 0);
                   $4 = 42;
                   if ((global$2 | 0) == 1) {
                    break label$2
                   }
                  }
                 }
                 if (!global$2) {
                  $7 = HEAP32[HEAP32[HEAP32[$5 + 108 >> 2] + 4 >> 2] >> 2];
                  $1 = HEAP32[$0 >> 2];
                 }
                 if (global$2 ? ($6 | 0) == 43 : 1) {
                  IncludeFile($1, $7);
                  $4 = 43;
                  if ((global$2 | 0) == 1) {
                   break label$2
                  }
                 }
                 if (!global$2) {
                  break label$12
                 }
                }
                if (global$2 ? ($6 | 0) == 44 : 1) {
                 $3 = LexGetToken($0, 0, 1);
                 $4 = 44;
                 if ((global$2 | 0) == 1) {
                  break label$2
                 }
                 $1 = $3;
                }
                $1 = global$2 ? $1 : ($1 | 0) != 43;
                if ($1 | (global$2 | 0) == 2) {
                 if (global$2 ? ($6 | 0) == 45 : 1) {
                  ProgramFail($0, 2400, 0);
                  $4 = 45;
                  if ((global$2 | 0) == 1) {
                   break label$2
                  }
                 }
                }
                if (global$2 ? ($6 | 0) == 46 : 1) {
                 $3 = ExpressionParseInt($0);
                 $4 = 46;
                 if ((global$2 | 0) == 1) {
                  break label$2
                 }
                 $2 = $3;
                }
                if (global$2 ? ($6 | 0) == 47 : 1) {
                 $3 = LexGetToken($0, 0, 1);
                 $4 = 47;
                 if ((global$2 | 0) == 1) {
                  break label$2
                 }
                 $1 = $3;
                }
                $1 = global$2 ? $1 : ($1 | 0) != 44;
                if ($1 | (global$2 | 0) == 2) {
                 if (global$2 ? ($6 | 0) == 48 : 1) {
                  ProgramFail($0, 2445, 0);
                  $4 = 48;
                  if ((global$2 | 0) == 1) {
                   break label$2
                  }
                 }
                }
                if (global$2 ? ($6 | 0) == 49 : 1) {
                 $3 = LexGetToken($0, 0, 0);
                 $4 = 49;
                 if ((global$2 | 0) == 1) {
                  break label$2
                 }
                 $1 = $3;
                }
                $1 = global$2 ? $1 : ($1 | 0) != 52;
                if ($1 | (global$2 | 0) == 2) {
                 if (global$2 ? ($6 | 0) == 50 : 1) {
                  ProgramFail($0, 2458, 0);
                  $4 = 50;
                  if ((global$2 | 0) == 1) {
                   break label$2
                  }
                 }
                }
                if (!global$2) {
                 $7 = HEAP32[$0 + 20 >> 2];
                 HEAP32[$0 + 20 >> 2] = $2;
                 $2 = HEAP32[$0 + 16 >> 2];
                 HEAP32[$0 + 16 >> 2] = 3;
                 $1 = $2 + -1 >>> 0 > 1;
                }
                if (global$2 ? ($6 | 0) == 51 : 1) {
                 $3 = ParseBlock($0, 1, $1);
                 $4 = 51;
                 if ((global$2 | 0) == 1) {
                  break label$2
                 }
                 $1 = $3;
                }
                if (!global$2) {
                 $1 = HEAP32[$0 + 16 >> 2] != 2;
                 if ($1) {
                  HEAP32[$0 + 16 >> 2] = $2
                 }
                 HEAP32[$0 + 20 >> 2] = $7;
                 $2 = 0;
                 break label$12;
                }
               }
               $1 = global$2 ? $1 : HEAP32[$0 + 16 >> 2] == 3;
               label$150 : {
                if ($1 | (global$2 | 0) == 2) {
                 if (!global$2) {
                  HEAP32[$0 + 16 >> 2] = 0
                 }
                 if (global$2 ? ($6 | 0) == 52 : 1) {
                  $3 = ExpressionParseInt($0);
                  $4 = 52;
                  if ((global$2 | 0) == 1) {
                   break label$2
                  }
                  $7 = $3;
                 }
                 if (!global$2) {
                  HEAP32[$0 + 16 >> 2] = 3;
                  break label$150;
                 }
                }
                if (global$2 ? ($6 | 0) == 53 : 1) {
                 $3 = ExpressionParseInt($0);
                 $4 = 53;
                 if ((global$2 | 0) == 1) {
                  break label$2
                 }
                 $7 = $3;
                }
               }
               $2 = global$2 ? $2 : 0;
               if (global$2 ? ($6 | 0) == 54 : 1) {
                $3 = LexGetToken($0, 0, 1);
                $4 = 54;
                if ((global$2 | 0) == 1) {
                 break label$2
                }
                $1 = $3;
               }
               $1 = global$2 ? $1 : ($1 | 0) != 14;
               if ($1 | (global$2 | 0) == 2) {
                if (global$2 ? ($6 | 0) == 55 : 1) {
                 ProgramFail($0, 2510, 0);
                 $4 = 55;
                 if ((global$2 | 0) == 1) {
                  break label$2
                 }
                }
               }
               if (!global$2) {
                $1 = HEAP32[$0 + 16 >> 2] != 3;
                if ($1) {
                 break label$12
                }
                $1 = HEAP32[$0 + 20 >> 2] != ($7 | 0);
                if ($1) {
                 break label$12
                }
                break label$14;
               }
              }
              $2 = global$2 ? $2 : 0;
              if (global$2 ? ($6 | 0) == 56 : 1) {
               $3 = LexGetToken($0, 0, 1);
               $4 = 56;
               if ((global$2 | 0) == 1) {
                break label$2
               }
               $1 = $3;
              }
              $1 = global$2 ? $1 : ($1 | 0) != 14;
              if ($1 | (global$2 | 0) == 2) {
               if (global$2 ? ($6 | 0) == 57 : 1) {
                ProgramFail($0, 2510, 0);
                $4 = 57;
                if ((global$2 | 0) == 1) {
                 break label$2
                }
               }
              }
              if (!global$2) {
               $1 = HEAP32[$0 + 16 >> 2] == 3;
               if ($1) {
                break label$14
               }
               break label$12;
              }
             }
             if (!global$2) {
              $2 = HEAP32[$0 + 16 >> 2];
              if ($2) {
               break label$13
              }
              HEAP32[$0 + 16 >> 2] = 4;
              $2 = $1;
              break label$12;
             }
            }
            if (!global$2) {
             $2 = HEAP32[$0 + 16 >> 2];
             if ($2) {
              break label$13
             }
             HEAP32[$0 + 16 >> 2] = 5;
             $2 = $1;
             break label$12;
            }
           }
           $2 = global$2 ? $2 : !HEAP32[$0 + 16 >> 2];
           if ($2 | (global$2 | 0) == 2) {
            $2 = global$2 ? $2 : HEAP32[HEAP32[$0 >> 2] + 1304 >> 2];
            label$174 : {
             label$175 : {
              if (!global$2) {
               if ($2) {
                $2 = !HEAP32[HEAP32[HEAP32[$2 + 48 >> 2] >> 2] >> 2];
                if ($2) {
                 break label$175
                }
               }
               $2 = $5 + 8 | 0;
              }
              if (global$2 ? ($6 | 0) == 58 : 1) {
               $3 = ExpressionParse($0, $2);
               $4 = 58;
               if ((global$2 | 0) == 1) {
                break label$2
               }
               $2 = $3;
              }
              $2 = global$2 ? $2 : !$2;
              if ($2 | (global$2 | 0) == 2) {
               if (global$2 ? ($6 | 0) == 59 : 1) {
                ProgramFail($0, 2523, 0);
                $4 = 59;
                if ((global$2 | 0) == 1) {
                 break label$2
                }
               }
              }
              if (!global$2) {
               $7 = HEAP32[$0 >> 2];
               $2 = HEAP32[$7 + 1304 >> 2];
               $8 = !$2;
              }
              label$183 : {
               if (!global$2) {
                if ($8) {
                 $2 = ExpressionCoerceInteger(HEAP32[$5 + 8 >> 2]);
                 PlatformExit($7, $2);
                 break label$183;
                }
                $7 = HEAP32[$5 + 8 >> 2];
                $2 = HEAP32[$2 + 48 >> 2];
               }
               if (global$2 ? ($6 | 0) == 60 : 1) {
                ExpressionAssign($0, $2, $7, 1, 0, 0, 0);
                $4 = 60;
                if ((global$2 | 0) == 1) {
                 break label$2
                }
               }
              }
              $2 = global$2 ? $2 : HEAP32[$5 + 8 >> 2];
              if (global$2 ? ($6 | 0) == 61 : 1) {
               VariableStackPop($0, $2);
               $4 = 61;
               if ((global$2 | 0) == 1) {
                break label$2
               }
              }
              if (!global$2) {
               break label$174
              }
             }
             $2 = global$2 ? $2 : $5 + 8 | 0;
             if (global$2 ? ($6 | 0) == 62 : 1) {
              $3 = ExpressionParse($0, $2);
              $4 = 62;
              if ((global$2 | 0) == 1) {
               break label$2
              }
              $2 = $3;
             }
             if (!global$2) {
              $2 = !$2;
              if ($2) {
               break label$174
              }
             }
             if (global$2 ? ($6 | 0) == 63 : 1) {
              ProgramFail($0, 2548, 0);
              $4 = 63;
              if ((global$2 | 0) == 1) {
               break label$2
              }
             }
            }
            if (!global$2) {
             HEAP32[$0 + 16 >> 2] = 2;
             $2 = $1;
             break label$12;
            }
           }
           $2 = global$2 ? $2 : $5 + 8 | 0;
           if (global$2 ? ($6 | 0) == 64 : 1) {
            $3 = ExpressionParse($0, $2);
            $4 = 64;
            if ((global$2 | 0) == 1) {
             break label$2
            }
            $2 = $3;
           }
           if (!global$2) {
            $2 = $1;
            break label$12;
           }
          }
          if (global$2 ? ($6 | 0) == 65 : 1) {
           ParseTypedef($0);
           $4 = 65;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (!global$2) {
           $2 = $1;
           break label$12;
          }
         }
         $2 = global$2 ? $2 : $5 + 108 | 0;
         if (global$2 ? ($6 | 0) == 66 : 1) {
          $3 = LexGetToken($0, $2, 1);
          $4 = 66;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $2 = $3;
         }
         $2 = global$2 ? $2 : ($2 | 0) != 45;
         if ($2 | (global$2 | 0) == 2) {
          if (global$2 ? ($6 | 0) == 67 : 1) {
           ProgramFail($0, 2328, 0);
           $4 = 67;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
         }
         if (!global$2) {
          $2 = HEAP32[$0 + 16 >> 2];
          if ($2) {
           break label$13
          }
          $2 = HEAP32[HEAP32[HEAP32[$5 + 108 >> 2] + 4 >> 2] >> 2];
          HEAP32[$0 + 16 >> 2] = 6;
          HEAP32[$0 + 24 >> 2] = $2;
          $2 = $1;
          break label$12;
         }
        }
        $2 = global$2 ? $2 : $5 + 108 | 0;
        if (global$2 ? ($6 | 0) == 68 : 1) {
         $3 = LexGetToken($0, $2, 1);
         $4 = 68;
         if ((global$2 | 0) == 1) {
          break label$2
         }
         $2 = $3;
        }
        $2 = global$2 ? $2 : ($2 | 0) != 45;
        if ($2 | (global$2 | 0) == 2) {
         if (global$2 ? ($6 | 0) == 69 : 1) {
          ProgramFail($0, 2328, 0);
          $4 = 69;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
        }
        if (!global$2) {
         $2 = HEAP32[$0 + 16 >> 2];
         if ($2) {
          break label$13
         }
         $2 = HEAP32[$0 >> 2];
         $2 = TableDelete($2, $2, HEAP32[HEAP32[HEAP32[$5 + 108 >> 2] + 4 >> 2] >> 2]);
         HEAP32[$5 + 8 >> 2] = $2;
         $2 = !$2;
        }
        if ((global$2 | 0) == 2 | $2) {
         if (!global$2) {
          $2 = HEAP32[HEAP32[HEAP32[$5 + 108 >> 2] + 4 >> 2] >> 2];
          HEAP32[$5 >> 2] = $2;
         }
         if (global$2 ? ($6 | 0) == 70 : 1) {
          ProgramFail($0, 2585, $5);
          $4 = 70;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
        }
        if (!global$2) {
         VariableFree(HEAP32[$0 >> 2], HEAP32[$5 + 8 >> 2]);
         $2 = $1;
         break label$12;
        }
       }
       if (!global$2) {
        $3 = HEAP32[$5 + 60 >> 2];
        $4 = HEAP32[$5 + 56 >> 2];
        HEAP32[$0 >> 2] = $4;
        HEAP32[$0 + 4 >> 2] = $3;
        HEAP32[$0 + 40 >> 2] = HEAP32[$5 + 96 >> 2];
        $4 = HEAP32[$5 + 92 >> 2];
        $3 = HEAP32[$5 + 88 >> 2];
        HEAP32[$0 + 32 >> 2] = $3;
        HEAP32[$0 + 36 >> 2] = $4;
        $3 = HEAP32[$5 + 84 >> 2];
        $4 = HEAP32[$5 + 80 >> 2];
        HEAP32[$0 + 24 >> 2] = $4;
        HEAP32[$0 + 28 >> 2] = $3;
        $4 = HEAP32[$5 + 76 >> 2];
        $3 = HEAP32[$5 + 72 >> 2];
        HEAP32[$0 + 16 >> 2] = $3;
        HEAP32[$0 + 20 >> 2] = $4;
        $3 = $5 - -64 | 0;
        $4 = HEAP32[$3 >> 2];
        $3 = HEAP32[$3 + 4 >> 2];
        HEAP32[$0 + 8 >> 2] = $4;
        HEAP32[$0 + 12 >> 2] = $3;
        $2 = 1;
        break label$11;
       }
      }
      if (!global$2) {
       $2 = 0;
       HEAP32[$0 + 16 >> 2] = 0;
       break label$12;
      }
     }
     $2 = global$2 ? $2 : $1;
    }
    $1 = global$2 ? $1 : !$2;
    label$213 : {
     if ($1 ? !global$2 : 0) {
      break label$213
     }
     if (global$2 ? ($6 | 0) == 71 : 1) {
      $3 = LexGetToken($0, 0, 1);
      $4 = 71;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $3;
     }
     if (($1 | 0) == 50 ? !global$2 : 0) {
      break label$213
     }
     if (global$2 ? ($6 | 0) == 72 : 1) {
      ProgramFail($0, 2432, 0);
      $4 = 72;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    $2 = global$2 ? $2 : 2;
   }
   if (!global$2) {
    global$0 = $5 + 112 | 0;
    return $2 | 0;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $5;
  HEAP32[$3 + 16 >> 2] = $7;
  HEAP32[$3 + 20 >> 2] = $8;
  HEAP32[$3 + 24 >> 2] = $9;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 28;
  return 0;
 }
 
 function ParserCopy($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $2 = $1;
  $1 = HEAPU8[$2 | 0] | HEAPU8[$2 + 1 | 0] << 8 | (HEAPU8[$2 + 2 | 0] << 16 | HEAPU8[$2 + 3 | 0] << 24);
  $3 = HEAPU8[$2 + 4 | 0] | HEAPU8[$2 + 5 | 0] << 8 | (HEAPU8[$2 + 6 | 0] << 16 | HEAPU8[$2 + 7 | 0] << 24);
  $4 = $1;
  $1 = $0;
  HEAP8[$1 | 0] = $4;
  HEAP8[$1 + 1 | 0] = $4 >>> 8;
  HEAP8[$1 + 2 | 0] = $4 >>> 16;
  HEAP8[$1 + 3 | 0] = $4 >>> 24;
  HEAP8[$1 + 4 | 0] = $3;
  HEAP8[$1 + 5 | 0] = $3 >>> 8;
  HEAP8[$1 + 6 | 0] = $3 >>> 16;
  HEAP8[$1 + 7 | 0] = $3 >>> 24;
  $3 = HEAPU8[$2 + 40 | 0] | HEAPU8[$2 + 41 | 0] << 8 | (HEAPU8[$2 + 42 | 0] << 16 | HEAPU8[$2 + 43 | 0] << 24);
  HEAP8[$1 + 40 | 0] = $3;
  HEAP8[$1 + 41 | 0] = $3 >>> 8;
  HEAP8[$1 + 42 | 0] = $3 >>> 16;
  HEAP8[$1 + 43 | 0] = $3 >>> 24;
  $1 = HEAPU8[$2 + 36 | 0] | HEAPU8[$2 + 37 | 0] << 8 | (HEAPU8[$2 + 38 | 0] << 16 | HEAPU8[$2 + 39 | 0] << 24);
  $3 = HEAPU8[$2 + 32 | 0] | HEAPU8[$2 + 33 | 0] << 8 | (HEAPU8[$2 + 34 | 0] << 16 | HEAPU8[$2 + 35 | 0] << 24);
  $4 = $3;
  $3 = $0;
  HEAP8[$3 + 32 | 0] = $4;
  HEAP8[$3 + 33 | 0] = $4 >>> 8;
  HEAP8[$3 + 34 | 0] = $4 >>> 16;
  HEAP8[$3 + 35 | 0] = $4 >>> 24;
  HEAP8[$3 + 36 | 0] = $1;
  HEAP8[$3 + 37 | 0] = $1 >>> 8;
  HEAP8[$3 + 38 | 0] = $1 >>> 16;
  HEAP8[$3 + 39 | 0] = $1 >>> 24;
  $3 = HEAPU8[$2 + 28 | 0] | HEAPU8[$2 + 29 | 0] << 8 | (HEAPU8[$2 + 30 | 0] << 16 | HEAPU8[$2 + 31 | 0] << 24);
  $1 = HEAPU8[$2 + 24 | 0] | HEAPU8[$2 + 25 | 0] << 8 | (HEAPU8[$2 + 26 | 0] << 16 | HEAPU8[$2 + 27 | 0] << 24);
  $4 = $1;
  $1 = $0;
  HEAP8[$1 + 24 | 0] = $4;
  HEAP8[$1 + 25 | 0] = $4 >>> 8;
  HEAP8[$1 + 26 | 0] = $4 >>> 16;
  HEAP8[$1 + 27 | 0] = $4 >>> 24;
  HEAP8[$1 + 28 | 0] = $3;
  HEAP8[$1 + 29 | 0] = $3 >>> 8;
  HEAP8[$1 + 30 | 0] = $3 >>> 16;
  HEAP8[$1 + 31 | 0] = $3 >>> 24;
  $1 = HEAPU8[$2 + 20 | 0] | HEAPU8[$2 + 21 | 0] << 8 | (HEAPU8[$2 + 22 | 0] << 16 | HEAPU8[$2 + 23 | 0] << 24);
  $3 = HEAPU8[$2 + 16 | 0] | HEAPU8[$2 + 17 | 0] << 8 | (HEAPU8[$2 + 18 | 0] << 16 | HEAPU8[$2 + 19 | 0] << 24);
  $4 = $3;
  $3 = $0;
  HEAP8[$3 + 16 | 0] = $4;
  HEAP8[$3 + 17 | 0] = $4 >>> 8;
  HEAP8[$3 + 18 | 0] = $4 >>> 16;
  HEAP8[$3 + 19 | 0] = $4 >>> 24;
  HEAP8[$3 + 20 | 0] = $1;
  HEAP8[$3 + 21 | 0] = $1 >>> 8;
  HEAP8[$3 + 22 | 0] = $1 >>> 16;
  HEAP8[$3 + 23 | 0] = $1 >>> 24;
  $3 = HEAPU8[$2 + 12 | 0] | HEAPU8[$2 + 13 | 0] << 8 | (HEAPU8[$2 + 14 | 0] << 16 | HEAPU8[$2 + 15 | 0] << 24);
  $1 = HEAPU8[$2 + 8 | 0] | HEAPU8[$2 + 9 | 0] << 8 | (HEAPU8[$2 + 10 | 0] << 16 | HEAPU8[$2 + 11 | 0] << 24);
  $4 = $1;
  $1 = $0;
  HEAP8[$1 + 8 | 0] = $4;
  HEAP8[$1 + 9 | 0] = $4 >>> 8;
  HEAP8[$1 + 10 | 0] = $4 >>> 16;
  HEAP8[$1 + 11 | 0] = $4 >>> 24;
  HEAP8[$1 + 12 | 0] = $3;
  HEAP8[$1 + 13 | 0] = $3 >>> 8;
  HEAP8[$1 + 14 | 0] = $3 >>> 16;
  HEAP8[$1 + 15 | 0] = $3 >>> 24;
 }
 
 function ParseDeclaration($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -36;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $3 = HEAP32[$2 + 8 >> 2];
   $4 = HEAP32[$2 + 12 >> 2];
   $7 = HEAP32[$2 + 16 >> 2];
   $8 = HEAP32[$2 + 20 >> 2];
   $9 = HEAP32[$2 + 24 >> 2];
   $10 = HEAP32[$2 + 28 >> 2];
   $11 = HEAP32[$2 + 32 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $4 = global$0 - 32 | 0;
   global$0 = $4;
   HEAP32[$4 + 16 >> 2] = 0;
   HEAP32[$4 + 12 >> 2] = 0;
   $8 = HEAP32[$0 >> 2];
   $7 = $4 + 24 | 0;
   $3 = $4 + 16 | 0;
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $2 = TypeParseFront($0, $7, $3);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $7 = $2;
   }
   if (!global$2) {
    $10 = $8 + 1808 | 0;
    $7 = 0;
   }
   while (1) {
    if (!global$2) {
     $9 = $4 + 20 | 0;
     $11 = $4 + 28 | 0;
     $3 = HEAP32[$4 + 24 >> 2];
    }
    if (global$2 ? ($5 | 0) == 1 : 1) {
     TypeParseIdentPart($0, $3, $9, $11);
     $6 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (!global$2) {
     $1 = $1 + -58 | 0;
     $3 = $1 >>> 0 <= 10;
     $1 = 1 << $1 & 1539 ? $3 : 0;
    }
    label$11 : {
     if (!global$2) {
      if ($1) {
       break label$11
      }
      $3 = HEAP32[$8 + 2756 >> 2];
      $1 = ($3 | 0) != HEAP32[$4 + 28 >> 2];
      if ($1) {
       break label$11
      }
     }
     if (global$2 ? ($5 | 0) == 2 : 1) {
      ProgramFail($0, 2328, 0);
      $6 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    $2 = !global$2;
    if (!global$2) {
     $3 = HEAP32[$8 + 2756 >> 2];
     $1 = ($3 | 0) == HEAP32[$4 + 28 >> 2];
    }
    label$14 : {
     label$15 : {
      if ($1 ? $2 : 0) {
       break label$15
      }
      if (global$2 ? ($5 | 0) == 3 : 1) {
       $2 = LexGetToken($0, 0, 0);
       $6 = 3;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $1 = $2;
      }
      if (!global$2) {
       $3 = HEAP32[$4 + 20 >> 2];
       $1 = ($1 | 0) == 43;
      }
      if ((global$2 | 0) == 2 | $1) {
       $1 = global$2 ? $1 : HEAP32[$4 + 28 >> 2];
       if (global$2 ? ($5 | 0) == 4 : 1) {
        $2 = ParseFunctionDefinition($0, $3, $1);
        $6 = 4;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $0 = $2;
       }
       if (!global$2) {
        $1 = 0;
        break label$14;
       }
      }
      $1 = global$2 ? $1 : ($3 | 0) != ($10 | 0);
      label$25 : {
       if (!global$2) {
        if ($1) {
         break label$25
        }
        $3 = HEAP32[$8 + 2756 >> 2];
        $1 = ($3 | 0) == HEAP32[$4 + 28 >> 2];
        if ($1) {
         break label$25
        }
       }
       if (global$2 ? ($5 | 0) == 5 : 1) {
        ProgramFail($0, 2348, 0);
        $6 = 5;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
      }
      if (!global$2) {
       $1 = HEAP32[$0 + 16 >> 2];
       $3 = $1 >>> 0 > 6;
      }
      label$29 : {
       if (!global$2) {
        if ($3) {
         break label$29
        }
        label$31 : {
         $1 = $1 - 1 | 0;
         switch ($1 | 0) {
         case 0:
         case 1:
         case 2:
         case 3:
         case 4:
          break label$29;
         default:
          break label$31;
         };
        }
        $7 = HEAP32[$4 + 20 >> 2];
        $3 = HEAP32[$4 + 16 >> 2];
        $9 = $4 + 12 | 0;
        $1 = HEAP32[$4 + 28 >> 2];
       }
       if (global$2 ? ($5 | 0) == 6 : 1) {
        $2 = VariableDefineButIgnoreIdentical($0, $1, $7, $3, $9);
        $6 = 6;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $7 = $2;
       }
      }
      if (global$2 ? ($5 | 0) == 7 : 1) {
       $2 = LexGetToken($0, 0, 0);
       $6 = 7;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $1 = $2;
      }
      if (!global$2) {
       $1 = ($1 | 0) != 2;
       if ($1) {
        break label$15
       }
      }
      if (global$2 ? ($5 | 0) == 8 : 1) {
       $2 = LexGetToken($0, 0, 1);
       $6 = 8;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $1 = $2;
      }
      if (!global$2) {
       $3 = HEAP32[$4 + 12 >> 2] != 0;
       $1 = $3 | !HEAP32[$4 + 16 >> 2];
      }
      if (global$2 ? ($5 | 0) == 9 : 1) {
       ParseDeclarationAssignment($0, $7, $1);
       $6 = 9;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     $1 = global$2 ? $1 : 1;
     if (global$2 ? ($5 | 0) == 10 : 1) {
      $2 = LexGetToken($0, 0, 0);
      $6 = 10;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $2;
     }
     if (!global$2) {
      $3 = ($3 | 0) != 1;
      if ($3) {
       break label$14
      }
      $1 = 1;
     }
     if (global$2 ? ($5 | 0) == 11 : 1) {
      $2 = LexGetToken($0, 0, 1);
      $6 = 11;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $2;
     }
     if (!global$2) {
      continue
     }
    }
    break;
   };
   if (!global$2) {
    global$0 = $4 + 32 | 0;
    return $1;
   }
   abort();
  }
  $2 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 8 >> 2] = $3;
  HEAP32[$2 + 12 >> 2] = $4;
  HEAP32[$2 + 16 >> 2] = $7;
  HEAP32[$2 + 20 >> 2] = $8;
  HEAP32[$2 + 24 >> 2] = $9;
  HEAP32[$2 + 28 >> 2] = $10;
  HEAP32[$2 + 32 >> 2] = $11;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 36;
  return 0;
 }
 
 function ParseBlock($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $7 = HEAP32[$3 + 16 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $4 = global$0 - 16 | 0;
   global$0 = $4;
   HEAP32[$4 + 12 >> 2] = 0;
   $7 = VariableScopeBegin($0, $4 + 12 | 0);
   $1 = !$1;
  }
  label$2 : {
   label$5 : {
    if ($1 ? !global$2 : 0) {
     break label$5
    }
    if (global$2 ? !$5 : 1) {
     $3 = LexGetToken($0, 0, 1);
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $1 = $3;
    }
    if (!global$2) {
     $1 = ($1 | 0) == 52;
     if ($1) {
      break label$5
     }
    }
    if (global$2 ? ($5 | 0) == 1 : 1) {
     ProgramFail($0, 2458, 0);
     $6 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $2 = !$2;
    $1 = HEAP32[$0 + 16 >> 2];
   }
   label$10 : {
    label$11 : {
     if (!global$2) {
      if ($2) {
       break label$11
      }
      $2 = ($1 | 0) == 1;
      if ($2) {
       break label$11
      }
     }
     while (1) {
      if (global$2 ? ($5 | 0) == 2 : 1) {
       $3 = ParseStatement($0, 1);
       $6 = 2;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $1 = $3;
      }
      if (!global$2) {
       $1 = ($1 | 0) == 2;
       if ($1) {
        continue
       }
      }
      break;
     };
     if (!global$2) {
      break label$10
     }
    }
    if (!global$2) {
     HEAP32[$0 + 16 >> 2] = 1
    }
    while (1) {
     if (global$2 ? ($5 | 0) == 3 : 1) {
      $3 = ParseStatement($0, 1);
      $6 = 3;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $2 = $3;
     }
     if (!global$2) {
      $2 = ($2 | 0) == 2;
      if ($2) {
       continue
      }
     }
     break;
    };
    if (!global$2) {
     HEAP32[$0 + 16 >> 2] = $1
    }
   }
   if (global$2 ? ($5 | 0) == 4 : 1) {
    $3 = LexGetToken($0, 0, 1);
    $6 = 4;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $3;
   }
   if ((global$2 | 0) == 2 | (global$2 ? $1 : ($1 | 0) != 53)) {
    if (global$2 ? ($5 | 0) == 5 : 1) {
     ProgramFail($0, 2315, 0);
     $6 = 5;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    VariableScopeEnd($0, $7, HEAP32[$4 + 12 >> 2]);
    global$0 = $4 + 16 | 0;
    $0 = HEAP32[$0 + 16 >> 2];
    return $0;
   }
   abort();
  }
  $3 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[$3 + 16 >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
  return 0;
 }
 
 function ParserCopyPos($0, $1) {
  HEAP32[$0 + 4 >> 2] = HEAP32[$1 + 4 >> 2];
  HEAP16[$0 + 12 >> 1] = HEAPU16[$1 + 12 >> 1];
  HEAP16[$0 + 32 >> 1] = HEAPU16[$1 + 32 >> 1];
  HEAP16[$0 + 34 >> 1] = HEAPU16[$1 + 34 >> 1];
  HEAP16[$0 + 14 >> 1] = HEAPU16[$1 + 14 >> 1];
 }
 
 function ParseFor($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $6 = HEAP32[$1 + 12 >> 2];
   $7 = HEAP32[$1 + 16 >> 2];
   $8 = HEAP32[$1 + 20 >> 2];
   $2 = HEAP32[$1 + 8 >> 2];
   $3 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = global$0 - 208 | 0;
   global$0 = $6;
   $7 = HEAP32[$0 + 16 >> 2];
   HEAP32[$6 + 12 >> 2] = 0;
   $3 = $6 + 12 | 0;
   $8 = VariableScopeBegin($0, $3);
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $1 = LexGetToken($0, 0, 1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $1;
   }
   $3 = global$2 ? $3 : ($3 | 0) != 43;
   if ($3 | (global$2 | 0) == 2) {
    if (global$2 ? ($4 | 0) == 1 : 1) {
     ProgramFail($0, 2400, 0);
     $5 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (global$2 ? ($4 | 0) == 2 : 1) {
    $1 = ParseStatement($0, 1);
    $5 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $1;
   }
   $3 = global$2 ? $3 : ($3 | 0) != 2;
   if ($3 | (global$2 | 0) == 2) {
    if (global$2 ? ($4 | 0) == 3 : 1) {
     ProgramFail($0, 2413, 0);
     $5 = 3;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    ParserCopyPos($6 + 160 | 0, $0);
    $3 = 1;
   }
   if (global$2 ? ($4 | 0) == 4 : 1) {
    $1 = LexGetToken($0, 0, 0);
    $5 = 4;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $1;
   }
   $2 = global$2 ? $2 : ($2 | 0) != 50;
   if ($2 | (global$2 | 0) == 2) {
    if (global$2 ? ($4 | 0) == 5 : 1) {
     $1 = ExpressionParseInt($0);
     $5 = 5;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $3 = $1;
    }
   }
   if (global$2 ? ($4 | 0) == 6 : 1) {
    $1 = LexGetToken($0, 0, 1);
    $5 = 6;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $1;
   }
   $2 = global$2 ? $2 : ($2 | 0) != 50;
   if ($2 | (global$2 | 0) == 2) {
    if (global$2 ? ($4 | 0) == 7 : 1) {
     ProgramFail($0, 2432, 0);
     $5 = 7;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $2 = $6 + 112 | 0;
    ParserCopyPos($2, $0);
   }
   if (global$2 ? ($4 | 0) == 8 : 1) {
    $1 = ParseStatementMaybeRun($0, 0, 0);
    $5 = 8;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $1;
   }
   if (global$2 ? ($4 | 0) == 9 : 1) {
    $1 = LexGetToken($0, 0, 1);
    $5 = 9;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $1;
   }
   $2 = global$2 ? $2 : ($2 | 0) != 44;
   if ($2 | (global$2 | 0) == 2) {
    if (global$2 ? ($4 | 0) == 10 : 1) {
     ProgramFail($0, 2445, 0);
     $5 = 10;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $2 = $6 - -64 | 0;
    ParserCopyPos($2, $0);
   }
   if (global$2 ? ($4 | 0) == 11 : 1) {
    $1 = ParseStatementMaybeRun($0, $3, 1);
    $5 = 11;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $1;
   }
   $2 = global$2 ? $2 : ($2 | 0) != 2;
   if ($2 | (global$2 | 0) == 2) {
    if (global$2 ? ($4 | 0) == 12 : 1) {
     ProgramFail($0, 2413, 0);
     $5 = 12;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    if (!(HEAP32[$0 + 16 >> 2] != 5 | $7)) {
     HEAP32[$0 + 16 >> 2] = 0
    }
    $2 = $6 + 16 | 0;
    ParserCopyPos($2, $0);
    $3 = !$3;
   }
   label$35 : {
    if (!global$2) {
     if ($3) {
      break label$35
     }
     $3 = HEAP32[$0 + 16 >> 2];
     if ($3) {
      break label$35
     }
    }
    while (1) {
     $3 = global$2 ? $3 : HEAP32[$0 >> 2];
     if (global$2 ? ($4 | 0) == 13 : 1) {
      emscripten_sleep_pc($3);
      $5 = 13;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      $3 = $6 + 112 | 0;
      ParserCopyPos($0, $3);
     }
     if (global$2 ? ($4 | 0) == 14 : 1) {
      $1 = ParseStatement($0, 0);
      $5 = 14;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $1;
     }
     if (!global$2) {
      ParserCopyPos($0, $6 + 160 | 0);
      $3 = 1;
     }
     if (global$2 ? ($4 | 0) == 15 : 1) {
      $1 = LexGetToken($0, 0, 0);
      $5 = 15;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $2 = $1;
     }
     $2 = global$2 ? $2 : ($2 | 0) != 50;
     if ($2 | (global$2 | 0) == 2) {
      if (global$2 ? ($4 | 0) == 16 : 1) {
       $1 = ExpressionParseInt($0);
       $5 = 16;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $3 = $1;
      }
     }
     if (!global$2) {
      if (!$3) {
       break label$35
      }
      ParserCopyPos($0, $6 - -64 | 0);
     }
     if (global$2 ? ($4 | 0) == 17 : 1) {
      ParseStatement($0, 1);
      $5 = 17;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      if (HEAP32[$0 + 16 >> 2] == 5) {
       HEAP32[$0 + 16 >> 2] = 0
      }
      $3 = !HEAP32[$0 + 16 >> 2];
      if ($3) {
       continue
      }
     }
     break;
    };
   }
   if (!global$2) {
    if (!(HEAP32[$0 + 16 >> 2] != 4 | $7)) {
     HEAP32[$0 + 16 >> 2] = 0
    }
    VariableScopeEnd($0, $8, HEAP32[$6 + 12 >> 2]);
    ParserCopyPos($0, $6 + 16 | 0);
    global$0 = $6 + 208 | 0;
   }
   return;
  }
  $1 = $5;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $3;
  HEAP32[$1 + 8 >> 2] = $2;
  HEAP32[$1 + 12 >> 2] = $6;
  HEAP32[$1 + 16 >> 2] = $7;
  HEAP32[$1 + 20 >> 2] = $8;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
 }
 
 function ParseMacroDefinition($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -32;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $3 = HEAP32[$2 + 8 >> 2];
   $5 = HEAP32[$2 + 12 >> 2];
   $7 = HEAP32[$2 + 16 >> 2];
   $8 = HEAP32[$2 + 20 >> 2];
   $9 = HEAP32[$2 + 24 >> 2];
   $10 = HEAP32[$2 + 28 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $7 = global$0 + -64 | 0;
   global$0 = $7;
   $1 = $7 + 60 | 0;
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $2 = LexGetToken($0, $1, 1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $2;
   }
   $1 = global$2 ? $1 : ($1 | 0) != 45;
   if ($1 | (global$2 | 0) == 2) {
    if (global$2 ? ($4 | 0) == 1 : 1) {
     ProgramFail($0, 2328, 0);
     $6 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $9 = HEAP32[HEAP32[HEAP32[$7 + 60 >> 2] + 4 >> 2] >> 2];
    $1 = (LexRawPeekToken($0) | 0) == 92;
   }
   label$10 : {
    if ((global$2 | 0) == 2 | $1) {
     if (global$2 ? ($4 | 0) == 2 : 1) {
      $2 = LexGetToken($0, 0, 1);
      $6 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $2;
     }
     if (!global$2) {
      ParserCopy($7 + 8 | 0, $0);
      $1 = $7 + 8 | 0;
     }
     if (global$2 ? ($4 | 0) == 3 : 1) {
      $2 = ParseCountParams($1);
      $6 = 3;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $2;
     }
     if (!global$2) {
      $5 = HEAP32[$0 >> 2];
      $3 = ($1 << 2) + 52 | 0;
     }
     if (global$2 ? ($4 | 0) == 4 : 1) {
      $2 = VariableAllocValueAndData($5, $0, $3, 0, 0, 1);
      $6 = 4;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $5 = $2;
     }
     if (!global$2) {
      HEAP32[HEAP32[$5 + 4 >> 2] >> 2] = $1;
      $1 = HEAP32[$5 + 4 >> 2];
      $3 = $1 + 52 | 0;
      HEAP32[$1 + 4 >> 2] = $3;
      $1 = $7 + 56 | 0;
     }
     if (global$2 ? ($4 | 0) == 5 : 1) {
      $2 = LexGetToken($0, $1, 1);
      $6 = 5;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $2;
     }
     $1 = global$2 ? $1 : 0;
     while (1) {
      $8 = global$2 ? $8 : ($3 | 0) != 45;
      if ($8 | (global$2 | 0) == 2) {
       if (!global$2) {
        $1 = ($3 | 0) == 44;
        if ($1) {
         break label$10
        }
       }
       if (global$2 ? ($4 | 0) == 6 : 1) {
        ProgramFail($0, 2377, 0);
        $6 = 6;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        break label$10
       }
      }
      if (!global$2) {
       $3 = HEAP32[HEAP32[$5 + 4 >> 2] + 4 >> 2] + ($1 << 2) | 0;
       $8 = HEAP32[HEAP32[HEAP32[$7 + 56 >> 2] + 4 >> 2] >> 2];
       HEAP32[$3 >> 2] = $8;
       $1 = $1 + 1 | 0;
      }
      if (global$2 ? ($4 | 0) == 7 : 1) {
       $2 = LexGetToken($0, 0, 1);
       $6 = 7;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $3 = $2;
      }
      if (!global$2) {
       $8 = ($3 | 0) == 44;
       if ($8) {
        continue
       }
       $8 = ($3 | 0) == 1;
      }
      if ((global$2 | 0) == 2 | $8) {
       $3 = global$2 ? $3 : $7 + 56 | 0;
       if (global$2 ? ($4 | 0) == 8 : 1) {
        $2 = LexGetToken($0, $3, 1);
        $6 = 8;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $3 = $2;
       }
       if (!global$2) {
        continue
       }
      }
      if (global$2 ? ($4 | 0) == 9 : 1) {
       ProgramFail($0, 2073, 0);
       $6 = 9;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       continue
      }
      break;
     };
    }
    $1 = global$2 ? $1 : HEAP32[$0 >> 2];
    if (global$2 ? ($4 | 0) == 10 : 1) {
     $2 = VariableAllocValueAndData($1, $0, 52, 0, 0, 1);
     $6 = 10;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $5 = $2;
    }
    if (!global$2) {
     $1 = HEAP32[$5 + 4 >> 2];
     HEAP32[$1 >> 2] = 0;
    }
   }
   if (!global$2) {
    ParserCopy(HEAP32[$5 + 4 >> 2] + 8 | 0, $0);
    $1 = HEAP32[$0 >> 2] + 1940 | 0;
    HEAP32[$5 >> 2] = $1;
   }
   if (global$2 ? ($4 | 0) == 11 : 1) {
    LexToEndOfLine($0);
    $6 = 11;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   $1 = global$2 ? $1 : HEAP32[$5 + 4 >> 2] + 8 | 0;
   if (global$2 ? ($4 | 0) == 12 : 1) {
    $2 = LexCopyTokens($1, $0);
    $6 = 12;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $2;
   }
   if (!global$2) {
    HEAP32[HEAP32[$5 + 4 >> 2] + 12 >> 2] = $1;
    $3 = HEAP32[$0 + 8 >> 2];
    $8 = HEAP16[$0 + 12 >> 1];
    $10 = HEAP16[$0 + 14 >> 1];
    $1 = HEAP32[$0 >> 2];
   }
   if (global$2 ? ($4 | 0) == 13 : 1) {
    $2 = TableSet($1, $1, $9, $5, $3, $8, $10);
    $6 = 13;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $2;
   }
   if ((global$2 | 0) == 2 | (global$2 ? $1 : !$1)) {
    if (!global$2) {
     HEAP32[$7 >> 2] = $9
    }
    if (global$2 ? ($4 | 0) == 14 : 1) {
     ProgramFail($0, 2221, $7);
     $6 = 14;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    global$0 = $7 - -64 | 0
   }
   return;
  }
  $2 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 8 >> 2] = $3;
  HEAP32[$2 + 12 >> 2] = $5;
  HEAP32[$2 + 16 >> 2] = $7;
  HEAP32[$2 + 20 >> 2] = $8;
  HEAP32[$2 + 24 >> 2] = $9;
  HEAP32[$2 + 28 >> 2] = $10;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 32;
 }
 
 function ParseTypedef($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $3 = HEAP32[$2 + 8 >> 2];
   $2 = HEAP32[$2 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $1 = global$0 - 32 | 0;
   global$0 = $1;
   $3 = $1 + 28 | 0;
   $2 = $1 + 24 | 0;
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    TypeParse($0, $3, $2, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   $3 = global$2 ? $3 : !HEAP32[$0 + 16 >> 2];
   if ($3 | (global$2 | 0) == 2) {
    if (!global$2) {
     $3 = HEAP32[$0 >> 2];
     HEAP32[$1 >> 2] = $3 + 1852;
     HEAP32[$1 + 4 >> 2] = $1 + 28;
     $2 = HEAP32[$1 + 24 >> 2];
    }
    if (global$2 ? ($4 | 0) == 1 : 1) {
     VariableDefine($3, $0, $2, $1, 0, 0);
     $5 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    global$0 = $1 + 32 | 0
   }
   return;
  }
  $4 = $5;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $3;
  HEAP32[$4 + 12 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function ParseCountParams($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $3 = HEAP32[$1 + 8 >> 2];
   $4 = HEAP32[$1 + 12 >> 2];
   $5 = HEAP32[$1 + 16 >> 2];
   $2 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = 1;
   $2 = 0;
  }
  $7 = $5;
  label$2 : {
   if (global$2 ? !$6 : 1) {
    $1 = LexGetToken($0, 0, 1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $4 = $1;
   }
   $5 = global$2 ? $7 : ($4 | 0) == 44;
   if (!(($4 | 0) == 93 | $5 ? !global$2 : 0)) {
    while (1) {
     label$10 : {
      if (global$2 ? ($6 | 0) == 1 : 1) {
       $1 = LexGetToken($0, 0, 1);
       $8 = 1;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $2 = $1;
      }
      if (!global$2) {
       if (($2 | 0) == 93 | ($2 | 0) == 44) {
        break label$10
       }
       $2 = ($2 | 0) != 1;
       if ($2) {
        continue
       }
       $3 = $3 + 1 | 0;
       continue;
      }
     }
     break;
    };
    $2 = global$2 ? $2 : $3;
   }
   if (!global$2) {
    return $2
   }
   abort();
  }
  $1 = $8;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP32[$1 + 8 >> 2] = $3;
  HEAP32[$1 + 12 >> 2] = $4;
  HEAP32[$1 + 16 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
  return 0;
 }
 
 function ParseFunctionDefinition($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -36;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $6 = HEAP32[$4 + 16 >> 2];
   $5 = HEAP32[$4 + 20 >> 2];
   $7 = HEAP32[$4 + 24 >> 2];
   $10 = HEAP32[$4 + 28 >> 2];
   $11 = HEAP32[$4 + 32 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = global$0 - 144 | 0;
   global$0 = $5;
   $10 = HEAP32[$0 >> 2];
   $3 = HEAP32[$10 + 1304 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2 | $3) {
    if (global$2 ? !$8 : 1) {
     ProgramFail($0, 1996, 0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   $7 = global$2 ? $7 : 0;
   if (global$2 ? ($8 | 0) == 1 : 1) {
    $4 = LexGetToken($0, 0, 1);
    $9 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $4;
   }
   if (!global$2) {
    $3 = $5 + 88 | 0;
    ParserCopy($3, $0);
   }
   $12 = $6;
   if (global$2 ? ($8 | 0) == 2 : 1) {
    $4 = ParseCountParams($0);
    $9 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $4;
   }
   $6 = global$2 ? $12 : ($3 | 0) >= 17;
   if ($6 | (global$2 | 0) == 2) {
    if (!global$2) {
     HEAP32[$5 + 32 >> 2] = 16;
     $6 = $5 + 32 | 0;
    }
    if (global$2 ? ($8 | 0) == 3 : 1) {
     ProgramFail($0, 2040, $6);
     $9 = 3;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   $6 = global$2 ? $6 : ($3 << 3) + 68 | 0;
   if (global$2 ? ($8 | 0) == 4 : 1) {
    $4 = VariableAllocValueAndData($10, $0, $6, 0, 0, 1);
    $9 = 4;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $6 = $4;
   }
   if (!global$2) {
    HEAP32[$6 >> 2] = $10 + 1896;
    HEAP32[HEAP32[$6 + 4 >> 2] >> 2] = $1;
    HEAP32[HEAP32[$6 + 4 >> 2] + 4 >> 2] = $3;
    HEAP32[HEAP32[$6 + 4 >> 2] + 8 >> 2] = 0;
    $1 = HEAP32[$6 + 4 >> 2];
    $11 = $1 + 68 | 0;
    HEAP32[$1 + 12 >> 2] = $11;
    $1 = HEAP32[$6 + 4 >> 2];
    $11 = HEAP32[$1 + 12 >> 2];
    $3 = $11 + ($3 << 2) | 0;
    HEAP32[$1 + 16 >> 2] = $3;
    $1 = HEAP32[HEAP32[$6 + 4 >> 2] + 4 >> 2];
    $3 = ($1 | 0) < 1;
   }
   label$17 : {
    if (!global$2) {
     if ($3) {
      break label$17
     }
     $7 = 0;
     $3 = 0;
    }
    while (1) {
     $1 = global$2 ? $1 : ($1 + -1 | 0) != ($3 | 0);
     label$20 : {
      if (!global$2) {
       if ($1) {
        break label$20
       }
       $1 = $5 + 88 | 0;
      }
      if (global$2 ? ($8 | 0) == 5 : 1) {
       $4 = LexGetToken($1, 0, 0);
       $9 = 5;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $1 = $4;
      }
      if (!global$2) {
       $1 = ($1 | 0) != 51;
       if ($1) {
        break label$20
       }
       $3 = HEAP32[$6 + 4 >> 2];
       $1 = HEAP32[$3 + 4 >> 2] + -1 | 0;
       HEAP32[$3 + 4 >> 2] = $1;
       $1 = HEAP32[$6 + 4 >> 2];
       HEAP32[$1 + 8 >> 2] = 1;
       break label$17;
      }
     }
     if (!global$2) {
      $7 = $5 + 140 | 0;
      $11 = $5 + 136 | 0;
      $1 = $5 + 88 | 0;
     }
     if (global$2 ? ($8 | 0) == 6 : 1) {
      TypeParse($1, $7, $11, 0);
      $9 = 6;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      $1 = HEAP32[$5 + 140 >> 2];
      label$28 : {
       if (!HEAP32[$1 >> 2]) {
        $1 = HEAP32[$6 + 4 >> 2];
        $7 = HEAP32[$1 + 4 >> 2] + -1 | 0;
        HEAP32[$1 + 4 >> 2] = $7;
        $3 = $3 + -1 | 0;
        break label$28;
       }
       $7 = $3 << 2;
       HEAP32[$7 + HEAP32[HEAP32[$6 + 4 >> 2] + 12 >> 2] >> 2] = $1;
       $1 = HEAP32[HEAP32[$6 + 4 >> 2] + 16 >> 2] + $7 | 0;
       $7 = HEAP32[$5 + 136 >> 2];
       HEAP32[$1 >> 2] = $7;
      }
      $1 = $5 + 88 | 0;
     }
     $12 = $1;
     if (global$2 ? ($8 | 0) == 7 : 1) {
      $4 = LexGetToken($1, 0, 1);
      $9 = 7;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $7 = $4;
     }
     $1 = global$2 ? $12 : ($7 | 0) == 1;
     label$32 : {
      if (!global$2) {
       if ($1) {
        break label$32
       }
       $1 = ($3 | 0) >= (HEAP32[HEAP32[$6 + 4 >> 2] + 4 >> 2] + -1 | 0);
       if ($1) {
        break label$32
       }
       $1 = $5 + 88 | 0;
      }
      if (global$2 ? ($8 | 0) == 8 : 1) {
       ProgramFail($1, 2073, 0);
       $9 = 8;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     if (!global$2) {
      $3 = $3 + 1 | 0;
      $1 = HEAP32[HEAP32[$6 + 4 >> 2] + 4 >> 2];
      $11 = ($3 | 0) < ($1 | 0);
      if ($11) {
       continue
      }
     }
     break;
    };
   }
   $1 = global$2 ? $1 : !HEAP32[HEAP32[$6 + 4 >> 2] + 4 >> 2];
   label$37 : {
    if (!global$2) {
     if ($1) {
      break label$37
     }
     label$39 : {
      $3 = $7 + -44 | 0;
      if ($3 >>> 0 > 7) {
       $1 = ($7 | 0) == 1;
       if ($1) {
        break label$37
       }
       break label$39;
      }
      $1 = $3 - 1 | 0;
      switch ($1 | 0) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
       break label$39;
      default:
       break label$37;
      };
     }
     $1 = $5 + 88 | 0;
    }
    if (global$2 ? ($8 | 0) == 9 : 1) {
     ProgramFail($1, 2088, 0);
     $9 = 9;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $1 = strcmp($2, 2102)
   }
   label$43 : {
    if (!global$2) {
     if ($1) {
      break label$43
     }
     $1 = $10 + 1412 | 0;
     $3 = HEAP32[HEAP32[$6 + 4 >> 2] >> 2];
     $7 = ($1 | 0) == ($3 | 0);
    }
    label$45 : {
     if (!global$2) {
      if ($7) {
       break label$45
      }
      $7 = $10 + 1808 | 0;
      $3 = ($7 | 0) == ($3 | 0);
      if ($3) {
       break label$45
      }
     }
     if (global$2 ? ($8 | 0) == 10 : 1) {
      ProgramFail($0, 2107, 0);
      $9 = 10;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (!global$2) {
     label$49 : {
      $7 = HEAP32[$6 + 4 >> 2];
      $3 = HEAP32[$7 + 4 >> 2];
      if ($3 >>> 0 > 2) {
       break label$49
      }
      label$50 : {
       $3 = $3 - 1 | 0;
       switch ($3 | 0) {
       case 0:
        break label$49;
       case 1:
        break label$50;
       default:
        break label$43;
       };
      }
      $3 = HEAP32[HEAP32[$7 + 12 >> 2] >> 2];
      $1 = ($3 | 0) == ($1 | 0);
      if ($1) {
       break label$43
      }
     }
    }
    if (global$2 ? ($8 | 0) == 11 : 1) {
     ProgramFail($0, 2143, 0);
     $9 = 11;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (global$2 ? ($8 | 0) == 12 : 1) {
    $4 = LexGetToken($0, 0, 0);
    $9 = 12;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $4;
   }
   if (!global$2) {
    $3 = $1 + -50 | 0;
    $1 = $3 >>> 0 > 2;
   }
   label$54 : {
    label$55 : {
     label$56 : {
      if (!global$2) {
       if ($1) {
        break label$56
       }
       label$58 : {
        $1 = $3 - 1 | 0;
        switch ($1 | 0) {
        case 1:
         break label$55;
        case 0:
         break label$56;
        default:
         break label$58;
        };
       }
      }
      if (global$2 ? ($8 | 0) == 13 : 1) {
       $4 = LexGetToken($0, 0, 1);
       $9 = 13;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $1 = $4;
      }
      if (!global$2) {
       break label$54
      }
     }
     if (global$2 ? ($8 | 0) == 14 : 1) {
      ProgramFail($0, 2168, 0);
      $9 = 14;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (!global$2) {
     $1 = $5 + 40 | 0;
     ParserCopy($1, $0);
    }
    if (global$2 ? ($8 | 0) == 15 : 1) {
     $4 = ParseStatementMaybeRun($0, 0, 1);
     $9 = 15;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $1 = $4;
    }
    $1 = global$2 ? $1 : ($1 | 0) != 2;
    if ($1 | (global$2 | 0) == 2) {
     if (global$2 ? ($8 | 0) == 16 : 1) {
      ProgramFail($0, 2192, 0);
      $9 = 16;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (!global$2) {
     $4 = HEAP32[$5 + 44 >> 2];
     $1 = HEAP32[$5 + 40 >> 2];
     $3 = HEAP32[$6 + 4 >> 2];
     HEAP32[$3 + 24 >> 2] = $1;
     HEAP32[$3 + 28 >> 2] = $4;
     $7 = HEAP32[$5 + 80 >> 2];
     HEAP32[$3 - -64 >> 2] = $7;
     $1 = HEAP32[$5 + 76 >> 2];
     $4 = HEAP32[$5 + 72 >> 2];
     HEAP32[$3 + 56 >> 2] = $4;
     HEAP32[$3 + 60 >> 2] = $1;
     $4 = $5 - -64 | 0;
     $1 = HEAP32[$4 >> 2];
     $4 = HEAP32[$4 + 4 >> 2];
     HEAP32[$3 + 48 >> 2] = $1;
     HEAP32[$3 + 52 >> 2] = $4;
     $1 = HEAP32[$5 + 60 >> 2];
     $4 = HEAP32[$5 + 56 >> 2];
     HEAP32[$3 + 40 >> 2] = $4;
     HEAP32[$3 + 44 >> 2] = $1;
     $4 = HEAP32[$5 + 52 >> 2];
     $1 = HEAP32[$5 + 48 >> 2];
     HEAP32[$3 + 32 >> 2] = $1;
     HEAP32[$3 + 36 >> 2] = $4;
     $1 = $5 + 40 | 0;
    }
    if (global$2 ? ($8 | 0) == 17 : 1) {
     $4 = LexCopyTokens($1, $0);
     $9 = 17;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $3 = $4;
    }
    if (!global$2) {
     HEAP32[HEAP32[$6 + 4 >> 2] + 28 >> 2] = $3;
     $1 = !TableGet($10, $2, $5 + 84 | 0, 0, 0, 0);
     if ($1) {
      break label$54
     }
     if (!HEAP32[HEAP32[HEAP32[$5 + 84 >> 2] + 4 >> 2] + 28 >> 2]) {
      $1 = TableDelete($10, $10, $2);
      VariableFree($10, $1);
      break label$54;
     }
     HEAP32[$5 + 16 >> 2] = $2;
     $1 = $5 + 16 | 0;
    }
    if (global$2 ? ($8 | 0) == 18 : 1) {
     ProgramFail($0, 2221, $1);
     $9 = 18;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $3 = HEAP16[$0 + 12 >> 1];
    $7 = HEAP16[$0 + 14 >> 1];
    $1 = HEAP32[$0 + 8 >> 2];
   }
   if (global$2 ? ($8 | 0) == 19 : 1) {
    $4 = TableSet($10, $10, $2, $6, $1, $3, $7);
    $9 = 19;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $4;
   }
   if ((global$2 | 0) == 2 | (global$2 ? $1 : !$1)) {
    if (!global$2) {
     HEAP32[$5 >> 2] = $2
    }
    if (global$2 ? ($8 | 0) == 20 : 1) {
     ProgramFail($0, 2221, $5);
     $9 = 20;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    global$0 = $5 + 144 | 0;
    return $6;
   }
   abort();
  }
  $4 = $9;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $6;
  HEAP32[$4 + 20 >> 2] = $5;
  HEAP32[$4 + 24 >> 2] = $7;
  HEAP32[$4 + 28 >> 2] = $10;
  HEAP32[$4 + 32 >> 2] = $11;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 36;
  return 0;
 }
 
 function ParseArrayInitialiser($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -36;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $9 = HEAP32[$4 + 20 >> 2];
   $8 = HEAP32[$4 + 24 >> 2];
   $10 = HEAP32[$4 + 28 >> 2];
   $11 = HEAP32[$4 + 32 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $10 = global$0 - 48 | 0;
   global$0 = $10;
   $3 = !$2;
  }
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($3) {
      break label$5
     }
     $3 = HEAP32[$0 + 16 >> 2];
     if ($3) {
      break label$5
     }
     ParserCopy($10, $0);
    }
    if (global$2 ? !$6 : 1) {
     $4 = ParseArrayInitialiser($10, $1, 0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $5 = $4;
    }
    if (!global$2) {
     $3 = HEAP32[$1 >> 2];
     $9 = HEAP32[$3 >> 2] != 13;
    }
    if ((global$2 | 0) == 2 | $9) {
     if (global$2 ? ($6 | 0) == 1 : 1) {
      AssignFail($0, 2245, $3, 0, 0, 0, 0, 0);
      $7 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (!global$2) {
     $3 = HEAP32[$1 >> 2];
     $9 = HEAP32[$3 + 4 >> 2];
     if ($9) {
      break label$5
     }
     $9 = HEAP32[$0 >> 2];
     $8 = HEAP32[$3 + 20 >> 2];
     $11 = HEAP32[$3 >> 2];
     $3 = HEAP32[$3 + 16 >> 2];
    }
    if (global$2 ? ($6 | 0) == 2 : 1) {
     $4 = TypeGetMatching($9, $0, $8, $11, $5, $3, 1);
     $7 = 2;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $3 = $4;
    }
    if (!global$2) {
     HEAP32[$1 >> 2] = $3;
     $3 = TypeSizeValue($1, 0);
    }
    if (global$2 ? ($6 | 0) == 3 : 1) {
     VariableRealloc($0, $1, $3);
     $7 = 3;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   $9 = global$2 ? $9 : 0;
   if (global$2 ? ($6 | 0) == 4 : 1) {
    $4 = LexGetToken($0, 0, 0);
    $7 = 4;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $4;
   }
   $3 = global$2 ? $3 : ($3 | 0) != 53;
   if ($3 | (global$2 | 0) == 2) {
    $9 = global$2 ? $9 : 0;
    while (1) {
     if (global$2 ? ($6 | 0) == 5 : 1) {
      $4 = LexGetToken($0, 0, 0);
      $7 = 5;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $4;
     }
     if (!global$2) {
      $8 = ($2 | 0) != 0;
      $5 = $8 & !HEAP32[$0 + 16 >> 2];
      $3 = ($3 | 0) == 52;
     }
     label$21 : {
      if ((global$2 | 0) == 2 | $3) {
       if (!global$2) {
        $5 = !$5;
        $3 = $1;
       }
       label$26 : {
        if (!global$2) {
         if ($5) {
          break label$26
         }
         $3 = HEAP32[HEAP32[$1 >> 2] + 20 >> 2];
         $5 = HEAP32[$3 + 4 >> 2];
         $3 = TypeSize($3, $5, 1);
         $5 = HEAP32[HEAP32[$1 >> 2] + 20 >> 2];
         $8 = HEAP32[$1 + 4 >> 2];
         $3 = $8 + Math_imul($3, $9) | 0;
        }
        if (global$2 ? ($6 | 0) == 6 : 1) {
         $4 = VariableAllocValueFromExistingData($0, $5, $3, 1, $1);
         $7 = 6;
         if ((global$2 | 0) == 1) {
          break label$2
         }
         $3 = $4;
        }
        if (!global$2) {
         $5 = ($9 | 0) < HEAP32[HEAP32[$1 >> 2] + 4 >> 2];
         if ($5) {
          break label$26
         }
        }
        if (global$2 ? ($6 | 0) == 7 : 1) {
         ProgramFail($0, 2271, 0);
         $7 = 7;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
       }
       if (global$2 ? ($6 | 0) == 8 : 1) {
        $4 = LexGetToken($0, 0, 1);
        $7 = 8;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $5 = $4;
       }
       if (global$2 ? ($6 | 0) == 9 : 1) {
        $4 = ParseArrayInitialiser($0, $3, $2);
        $7 = 9;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $3 = $4;
       }
       if (!global$2) {
        break label$21
       }
      }
      $3 = global$2 ? $3 : 0;
      if ((global$2 | 0) == 2 | $5) {
       if (!global$2) {
        $3 = HEAP32[$1 >> 2];
        $8 = HEAP32[$3 >> 2] != 13;
        $5 = 1;
       }
       label$35 : {
        if ($8 ? !global$2 : 0) {
         break label$35
        }
        while (1) {
         if (!global$2) {
          $8 = HEAP32[$3 + 4 >> 2];
          $5 = Math_imul($8, $5);
          $3 = HEAP32[$3 + 20 >> 2];
         }
         if (global$2 ? ($6 | 0) == 10 : 1) {
          $4 = LexGetToken($0, 0, 0);
          $7 = 10;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $8 = $4;
         }
         if (!global$2) {
          if (($8 | 0) == 48) {
           $8 = HEAP32[HEAP32[$3 + 20 >> 2] >> 2] == 3;
           if ($8) {
            break label$35
           }
          }
          $8 = HEAP32[$3 >> 2] == 13;
          if ($8) {
           continue
          }
         }
         break;
        };
       }
       if (!global$2) {
        $8 = TypeSize($3, HEAP32[$3 + 4 >> 2], 1);
        $5 = ($9 | 0) >= ($5 | 0);
       }
       if ((global$2 | 0) == 2 | $5) {
        if (global$2 ? ($6 | 0) == 11 : 1) {
         ProgramFail($0, 2271, 0);
         $7 = 11;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
       }
       if (!global$2) {
        $8 = Math_imul($9, $8);
        $5 = $8 + HEAP32[$1 + 4 >> 2] | 0;
       }
       if (global$2 ? ($6 | 0) == 12 : 1) {
        $4 = VariableAllocValueFromExistingData($0, $3, $5, 1, $1);
        $7 = 12;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $3 = $4;
       }
      }
      if (global$2 ? ($6 | 0) == 13 : 1) {
       $4 = ExpressionParse($0, $10);
       $7 = 13;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $5 = $4;
      }
      $5 = global$2 ? $5 : !$5;
      if ($5 | (global$2 | 0) == 2) {
       if (global$2 ? ($6 | 0) == 14 : 1) {
        ProgramFail($0, 2295, 0);
        $7 = 14;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
      }
      if (!global$2) {
       $5 = !$2;
       if ($5) {
        break label$21
       }
       $5 = HEAP32[$0 + 16 >> 2];
       if ($5) {
        break label$21
       }
       $5 = HEAP32[$10 >> 2];
      }
      if (global$2 ? ($6 | 0) == 15 : 1) {
       ExpressionAssign($0, $3, $5, 0, 0, 0, 0);
       $7 = 15;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      $5 = global$2 ? $5 : HEAP32[$10 >> 2];
      if (global$2 ? ($6 | 0) == 16 : 1) {
       VariableStackPop($0, $5);
       $7 = 16;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (global$2 ? ($6 | 0) == 17 : 1) {
       VariableStackPop($0, $3);
       $7 = 17;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     $12 = $5;
     if (global$2 ? ($6 | 0) == 18 : 1) {
      $4 = LexGetToken($0, 0, 0);
      $7 = 18;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $4;
     }
     $5 = global$2 ? $12 : ($3 | 0) == 53;
     label$58 : {
      if (!global$2) {
       if ($5) {
        break label$58
       }
       $5 = ($3 | 0) == 1;
      }
      if ((global$2 | 0) == 2 | $5) {
       if (global$2 ? ($6 | 0) == 19 : 1) {
        $4 = LexGetToken($0, 0, 1);
        $7 = 19;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $3 = $4;
       }
       if (global$2 ? ($6 | 0) == 20 : 1) {
        $4 = LexGetToken($0, 0, 0);
        $7 = 20;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $3 = $4;
       }
       if (!global$2) {
        break label$58
       }
      }
      if (global$2 ? ($6 | 0) == 21 : 1) {
       ProgramFail($0, 2073, 0);
       $7 = 21;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     if (!global$2) {
      $9 = $9 + 1 | 0;
      $3 = ($3 | 0) != 53;
      if ($3) {
       continue
      }
     }
     break;
    };
   }
   if (global$2 ? ($6 | 0) == 22 : 1) {
    LexGetToken($0, 0, 1);
    $7 = 22;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    global$0 = $10 + 48 | 0;
    return $9;
   }
   abort();
  }
  $4 = $7;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  HEAP32[$4 + 20 >> 2] = $9;
  HEAP32[$4 + 24 >> 2] = $8;
  HEAP32[$4 + 28 >> 2] = $10;
  HEAP32[$4 + 32 >> 2] = $11;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 36;
  return 0;
 }
 
 function ParseDeclarationAssignment($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $5 = HEAP32[$3 + 16 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = global$0 - 16 | 0;
   global$0 = $5;
  }
  label$2 : {
   if (global$2 ? !$6 : 1) {
    $3 = LexGetToken($0, 0, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $4 = $3;
   }
   $4 = global$2 ? $4 : ($4 | 0) == 52;
   label$5 : {
    if ($4 | (global$2 | 0) == 2) {
     if (global$2 ? ($6 | 0) == 1 : 1) {
      $3 = LexGetToken($0, 0, 1);
      $7 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $4 = $3;
     }
     if (global$2 ? ($6 | 0) == 2 : 1) {
      $3 = ParseArrayInitialiser($0, $1, $2);
      $7 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $0 = $3;
     }
     if (!global$2) {
      break label$5
     }
    }
    $4 = global$2 ? $4 : $5 + 12 | 0;
    if (global$2 ? ($6 | 0) == 3 : 1) {
     $3 = ExpressionParse($0, $4);
     $7 = 3;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $4 = $3;
    }
    if ((global$2 | 0) == 2 | (global$2 ? $4 : !$4)) {
     if (global$2 ? ($6 | 0) == 4 : 1) {
      ProgramFail($0, 2295, 0);
      $7 = 4;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (!global$2) {
     if (HEAP32[$0 + 16 >> 2] | !$2) {
      break label$5
     }
     $2 = HEAP32[$5 + 12 >> 2];
    }
    if (global$2 ? ($6 | 0) == 5 : 1) {
     ExpressionAssign($0, $1, $2, 0, 0, 0, 0);
     $7 = 5;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    $1 = global$2 ? $1 : HEAP32[$5 + 12 >> 2];
    if (global$2 ? ($6 | 0) == 6 : 1) {
     VariableStackPop($0, $1);
     $7 = 6;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    global$0 = $5 + 16 | 0
   }
   return;
  }
  $3 = $7;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[$3 + 16 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function PicocParse($0, $1, $2, $3, $4, $5, $6, $7) {
  var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -44;
   $8 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$8 >> 2];
   $2 = HEAP32[$8 + 8 >> 2];
   $3 = HEAP32[$8 + 12 >> 2];
   $4 = HEAP32[$8 + 16 >> 2];
   $5 = HEAP32[$8 + 20 >> 2];
   $6 = HEAP32[$8 + 24 >> 2];
   $7 = HEAP32[$8 + 28 >> 2];
   $9 = HEAP32[$8 + 32 >> 2];
   $10 = HEAP32[$8 + 36 >> 2];
   $13 = HEAP32[$8 + 40 >> 2];
   $1 = HEAP32[$8 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $11 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $10 = global$0 - 48 | 0;
   global$0 = $10;
  }
  label$2 : {
   if (global$2 ? !$11 : 1) {
    $8 = TableStrRegister($0, $1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $8;
   }
   if (global$2 ? ($11 | 0) == 1 : 1) {
    $8 = LexAnalyse($0, $1, $2, $3, 0);
    $12 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $8;
   }
   $9 = global$2 ? $9 : !$5;
   if ($9 | (global$2 | 0) == 2) {
    if (!global$2) {
     $9 = HeapAllocMem($0, 12);
     $13 = !$9;
    }
    if ((global$2 | 0) == 2 | $13) {
     if (global$2 ? ($11 | 0) == 2 : 1) {
      ProgramFailNoParser($0, 2605, 0);
      $12 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (!global$2) {
     HEAP32[$9 >> 2] = $3;
     HEAP32[$9 + 4 >> 2] = $6 ? $2 : 0;
     HEAP32[$9 + 8 >> 2] = HEAP32[$0 + 8 >> 2];
     HEAP32[$0 + 8 >> 2] = $9;
    }
   }
   if (!global$2) {
    LexInitParser($10, $0, $2, $3, $1, $4, $7)
   }
   while (1) {
    if (global$2 ? ($11 | 0) == 3 : 1) {
     $8 = ParseStatement($10, 1);
     $12 = 3;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $2 = $8;
    }
    if (!global$2) {
     $1 = ($2 | 0) == 2;
     if ($1) {
      continue
     }
    }
    break;
   };
   if ((global$2 | 0) == 2 | (global$2 ? $1 : ($2 | 0) == 1)) {
    if (global$2 ? ($11 | 0) == 4 : 1) {
     ProgramFail($10, 2619, 0);
     $12 = 4;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    if ($5) {
     HeapFreeMem($0, $3)
    }
    global$0 = $10 + 48 | 0;
   }
   return;
  }
  $8 = $12;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $8;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $8 = HEAP32[global$3 >> 2];
  HEAP32[$8 >> 2] = $0;
  HEAP32[$8 + 4 >> 2] = $1;
  HEAP32[$8 + 8 >> 2] = $2;
  HEAP32[$8 + 12 >> 2] = $3;
  HEAP32[$8 + 16 >> 2] = $4;
  HEAP32[$8 + 20 >> 2] = $5;
  HEAP32[$8 + 24 >> 2] = $6;
  HEAP32[$8 + 28 >> 2] = $7;
  HEAP32[$8 + 32 >> 2] = $9;
  HEAP32[$8 + 36 >> 2] = $10;
  HEAP32[$8 + 40 >> 2] = $13;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 44;
 }
 
 function PicocParseInteractiveNoStartPrompt($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -32;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $6 = HEAP32[$4 + 20 >> 2];
   $7 = HEAP32[$4 + 24 >> 2];
   $8 = HEAP32[$4 + 28 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $9 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  folding_inner0 : {
   if (!global$2) {
    $7 = global$0 - 48 | 0;
    global$0 = $7;
    $5 = dlmalloc(40);
    HEAP32[$5 >> 2] = 0;
    $2 = HEAP32[$0 + 2756 >> 2];
    HEAP32[6013] = 0;
    LexInitParser($7, $0, 0, 0, $2, 1, $1);
    $1 = HEAP32[6013];
    HEAP32[6013] = 0;
    $2 = -1;
    $3 = !$1;
    label$5 : {
     if ($3) {
      break label$5
     }
     $3 = HEAP32[6014];
     if (!$3) {
      break label$5
     }
     $2 = testSetjmp(HEAP32[$1 >> 2], $5 | 0, 4) | 0;
     if (!$2) {
      break folding_inner0
     }
     setTempRet0($3 | 0);
    }
    getTempRet0() | 0;
    $1 = ($2 | 0) != 1;
    if ($1) {
     $1 = $0 + 2204 | 0;
     $5 = saveSetjmp($1 | 0, 1, $5 | 0, 4) | 0;
     $6 = getTempRet0() | 0;
    } else {
     $6 = 4
    }
   }
   label$2 : {
    label$9 : while (1) {
     if (!global$2) {
      HEAP32[6013] = 0
     }
     if (global$2 ? !$9 : 1) {
      __invoke_void__struct_Picoc_Struct__i32(16, $0 | 0, $7 | 0);
      $10 = 0;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      $1 = HEAP32[6013];
      HEAP32[6013] = 0;
      $2 = -1;
      $3 = !$1;
      label$13 : {
       if ($3) {
        break label$13
       }
       $3 = HEAP32[6014];
       if (!$3) {
        break label$13
       }
       $2 = testSetjmp(HEAP32[$1 >> 2], $5 | 0, $6 | 0) | 0;
       if (!$2) {
        break folding_inner0
       }
       setTempRet0($3 | 0);
      }
      getTempRet0() | 0;
      $1 = ($2 | 0) == 1;
      if ($1) {
       continue
      }
     }
     while (1) {
      if (!global$2) {
       HEAP32[6013] = 0;
       LexInteractiveStatementPrompt($0);
       $1 = HEAP32[6013];
       HEAP32[6013] = 0;
       $2 = -1;
       $3 = !$1;
       label$17 : {
        if ($3) {
         break label$17
        }
        $3 = HEAP32[6014];
        if (!$3) {
         break label$17
        }
        $2 = testSetjmp(HEAP32[$1 >> 2], $5 | 0, $6 | 0) | 0;
        if (!$2) {
         break folding_inner0
        }
        setTempRet0($3 | 0);
       }
       getTempRet0() | 0;
       $1 = ($2 | 0) == 1;
       if ($1) {
        continue label$9
       }
       HEAP32[6013] = 0;
      }
      if (global$2 ? ($9 | 0) == 1 : 1) {
       $4 = __invoke_i32_i8__i8_(18, $7 | 0, 1) | 0;
       $10 = 1;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $3 = $4;
      }
      if (!global$2) {
       $1 = HEAP32[6013];
       HEAP32[6013] = 0;
       $2 = -1;
       label$21 : {
        if (!$1) {
         break label$21
        }
        $8 = HEAP32[6014];
        if (!$8) {
         break label$21
        }
        $2 = testSetjmp(HEAP32[$1 >> 2], $5 | 0, $6 | 0) | 0;
        if (!$2) {
         emscripten_longjmp($1 | 0, $8 | 0);
         abort();
        }
        setTempRet0($8 | 0);
       }
       getTempRet0() | 0;
       $1 = ($2 | 0) == 1;
       if ($1) {
        continue label$9
       }
       HEAP32[6013] = 0;
      }
      if (global$2 ? ($9 | 0) == 2 : 1) {
       __invoke_void__struct_Picoc_Struct__i32(19, $0 | 0, $7 | 0);
       $10 = 2;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       $1 = HEAP32[6013];
       HEAP32[6013] = 0;
       $2 = -1;
       label$25 : {
        if (!$1) {
         break label$25
        }
        $8 = HEAP32[6014];
        if (!$8) {
         break label$25
        }
        $2 = testSetjmp(HEAP32[$1 >> 2], $5 | 0, $6 | 0) | 0;
        if (!$2) {
         emscripten_longjmp($1 | 0, $8 | 0);
         abort();
        }
        setTempRet0($8 | 0);
       }
       getTempRet0() | 0;
       $1 = ($2 | 0) == 1;
       if ($1) {
        continue label$9
       }
       $1 = ($3 | 0) == 2;
       if ($1) {
        continue
       }
      }
      break;
     };
     $1 = global$2 ? $1 : ($3 | 0) == 1;
     if ($1 | (global$2 | 0) == 2) {
      if (!global$2) {
       HEAP32[6013] = 0
      }
      if (global$2 ? ($9 | 0) == 3 : 1) {
       __invoke_void__struct_Picoc_Struct__i32_i8__(20, $7 | 0, 2619, 0);
       $10 = 3;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       $1 = HEAP32[6013];
       HEAP32[6013] = 0;
       $2 = -1;
       $3 = !$1;
       label$31 : {
        if ($3) {
         break label$31
        }
        $3 = HEAP32[6014];
        if (!$3) {
         break label$31
        }
        $2 = testSetjmp(HEAP32[$1 >> 2], $5 | 0, $6 | 0) | 0;
        if (!$2) {
         break folding_inner0
        }
        setTempRet0($3 | 0);
       }
       getTempRet0() | 0;
       $1 = ($2 | 0) == 1;
       if ($1) {
        continue
       }
      }
     }
     if (!global$2) {
      $1 = HEAP32[$0 + 2196 >> 2];
      HEAP32[6013] = 0;
     }
     if (global$2 ? ($9 | 0) == 4 : 1) {
      __invoke_void__struct_Picoc_Struct__i32_i8__(21, $1 | 0, 2631, 0);
      $10 = 4;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      $1 = HEAP32[6013];
      HEAP32[6013] = 0;
      $2 = -1;
      $3 = !$1;
      label$36 : {
       if ($3) {
        break label$36
       }
       $3 = HEAP32[6014];
       if (!$3) {
        break label$36
       }
       $2 = testSetjmp(HEAP32[$1 >> 2], $5 | 0, $6 | 0) | 0;
       if (!$2) {
        break folding_inner0
       }
       setTempRet0($3 | 0);
      }
      getTempRet0() | 0;
      $1 = ($2 | 0) == 1;
      if ($1) {
       continue
      }
     }
     break;
    };
    if (!global$2) {
     dlfree($5);
     global$0 = $7 + 48 | 0;
    }
    return;
   }
   $4 = $10;
   HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
   $4 = HEAP32[global$3 >> 2];
   HEAP32[$4 >> 2] = $0;
   HEAP32[$4 + 4 >> 2] = $1;
   HEAP32[$4 + 8 >> 2] = $2;
   HEAP32[$4 + 12 >> 2] = $3;
   HEAP32[$4 + 16 >> 2] = $5;
   HEAP32[$4 + 20 >> 2] = $6;
   HEAP32[$4 + 24 >> 2] = $7;
   HEAP32[$4 + 28 >> 2] = $8;
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 32;
   return;
  }
  emscripten_longjmp($1 | 0, $3 | 0);
  abort();
 }
 
 function PicocParseInteractive($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $1 = global$2 ? $1 : HEAP32[$0 + 2196 >> 2];
  label$2 : {
   if (global$2 ? !$2 : 1) {
    PlatformPrintf($1, 2633, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 1 : 1) {
    PicocParseInteractiveNoStartPrompt($0, 1);
    $3 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  $2 = $3;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function IsTypeToken($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $5 = HEAP32[$3 + 12 >> 2];
   $6 = HEAP32[$3 + 16 >> 2];
   $3 = HEAP32[$3 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = global$0 - 16 | 0;
   global$0 = $3;
   $6 = $1 + -54 >>> 0 < 16;
   $5 = 1;
  }
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($6) {
      break label$5
     }
     $5 = 0;
     if (($1 | 0) != 45) {
      break label$5
     }
     if (!VariableDefined(HEAP32[$0 >> 2], HEAP32[HEAP32[$2 + 4 >> 2] >> 2])) {
      break label$5
     }
     $2 = HEAP32[HEAP32[$2 + 4 >> 2] >> 2];
     $6 = $3 + 12 | 0;
     $1 = HEAP32[$0 >> 2];
    }
    if (global$2 ? !$4 : 1) {
     VariableGet($1, $0, $2, $6);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (!global$2) {
     if (HEAP32[HEAP32[$3 + 12 >> 2] >> 2] != (HEAP32[$0 >> 2] + 1852 | 0)) {
      break label$5
     }
     $5 = 1;
    }
   }
   if (!global$2) {
    global$0 = $3 + 16 | 0;
    return $5;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $5;
  HEAP32[$4 + 16 >> 2] = $6;
  HEAP32[$4 + 20 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  return 0;
 }
 
 function ExpressionCoerceInteger($0) {
  var $1 = 0, $2 = 0.0, $3 = 0;
  folding_inner0 : {
   $1 = HEAP32[HEAP32[$0 >> 2] >> 2] + -1 | 0;
   label$1 : {
    if ($1 >>> 0 > 12) {
     break label$1
    }
    label$2 : {
     label$3 : {
      label$5 : {
       label$7 : {
        label$10 : {
         switch ($1 - 1 | 0) {
         case 1:
          return HEAP8[HEAP32[$0 + 4 >> 2]];
         case 8:
         case 9:
          break label$1;
         case 0:
          break label$10;
         case 7:
          break label$2;
         case 11:
          break label$3;
         case 5:
          break label$5;
         case 4:
          break label$7;
         default:
          break folding_inner0;
         };
        }
        return HEAP16[HEAP32[$0 + 4 >> 2] >> 1];
       }
       return HEAPU16[HEAP32[$0 + 4 >> 2] >> 1];
      }
      return HEAPU8[HEAP32[$0 + 4 >> 2]];
     }
     return HEAP32[$0 + 4 >> 2];
    }
    $2 = HEAPF64[HEAP32[$0 + 4 >> 2] >> 3];
    if (Math_abs($2) < 2147483648.0) {
     return ~~$2
    }
    $3 = -2147483648;
   }
   return $3;
  }
  return HEAP32[HEAP32[$0 + 4 >> 2] >> 2];
 }
 
 function ExpressionCoerceUnsignedInteger($0) {
  var $1 = 0.0, $2 = 0;
  folding_inner0 : {
   $2 = HEAP32[HEAP32[$0 >> 2] >> 2] + -1 | 0;
   label$1 : {
    if ($2 >>> 0 > 12) {
     break label$1
    }
    label$2 : {
     label$3 : {
      label$5 : {
       label$7 : {
        label$10 : {
         switch ($2 - 1 | 0) {
         case 1:
          return HEAP8[HEAP32[$0 + 4 >> 2]];
         case 8:
         case 9:
          break label$1;
         case 0:
          break label$10;
         case 7:
          break label$2;
         case 11:
          break label$3;
         case 5:
          break label$5;
         case 4:
          break label$7;
         default:
          break folding_inner0;
         };
        }
        return HEAP16[HEAP32[$0 + 4 >> 2] >> 1];
       }
       return HEAPU16[HEAP32[$0 + 4 >> 2] >> 1];
      }
      return HEAPU8[HEAP32[$0 + 4 >> 2]];
     }
     return HEAP32[$0 + 4 >> 2];
    }
    $1 = HEAPF64[HEAP32[$0 + 4 >> 2] >> 3];
    if ($1 < 4294967296.0 & $1 >= 0.0) {
     return ~~$1 >>> 0
    }
   }
   return 0;
  }
  return HEAP32[HEAP32[$0 + 4 >> 2] >> 2];
 }
 
 function ExpressionCoerceFP($0) {
  var $1 = 0;
  $1 = HEAP32[HEAP32[$0 >> 2] >> 2] + -1 | 0;
  if ($1 >>> 0 > 8) {
   return 0.0
  }
  label$2 : {
   switch ($1 - 1 | 0) {
   default:
    return +HEAP32[HEAP32[$0 + 4 >> 2] >> 2];
   case 1:
    return +HEAP8[HEAP32[$0 + 4 >> 2]];
   case 0:
    return +HEAP16[HEAP32[$0 + 4 >> 2] >> 1];
   case 2:
    return +HEAP32[HEAP32[$0 + 4 >> 2] >> 2];
   case 3:
    return +HEAPU32[HEAP32[$0 + 4 >> 2] >> 2];
   case 4:
    return +HEAPU16[HEAP32[$0 + 4 >> 2] >> 1];
   case 6:
    return +HEAPU32[HEAP32[$0 + 4 >> 2] >> 2];
   case 5:
    return +HEAPU8[HEAP32[$0 + 4 >> 2]];
   case 7:
    break label$2;
   };
  }
  return HEAPF64[HEAP32[$0 + 4 >> 2] >> 3];
 }
 
 function ExpressionAssignInt($0, $1, $2, $3) {
  var $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $4 = HEAP32[$4 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  folding_inner1 : {
   folding_inner0 : {
    label$2 : {
     if ((global$2 | 0) == 2 | (global$2 ? $4 : !HEAPU8[$1 + 15 | 0])) {
      if (global$2 ? !$5 : 1) {
       ProgramFail($0, 2664, 0);
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     if (!global$2) {
      $0 = $2;
      if ($3) {
       $0 = ExpressionCoerceInteger($1)
      }
      $3 = HEAP32[HEAP32[$1 >> 2] >> 2] + -1 | 0;
      if ($3 >>> 0 <= 7) {
       label$11 : {
        label$16 : {
         switch ($3 - 1 | 0) {
         case 0:
         case 4:
          break folding_inner1;
         case 5:
          break label$11;
         case 1:
          break label$16;
         default:
          break folding_inner0;
         };
        }
        HEAP8[HEAP32[$1 + 4 >> 2]] = $2;
        return $0;
       }
       HEAP8[HEAP32[$1 + 4 >> 2]] = $2;
      }
      return $0;
     }
     abort();
    }
    HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
    $5 = HEAP32[global$3 >> 2];
    HEAP32[$5 >> 2] = $0;
    HEAP32[$5 + 4 >> 2] = $1;
    HEAP32[$5 + 8 >> 2] = $2;
    HEAP32[$5 + 12 >> 2] = $3;
    HEAP32[$5 + 16 >> 2] = $4;
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
    return 0;
   }
   HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
   return $0;
  }
  HEAP16[HEAP32[$1 + 4 >> 2] >> 1] = $2;
  return $0;
 }
 
 function ExpressionAssignFP($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $5 = HEAP32[$3 + 12 >> 2];
   wasm2js_scratch_store_i32(0, HEAP32[$3 + 8 >> 2]);
   wasm2js_scratch_store_i32(1, $5 | 0);
   $2 = +wasm2js_scratch_load_f64();
   $3 = HEAP32[$3 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2 | (global$2 ? $3 : !HEAPU8[$1 + 15 | 0])) {
    if (global$2 ? !$4 : 1) {
     ProgramFail($0, 2664, 0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = $2;
    return $2;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  wasm2js_scratch_store_f64(+$2);
  $5 = wasm2js_scratch_load_i32(1) | 0;
  HEAP32[$4 + 8 >> 2] = wasm2js_scratch_load_i32(0);
  HEAP32[$4 + 12 >> 2] = $5;
  HEAP32[$4 + 16 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
  return 0.0;
 }
 
 function ExpressionStackPushValueNode($0, $1, $2) {
  var $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $3 = global$2 ? $3 : HEAP32[$0 >> 2];
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = VariableAlloc($3, $0, 16, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $4;
   }
   if (!global$2) {
    $3 = HEAP32[$1 >> 2];
    HEAP32[$0 + 4 >> 2] = $2;
    HEAP32[$0 >> 2] = $3;
    HEAP32[$1 >> 2] = $0;
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function ExpressionStackPushValueByType($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $4 = global$2 ? $4 : HEAP32[$0 >> 2];
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $3 = VariableAllocValueFromType($4, $0, $2, 0, 0, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $3;
   }
   if (global$2 ? ($5 | 0) == 1 : 1) {
    ExpressionStackPushValueNode($0, $1, $2);
    $6 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    return $2
   }
   abort();
  }
  $3 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function ExpressionStackPushValue($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $4 = global$2 ? $4 : HEAP32[$0 >> 2];
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $3 = VariableAllocValueAndCopy($4, $0, $2, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $3;
   }
   if (global$2 ? ($5 | 0) == 1 : 1) {
    ExpressionStackPushValueNode($0, $1, $2);
    $6 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  $3 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function ExpressionStackPushLValue($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   }
   if (global$2 ? !$5 : 1) {
    $4 = VariableAllocValueShared($0, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[$2 + 4 >> 2] = HEAP32[$2 + 4 >> 2] + $3
   }
   if (global$2 ? ($5 | 0) == 1 : 1) {
    ExpressionStackPushValueNode($0, $1, $2);
    $6 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  $4 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function ExpressionStackPushDereference($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -28;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $5 = HEAP32[$3 + 16 >> 2];
   $6 = HEAP32[$3 + 20 >> 2];
   $7 = HEAP32[$3 + 24 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if (!global$2) {
    $4 = global$0 - 16 | 0;
    global$0 = $4;
    $6 = $4 + 8 | 0;
    $7 = $4 + 4 | 0;
    $2 = VariableDereferencePointer($0, $2, $4 + 12 | 0, $6, $7, $4);
    $5 = !$2;
   }
   if ((global$2 | 0) == 2 | $5) {
    if (global$2 ? !$8 : 1) {
     ProgramFail($0, 2685, 0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $6 = HEAP32[$4 >> 2];
    $7 = HEAP32[$4 + 12 >> 2];
    $5 = HEAP32[$4 + 4 >> 2];
   }
   if (global$2 ? ($8 | 0) == 1 : 1) {
    $3 = VariableAllocValueFromExistingData($0, $5, $2, $6, $7);
    $9 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $3;
   }
   if (global$2 ? ($8 | 0) == 2 : 1) {
    ExpressionStackPushValueNode($0, $1, $2);
    $9 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    global$0 = $4 + 16 | 0
   }
   return;
  }
  $3 = $9;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[$3 + 16 >> 2] = $5;
  HEAP32[$3 + 20 >> 2] = $6;
  HEAP32[$3 + 24 >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 28;
 }
 
 function ExpressionPushInt($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $5 = HEAP32[$3 + 16 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $4 = HEAP32[$0 >> 2];
   $5 = $4 + 1412 | 0;
  }
  label$2 : {
   if (global$2 ? !$6 : 1) {
    $3 = VariableAllocValueFromType($4, $0, $5, 0, 0, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $4 = $3;
   }
   if (!global$2) {
    HEAP32[HEAP32[$4 + 4 >> 2] >> 2] = $2
   }
   if (global$2 ? ($6 | 0) == 1 : 1) {
    ExpressionStackPushValueNode($0, $1, $4);
    $7 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  $3 = $7;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[$3 + 16 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function ExpressionPushFP($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 12 >> 2];
   wasm2js_scratch_store_i32(0, HEAP32[$3 + 8 >> 2]);
   wasm2js_scratch_store_i32(1, $1 | 0);
   $2 = +wasm2js_scratch_load_f64();
   $4 = HEAP32[$3 + 16 >> 2];
   $5 = HEAP32[$3 + 20 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $4 = HEAP32[$0 >> 2];
   $5 = $4 + 1764 | 0;
  }
  label$2 : {
   if (global$2 ? !$6 : 1) {
    $3 = VariableAllocValueFromType($4, $0, $5, 0, 0, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $4 = $3;
   }
   if (!global$2) {
    HEAPF64[HEAP32[$4 + 4 >> 2] >> 3] = $2
   }
   if (global$2 ? ($6 | 0) == 1 : 1) {
    ExpressionStackPushValueNode($0, $1, $4);
    $7 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  $3 = $7;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  wasm2js_scratch_store_f64(+$2);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  HEAP32[$3 + 8 >> 2] = wasm2js_scratch_load_i32(0);
  HEAP32[$3 + 12 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $4;
  HEAP32[$3 + 20 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
 }
 
 function ExpressionAssignToPointer($0, $1, $2, $3, $4, $5) {
  var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -48;
   $6 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$6 >> 2];
   $1 = HEAP32[$6 + 4 >> 2];
   $2 = HEAP32[$6 + 8 >> 2];
   $3 = HEAP32[$6 + 12 >> 2];
   $4 = HEAP32[$6 + 16 >> 2];
   $5 = HEAP32[$6 + 20 >> 2];
   $8 = HEAP32[$6 + 24 >> 2];
   $10 = HEAP32[$6 + 28 >> 2];
   $9 = HEAP32[$6 + 32 >> 2];
   $11 = HEAP32[$6 + 36 >> 2];
   $12 = HEAP32[$6 + 40 >> 2];
   $6 = HEAP32[$6 + 44 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $7 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  folding_inner0 : {
   if (!global$2) {
    $8 = HEAP32[$2 >> 2];
    $10 = HEAP32[$1 >> 2];
    if (($8 | 0) == ($10 | 0)) {
     break folding_inner0
    }
    $9 = HEAP32[HEAP32[$0 >> 2] + 2084 >> 2];
    if (($9 | 0) == ($8 | 0)) {
     break folding_inner0
    }
    $12 = HEAP32[$10 + 20 >> 2];
    label$5 : {
     if (($10 | 0) != ($9 | 0) | HEAP32[$8 >> 2] != 12) {
      break label$5
     }
     break folding_inner0;
    }
    $11 = HEAP32[$8 >> 2];
    if (!(($11 | 0) != 13 | (HEAP32[$8 + 20 >> 2] != ($12 | 0) ? ($10 | 0) != ($9 | 0) : 0))) {
     HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = HEAP32[$2 + 4 >> 2];
     return;
    }
    label$9 : {
     if (($11 | 0) != 12) {
      break label$9
     }
     $6 = HEAP32[$8 + 20 >> 2];
     if (HEAP32[$6 >> 2] != 13 | (HEAP32[$6 + 20 >> 2] != ($12 | 0) ? ($10 | 0) != ($9 | 0) : 0)) {
      break label$9
     }
     $2 = VariableDereferencePointer($0, $2, 0, 0, 0, 0);
     HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
     return;
    }
    label$11 : {
     $9 = $11 + -1 | 0;
     if ($9 >>> 0 > 8) {
      break label$11
     }
     if (ExpressionCoerceInteger($2)) {
      break label$11
     }
     HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = 0;
     return;
    }
    label$12 : {
     if (!$5) {
      break label$12
     }
     if ($9 >>> 0 <= 8) {
      HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = ExpressionCoerceUnsignedInteger($2);
      return;
     }
     if (($11 | 0) != 12) {
      break label$12
     }
     break folding_inner0;
    }
   }
   label$2 : {
    if (global$2 ? !$7 : 1) {
     AssignFail($0, 2710, $10, $8, 0, 0, $3, $4);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    return;
   }
   HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
   $7 = HEAP32[global$3 >> 2];
   HEAP32[$7 >> 2] = $0;
   HEAP32[$7 + 4 >> 2] = $1;
   HEAP32[$7 + 8 >> 2] = $2;
   HEAP32[$7 + 12 >> 2] = $3;
   HEAP32[$7 + 16 >> 2] = $4;
   HEAP32[$7 + 20 >> 2] = $5;
   HEAP32[$7 + 24 >> 2] = $8;
   HEAP32[$7 + 28 >> 2] = $10;
   HEAP32[$7 + 32 >> 2] = $9;
   HEAP32[$7 + 36 >> 2] = $11;
   HEAP32[$7 + 40 >> 2] = $12;
   HEAP32[$7 + 44 >> 2] = $6;
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 48;
   return;
  }
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = HEAP32[HEAP32[$2 + 4 >> 2] >> 2];
 }
 
 function ExpressionAssign($0, $1, $2, $3, $4, $5, $6) {
  var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -40;
   $7 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$7 >> 2];
   $2 = HEAP32[$7 + 8 >> 2];
   $3 = HEAP32[$7 + 12 >> 2];
   $4 = HEAP32[$7 + 16 >> 2];
   $5 = HEAP32[$7 + 20 >> 2];
   $6 = HEAP32[$7 + 24 >> 2];
   $8 = HEAP32[$7 + 28 >> 2];
   $11 = HEAP32[$7 + 32 >> 2];
   $12 = HEAP32[$7 + 36 >> 2];
   $1 = HEAP32[$7 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $9 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  folding_inner1 : {
   folding_inner0 : {
    label$2 : {
     label$4 : {
      if (!global$2) {
       if ($3) {
        break label$4
       }
       $3 = HEAPU8[$1 + 15 | 0];
       if ($3) {
        break label$4
       }
      }
      if (global$2 ? !$9 : 1) {
       AssignFail($0, 2721, 0, 0, 0, 0, $4, $5);
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     if (!global$2) {
      $3 = HEAP32[$1 >> 2];
      $8 = HEAP32[$3 >> 2] + -1 >>> 0 > 8;
     }
     label$8 : {
      if (!global$2) {
       if ($8) {
        break label$8
       }
       $11 = HEAP32[$2 >> 2];
       $8 = HEAP32[$11 >> 2];
       $12 = $8 + -1 >>> 0 < 9;
       if ($12) {
        break label$8
       }
       $8 = ($8 | 0) == 12 ? $6 : 0;
       if ($8) {
        break label$8
       }
      }
      if (global$2 ? ($9 | 0) == 1 : 1) {
       AssignFail($0, 2710, $3, $11, 0, 0, $4, $5);
       $10 = 1;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     if (!global$2) {
      $8 = HEAP32[$1 >> 2];
      $3 = HEAP32[$8 >> 2] + -1 | 0;
      $11 = $3 >>> 0 > 14;
     }
     label$12 : {
      if (!global$2) {
       if ($11) {
        break label$12
       }
       $3 = $3 - 1 | 0;
      }
      label$14 : {
       label$15 : {
        label$16 : {
         if (!global$2) {
          label$18 : {
           label$19 : {
            label$21 : {
             label$24 : {
              switch ($3 | 0) {
              case 0:
               HEAP16[HEAP32[$1 + 4 >> 2] >> 1] = ExpressionCoerceInteger($2);
               return;
              case 3:
              case 6:
               break folding_inner1;
              case 8:
              case 9:
               break label$12;
              case 12:
              case 13:
               break label$14;
              case 11:
               break label$15;
              case 10:
               break label$16;
              case 7:
               break label$18;
              case 5:
               break label$19;
              case 4:
               break label$21;
              case 1:
               break label$24;
              default:
               break folding_inner0;
              };
             }
             HEAP8[HEAP32[$1 + 4 >> 2]] = ExpressionCoerceInteger($2);
             return;
            }
            HEAP16[HEAP32[$1 + 4 >> 2] >> 1] = ExpressionCoerceUnsignedInteger($2);
            return;
           }
           HEAP8[HEAP32[$1 + 4 >> 2]] = ExpressionCoerceUnsignedInteger($2);
           return;
          }
          $11 = HEAP32[$2 >> 2];
          $3 = HEAP32[$11 >> 2];
          $12 = $3 + -1 >>> 0 < 9;
         }
         label$27 : {
          if (!global$2) {
           if ($12) {
            break label$27
           }
           $3 = ($3 | 0) == 12 ? $6 : 0;
           if ($3) {
            break label$27
           }
          }
          if (global$2 ? ($9 | 0) == 2 : 1) {
           AssignFail($0, 2710, $8, $11, 0, 0, $4, $5);
           $10 = 2;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
         }
         if (!global$2) {
          HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = ExpressionCoerceFP($2);
          return;
         }
        }
        if (global$2 ? ($9 | 0) == 3 : 1) {
         ExpressionAssignToPointer($0, $1, $2, $4, $5, $6);
         $10 = 3;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         return
        }
       }
       if (!global$2) {
        $3 = HEAP32[$2 >> 2];
        $6 = HEAP32[$3 >> 2] != 13;
       }
       label$34 : {
        if (!global$2) {
         if ($6) {
          break label$34
         }
         $6 = HEAP32[$8 + 4 >> 2];
         if ($6) {
          break label$34
         }
         HEAP32[$1 >> 2] = $3;
         $3 = TypeSizeValue($1, 0);
        }
        if (global$2 ? ($9 | 0) == 4 : 1) {
         VariableRealloc($0, $1, $3);
         $10 = 4;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         $3 = HEAP32[$1 + 8 >> 2];
         $6 = !$3;
         if ($6) {
          break label$34
         }
         HEAP32[$3 + 4 >> 2] = HEAP32[$1 + 4 >> 2];
         $6 = HEAPU8[$1 + 14 | 0];
         HEAP8[$3 + 14 | 0] = $6;
        }
       }
       if (!global$2) {
        $3 = HEAP32[$1 >> 2];
        $6 = HEAP32[$3 + 20 >> 2];
        $8 = HEAP32[$6 >> 2] != 3;
       }
       label$39 : {
        if (!global$2) {
         if ($8) {
          break label$39
         }
         $8 = HEAP32[$2 >> 2];
         if (HEAP32[$8 >> 2] != 12) {
          break label$39
         }
         $8 = HEAP32[HEAP32[$8 + 20 >> 2] >> 2] != 3;
         if ($8) {
          break label$39
         }
         $4 = !HEAP32[$3 + 4 >> 2];
        }
        if ((global$2 | 0) == 2 | $4) {
         if (!global$2) {
          $4 = HEAP32[$0 >> 2];
          $5 = HEAP32[$3 >> 2];
          $8 = strlen(HEAP32[HEAP32[$2 + 4 >> 2] >> 2]) + 1 | 0;
          $3 = HEAP32[$3 + 16 >> 2];
         }
         if (global$2 ? ($9 | 0) == 5 : 1) {
          $7 = TypeGetMatching($4, $0, $6, $5, $8, $3, 1);
          $10 = 5;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $3 = $7;
         }
         if (!global$2) {
          HEAP32[$1 >> 2] = $3;
          $3 = TypeSizeValue($1, 0);
         }
         if (global$2 ? ($9 | 0) == 6 : 1) {
          VariableRealloc($0, $1, $3);
          $10 = 6;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
        }
        if (!global$2) {
         memcpy(HEAP32[$1 + 4 >> 2], HEAP32[HEAP32[$2 + 4 >> 2] >> 2], TypeSizeValue($1, 0));
         return;
        }
       }
       if (!global$2) {
        $6 = HEAP32[$2 >> 2];
        $8 = ($6 | 0) != ($3 | 0);
       }
       if ((global$2 | 0) == 2 | $8) {
        if (global$2 ? ($9 | 0) == 7 : 1) {
         AssignFail($0, 2710, $3, $6, 0, 0, $4, $5);
         $10 = 7;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
       }
       if (!global$2) {
        $3 = HEAP32[HEAP32[$1 >> 2] + 4 >> 2];
        $6 = HEAP32[HEAP32[$2 >> 2] + 4 >> 2];
        $8 = ($3 | 0) != ($6 | 0);
       }
       if ((global$2 | 0) == 2 | $8) {
        if (global$2 ? ($9 | 0) == 8 : 1) {
         AssignFail($0, 2735, 0, 0, $3, $6, $4, $5);
         $10 = 8;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
       }
       if (!global$2) {
        memcpy(HEAP32[$1 + 4 >> 2], HEAP32[$2 + 4 >> 2], TypeSizeValue($1, 0));
        return;
       }
      }
      if (global$2) {
       $7 = $6
      } else {
       $3 = HEAP32[$2 >> 2];
       $7 = ($8 | 0) != ($3 | 0);
      }
      if ($7 | (global$2 | 0) == 2) {
       if (global$2 ? ($9 | 0) == 9 : 1) {
        AssignFail($0, 2710, $8, $3, 0, 0, $4, $5);
        $10 = 9;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
      }
      if (!global$2) {
       memcpy(HEAP32[$1 + 4 >> 2], HEAP32[$2 + 4 >> 2], TypeSizeValue($2, 0));
       return;
      }
     }
     if (global$2 ? ($9 | 0) == 10 : 1) {
      AssignFail($0, 2778, $8, 0, 0, 0, $4, $5);
      $10 = 10;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     return;
    }
    $7 = $10;
    HEAP32[HEAP32[global$3 >> 2] >> 2] = $7;
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
    $7 = HEAP32[global$3 >> 2];
    HEAP32[$7 >> 2] = $0;
    HEAP32[$7 + 4 >> 2] = $1;
    HEAP32[$7 + 8 >> 2] = $2;
    HEAP32[$7 + 12 >> 2] = $3;
    HEAP32[$7 + 16 >> 2] = $4;
    HEAP32[$7 + 20 >> 2] = $5;
    HEAP32[$7 + 24 >> 2] = $6;
    HEAP32[$7 + 28 >> 2] = $8;
    HEAP32[$7 + 32 >> 2] = $11;
    HEAP32[$7 + 36 >> 2] = $12;
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 40;
    return;
   }
   HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = ExpressionCoerceInteger($2);
   return;
  }
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = ExpressionCoerceUnsignedInteger($2);
 }
 
 function ExpressionQuestionMarkOperator($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $5 = HEAP32[$5 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2 | (global$2 ? $5 : HEAP32[HEAP32[$3 >> 2] >> 2] + -1 >>> 0 >= 9)) {
    if (global$2 ? !$4 : 1) {
     ProgramFail($0, 2781, 0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $3 = ExpressionCoerceInteger($3)
   }
   if ((global$2 | 0) == 2 | $3) {
    if (global$2 ? ($4 | 0) == 1 : 1) {
     ExpressionStackPushValue($0, $1, $2);
     $6 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (!global$2) {
     return
    }
   }
   $2 = global$2 ? $2 : HEAP32[$0 >> 2] + 1808 | 0;
   if (global$2 ? ($4 | 0) == 2 : 1) {
    ExpressionStackPushValueByType($0, $1, $2);
    $6 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  $4 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function ExpressionColonOperator($0, $1, $2, $3) {
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $2 = global$2 ? $2 : HEAP32[HEAP32[$3 >> 2] >> 2] ? $3 : $2;
  label$2 : {
   if (global$2 ? !$4 : 1) {
    ExpressionStackPushValue($0, $1, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function ExpressionPrefixOperator($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0.0, $10 = 0, $11 = 0.0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -36;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $1 = HEAP32[$4 + 24 >> 2];
   wasm2js_scratch_store_i32(0, HEAP32[$4 + 20 >> 2]);
   wasm2js_scratch_store_i32(1, $1 | 0);
   $9 = +wasm2js_scratch_load_f64();
   $8 = HEAP32[$4 + 28 >> 2];
   $10 = HEAP32[$4 + 32 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = $2 + -19 | 0;
   $8 = $5 >>> 0 > 18;
  }
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($8) {
      break label$5
     }
     $5 = $5 - 1 | 0;
    }
    label$7 : {
     label$8 : {
      if (!global$2) {
       label$11 : {
        switch ($5 | 0) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
         break label$5;
        case 17:
         break label$7;
        case 10:
         break label$8;
        default:
         break label$11;
        };
       }
       $2 = !HEAPU8[$3 + 15 | 0];
      }
      if ((global$2 | 0) == 2 | $2) {
       if (global$2 ? !$6 : 1) {
        ProgramFail($0, 2822, 0);
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
      }
      if (!global$2) {
       $5 = HEAP32[$3 + 4 >> 2];
       $2 = HEAP32[$0 >> 2];
       $8 = HEAP32[$2 + 2756 >> 2];
       $3 = HEAP32[$3 >> 2];
      }
      if (global$2 ? ($6 | 0) == 1 : 1) {
       $4 = TypeGetMatching($2, $0, $3, 12, 0, $8, 1);
       $7 = 1;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $3 = $4;
      }
      if (global$2 ? ($6 | 0) == 2 : 1) {
       $4 = VariableAllocValueFromType($2, $0, $3, 0, 0, 0);
       $7 = 2;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $3 = $4;
      }
      if (!global$2) {
       $2 = HEAP32[$3 + 4 >> 2];
       HEAP32[$2 >> 2] = $5;
      }
      if (global$2 ? ($6 | 0) == 3 : 1) {
       ExpressionStackPushValueNode($0, $1, $3);
       $7 = 3;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       return
      }
     }
     if (global$2 ? ($6 | 0) == 4 : 1) {
      ExpressionStackPushDereference($0, $1, $3);
      $7 = 4;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      return
     }
    }
    if (!global$2) {
     $2 = HEAP32[$3 >> 2];
     $5 = ($2 | 0) == (HEAP32[$0 >> 2] + 1852 | 0);
    }
    if ((global$2 | 0) == 2 | $5) {
     if (!global$2) {
      $3 = HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
      $2 = HEAP32[$3 + 4 >> 2];
      $2 = TypeSize($3, $2, 1);
     }
     if (global$2 ? ($6 | 0) == 5 : 1) {
      ExpressionPushInt($0, $1, $2);
      $7 = 5;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      return
     }
    }
    if (!global$2) {
     $3 = HEAP32[$2 + 4 >> 2];
     $2 = TypeSize($2, $3, 1);
    }
    if (global$2 ? ($6 | 0) == 6 : 1) {
     ExpressionPushInt($0, $1, $2);
     $7 = 6;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (!global$2) {
     return
    }
   }
   if (!global$2) {
    $5 = HEAP32[$3 >> 2];
    $8 = ($5 | 0) == (HEAP32[$0 >> 2] + 1764 | 0);
   }
   if ((global$2 | 0) == 2 | $8) {
    if (!global$2) {
     $2 = $2 + -28 | 0;
     $5 = $2 >>> 0 > 7;
    }
    label$35 : {
     if (!global$2) {
      if ($5) {
       break label$35
      }
      $2 = $2 - 1 | 0;
     }
     label$37 : {
      label$38 : {
       label$39 : {
        label$40 : {
         if (!global$2) {
          label$42 : {
           switch ($2 | 0) {
           case 1:
           case 2:
           case 3:
            break label$35;
           case 6:
            break label$37;
           case 5:
            break label$38;
           case 4:
            break label$39;
           case 0:
            break label$40;
           default:
            break label$42;
           };
          }
          $2 = HEAP32[$3 + 4 >> 2];
          $9 = HEAPF64[$2 >> 3];
         }
         if (global$2 ? ($6 | 0) == 7 : 1) {
          ExpressionPushFP($0, $1, $9);
          $7 = 7;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          return
         }
        }
        if (!global$2) {
         $2 = HEAP32[$3 + 4 >> 2];
         $9 = -HEAPF64[$2 >> 3];
        }
        if (global$2 ? ($6 | 0) == 8 : 1) {
         ExpressionPushFP($0, $1, $9);
         $7 = 8;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         return
        }
       }
       if (!global$2) {
        $2 = HEAP32[$3 + 4 >> 2];
        $9 = HEAPF64[$2 >> 3] + 1.0;
       }
       if (global$2 ? ($6 | 0) == 9 : 1) {
        $11 = ExpressionAssignFP($0, $3, $9);
        $7 = 9;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $9 = $11;
       }
       if (global$2 ? ($6 | 0) == 10 : 1) {
        ExpressionPushFP($0, $1, $9);
        $7 = 10;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        return
       }
      }
      if (!global$2) {
       $2 = HEAP32[$3 + 4 >> 2];
       $9 = HEAPF64[$2 >> 3] + -1.0;
      }
      if (global$2 ? ($6 | 0) == 11 : 1) {
       $11 = ExpressionAssignFP($0, $3, $9);
       $7 = 11;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $9 = $11;
      }
      if (global$2 ? ($6 | 0) == 12 : 1) {
       ExpressionPushFP($0, $1, $9);
       $7 = 12;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       return
      }
     }
     if (!global$2) {
      $2 = HEAPF64[HEAP32[$3 + 4 >> 2] >> 3] == 0.0;
      $9 = $2 ? 1.0 : 0.0;
     }
     if (global$2 ? ($6 | 0) == 13 : 1) {
      ExpressionPushFP($0, $1, $9);
      $7 = 13;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      return
     }
    }
    if (global$2 ? ($6 | 0) == 14 : 1) {
     ProgramFail($0, 2852, 0);
     $7 = 14;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (global$2 ? ($6 | 0) == 15 : 1) {
     ExpressionPushFP($0, $1, 0.0);
     $7 = 15;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (!global$2) {
     return
    }
   }
   if (!global$2) {
    $8 = HEAP32[$5 >> 2];
    $10 = $8 + -1 >>> 0 < 8;
   }
   label$63 : {
    label$64 : {
     if (!global$2) {
      label$66 : {
       if ($10) {
        break label$66
       }
       $8 = $8 + -9 | 0;
       if ($8 >>> 0 > 3) {
        break label$63
       }
       $8 = $8 - 1 | 0;
       switch ($8 | 0) {
       case 0:
       case 1:
        break label$63;
       case 2:
        break label$64;
       default:
        break label$66;
       };
      }
      $2 = $2 + -28 | 0;
      $8 = $2 >>> 0 > 8;
      $5 = ExpressionCoerceInteger($3);
     }
     label$67 : {
      label$68 : {
       if (!global$2) {
        if ($8) {
         break label$68
        }
        $2 = $2 - 1 | 0;
       }
       label$70 : {
        label$71 : {
         label$72 : {
          label$73 : {
           if (!global$2) {
            label$75 : {
             switch ($2 | 0) {
             case 1:
             case 2:
             case 3:
              break label$68;
             case 7:
              break label$70;
             case 6:
              break label$71;
             case 5:
              break label$72;
             case 4:
              break label$73;
             case 0:
              break label$75;
             default:
              break label$67;
             };
            }
            $2 = 0 - $5 | 0;
           }
           if (global$2 ? ($6 | 0) == 16 : 1) {
            ExpressionPushInt($0, $1, $2);
            $7 = 16;
            if ((global$2 | 0) == 1) {
             break label$2
            }
           }
           if (!global$2) {
            return
           }
          }
          $2 = global$2 ? $2 : $5 + 1 | 0;
          if (global$2 ? ($6 | 0) == 17 : 1) {
           $4 = ExpressionAssignInt($0, $3, $2, 0);
           $7 = 17;
           if ((global$2 | 0) == 1) {
            break label$2
           }
           $2 = $4;
          }
          if (global$2 ? ($6 | 0) == 18 : 1) {
           ExpressionPushInt($0, $1, $2);
           $7 = 18;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (!global$2) {
           return
          }
         }
         $2 = global$2 ? $2 : $5 + -1 | 0;
         if (global$2 ? ($6 | 0) == 19 : 1) {
          $4 = ExpressionAssignInt($0, $3, $2, 0);
          $7 = 19;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $2 = $4;
         }
         if (global$2 ? ($6 | 0) == 20 : 1) {
          ExpressionPushInt($0, $1, $2);
          $7 = 20;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          return
         }
        }
        $2 = global$2 ? $2 : !$5;
        if (global$2 ? ($6 | 0) == 21 : 1) {
         ExpressionPushInt($0, $1, $2);
         $7 = 21;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         return
        }
       }
       $2 = global$2 ? $2 : $5 ^ -1;
       if (global$2 ? ($6 | 0) == 22 : 1) {
        ExpressionPushInt($0, $1, $2);
        $7 = 22;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        return
       }
      }
      $5 = global$2 ? $5 : 0;
      if (global$2 ? ($6 | 0) == 23 : 1) {
       ProgramFail($0, 2852, 0);
       $7 = 23;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     if (global$2 ? ($6 | 0) == 24 : 1) {
      ExpressionPushInt($0, $1, $5);
      $7 = 24;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      return
     }
    }
    if (!global$2) {
     $5 = TypeSize(HEAP32[$5 + 20 >> 2], 0, 1);
     $8 = !HEAPU8[$3 + 15 | 0];
    }
    if ((global$2 | 0) == 2 | $8) {
     if (global$2 ? ($6 | 0) == 25 : 1) {
      ProgramFail($0, 2664, 0);
      $7 = 25;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (global$2) {
     $4 = $8
    } else {
     $2 = $2 + -33 | 0;
     $4 = $2 >>> 0 <= 2;
    }
    label$94 : {
     if ($4 | (global$2 | 0) == 2) {
      $2 = global$2 ? $2 : $2 - 1 | 0;
      label$98 : {
       label$99 : {
        if (!global$2) {
         label$101 : {
          switch ($2 | 0) {
          case 1:
           break label$101;
          case 0:
           break label$98;
          default:
           break label$99;
          };
         }
         $2 = !HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
        }
        if (global$2 ? ($6 | 0) == 26 : 1) {
         ExpressionPushInt($0, $1, $2);
         $7 = 26;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         return
        }
       }
       if (!global$2) {
        $2 = HEAP32[$3 + 4 >> 2];
        $5 = HEAP32[$2 >> 2] + $5 | 0;
        HEAP32[$2 >> 2] = $5;
        break label$94;
       }
      }
      if (!global$2) {
       $2 = HEAP32[$3 + 4 >> 2];
       $5 = HEAP32[$2 >> 2] - $5 | 0;
       HEAP32[$2 >> 2] = $5;
       break label$94;
      }
     }
     if (global$2 ? ($6 | 0) == 27 : 1) {
      ProgramFail($0, 2852, 0);
      $7 = 27;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (!global$2) {
     $2 = HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
     $3 = HEAP32[$3 >> 2];
    }
    if (global$2 ? ($6 | 0) == 28 : 1) {
     $4 = ExpressionStackPushValueByType($0, $1, $3);
     $7 = 28;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $0 = $4;
    }
    if (!global$2) {
     HEAP32[HEAP32[$0 + 4 >> 2] >> 2] = $2;
     return;
    }
   }
   if (global$2 ? ($6 | 0) == 29 : 1) {
    ProgramFail($0, 2852, 0);
    $7 = 29;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  wasm2js_scratch_store_f64(+$9);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  HEAP32[$4 + 20 >> 2] = wasm2js_scratch_load_i32(0);
  HEAP32[$4 + 24 >> 2] = $1;
  HEAP32[$4 + 28 >> 2] = $8;
  HEAP32[$4 + 32 >> 2] = $10;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 36;
 }
 
 function ExpressionPostfixOperator($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0.0, $10 = 0, $11 = 0.0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -36;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $8 = HEAP32[$4 + 20 >> 2];
   $1 = HEAP32[$4 + 28 >> 2];
   wasm2js_scratch_store_i32(0, HEAP32[$4 + 24 >> 2]);
   wasm2js_scratch_store_i32(1, $1 | 0);
   $9 = +wasm2js_scratch_load_f64();
   $10 = HEAP32[$4 + 32 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if (!global$2) {
    $8 = HEAP32[$3 >> 2];
    $5 = ($8 | 0) == (HEAP32[$0 >> 2] + 1764 | 0);
   }
   if ((global$2 | 0) == 2 | $5) {
    if (!global$2) {
     $2 = $2 + -33 | 0;
     $8 = $2 >>> 0 <= 1;
    }
    if ((global$2 | 0) == 2 | $8) {
     $2 = global$2 ? $2 : $2 - 1 | 0;
     if ($2 | (global$2 | 0) == 2) {
      if (!global$2) {
       $2 = HEAP32[$3 + 4 >> 2];
       $9 = HEAPF64[$2 >> 3] + 1.0;
      }
      if (global$2 ? !$6 : 1) {
       $11 = ExpressionAssignFP($0, $3, $9);
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $9 = $11;
      }
      if (global$2 ? ($6 | 0) == 1 : 1) {
       ExpressionPushFP($0, $1, $9);
       $7 = 1;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       return
      }
     }
     if (!global$2) {
      $2 = HEAP32[$3 + 4 >> 2];
      $9 = HEAPF64[$2 >> 3] + -1.0;
     }
     if (global$2 ? ($6 | 0) == 2 : 1) {
      $11 = ExpressionAssignFP($0, $3, $9);
      $7 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $9 = $11;
     }
     if (global$2 ? ($6 | 0) == 3 : 1) {
      ExpressionPushFP($0, $1, $9);
      $7 = 3;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      return
     }
    }
    if (global$2 ? ($6 | 0) == 4 : 1) {
     ProgramFail($0, 2852, 0);
     $7 = 4;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (global$2 ? ($6 | 0) == 5 : 1) {
     ExpressionPushFP($0, $1, 0.0);
     $7 = 5;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (!global$2) {
     return
    }
   }
   if (!global$2) {
    $5 = HEAP32[$8 >> 2];
    $10 = $5 + -1 >>> 0 < 8;
   }
   label$23 : {
    label$24 : {
     if (!global$2) {
      label$26 : {
       if ($10) {
        break label$26
       }
       $5 = $5 + -9 | 0;
       $10 = $5 >>> 0 > 3;
       if ($10) {
        break label$23
       }
       $5 = $5 - 1 | 0;
       switch ($5 | 0) {
       case 0:
       case 1:
        break label$23;
       case 2:
        break label$24;
       default:
        break label$26;
       };
      }
      $8 = ExpressionCoerceInteger($3);
      $2 = $2 + -33 | 0;
      $5 = $2 >>> 0 > 11;
     }
     label$27 : {
      if (!global$2) {
       if ($5) {
        break label$27
       }
       $2 = $2 - 1 | 0;
      }
      label$29 : {
       label$30 : {
        label$31 : {
         if (!global$2) {
          label$33 : {
           switch ($2 | 0) {
           case 1:
           case 2:
           case 3:
           case 4:
           case 5:
           case 7:
           case 8:
           case 9:
            break label$27;
           case 10:
            break label$29;
           case 6:
            break label$30;
           case 0:
            break label$31;
           default:
            break label$33;
           };
          }
          $2 = $8 + 1 | 0;
         }
         if (global$2 ? ($6 | 0) == 6 : 1) {
          $4 = ExpressionAssignInt($0, $3, $2, 1);
          $7 = 6;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $2 = $4;
         }
         if (global$2 ? ($6 | 0) == 7 : 1) {
          ExpressionPushInt($0, $1, $2);
          $7 = 7;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          return
         }
        }
        $2 = global$2 ? $2 : $8 + -1 | 0;
        if (global$2 ? ($6 | 0) == 8 : 1) {
         $4 = ExpressionAssignInt($0, $3, $2, 1);
         $7 = 8;
         if ((global$2 | 0) == 1) {
          break label$2
         }
         $2 = $4;
        }
        if (global$2 ? ($6 | 0) == 9 : 1) {
         ExpressionPushInt($0, $1, $2);
         $7 = 9;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         return
        }
       }
       if (global$2 ? ($6 | 0) == 10 : 1) {
        ProgramFail($0, 2870, 0);
        $7 = 10;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (global$2 ? ($6 | 0) == 11 : 1) {
        ExpressionPushInt($0, $1, 0);
        $7 = 11;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        return
       }
      }
      if (global$2 ? ($6 | 0) == 12 : 1) {
       ProgramFail($0, 2870, 0);
       $7 = 12;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (global$2 ? ($6 | 0) == 13 : 1) {
       ExpressionPushInt($0, $1, 0);
       $7 = 13;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       return
      }
     }
     if (global$2 ? ($6 | 0) == 14 : 1) {
      ProgramFail($0, 2852, 0);
      $7 = 14;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (global$2 ? ($6 | 0) == 15 : 1) {
      ExpressionPushInt($0, $1, 0);
      $7 = 15;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      return
     }
    }
    if (!global$2) {
     $5 = TypeSize(HEAP32[$8 + 20 >> 2], 0, 1);
     $10 = !HEAPU8[$3 + 15 | 0];
     $8 = HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
    }
    if ((global$2 | 0) == 2 | $10) {
     if (global$2 ? ($6 | 0) == 16 : 1) {
      ProgramFail($0, 2664, 0);
      $7 = 16;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (!global$2) {
     $2 = $2 + -33 | 0;
     $10 = $2 >>> 0 <= 1;
    }
    label$53 : {
     if (!global$2) {
      if ($10) {
       if ($2 - 1) {
        $2 = HEAP32[$3 + 4 >> 2];
        $5 = HEAP32[$2 >> 2] + $5 | 0;
        HEAP32[$2 >> 2] = $5;
        break label$53;
       }
       $2 = HEAP32[$3 + 4 >> 2];
       $5 = HEAP32[$2 >> 2] - $5 | 0;
       HEAP32[$2 >> 2] = $5;
       break label$53;
      }
     }
     if (global$2 ? ($6 | 0) == 17 : 1) {
      ProgramFail($0, 2852, 0);
      $7 = 17;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    $2 = global$2 ? $2 : HEAP32[$3 >> 2];
    if (global$2 ? ($6 | 0) == 18 : 1) {
     $4 = ExpressionStackPushValueByType($0, $1, $2);
     $7 = 18;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $0 = $4;
    }
    if (!global$2) {
     HEAP32[HEAP32[$0 + 4 >> 2] >> 2] = $8;
     return;
    }
   }
   if (global$2 ? ($6 | 0) == 19 : 1) {
    ProgramFail($0, 2852, 0);
    $7 = 19;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  $4 = $7;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  HEAP32[$4 + 20 >> 2] = $8;
  wasm2js_scratch_store_f64(+$9);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  HEAP32[$4 + 24 >> 2] = wasm2js_scratch_load_i32(0);
  HEAP32[$4 + 28 >> 2] = $1;
  HEAP32[$4 + 32 >> 2] = $10;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 36;
 }
 
 function ExpressionInfixOperator($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0.0, $11 = 0.0, $12 = 0, $13 = 0, $14 = 0, $15 = 0.0, $16 = 0, $17 = 0, $18 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -64;
   $7 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$7 >> 2];
   $2 = HEAP32[$7 + 8 >> 2];
   $3 = HEAP32[$7 + 12 >> 2];
   $4 = HEAP32[$7 + 16 >> 2];
   $8 = HEAP32[$7 + 20 >> 2];
   $9 = HEAP32[$7 + 24 >> 2];
   $1 = HEAP32[$7 + 32 >> 2];
   $16 = HEAP32[$7 + 28 >> 2];
   wasm2js_scratch_store_i32(0, $16 | 0);
   wasm2js_scratch_store_i32(1, $1 | 0);
   $10 = +wasm2js_scratch_load_f64();
   $16 = HEAP32[$7 + 40 >> 2];
   $1 = HEAP32[$7 + 36 >> 2];
   wasm2js_scratch_store_i32(0, $1 | 0);
   wasm2js_scratch_store_i32(1, $16 | 0);
   $11 = +wasm2js_scratch_load_f64();
   $12 = HEAP32[$7 + 44 >> 2];
   $13 = HEAP32[$7 + 48 >> 2];
   $14 = HEAP32[$7 + 52 >> 2];
   $17 = HEAP32[$7 + 56 >> 2];
   $18 = HEAP32[$7 + 60 >> 2];
   $1 = HEAP32[$7 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if (!global$2) {
    $17 = global$0 - 16 | 0;
    global$0 = $17;
    $9 = !($4 ? $3 : 0);
   }
   if ((global$2 | 0) == 2 | $9) {
    if (global$2 ? !$5 : 1) {
     ProgramFail($0, 2884, 0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $9 = $2 + -13 | 0;
    $8 = $9 >>> 0 > 26;
   }
   label$9 : {
    label$10 : {
     if (!global$2) {
      if ($8) {
       break label$10
      }
      $9 = $9 - 1 | 0;
     }
     label$12 : {
      label$13 : {
       if (!global$2) {
        label$16 : {
         switch ($9 | 0) {
         case 1:
         case 2:
         case 3:
         case 4:
         case 5:
         case 6:
         case 7:
         case 8:
         case 9:
         case 10:
         case 11:
         case 12:
         case 13:
         case 14:
         case 15:
         case 16:
         case 17:
         case 18:
         case 19:
         case 20:
         case 21:
         case 22:
         case 23:
         case 24:
          break label$10;
         case 0:
          break label$12;
         case 25:
          break label$16;
         default:
          break label$13;
         };
        }
        $2 = HEAP32[HEAP32[$4 >> 2] >> 2] + -1 >>> 0 >= 9;
       }
       if ((global$2 | 0) == 2 | $2) {
        if (global$2 ? ($5 | 0) == 1 : 1) {
         ProgramFail($0, 2903, 0);
         $6 = 1;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
       }
       if (!global$2) {
        $9 = ExpressionCoerceInteger($4);
        $4 = HEAP32[$3 >> 2];
        $2 = HEAP32[$4 >> 2] + -12 | 0;
        $8 = $2 >>> 0 <= 1;
       }
       if ((global$2 | 0) == 2 | $8) {
        $2 = global$2 ? $2 : !($2 - 1);
        if ($2 | (global$2 | 0) == 2) {
         if (!global$2) {
          $2 = HEAP32[$4 + 20 >> 2];
          $8 = HEAP32[$3 + 4 >> 2];
          $4 = $8 + TypeSize($4, $9, 1) | 0;
          $9 = HEAP8[$3 + 15 | 0];
          $3 = HEAP32[$3 + 8 >> 2];
         }
         if (global$2 ? ($5 | 0) == 2 : 1) {
          $7 = VariableAllocValueFromExistingData($0, $2, $4, $9, $3);
          $6 = 2;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $2 = $7;
         }
         if (global$2 ? ($5 | 0) == 3 : 1) {
          ExpressionStackPushValueNode($0, $1, $2);
          $6 = 3;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          break label$9
         }
        }
        if (!global$2) {
         $2 = HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
         $4 = HEAP32[$4 + 20 >> 2];
         $8 = TypeSize($4, 0, 1);
         $2 = $2 + Math_imul($9, $8) | 0;
         $9 = HEAP8[$3 + 15 | 0];
         $3 = HEAP32[$3 + 8 >> 2];
        }
        if (global$2 ? ($5 | 0) == 4 : 1) {
         $7 = VariableAllocValueFromExistingData($0, $4, $2, $9, $3);
         $6 = 4;
         if ((global$2 | 0) == 1) {
          break label$2
         }
         $2 = $7;
        }
        if (global$2 ? ($5 | 0) == 5 : 1) {
         ExpressionStackPushValueNode($0, $1, $2);
         $6 = 5;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         break label$9
        }
       }
       if (!global$2) {
        HEAP32[$17 >> 2] = $4
       }
       if (global$2 ? ($5 | 0) == 6 : 1) {
        ProgramFail($0, 2934, $17);
        $6 = 6;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (global$2 ? ($5 | 0) == 7 : 1) {
        ExpressionStackPushValueNode($0, $1, 0);
        $6 = 7;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        break label$9
       }
      }
      if (global$2 ? ($5 | 0) == 8 : 1) {
       ExpressionQuestionMarkOperator($0, $1, $4, $3);
       $6 = 8;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       break label$9
      }
     }
     if (global$2 ? ($5 | 0) == 9 : 1) {
      ExpressionColonOperator($0, $1, $4, $3);
      $6 = 9;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      break label$9
     }
    }
    if (!global$2) {
     $8 = HEAP32[$4 >> 2];
     $18 = HEAP32[$0 >> 2];
     $9 = $18 + 1764 | 0;
     $12 = ($8 | 0) != ($9 | 0);
     $13 = !$12;
    }
    label$34 : {
     label$35 : {
      label$36 : {
       label$37 : {
        if (!global$2) {
         label$39 : {
          if ($13) {
           $13 = HEAP32[$3 >> 2];
           $14 = ($13 | 0) == ($9 | 0);
           if ($14) {
            break label$39
           }
           $13 = HEAP32[$13 >> 2] + -1 >>> 0 < 9;
           if ($13) {
            break label$39
           }
          }
          $13 = HEAP32[$8 >> 2];
          $8 = $13 + -1 | 0;
          $14 = $8 >>> 0 > 8;
          if ($14) {
           break label$36
          }
          $14 = HEAP32[$3 >> 2] != ($9 | 0);
          if ($14) {
           break label$37
          }
         }
         if ($12) {
          $10 = +(ExpressionCoerceInteger($4) | 0)
         } else {
          $10 = HEAPF64[HEAP32[$4 + 4 >> 2] >> 3]
         }
         $8 = HEAP32[$3 >> 2];
         $11 = HEAPF64[HEAP32[$3 + 4 >> 2] >> 3];
         label$43 : {
          if (($9 | 0) == ($8 | 0)) {
           break label$43
          }
          $11 = +(ExpressionCoerceInteger($3) | 0);
         }
         $4 = $2 + -2 | 0;
         $2 = $4 >>> 0 > 29;
        }
        label$45 : {
         label$46 : {
          if (!global$2) {
           if ($2) {
            break label$46
           }
           $2 = $4 - 1 | 0;
          }
          label$48 : {
           label$49 : {
            label$50 : {
             label$51 : {
              label$52 : {
               label$53 : {
                label$54 : {
                 label$55 : {
                  label$56 : {
                   label$57 : {
                    label$58 : {
                     label$59 : {
                      label$60 : {
                       label$61 : {
                        if (!global$2) {
                         label$64 : {
                          switch ($2 | 0) {
                          case 4:
                          case 5:
                          case 6:
                          case 7:
                          case 8:
                          case 9:
                          case 10:
                          case 11:
                          case 12:
                          case 13:
                          case 14:
                          case 15:
                          case 16:
                          case 23:
                          case 24:
                           break label$46;
                          case 28:
                           break label$48;
                          case 27:
                           break label$49;
                          case 26:
                           break label$50;
                          case 25:
                           break label$51;
                          case 22:
                           break label$52;
                          case 21:
                           break label$53;
                          case 20:
                           break label$54;
                          case 19:
                           break label$55;
                          case 18:
                           break label$56;
                          case 17:
                           break label$57;
                          case 3:
                           break label$58;
                          case 2:
                           break label$59;
                          case 1:
                           break label$60;
                          case 0:
                           break label$61;
                          default:
                           break label$64;
                          };
                         }
                         $2 = HEAP32[$8 >> 2] == 9;
                        }
                        if ((global$2 | 0) == 2 | $2) {
                         $4 = global$2 ? $4 : 0;
                         if (global$2 ? ($5 | 0) == 10 : 1) {
                          $15 = ExpressionAssignFP($0, $3, $10);
                          $6 = 10;
                          if ((global$2 | 0) == 1) {
                           break label$2
                          }
                          $10 = $15;
                         }
                         if (!global$2) {
                          break label$45
                         }
                        }
                        if (!global$2) {
                         $11 = Math_abs($10);
                         $2 = ~~$10;
                         label$68 : {
                          if ($11 < 2147483648.0) {
                           break label$68
                          }
                          $2 = -2147483648;
                         }
                         $10 = 0.0;
                         $4 = 1;
                        }
                        if (global$2 ? ($5 | 0) == 11 : 1) {
                         $7 = ExpressionAssignInt($0, $3, $2, 0);
                         $6 = 11;
                         if ((global$2 | 0) == 1) {
                          break label$2
                         }
                         $3 = $7;
                        }
                        if (!global$2) {
                         break label$34
                        }
                       }
                       if (!global$2) {
                        $10 = $10 + $11;
                        $2 = HEAP32[$8 >> 2] == 9;
                       }
                       if ((global$2 | 0) == 2 | $2) {
                        $4 = global$2 ? $4 : 0;
                        if (global$2 ? ($5 | 0) == 12 : 1) {
                         $15 = ExpressionAssignFP($0, $3, $10);
                         $6 = 12;
                         if ((global$2 | 0) == 1) {
                          break label$2
                         }
                         $10 = $15;
                        }
                        if (!global$2) {
                         break label$45
                        }
                       }
                       if (!global$2) {
                        $11 = Math_abs($10);
                        $2 = ~~$10;
                        label$76 : {
                         if ($11 < 2147483648.0) {
                          break label$76
                         }
                         $2 = -2147483648;
                        }
                        $10 = 0.0;
                        $4 = 1;
                       }
                       if (global$2 ? ($5 | 0) == 13 : 1) {
                        $7 = ExpressionAssignInt($0, $3, $2, 0);
                        $6 = 13;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                        $3 = $7;
                       }
                       if (!global$2) {
                        break label$34
                       }
                      }
                      if (!global$2) {
                       $10 = $11 - $10;
                       $2 = HEAP32[$8 >> 2] == 9;
                      }
                      if ((global$2 | 0) == 2 | $2) {
                       $4 = global$2 ? $4 : 0;
                       if (global$2 ? ($5 | 0) == 14 : 1) {
                        $15 = ExpressionAssignFP($0, $3, $10);
                        $6 = 14;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                        $10 = $15;
                       }
                       if (!global$2) {
                        break label$45
                       }
                      }
                      if (!global$2) {
                       $11 = Math_abs($10);
                       $2 = ~~$10;
                       label$84 : {
                        if ($11 < 2147483648.0) {
                         break label$84
                        }
                        $2 = -2147483648;
                       }
                       $10 = 0.0;
                       $4 = 1;
                      }
                      if (global$2 ? ($5 | 0) == 15 : 1) {
                       $7 = ExpressionAssignInt($0, $3, $2, 0);
                       $6 = 15;
                       if ((global$2 | 0) == 1) {
                        break label$2
                       }
                       $3 = $7;
                      }
                      if (!global$2) {
                       break label$34
                      }
                     }
                     if (!global$2) {
                      $10 = $10 * $11;
                      $2 = HEAP32[$8 >> 2] == 9;
                     }
                     if ((global$2 | 0) == 2 | $2) {
                      $4 = global$2 ? $4 : 0;
                      if (global$2 ? ($5 | 0) == 16 : 1) {
                       $15 = ExpressionAssignFP($0, $3, $10);
                       $6 = 16;
                       if ((global$2 | 0) == 1) {
                        break label$2
                       }
                       $10 = $15;
                      }
                      if (!global$2) {
                       break label$45
                      }
                     }
                     if (!global$2) {
                      $11 = Math_abs($10);
                      $2 = ~~$10;
                      label$92 : {
                       if ($11 < 2147483648.0) {
                        break label$92
                       }
                       $2 = -2147483648;
                      }
                      $10 = 0.0;
                      $4 = 1;
                     }
                     if (global$2 ? ($5 | 0) == 17 : 1) {
                      $7 = ExpressionAssignInt($0, $3, $2, 0);
                      $6 = 17;
                      if ((global$2 | 0) == 1) {
                       break label$2
                      }
                      $3 = $7;
                     }
                     if (!global$2) {
                      break label$34
                     }
                    }
                    if (!global$2) {
                     $10 = $11 / $10;
                     $2 = HEAP32[$8 >> 2] == 9;
                    }
                    if ((global$2 | 0) == 2 | $2) {
                     $4 = global$2 ? $4 : 0;
                     if (global$2 ? ($5 | 0) == 18 : 1) {
                      $15 = ExpressionAssignFP($0, $3, $10);
                      $6 = 18;
                      if ((global$2 | 0) == 1) {
                       break label$2
                      }
                      $10 = $15;
                     }
                     if (!global$2) {
                      break label$45
                     }
                    }
                    if (!global$2) {
                     $11 = Math_abs($10);
                     $2 = ~~$10;
                     label$100 : {
                      if ($11 < 2147483648.0) {
                       break label$100
                      }
                      $2 = -2147483648;
                     }
                     $10 = 0.0;
                     $4 = 1;
                    }
                    if (global$2 ? ($5 | 0) == 19 : 1) {
                     $7 = ExpressionAssignInt($0, $3, $2, 0);
                     $6 = 19;
                     if ((global$2 | 0) == 1) {
                      break label$2
                     }
                     $3 = $7;
                    }
                    if (!global$2) {
                     break label$34
                    }
                   }
                   if (!global$2) {
                    $3 = $11 == $10;
                    break label$35;
                   }
                  }
                  if (!global$2) {
                   $3 = $11 != $10;
                   break label$35;
                  }
                 }
                 if (!global$2) {
                  $3 = $11 < $10;
                  break label$35;
                 }
                }
                if (!global$2) {
                 $3 = $11 > $10;
                 break label$35;
                }
               }
               if (!global$2) {
                $3 = $11 <= $10;
                break label$35;
               }
              }
              if (!global$2) {
               $3 = $11 >= $10;
               break label$35;
              }
             }
             if (!global$2) {
              $4 = 0;
              $10 = $10 + $11;
              break label$45;
             }
            }
            if (!global$2) {
             $4 = 0;
             $10 = $11 - $10;
             break label$45;
            }
           }
           if (!global$2) {
            $4 = 0;
            $10 = $10 * $11;
            break label$45;
           }
          }
          if (!global$2) {
           $4 = 0;
           $10 = $11 / $10;
           break label$45;
          }
         }
         $4 = global$2 ? $4 : 0;
         if (global$2 ? ($5 | 0) == 20 : 1) {
          ProgramFail($0, 2852, 0);
          $6 = 20;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         $10 = global$2 ? $10 : 0.0;
        }
        if (!global$2) {
         $3 = 0;
         break label$34;
        }
       }
       if (!global$2) {
        $9 = $8 >>> 0 > 8;
        if ($9) {
         break label$36
        }
        $9 = HEAP32[HEAP32[$3 >> 2] >> 2] + -1 >>> 0 > 8;
        if ($9) {
         break label$36
        }
        $9 = ExpressionCoerceInteger($4);
        $8 = ExpressionCoerceInteger($3);
        $4 = $2 + -2 | 0;
        $2 = $4 >>> 0 > 30;
       }
       label$116 : {
        if (!global$2) {
         if ($2) {
          break label$116
         }
         $2 = $4 - 1 | 0;
        }
        label$118 : {
         label$119 : {
          label$120 : {
           label$121 : {
            label$122 : {
             label$123 : {
              label$124 : {
               label$125 : {
                label$126 : {
                 label$127 : {
                  label$128 : {
                   label$129 : {
                    label$130 : {
                     label$131 : {
                      label$132 : {
                       label$133 : {
                        label$134 : {
                         label$135 : {
                          label$136 : {
                           label$137 : {
                            label$138 : {
                             label$139 : {
                              label$140 : {
                               label$141 : {
                                label$142 : {
                                 label$143 : {
                                  label$144 : {
                                   label$145 : {
                                    if (!global$2) {
                                     label$147 : {
                                      switch ($2 | 0) {
                                      case 10:
                                      case 11:
                                       break label$116;
                                      case 29:
                                       break label$118;
                                      case 28:
                                       break label$119;
                                      case 27:
                                       break label$120;
                                      case 26:
                                       break label$121;
                                      case 25:
                                       break label$122;
                                      case 24:
                                       break label$123;
                                      case 23:
                                       break label$124;
                                      case 22:
                                       break label$125;
                                      case 21:
                                       break label$126;
                                      case 20:
                                       break label$127;
                                      case 19:
                                       break label$128;
                                      case 18:
                                       break label$129;
                                      case 17:
                                       break label$130;
                                      case 16:
                                       break label$131;
                                      case 15:
                                       break label$132;
                                      case 14:
                                       break label$133;
                                      case 13:
                                       break label$134;
                                      case 12:
                                       break label$135;
                                      case 9:
                                       break label$136;
                                      case 8:
                                       break label$137;
                                      case 7:
                                       break label$138;
                                      case 6:
                                       break label$139;
                                      case 5:
                                       break label$140;
                                      case 4:
                                       break label$141;
                                      case 3:
                                       break label$142;
                                      case 2:
                                       break label$143;
                                      case 1:
                                       break label$144;
                                      case 0:
                                       break label$145;
                                      default:
                                       break label$147;
                                      };
                                     }
                                    }
                                    if (global$2 ? ($5 | 0) == 21 : 1) {
                                     $7 = ExpressionAssignInt($0, $3, $9, 0);
                                     $6 = 21;
                                     if ((global$2 | 0) == 1) {
                                      break label$2
                                     }
                                     $2 = $7;
                                    }
                                    if (global$2 ? ($5 | 0) == 22 : 1) {
                                     ExpressionPushInt($0, $1, $2);
                                     $6 = 22;
                                     if ((global$2 | 0) == 1) {
                                      break label$2
                                     }
                                    }
                                    if (!global$2) {
                                     break label$9
                                    }
                                   }
                                   $2 = global$2 ? $2 : $8 + $9 | 0;
                                   if (global$2 ? ($5 | 0) == 23 : 1) {
                                    $7 = ExpressionAssignInt($0, $3, $2, 0);
                                    $6 = 23;
                                    if ((global$2 | 0) == 1) {
                                     break label$2
                                    }
                                    $2 = $7;
                                   }
                                   if (global$2 ? ($5 | 0) == 24 : 1) {
                                    ExpressionPushInt($0, $1, $2);
                                    $6 = 24;
                                    if ((global$2 | 0) == 1) {
                                     break label$2
                                    }
                                   }
                                   if (!global$2) {
                                    break label$9
                                   }
                                  }
                                  $2 = global$2 ? $2 : $8 - $9 | 0;
                                  if (global$2 ? ($5 | 0) == 25 : 1) {
                                   $7 = ExpressionAssignInt($0, $3, $2, 0);
                                   $6 = 25;
                                   if ((global$2 | 0) == 1) {
                                    break label$2
                                   }
                                   $2 = $7;
                                  }
                                  if (global$2 ? ($5 | 0) == 26 : 1) {
                                   ExpressionPushInt($0, $1, $2);
                                   $6 = 26;
                                   if ((global$2 | 0) == 1) {
                                    break label$2
                                   }
                                  }
                                  if (!global$2) {
                                   break label$9
                                  }
                                 }
                                 $2 = global$2 ? $2 : Math_imul($8, $9);
                                 if (global$2 ? ($5 | 0) == 27 : 1) {
                                  $7 = ExpressionAssignInt($0, $3, $2, 0);
                                  $6 = 27;
                                  if ((global$2 | 0) == 1) {
                                   break label$2
                                  }
                                  $2 = $7;
                                 }
                                 if (global$2 ? ($5 | 0) == 28 : 1) {
                                  ExpressionPushInt($0, $1, $2);
                                  $6 = 28;
                                  if ((global$2 | 0) == 1) {
                                   break label$2
                                  }
                                 }
                                 if (!global$2) {
                                  break label$9
                                 }
                                }
                                $2 = global$2 ? $2 : ($8 | 0) / ($9 | 0) | 0;
                                if (global$2 ? ($5 | 0) == 29 : 1) {
                                 $7 = ExpressionAssignInt($0, $3, $2, 0);
                                 $6 = 29;
                                 if ((global$2 | 0) == 1) {
                                  break label$2
                                 }
                                 $2 = $7;
                                }
                                if (global$2 ? ($5 | 0) == 30 : 1) {
                                 ExpressionPushInt($0, $1, $2);
                                 $6 = 30;
                                 if ((global$2 | 0) == 1) {
                                  break label$2
                                 }
                                }
                                if (!global$2) {
                                 break label$9
                                }
                               }
                               $2 = global$2 ? $2 : ($8 | 0) % ($9 | 0) | 0;
                               if (global$2 ? ($5 | 0) == 31 : 1) {
                                $7 = ExpressionAssignInt($0, $3, $2, 0);
                                $6 = 31;
                                if ((global$2 | 0) == 1) {
                                 break label$2
                                }
                                $2 = $7;
                               }
                               if (global$2 ? ($5 | 0) == 32 : 1) {
                                ExpressionPushInt($0, $1, $2);
                                $6 = 32;
                                if ((global$2 | 0) == 1) {
                                 break label$2
                                }
                               }
                               if (!global$2) {
                                break label$9
                               }
                              }
                              $2 = global$2 ? $2 : $8 << $9;
                              if (global$2 ? ($5 | 0) == 33 : 1) {
                               $7 = ExpressionAssignInt($0, $3, $2, 0);
                               $6 = 33;
                               if ((global$2 | 0) == 1) {
                                break label$2
                               }
                               $2 = $7;
                              }
                              if (global$2 ? ($5 | 0) == 34 : 1) {
                               ExpressionPushInt($0, $1, $2);
                               $6 = 34;
                               if ((global$2 | 0) == 1) {
                                break label$2
                               }
                              }
                              if (!global$2) {
                               break label$9
                              }
                             }
                             $2 = global$2 ? $2 : $8 >> $9;
                             if (global$2 ? ($5 | 0) == 35 : 1) {
                              $7 = ExpressionAssignInt($0, $3, $2, 0);
                              $6 = 35;
                              if ((global$2 | 0) == 1) {
                               break label$2
                              }
                              $2 = $7;
                             }
                             if (global$2 ? ($5 | 0) == 36 : 1) {
                              ExpressionPushInt($0, $1, $2);
                              $6 = 36;
                              if ((global$2 | 0) == 1) {
                               break label$2
                              }
                             }
                             if (!global$2) {
                              break label$9
                             }
                            }
                            $2 = global$2 ? $2 : $8 & $9;
                            if (global$2 ? ($5 | 0) == 37 : 1) {
                             $7 = ExpressionAssignInt($0, $3, $2, 0);
                             $6 = 37;
                             if ((global$2 | 0) == 1) {
                              break label$2
                             }
                             $2 = $7;
                            }
                            if (global$2 ? ($5 | 0) == 38 : 1) {
                             ExpressionPushInt($0, $1, $2);
                             $6 = 38;
                             if ((global$2 | 0) == 1) {
                              break label$2
                             }
                            }
                            if (!global$2) {
                             break label$9
                            }
                           }
                           $2 = global$2 ? $2 : $8 | $9;
                           if (global$2 ? ($5 | 0) == 39 : 1) {
                            $7 = ExpressionAssignInt($0, $3, $2, 0);
                            $6 = 39;
                            if ((global$2 | 0) == 1) {
                             break label$2
                            }
                            $2 = $7;
                           }
                           if (global$2 ? ($5 | 0) == 40 : 1) {
                            ExpressionPushInt($0, $1, $2);
                            $6 = 40;
                            if ((global$2 | 0) == 1) {
                             break label$2
                            }
                           }
                           if (!global$2) {
                            break label$9
                           }
                          }
                          $2 = global$2 ? $2 : $8 ^ $9;
                          if (global$2 ? ($5 | 0) == 41 : 1) {
                           $7 = ExpressionAssignInt($0, $3, $2, 0);
                           $6 = 41;
                           if ((global$2 | 0) == 1) {
                            break label$2
                           }
                           $2 = $7;
                          }
                          if (global$2 ? ($5 | 0) == 42 : 1) {
                           ExpressionPushInt($0, $1, $2);
                           $6 = 42;
                           if ((global$2 | 0) == 1) {
                            break label$2
                           }
                          }
                          if (!global$2) {
                           break label$9
                          }
                         }
                         $2 = global$2 ? $2 : ($8 | $9) != 0;
                         if (global$2 ? ($5 | 0) == 43 : 1) {
                          ExpressionPushInt($0, $1, $2);
                          $6 = 43;
                          if ((global$2 | 0) == 1) {
                           break label$2
                          }
                         }
                         if (!global$2) {
                          break label$9
                         }
                        }
                        if (!global$2) {
                         $3 = ($8 | 0) != 0;
                         $2 = $3 & ($9 | 0) != 0;
                        }
                        if (global$2 ? ($5 | 0) == 44 : 1) {
                         ExpressionPushInt($0, $1, $2);
                         $6 = 44;
                         if ((global$2 | 0) == 1) {
                          break label$2
                         }
                        }
                        if (!global$2) {
                         break label$9
                        }
                       }
                       $2 = global$2 ? $2 : $8 | $9;
                       if (global$2 ? ($5 | 0) == 45 : 1) {
                        ExpressionPushInt($0, $1, $2);
                        $6 = 45;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                       }
                       if (!global$2) {
                        break label$9
                       }
                      }
                      $2 = global$2 ? $2 : $8 ^ $9;
                      if (global$2 ? ($5 | 0) == 46 : 1) {
                       ExpressionPushInt($0, $1, $2);
                       $6 = 46;
                       if ((global$2 | 0) == 1) {
                        break label$2
                       }
                      }
                      if (!global$2) {
                       break label$9
                      }
                     }
                     $2 = global$2 ? $2 : $8 & $9;
                     if (global$2 ? ($5 | 0) == 47 : 1) {
                      ExpressionPushInt($0, $1, $2);
                      $6 = 47;
                      if ((global$2 | 0) == 1) {
                       break label$2
                      }
                     }
                     if (!global$2) {
                      break label$9
                     }
                    }
                    $2 = global$2 ? $2 : ($8 | 0) == ($9 | 0);
                    if (global$2 ? ($5 | 0) == 48 : 1) {
                     ExpressionPushInt($0, $1, $2);
                     $6 = 48;
                     if ((global$2 | 0) == 1) {
                      break label$2
                     }
                    }
                    if (!global$2) {
                     break label$9
                    }
                   }
                   $2 = global$2 ? $2 : ($8 | 0) != ($9 | 0);
                   if (global$2 ? ($5 | 0) == 49 : 1) {
                    ExpressionPushInt($0, $1, $2);
                    $6 = 49;
                    if ((global$2 | 0) == 1) {
                     break label$2
                    }
                   }
                   if (!global$2) {
                    break label$9
                   }
                  }
                  $2 = global$2 ? $2 : ($8 | 0) < ($9 | 0);
                  if (global$2 ? ($5 | 0) == 50 : 1) {
                   ExpressionPushInt($0, $1, $2);
                   $6 = 50;
                   if ((global$2 | 0) == 1) {
                    break label$2
                   }
                  }
                  if (!global$2) {
                   break label$9
                  }
                 }
                 $2 = global$2 ? $2 : ($8 | 0) > ($9 | 0);
                 if (global$2 ? ($5 | 0) == 51 : 1) {
                  ExpressionPushInt($0, $1, $2);
                  $6 = 51;
                  if ((global$2 | 0) == 1) {
                   break label$2
                  }
                 }
                 if (!global$2) {
                  break label$9
                 }
                }
                $2 = global$2 ? $2 : ($8 | 0) <= ($9 | 0);
                if (global$2 ? ($5 | 0) == 52 : 1) {
                 ExpressionPushInt($0, $1, $2);
                 $6 = 52;
                 if ((global$2 | 0) == 1) {
                  break label$2
                 }
                }
                if (!global$2) {
                 break label$9
                }
               }
               $2 = global$2 ? $2 : ($8 | 0) >= ($9 | 0);
               if (global$2 ? ($5 | 0) == 53 : 1) {
                ExpressionPushInt($0, $1, $2);
                $6 = 53;
                if ((global$2 | 0) == 1) {
                 break label$2
                }
               }
               if (!global$2) {
                break label$9
               }
              }
              $2 = global$2 ? $2 : $8 << $9;
              if (global$2 ? ($5 | 0) == 54 : 1) {
               ExpressionPushInt($0, $1, $2);
               $6 = 54;
               if ((global$2 | 0) == 1) {
                break label$2
               }
              }
              if (!global$2) {
               break label$9
              }
             }
             $2 = global$2 ? $2 : $8 >> $9;
             if (global$2 ? ($5 | 0) == 55 : 1) {
              ExpressionPushInt($0, $1, $2);
              $6 = 55;
              if ((global$2 | 0) == 1) {
               break label$2
              }
             }
             if (!global$2) {
              break label$9
             }
            }
            $2 = global$2 ? $2 : $8 + $9 | 0;
            if (global$2 ? ($5 | 0) == 56 : 1) {
             ExpressionPushInt($0, $1, $2);
             $6 = 56;
             if ((global$2 | 0) == 1) {
              break label$2
             }
            }
            if (!global$2) {
             break label$9
            }
           }
           $2 = global$2 ? $2 : $8 - $9 | 0;
           if (global$2 ? ($5 | 0) == 57 : 1) {
            ExpressionPushInt($0, $1, $2);
            $6 = 57;
            if ((global$2 | 0) == 1) {
             break label$2
            }
           }
           if (!global$2) {
            break label$9
           }
          }
          $2 = global$2 ? $2 : Math_imul($8, $9);
          if (global$2 ? ($5 | 0) == 58 : 1) {
           ExpressionPushInt($0, $1, $2);
           $6 = 58;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (!global$2) {
           break label$9
          }
         }
         $2 = global$2 ? $2 : ($8 | 0) / ($9 | 0) | 0;
         if (global$2 ? ($5 | 0) == 59 : 1) {
          ExpressionPushInt($0, $1, $2);
          $6 = 59;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          break label$9
         }
        }
        $2 = global$2 ? $2 : ($8 | 0) % ($9 | 0) | 0;
        if (global$2 ? ($5 | 0) == 60 : 1) {
         ExpressionPushInt($0, $1, $2);
         $6 = 60;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         break label$9
        }
       }
       if (global$2 ? ($5 | 0) == 61 : 1) {
        ProgramFail($0, 2852, 0);
        $6 = 61;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (global$2 ? ($5 | 0) == 62 : 1) {
        ExpressionPushInt($0, $1, 0);
        $6 = 62;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        break label$9
       }
      }
      if (!global$2) {
       $9 = HEAP32[$3 >> 2];
       $12 = HEAP32[$9 >> 2];
       $14 = ($12 | 0) != 12;
      }
      label$196 : {
       if (!global$2) {
        if ($14) {
         break label$196
        }
        $8 = $8 >>> 0 <= 8;
       }
       if ((global$2 | 0) == 2 | $8) {
        if (!global$2) {
         $12 = ($2 | 1) + -21 | 0;
         $13 = $12 >>> 0 > 8;
         $8 = ExpressionCoerceInteger($4);
        }
        label$201 : {
         if (!global$2) {
          if ($13) {
           break label$201
          }
          $12 = $12 - 1 | 0;
         }
         label$203 : {
          if (!global$2) {
           label$205 : {
            switch ($12 | 0) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
             break label$201;
            case 7:
             break label$203;
            default:
             break label$205;
            };
           }
          }
          if ((global$2 | 0) == 2 | $8) {
           if (global$2 ? ($5 | 0) == 63 : 1) {
            ProgramFail($0, 2852, 0);
            $6 = 63;
            if ((global$2 | 0) == 1) {
             break label$2
            }
           }
          }
          if (!global$2) {
           $3 = HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
           $2 = ($2 | 0) == 20;
          }
          if ((global$2 | 0) == 2 | $2) {
           $2 = global$2 ? $2 : !$3;
           if (global$2 ? ($5 | 0) == 64 : 1) {
            ExpressionPushInt($0, $1, $2);
            $6 = 64;
            if ((global$2 | 0) == 1) {
             break label$2
            }
           }
           if (!global$2) {
            break label$9
           }
          }
          $2 = global$2 ? $2 : ($3 | 0) != 0;
          if (global$2 ? ($5 | 0) == 65 : 1) {
           ExpressionPushInt($0, $1, $2);
           $6 = 65;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (!global$2) {
           break label$9
          }
         }
         if (!global$2) {
          $4 = TypeSize(HEAP32[$9 + 20 >> 2], 0, 1);
          $9 = HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
          $3 = HEAP32[$3 >> 2];
         }
         if (global$2 ? ($5 | 0) == 66 : 1) {
          $7 = ExpressionStackPushValueByType($0, $1, $3);
          $6 = 66;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $0 = $7;
         }
         if (!global$2) {
          $3 = Math_imul($4, $8);
          $1 = 0 - $3 | 0;
          HEAP32[HEAP32[$0 + 4 >> 2] >> 2] = (($2 | 0) == 28 ? $3 : $1) + $9;
          break label$9;
         }
        }
        $12 = global$2 ? $12 : ($2 | 0) != 2;
        label$216 : {
         if (!global$2) {
          if ($8 | $12) {
           break label$216
          }
          HeapUnpopStack($18, 24);
         }
         if (global$2 ? ($5 | 0) == 67 : 1) {
          ExpressionAssign($0, $3, $4, 0, 0, 0, 0);
          $6 = 67;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (global$2 ? ($5 | 0) == 68 : 1) {
          ExpressionStackPushValueNode($0, $1, $3);
          $6 = 68;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          break label$9
         }
        }
        $4 = global$2 ? $4 : $2 + -3 >>> 0 <= 1;
        if ($4 | (global$2 | 0) == 2) {
         if (!global$2) {
          $4 = TypeSize(HEAP32[$9 + 20 >> 2], 0, 1);
          $9 = HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
          HeapUnpopStack(HEAP32[$0 >> 2], 24);
          $4 = Math_imul($4, $8);
          $8 = 0 - $4 | 0;
          $12 = HEAP32[$3 + 4 >> 2];
          $2 = (($2 | 0) == 3 ? $4 : $8) + $9 | 0;
          HEAP32[$12 >> 2] = $2;
         }
         if (global$2 ? ($5 | 0) == 69 : 1) {
          ExpressionStackPushValueNode($0, $1, $3);
          $6 = 69;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          break label$9
         }
        }
        if (global$2 ? ($5 | 0) == 70 : 1) {
         ProgramFail($0, 2852, 0);
         $6 = 70;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         break label$9
        }
       }
       if (!global$2) {
        $8 = ($2 | 0) == 2;
        if ($8) {
         break label$196
        }
        $8 = ($13 | 0) != 12;
        if ($8) {
         break label$196
        }
        $2 = $2 + -20 | 0;
        $9 = $2 >>> 0 > 9;
       }
       label$225 : {
        if (!global$2) {
         if ($9) {
          break label$225
         }
         $3 = HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
         $4 = HEAP32[HEAP32[$4 + 4 >> 2] >> 2];
         $2 = $2 - 1 | 0;
        }
        label$227 : {
         label$228 : {
          if (!global$2) {
           label$230 : {
            switch ($2 | 0) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
             break label$225;
            case 8:
             break label$227;
            case 0:
             break label$228;
            default:
             break label$230;
            };
           }
           $2 = ($3 | 0) == ($4 | 0);
          }
          if (global$2 ? ($5 | 0) == 71 : 1) {
           ExpressionPushInt($0, $1, $2);
           $6 = 71;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (!global$2) {
           break label$9
          }
         }
         $2 = global$2 ? $2 : ($3 | 0) != ($4 | 0);
         if (global$2 ? ($5 | 0) == 72 : 1) {
          ExpressionPushInt($0, $1, $2);
          $6 = 72;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          break label$9
         }
        }
        $2 = global$2 ? $2 : $3 - $4 | 0;
        if (global$2 ? ($5 | 0) == 73 : 1) {
         ExpressionPushInt($0, $1, $2);
         $6 = 73;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         break label$9
        }
       }
       if (global$2 ? ($5 | 0) == 74 : 1) {
        ProgramFail($0, 2852, 0);
        $6 = 74;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        break label$9
       }
      }
      $8 = global$2 ? $8 : ($2 | 0) != 38;
      label$235 : {
       if ($8 | (global$2 | 0) == 2) {
        if (!global$2) {
         $8 = ($2 | 0) != 2;
         if ($8) {
          break label$235
         }
         HeapUnpopStack($18, 24);
        }
        if (global$2 ? ($5 | 0) == 75 : 1) {
         ExpressionAssign($0, $3, $4, 0, 0, 0, 0);
         $6 = 75;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (global$2 ? ($5 | 0) == 76 : 1) {
         ExpressionStackPushValueNode($0, $1, $3);
         $6 = 76;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         break label$9
        }
       }
       $2 = global$2 ? $2 : HEAP32[HEAP32[$3 + 4 >> 2] >> 2];
       if (global$2 ? ($5 | 0) == 77 : 1) {
        $7 = ExpressionStackPushValueByType($0, $1, $2);
        $6 = 77;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $1 = $7;
       }
       if (global$2 ? ($5 | 0) == 78 : 1) {
        ExpressionAssign($0, $1, $4, 1, 0, 0, 1);
        $6 = 78;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        break label$9
       }
      }
      $8 = global$2 ? $8 : ($2 | 1) != 29;
      label$243 : {
       if (!global$2) {
        if (($12 | 0) != 13 | $8) {
         break label$243
        }
        $8 = ExpressionCoerceInteger($4);
        $9 = TypeSize(HEAP32[$9 + 20 >> 2], 0, 1);
        $12 = HEAP32[$3 + 4 >> 2];
        $4 = HEAP32[$0 >> 2];
        $13 = HEAP32[$4 + 2756 >> 2];
        $3 = HEAP32[$3 >> 2];
       }
       if (global$2 ? ($5 | 0) == 79 : 1) {
        $7 = TypeGetMatching($4, $0, $3, 12, 0, $13, 1);
        $6 = 79;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $3 = $7;
       }
       if (global$2 ? ($5 | 0) == 80 : 1) {
        $7 = VariableAllocValueFromType($4, $0, $3, 0, 0, 0);
        $6 = 80;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $3 = $7;
       }
       if (!global$2) {
        $4 = Math_imul($8, $9);
        $9 = 0 - $4 | 0;
        HEAP32[HEAP32[$3 + 4 >> 2] >> 2] = (($2 | 0) == 28 ? $4 : $9) + $12;
       }
       if (global$2 ? ($5 | 0) == 81 : 1) {
        ExpressionStackPushValueNode($0, $1, $3);
        $6 = 81;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        break label$9
       }
      }
      if (global$2 ? ($5 | 0) == 82 : 1) {
       ProgramFail($0, 2852, 0);
       $6 = 82;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       break label$9
      }
     }
     if (!global$2) {
      $10 = 0.0;
      $4 = 1;
     }
    }
    if ((global$2 | 0) == 2 | $4) {
     if (global$2 ? ($5 | 0) == 83 : 1) {
      ExpressionPushInt($0, $1, $3);
      $6 = 83;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      break label$9
     }
    }
    if (global$2 ? ($5 | 0) == 84 : 1) {
     ExpressionPushFP($0, $1, $10);
     $6 = 84;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    global$0 = $17 + 16 | 0
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $7 = HEAP32[global$3 >> 2];
  HEAP32[$7 >> 2] = $0;
  HEAP32[$7 + 4 >> 2] = $1;
  HEAP32[$7 + 8 >> 2] = $2;
  HEAP32[$7 + 12 >> 2] = $3;
  HEAP32[$7 + 16 >> 2] = $4;
  HEAP32[$7 + 20 >> 2] = $8;
  HEAP32[$7 + 24 >> 2] = $9;
  wasm2js_scratch_store_f64(+$10);
  $16 = wasm2js_scratch_load_i32(1) | 0;
  $0 = wasm2js_scratch_load_i32(0) | 0;
  HEAP32[$7 + 28 >> 2] = $0;
  HEAP32[$7 + 32 >> 2] = $16;
  wasm2js_scratch_store_f64(+$11);
  $16 = wasm2js_scratch_load_i32(1) | 0;
  HEAP32[$7 + 36 >> 2] = wasm2js_scratch_load_i32(0);
  HEAP32[$7 + 40 >> 2] = $16;
  HEAP32[$7 + 44 >> 2] = $12;
  HEAP32[$7 + 48 >> 2] = $13;
  HEAP32[$7 + 52 >> 2] = $14;
  HEAP32[$7 + 56 >> 2] = $17;
  HEAP32[$7 + 60 >> 2] = $18;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] - -64;
 }
 
 function ExpressionStackCollapse($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -40;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $6 = HEAP32[$5 + 20 >> 2];
   $8 = HEAP32[$5 + 24 >> 2];
   $9 = HEAP32[$5 + 28 >> 2];
   $11 = HEAP32[$5 + 32 >> 2];
   $5 = HEAP32[$5 + 36 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $7 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   label$4 : {
    if (!global$2) {
     $4 = HEAP32[$1 >> 2];
     if (!$4) {
      break label$4
     }
     $11 = $2;
    }
    while (1) {
     if (!global$2) {
      if (($11 | 0) < ($2 | 0)) {
       break label$4
      }
      $6 = HEAP32[$4 >> 2];
      if (!$6) {
       break label$4
      }
      $8 = HEAPU8[$4 + 14 | 0] ? $4 : $6;
      $11 = HEAPU16[$8 + 12 >> 1];
      $9 = ($11 | 0) < ($2 | 0);
     }
     label$8 : {
      if (!global$2) {
       if ($9) {
        break label$8
       }
       $9 = HEAPU8[$8 + 14 | 0];
       $5 = $9 >>> 0 > 3;
      }
      label$10 : {
       if (!global$2) {
        if ($5) {
         break label$10
        }
        $9 = $9 - 1 | 0;
       }
       label$12 : {
        label$13 : {
         label$14 : {
          label$15 : {
           if (!global$2) {
            label$17 : {
             switch ($9 | 0) {
             case 1:
              break label$14;
             case 2:
              break label$15;
             case 0:
              break label$17;
             default:
              break label$13;
             };
            }
            $10 = HEAP32[$0 >> 2];
            $4 = HEAP32[$4 + 4 >> 2];
            $9 = TypeStackSizeValue($4) + 40 | 0;
            HeapPopStack($10, 0, $9);
            HeapPopStack(HEAP32[$0 >> 2], $8, 16);
            HEAP32[$1 >> 2] = HEAP32[$8 >> 2];
            $6 = HEAP32[$0 + 16 >> 2];
            if ($6) {
             break label$12
            }
            $6 = HEAP32[$8 + 8 >> 2];
           }
           if (global$2 ? !$7 : 1) {
            ExpressionPrefixOperator($0, $1, $6, $4);
            $10 = 0;
            if ((global$2 | 0) == 1) {
             break label$2
            }
           }
           if (!global$2) {
            break label$10
           }
          }
          if (!global$2) {
           $6 = HEAP32[$6 + 4 >> 2];
           HeapPopStack(HEAP32[$0 >> 2], 0, 16);
           $10 = HEAP32[$0 >> 2];
           $5 = TypeStackSizeValue($6) + 40 | 0;
           $9 = HeapPopStack($10, $6, $5);
           HEAP32[$1 >> 2] = HEAP32[HEAP32[$4 >> 2] >> 2];
           if (HEAP32[$0 + 16 >> 2]) {
            break label$12
           }
           $4 = HEAP32[$8 + 8 >> 2];
          }
          if (global$2 ? ($7 | 0) == 1 : 1) {
           ExpressionPostfixOperator($0, $1, $4, $6);
           $10 = 1;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (!global$2) {
           break label$10
          }
         }
         if (!global$2) {
          $6 = HEAP32[$4 + 4 >> 2];
          if (!$6) {
           $11 = -1;
           break label$10;
          }
          $4 = HEAP32[HEAP32[$8 >> 2] + 4 >> 2];
          HeapPopStack(HEAP32[$0 >> 2], 0, TypeStackSizeValue($6) + 40 | 0);
          HeapPopStack(HEAP32[$0 >> 2], 0, 16);
          $10 = HEAP32[$0 >> 2];
          $5 = TypeStackSizeValue($4) + 40 | 0;
          HeapPopStack($10, $4, $5);
          HEAP32[$1 >> 2] = HEAP32[HEAP32[$8 >> 2] >> 2];
          $9 = HEAP32[$0 + 16 >> 2];
          if ($9) {
           break label$12
          }
          $8 = HEAP32[$8 + 8 >> 2];
         }
         if (global$2 ? ($7 | 0) == 2 : 1) {
          ExpressionInfixOperator($0, $1, $8, $4, $6);
          $10 = 2;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          break label$10
         }
        }
        if (!global$2) {
         __assert_fail(2958, 2994, 1043, 3007);
         abort();
        }
       }
       if (global$2 ? ($7 | 0) == 3 : 1) {
        ExpressionPushInt($0, $1, 0);
        $10 = 3;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
      }
      if (!global$2) {
       if (($11 | 0) > HEAP32[$3 >> 2]) {
        break label$8
       }
       HEAP32[$3 >> 2] = 2e4;
      }
     }
     if (!global$2) {
      $4 = HEAP32[$1 >> 2];
      if ($4) {
       continue
      }
     }
     break;
    };
   }
   return;
  }
  $7 = $10;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $7 = HEAP32[global$3 >> 2];
  HEAP32[$7 >> 2] = $0;
  HEAP32[$7 + 4 >> 2] = $1;
  HEAP32[$7 + 8 >> 2] = $2;
  HEAP32[$7 + 12 >> 2] = $3;
  HEAP32[$7 + 16 >> 2] = $4;
  HEAP32[$7 + 20 >> 2] = $6;
  HEAP32[$7 + 24 >> 2] = $8;
  HEAP32[$7 + 28 >> 2] = $9;
  HEAP32[$7 + 32 >> 2] = $11;
  HEAP32[$7 + 36 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 40;
 }
 
 function ExpressionStackPushOperator($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $5 = HEAP32[$5 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $5 = global$2 ? $5 : HEAP32[$0 >> 2];
  label$2 : {
   if (global$2 ? !$6 : 1) {
    $6 = VariableAlloc($5, $0, 16, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $6;
   }
   if (!global$2) {
    $5 = HEAP32[$1 >> 2];
    HEAP8[$0 + 14 | 0] = $2;
    HEAP32[$0 >> 2] = $5;
    HEAP16[$0 + 12 >> 1] = $4;
    HEAP32[$0 + 8 >> 2] = $3;
    HEAP32[$1 >> 2] = $0;
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $4;
  HEAP32[$6 + 20 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
 }
 
 function ExpressionGetStructElement($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -32;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $6 = HEAP32[$5 + 20 >> 2];
   $7 = HEAP32[$5 + 24 >> 2];
   $10 = HEAP32[$5 + 28 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = global$0 + -64 | 0;
   global$0 = $3;
   $4 = $3 + 60 | 0;
  }
  label$2 : {
   if (global$2 ? !$8 : 1) {
    $5 = LexGetToken($0, $4, 1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $4 = $5;
   }
   $4 = global$2 ? $4 : ($4 | 0) != 45;
   if ($4 | (global$2 | 0) == 2) {
    if (!global$2) {
     HEAP32[$3 + 32 >> 2] = ($2 | 0) == 41 ? 3076 : 3078;
     $4 = $3 + 32 | 0;
    }
    if (global$2 ? ($8 | 0) == 1 : 1) {
     ProgramFail($0, 3031, $4);
     $9 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   $4 = global$2 ? $4 : !HEAP32[$0 + 16 >> 2];
   if ($4 | (global$2 | 0) == 2) {
    if (!global$2) {
     $4 = HEAP32[HEAP32[$1 >> 2] + 4 >> 2];
     HEAP32[$3 + 56 >> 2] = $4;
     HEAP32[$3 + 52 >> 2] = HEAP32[$4 >> 2];
     $7 = HEAP32[$4 + 4 >> 2];
     HEAP32[$3 + 48 >> 2] = 0;
     if (($2 | 0) == 42) {
      $7 = VariableDereferencePointer($0, $4, $3 + 56 | 0, 0, $3 + 52 | 0, 0)
     }
     $6 = (HEAP32[HEAP32[$3 + 52 >> 2] >> 2] & -2) != 14;
    }
    if ((global$2 | 0) == 2 | $6) {
     if (!global$2) {
      HEAP32[$3 + 24 >> 2] = HEAP32[$4 >> 2];
      $6 = ($2 | 0) == 42 ? 3153 : 3161;
      HEAP32[$3 + 20 >> 2] = $6;
      HEAP32[$3 + 16 >> 2] = ($2 | 0) == 41 ? 3076 : 3078;
      $2 = $3 + 16 | 0;
     }
     if (global$2 ? ($8 | 0) == 2 : 1) {
      ProgramFail($0, 3081, $2);
      $9 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (!global$2) {
     $6 = !TableGet(HEAP32[HEAP32[$3 + 52 >> 2] + 32 >> 2], HEAP32[HEAP32[HEAP32[$3 + 60 >> 2] + 4 >> 2] >> 2], $3 + 48 | 0, 0, 0, 0);
     $2 = 0;
    }
    if ((global$2 | 0) == 2 | $6) {
     if (!global$2) {
      $6 = HEAP32[HEAP32[HEAP32[$3 + 60 >> 2] + 4 >> 2] >> 2];
      HEAP32[$3 >> 2] = $6;
     }
     if (global$2 ? ($8 | 0) == 3 : 1) {
      ProgramFail($0, 3162, $3);
      $9 = 3;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (!global$2) {
     HeapPopStack(HEAP32[$0 >> 2], $4, TypeStackSizeValue(HEAP32[$3 + 56 >> 2]) + 40 | 0);
     HEAP32[$1 >> 2] = HEAP32[HEAP32[$1 >> 2] >> 2];
     $4 = HEAP32[$3 + 48 >> 2];
     $7 = HEAP32[HEAP32[$4 + 4 >> 2] >> 2] + $7 | 0;
     $6 = $0;
     $4 = HEAP32[$4 >> 2];
     $10 = HEAP32[$3 + 56 >> 2];
     if ($10) {
      $2 = HEAP32[$10 + 8 >> 2]
     }
    }
    if (global$2 ? ($8 | 0) == 4 : 1) {
     $5 = VariableAllocValueFromExistingData($0, $4, $7, 1, $2);
     $9 = 4;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $0 = $5;
    }
    if (global$2 ? ($8 | 0) == 5 : 1) {
     ExpressionStackPushValueNode($6, $1, $0);
     $9 = 5;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    global$0 = $3 - -64 | 0
   }
   return;
  }
  $5 = $9;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[$5 + 20 >> 2] = $6;
  HEAP32[$5 + 24 >> 2] = $7;
  HEAP32[$5 + 28 >> 2] = $10;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 32;
 }
 
 function ExpressionParse($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -48;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $9 = HEAP32[$5 + 20 >> 2];
   $8 = HEAP32[$5 + 24 >> 2];
   $10 = HEAP32[$5 + 28 >> 2];
   $11 = HEAP32[$5 + 32 >> 2];
   $12 = HEAP32[$5 + 36 >> 2];
   $13 = HEAP32[$5 + 40 >> 2];
   $14 = HEAP32[$5 + 44 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $2 = global$0;
   $3 = $2 - 112 | 0;
   global$0 = $3;
   HEAP32[$3 + 104 >> 2] = 2e4;
   HEAP32[$3 + 100 >> 2] = 0;
   $13 = 0;
   $11 = 0;
   $14 = 0;
   $10 = 1;
   $9 = 0;
  }
  label$2 : {
   while (1) {
    if (!global$2) {
     ParserCopy($3 + 56 | 0, $0);
     $2 = $3 + 108 | 0;
    }
    $15 = $2;
    if (global$2 ? !$6 : 1) {
     $5 = LexGetToken($0, $2, 1);
     $7 = 0;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $4 = $5;
    }
    $2 = global$2 ? $15 : $4 + -2 >>> 0 >= 42;
    label$10 : {
     label$11 : {
      if (!global$2) {
       if ($2) {
        $2 = !$11;
        if ($2) {
         break label$11
        }
        $2 = ($4 | 0) != 44;
        if ($2) {
         break label$11
        }
       }
       $8 = ($4 | 0) == 14;
       $2 = $8 ? ($13 | 0) <= 0 : 0;
       if ($2) {
        break label$11
       }
       $2 = HEAPU16[($4 << 3) + 3808 >> 1];
      }
      if ((global$2 | 0) == 2 | $10) {
       if (!global$2) {
        $2 = $2 & 15;
        $9 = !$2;
       }
       if ((global$2 | 0) == 2 | $9) {
        if (global$2 ? ($6 | 0) == 1 : 1) {
         ProgramFail($0, 3196, 0);
         $7 = 1;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
       }
       if (!global$2) {
        $8 = ($4 | 0) == 43;
        $9 = $2 + $11 | 0;
       }
       if ((global$2 | 0) == 2 | $8) {
        $2 = global$2 ? $2 : $3 + 108 | 0;
        if (global$2 ? ($6 | 0) == 2 : 1) {
         $5 = LexGetToken($0, $2, 0);
         $7 = 2;
         if ((global$2 | 0) == 1) {
          break label$2
         }
         $2 = $5;
        }
        $4 = global$2 ? $4 : HEAP32[$3 + 108 >> 2];
        if (global$2 ? ($6 | 0) == 3 : 1) {
         $5 = IsTypeToken($0, $2, $4);
         $7 = 3;
         if ((global$2 | 0) == 1) {
          break label$2
         }
         $2 = $5;
        }
        $2 = global$2 ? $2 : !$2;
        label$25 : {
         if (!global$2) {
          if ($2) {
           break label$25
          }
          $4 = HEAP32[$3 + 100 >> 2];
          if ($4) {
           $2 = HEAP32[$4 + 8 >> 2] == 37;
           if ($2) {
            break label$25
           }
          }
          $9 = $3 + 52 | 0;
          $2 = $3 + 8 | 0;
         }
         if (global$2 ? ($6 | 0) == 4 : 1) {
          TypeParse($0, $2, $9, 0);
          $7 = 4;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         $2 = global$2 ? $2 : $3 + 108 | 0;
         if (global$2 ? ($6 | 0) == 5 : 1) {
          $5 = LexGetToken($0, $2, 1);
          $7 = 5;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $2 = $5;
         }
         $2 = global$2 ? $2 : ($2 | 0) != 44;
         if ($2 | (global$2 | 0) == 2) {
          if (global$2 ? ($6 | 0) == 6 : 1) {
           ProgramFail($0, 3223, 0);
           $7 = 6;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
         }
         if (!global$2) {
          $4 = $3 + 104 | 0;
          $9 = $11 + 15 | 0;
          $2 = $3 + 100 | 0;
         }
         if (global$2 ? ($6 | 0) == 7 : 1) {
          ExpressionStackCollapse($0, $2, $9, $4);
          $7 = 7;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          $4 = HEAP32[$0 >> 2];
          $2 = $4 + 1852 | 0;
         }
         if (global$2 ? ($6 | 0) == 8 : 1) {
          $5 = VariableAllocValueFromType($4, $0, $2, 0, 0, 0);
          $7 = 8;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $4 = $5;
         }
         if (!global$2) {
          $9 = HEAP32[$3 + 8 >> 2];
          HEAP32[HEAP32[$4 + 4 >> 2] >> 2] = $9;
          $2 = $3 + 100 | 0;
         }
         if (global$2 ? ($6 | 0) == 9 : 1) {
          ExpressionStackPushValueNode($0, $2, $4);
          $7 = 9;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          $9 = $11 + 14 | 0;
          $2 = $3 + 100 | 0;
         }
         if (global$2 ? ($6 | 0) == 10 : 1) {
          ExpressionStackPushOperator($0, $2, 2, 38, $9);
          $7 = 10;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          break label$10
         }
        }
        if (!global$2) {
         $11 = $11 + 20 | 0;
         break label$10;
        }
       }
       $8 = global$2 ? $8 : 0;
       if (global$2 ? ($6 | 0) == 11 : 1) {
        $5 = LexGetToken($0, 0, 0);
        $7 = 11;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $12 = $5;
       }
       if (!global$2) {
        $8 = $12 + -2 >>> 0 <= 40 ? ((HEAPU16[($12 << 3) + 3808 >> 1] & 15) == ($2 | 0) ? -1 : 0) : $8;
        $12 = $3 + 104 | 0;
        $2 = $3 + 100 | 0;
       }
       if (global$2 ? ($6 | 0) == 12 : 1) {
        ExpressionStackCollapse($0, $2, $9, $12);
        $7 = 12;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        $8 = $9 + $8 | 0;
        $2 = $3 + 100 | 0;
       }
       if (global$2 ? ($6 | 0) == 13 : 1) {
        ExpressionStackPushOperator($0, $2, 1, $4, $8);
        $7 = 13;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        break label$10
       }
      }
      $8 = global$2 ? $8 : $2 >>> 4 & 15;
      if ($8 | (global$2 | 0) == 2) {
       if (!global$2) {
        $2 = $4 + -40 | 0;
        $12 = $2 >>> 0 > 4;
       }
       label$50 : {
        if (!global$2) {
         if ($12) {
          break label$50
         }
         label$52 : {
          $2 = $2 - 1 | 0;
          switch ($2 | 0) {
          case 0:
          case 1:
          case 2:
           break label$50;
          default:
           break label$52;
          };
         }
         if (!$11) {
          $2 = $3 + 56 | 0;
          ParserCopy($0, $2);
          $14 = 1;
          $11 = 0;
          break label$10;
         }
         $4 = $3 + 104 | 0;
         $2 = $3 + 100 | 0;
        }
        if (global$2 ? ($6 | 0) == 14 : 1) {
         ExpressionStackCollapse($0, $2, $11, $4);
         $7 = 14;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         $11 = $11 + -20 | 0;
         break label$10;
        }
       }
       if (!global$2) {
        $9 = $8 + $11 | 0;
        $8 = $3 + 104 | 0;
        $2 = $3 + 100 | 0;
       }
       if (global$2 ? ($6 | 0) == 15 : 1) {
        ExpressionStackCollapse($0, $2, $9, $8);
        $7 = 15;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       $2 = global$2 ? $2 : $3 + 100 | 0;
       if (global$2 ? ($6 | 0) == 16 : 1) {
        ExpressionStackPushOperator($0, $2, 3, $4, $9);
        $7 = 16;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        break label$10
       }
      }
      if (!global$2) {
       $8 = $2 >>> 8 | 0;
       $2 = $8 & 15;
      }
      if ((global$2 | 0) == 2 | $2) {
       if (!global$2) {
        $9 = $2 + $11 | 0;
        $2 = $9;
        $8 = ($8 & 15) + -2 | 0;
        label$63 : {
         if ($8 >>> 0 > 12) {
          break label$63
         }
         $2 = $9;
         label$64 : {
          switch ($8 - 1 | 0) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
           break label$63;
          default:
           break label$64;
          };
         }
         $2 = $9 + 1 | 0;
        }
        $12 = $3 + 104 | 0;
        $8 = $3 + 100 | 0;
       }
       if (global$2 ? ($6 | 0) == 17 : 1) {
        ExpressionStackCollapse($0, $8, $2, $12);
        $7 = 17;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       $2 = global$2 ? $2 : $4 + -41 >>> 0 <= 1;
       label$66 : {
        if ($2 | (global$2 | 0) == 2) {
         $2 = global$2 ? $2 : $3 + 100 | 0;
         if (global$2 ? ($6 | 0) == 18 : 1) {
          ExpressionGetStructElement($0, $2, $4);
          $7 = 18;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          break label$66
         }
        }
        if (!global$2) {
         label$70 : {
          if ($4 + -15 >>> 0 > 1) {
           break label$70
          }
          $10 = HEAP32[HEAP32[$3 + 100 >> 2] + 4 >> 2];
          if (HEAP32[HEAP32[$10 >> 2] >> 2] + -1 >>> 0 > 8) {
           break label$70
          }
          $10 = ExpressionCoerceInteger($10);
          if (HEAP32[$3 + 104 >> 2] <= ($9 | 0)) {
           break label$70
          }
          $10 = ($10 | 0) != 0;
          $5 = $10 & ($4 | 0) == 15;
          $8 = ($4 | 0) != 16;
          $10 = $10 | $8;
          if ($5 ^ $10) {
           break label$70
          }
          HEAP32[$3 + 104 >> 2] = $9;
         }
         $2 = $3 + 100 | 0;
        }
        if (global$2 ? ($6 | 0) == 19 : 1) {
         ExpressionStackPushOperator($0, $2, 2, $4, $9);
         $7 = 19;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         $10 = 1;
         $2 = $4 + -13 | 0;
         $8 = $2 >>> 0 > 1;
         if ($8) {
          break label$66
         }
         $2 = $2 - 1 | 0;
         if ($2) {
          $13 = $13 + 1 | 0;
          break label$66;
         }
         $13 = $13 + -1 | 0;
        }
       }
       if (!global$2) {
        $2 = $11 + 20 | 0;
        $4 = ($4 | 0) == 39;
        $11 = $4 ? $2 : $11;
        break label$10;
       }
      }
      if (global$2 ? ($6 | 0) == 20 : 1) {
       ProgramFail($0, 3196, 0);
       $7 = 20;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       break label$10
      }
     }
     $2 = global$2 ? $2 : ($4 | 0) == 45;
     if ($2 | (global$2 | 0) == 2) {
      $2 = global$2 ? $2 : !$10;
      if ($2 | (global$2 | 0) == 2) {
       if (global$2 ? ($6 | 0) == 21 : 1) {
        ProgramFail($0, 3243, 0);
        $7 = 21;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
      }
      if (global$2 ? ($6 | 0) == 22 : 1) {
       $5 = LexGetToken($0, 0, 0);
       $7 = 22;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $2 = $5;
      }
      $2 = global$2 ? $2 : ($2 | 0) == 43;
      label$79 : {
       if ($2 | (global$2 | 0) == 2) {
        if (!global$2) {
         $4 = HEAP32[HEAP32[HEAP32[$3 + 108 >> 2] + 4 >> 2] >> 2];
         $8 = ($9 | 0) < HEAP32[$3 + 104 >> 2];
         $10 = $8 & !HEAP32[$0 + 16 >> 2];
         $2 = $3 + 100 | 0;
        }
        if (global$2 ? ($6 | 0) == 23 : 1) {
         ExpressionParseFunctionCall($0, $2, $4, $10);
         $7 = 23;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         break label$79
        }
       }
       $2 = global$2 ? $2 : !HEAP32[$0 + 16 >> 2];
       if ($2 | (global$2 | 0) == 2) {
        if (!global$2) {
         HEAP32[$3 + 52 >> 2] = 0;
         $4 = HEAP32[HEAP32[HEAP32[$3 + 108 >> 2] + 4 >> 2] >> 2];
         $10 = $3 + 52 | 0;
         $2 = HEAP32[$0 >> 2];
        }
        if (global$2 ? ($6 | 0) == 24 : 1) {
         VariableGet($2, $0, $4, $10);
         $7 = 24;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         $4 = HEAP32[$3 + 52 >> 2];
         $10 = HEAP32[$4 >> 2];
         $2 = HEAP32[$10 >> 2] == 11;
        }
        if ((global$2 | 0) == 2 | $2) {
         if (!global$2) {
          $4 = HEAP32[$4 + 4 >> 2] + 8 | 0;
          ParserCopy($3 + 8 | 0, $4);
          HEAP32[$3 + 24 >> 2] = HEAP32[$0 + 16 >> 2];
          $2 = HEAP32[HEAP32[HEAP32[$3 + 52 >> 2] + 4 >> 2] >> 2];
         }
         if ((global$2 | 0) == 2 | $2) {
          $2 = global$2 ? $2 : $3 + 8 | 0;
          if (global$2 ? ($6 | 0) == 25 : 1) {
           ProgramFail($2, 3272, 0);
           $7 = 25;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
         }
         if (!global$2) {
          $4 = $3 + 4 | 0;
          $2 = $3 + 8 | 0;
         }
         if (global$2 ? ($6 | 0) == 26 : 1) {
          $5 = ExpressionParse($2, $4);
          $7 = 26;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $2 = $5;
         }
         label$98 : {
          if ((global$2 | 0) == 2 | $2) {
           $2 = global$2 ? $2 : $3 + 8 | 0;
           if (global$2 ? ($6 | 0) == 27 : 1) {
            $5 = LexGetToken($2, 0, 0);
            $7 = 27;
            if ((global$2 | 0) == 1) {
             break label$2
            }
            $2 = $5;
           }
           if (!global$2) {
            $2 = ($2 | 0) == 95;
            if ($2) {
             break label$98
            }
           }
          }
          $2 = global$2 ? $2 : $3 + 8 | 0;
          if (global$2 ? ($6 | 0) == 28 : 1) {
           ProgramFail($2, 3296, 0);
           $7 = 28;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
         }
         if (!global$2) {
          $4 = HEAP32[$3 + 4 >> 2];
          $2 = $3 + 100 | 0;
         }
         if (global$2 ? ($6 | 0) == 29 : 1) {
          ExpressionStackPushValueNode($0, $2, $4);
          $7 = 29;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          break label$79
         }
        }
        $2 = global$2 ? $2 : (HEAP32[$0 >> 2] + 1808 | 0) == ($10 | 0);
        if ($2 | (global$2 | 0) == 2) {
         if (global$2 ? ($6 | 0) == 30 : 1) {
          ProgramFail($0, 3316, 0);
          $7 = 30;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          break label$79
         }
        }
        $2 = global$2 ? $2 : $3 + 100 | 0;
        if (global$2 ? ($6 | 0) == 31 : 1) {
         ExpressionStackPushLValue($0, $2, $4, 0);
         $7 = 31;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         break label$79
        }
       }
       $2 = global$2 ? $2 : $3 + 100 | 0;
       if (global$2 ? ($6 | 0) == 32 : 1) {
        ExpressionPushInt($0, $2, 0);
        $7 = 32;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
      }
      if (!global$2) {
       $10 = 0;
       $2 = ($9 | 0) > HEAP32[$3 + 104 >> 2];
       if ($2) {
        break label$10
       }
       HEAP32[$3 + 104 >> 2] = 2e4;
       break label$10;
      }
     }
     $2 = global$2 ? $2 : $4 + -45 >>> 0 <= 4;
     if ($2 | (global$2 | 0) == 2) {
      $2 = global$2 ? $2 : !$10;
      if ($2 | (global$2 | 0) == 2) {
       if (global$2 ? ($6 | 0) == 33 : 1) {
        ProgramFail($0, 3349, 0);
        $7 = 33;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
      }
      if (!global$2) {
       $4 = HEAP32[$3 + 108 >> 2];
       $2 = $3 + 100 | 0;
      }
      if (global$2 ? ($6 | 0) == 34 : 1) {
       ExpressionStackPushValue($0, $2, $4);
       $7 = 34;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       $10 = 0;
       break label$10;
      }
     }
     $2 = global$2 ? $2 : HEAP32[$3 + 108 >> 2];
     if (global$2 ? ($6 | 0) == 35 : 1) {
      $5 = IsTypeToken($0, $4, $2);
      $7 = 35;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $2 = $5;
     }
     if ((global$2 | 0) == 2 | $2) {
      $2 = global$2 ? $2 : !$10;
      if ($2 | (global$2 | 0) == 2) {
       if (global$2 ? ($6 | 0) == 36 : 1) {
        ProgramFail($0, 3373, 0);
        $7 = 36;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
      }
      if (!global$2) {
       ParserCopy($0, $3 + 56 | 0);
       $10 = 0;
       $4 = $3 + 52 | 0;
       $2 = $3 + 8 | 0;
      }
      if (global$2 ? ($6 | 0) == 37 : 1) {
       TypeParse($0, $2, $4, 0);
       $7 = 37;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       $4 = HEAP32[$0 >> 2];
       $2 = $4 + 1852 | 0;
      }
      if (global$2 ? ($6 | 0) == 38 : 1) {
       $5 = VariableAllocValueFromType($4, $0, $2, 0, 0, 0);
       $7 = 38;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $4 = $5;
      }
      if (!global$2) {
       $8 = HEAP32[$3 + 8 >> 2];
       HEAP32[HEAP32[$4 + 4 >> 2] >> 2] = $8;
       $2 = $3 + 100 | 0;
      }
      if (global$2 ? ($6 | 0) == 39 : 1) {
       ExpressionStackPushValueNode($0, $2, $4);
       $7 = 39;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       break label$10
      }
     }
     if (!global$2) {
      $2 = $3 + 56 | 0;
      ParserCopy($0, $2);
      $14 = 1;
     }
    }
    if (!global$2) {
     $2 = !$14;
     if ($2) {
      continue
     }
    }
    break;
   };
   $2 = global$2 ? $2 : ($11 | 0) >= 1;
   if ($2 | (global$2 | 0) == 2) {
    if (global$2 ? ($6 | 0) == 40 : 1) {
     ProgramFail($0, 3223, 0);
     $7 = 40;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $9 = $3 + 104 | 0;
    $2 = $3 + 100 | 0;
   }
   if (global$2 ? ($6 | 0) == 41 : 1) {
    ExpressionStackCollapse($0, $2, 0, $9);
    $7 = 41;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    $4 = HEAP32[$3 + 100 >> 2];
    $2 = !$4;
   }
   label$136 : {
    if (!global$2) {
     if ($2) {
      break label$136
     }
     $2 = !HEAP32[$0 + 16 >> 2];
    }
    if ((global$2 | 0) == 2 | $2) {
     $2 = global$2 ? $2 : !HEAPU8[$4 + 14 | 0];
     if (!((HEAP32[$4 >> 2] ? 0 : $2) ? !global$2 : 0)) {
      if (global$2 ? ($6 | 0) == 42 : 1) {
       ProgramFail($0, 2884, 0);
       $7 = 42;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     if (!global$2) {
      HEAP32[$1 >> 2] = HEAP32[HEAP32[$3 + 100 >> 2] + 4 >> 2];
      HeapPopStack(HEAP32[$0 >> 2], HEAP32[$3 + 100 >> 2], 16);
      break label$136;
     }
    }
    if (!global$2) {
     $0 = HEAP32[$0 >> 2];
     $4 = HEAP32[$4 + 4 >> 2];
     $1 = TypeStackSizeValue($4) + 40 | 0;
     HeapPopStack($0, $4, $1);
    }
   }
   if (!global$2) {
    global$0 = $3 + 112 | 0;
    $0 = HEAP32[$3 + 100 >> 2];
    return ($0 | 0) != 0;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[$5 + 20 >> 2] = $9;
  HEAP32[$5 + 24 >> 2] = $8;
  HEAP32[$5 + 28 >> 2] = $10;
  HEAP32[$5 + 32 >> 2] = $11;
  HEAP32[$5 + 36 >> 2] = $12;
  HEAP32[$5 + 40 >> 2] = $13;
  HEAP32[$5 + 44 >> 2] = $14;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 48;
  return 0;
 }
 
 function ExpressionParseFunctionCall($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -52;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $6 = HEAP32[$5 + 20 >> 2];
   $7 = HEAP32[$5 + 24 >> 2];
   $10 = HEAP32[$5 + 28 >> 2];
   $11 = HEAP32[$5 + 32 >> 2];
   $12 = HEAP32[$5 + 36 >> 2];
   $13 = HEAP32[$5 + 40 >> 2];
   $14 = HEAP32[$5 + 44 >> 2];
   $15 = HEAP32[$5 + 48 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $4 = global$0;
   $6 = $4 - 144 | 0;
   global$0 = $6;
   HEAP32[$6 + 140 >> 2] = 0;
   $10 = 0;
  }
  label$2 : {
   if (global$2 ? !$8 : 1) {
    $5 = LexGetToken($0, 0, 1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $4 = $5;
   }
   $14 = global$2 ? $14 : HEAP32[$0 + 16 >> 2];
   label$7 : {
    label$8 : {
     if ((global$2 | 0) == 2 | $3) {
      if (!global$2) {
       $11 = $6 + 140 | 0;
       $4 = HEAP32[$0 >> 2];
      }
      if (global$2 ? ($8 | 0) == 1 : 1) {
       VariableGet($4, $0, $2, $11);
       $9 = 1;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       $10 = HEAP32[$6 + 140 >> 2];
       $12 = HEAP32[$10 >> 2];
       $7 = HEAP32[$12 >> 2] + -10 | 0;
       $4 = $7 >>> 0 <= 1;
      }
      label$12 : {
       if ((global$2 | 0) == 2 | $4) {
        if (!global$2) {
         $4 = $7 - 1 | 0;
         if ($4) {
          break label$12
         }
         $3 = HEAP32[$10 + 4 >> 2];
        }
        if (global$2 ? ($8 | 0) == 2 : 1) {
         ExpressionParseMacroCall($0, $1, $2, $3);
         $9 = 2;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         break label$7
        }
       }
       if (!global$2) {
        HEAP32[$6 + 80 >> 2] = $12;
        $4 = $6 + 80 | 0;
       }
       if (global$2 ? ($8 | 0) == 3 : 1) {
        ProgramFail($0, 3499, $4);
        $9 = 3;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
      }
      $4 = global$2 ? $4 : HEAP32[HEAP32[HEAP32[$6 + 140 >> 2] + 4 >> 2] >> 2];
      if (global$2 ? ($8 | 0) == 4 : 1) {
       $5 = ExpressionStackPushValueByType($0, $1, $4);
       $9 = 4;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $4 = $5;
      }
      if (!global$2) {
       $13 = HEAP32[HEAP32[$1 >> 2] + 4 >> 2];
       HeapPushStackFrame(HEAP32[$0 >> 2]);
       $1 = HEAP32[$0 >> 2];
       $4 = HEAP32[HEAP32[HEAP32[$6 + 140 >> 2] + 4 >> 2] + 4 >> 2] << 2;
       $10 = HeapAllocStack($1, $4);
       if ($10) {
        break label$8
       }
       $10 = 0;
      }
      if (global$2 ? ($8 | 0) == 5 : 1) {
       ProgramFail($0, 3396, 0);
       $9 = 5;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       break label$8
      }
     }
     if (global$2 ? ($8 | 0) == 6 : 1) {
      ExpressionPushInt($0, $1, 0);
      $9 = 6;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      HEAP32[$0 + 16 >> 2] = 1;
      $13 = 0;
     }
    }
    $1 = global$2 ? $1 : 0;
    while (1) {
     $4 = global$2 ? $4 : !$3;
     label$27 : {
      if (!global$2) {
       if ($4) {
        break label$27
       }
       $7 = HEAP32[HEAP32[$6 + 140 >> 2] + 4 >> 2];
       $4 = ($1 | 0) >= HEAP32[$7 + 4 >> 2];
       if ($4) {
        break label$27
       }
       $12 = $1 << 2;
       $4 = $12 + $10 | 0;
       $11 = HEAP32[$0 >> 2];
       $7 = HEAP32[HEAP32[$7 + 12 >> 2] + $12 >> 2];
      }
      if (global$2 ? ($8 | 0) == 7 : 1) {
       $5 = VariableAllocValueFromType($11, $0, $7, 0, 0, 0);
       $9 = 7;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $11 = $5;
      }
      if (!global$2) {
       HEAP32[$4 >> 2] = $11
      }
     }
     $4 = global$2 ? $4 : $6 + 136 | 0;
     if (global$2 ? ($8 | 0) == 8 : 1) {
      $5 = ExpressionParse($0, $4);
      $9 = 8;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $4 = $5;
     }
     label$32 : {
      if ((global$2 | 0) == 2 | $4) {
       $4 = global$2 ? $4 : !$3;
       label$34 : {
        if (!global$2) {
         if ($4) {
          break label$34
         }
         $7 = HEAP32[HEAP32[$6 + 140 >> 2] + 4 >> 2];
         $4 = ($1 | 0) < HEAP32[$7 + 4 >> 2];
        }
        if ((global$2 | 0) == 2 | $4) {
         if (!global$2) {
          $7 = HEAP32[$6 + 136 >> 2];
          $11 = $1 + 1 | 0;
          $4 = HEAP32[($1 << 2) + $10 >> 2];
         }
         if (global$2 ? ($8 | 0) == 9 : 1) {
          ExpressionAssign($0, $4, $7, 1, $2, $11, 0);
          $9 = 9;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (global$2 ? ($8 | 0) == 10 : 1) {
          VariableStackPop($0, $7);
          $9 = 10;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          break label$34
         }
        }
        if (!global$2) {
         $4 = HEAP32[$7 + 8 >> 2];
         if ($4) {
          break label$34
         }
         HEAP32[$6 + 64 >> 2] = $2;
         $4 = $6 - -64 | 0;
        }
        if (global$2 ? ($8 | 0) == 11 : 1) {
         ProgramFail($0, 3410, $4);
         $9 = 11;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
       }
       $1 = global$2 ? $1 : $1 + 1 | 0;
       if (global$2 ? ($8 | 0) == 12 : 1) {
        $5 = LexGetToken($0, 0, 1);
        $9 = 12;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $7 = $5;
       }
       if (!global$2) {
        $4 = ($7 | 0) == 1;
        if ($4) {
         break label$32
        }
        $4 = ($7 | 0) == 44;
        if ($4) {
         break label$32
        }
       }
       if (global$2 ? ($8 | 0) == 13 : 1) {
        ProgramFail($0, 3437, 0);
        $9 = 13;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        break label$32
       }
      }
      if (global$2 ? ($8 | 0) == 14 : 1) {
       $5 = LexGetToken($0, 0, 1);
       $9 = 14;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $7 = $5;
      }
     }
     if (!global$2) {
      $4 = ($7 | 0) != 44;
      if ($4) {
       continue
      }
     }
     break;
    };
    if ((global$2 | 0) == 2 | $3) {
     $3 = global$2 ? $3 : ($1 | 0) < HEAP32[HEAP32[HEAP32[$6 + 140 >> 2] + 4 >> 2] + 4 >> 2];
     if ($3 | (global$2 | 0) == 2) {
      if (!global$2) {
       HEAP32[$6 + 48 >> 2] = $2;
       $3 = $6 + 48 | 0;
      }
      if (global$2 ? ($8 | 0) == 15 : 1) {
       ProgramFail($0, 3452, $3);
       $9 = 15;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     if (!global$2) {
      $3 = HEAP32[$6 + 140 >> 2];
      $7 = HEAP32[HEAP32[$3 + 4 >> 2] + 20 >> 2];
      $4 = !$7;
     }
     label$54 : {
      if ((global$2 | 0) == 2 | $4) {
       if (!global$2) {
        $12 = HEAP32[$0 + 40 >> 2];
        $3 = !HEAP32[HEAP32[$3 + 4 >> 2] + 28 >> 2];
       }
       if ((global$2 | 0) == 2 | $3) {
        if (!global$2) {
         HEAP32[$6 + 32 >> 2] = $2;
         $3 = $6 + 32 | 0;
        }
        if (global$2 ? ($8 | 0) == 16 : 1) {
         ProgramFail($0, 3481, $3);
         $9 = 16;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
       }
       if (!global$2) {
        ParserCopy($6 + 88 | 0, HEAP32[HEAP32[$6 + 140 >> 2] + 4 >> 2] + 24 | 0);
        $7 = 0;
        $4 = $0;
        $11 = $2;
        $15 = HEAP32[HEAP32[$6 + 140 >> 2] + 4 >> 2];
        if (HEAP32[$15 + 20 >> 2]) {
         $3 = HEAP32[$15 + 4 >> 2]
        } else {
         $3 = 0
        }
       }
       if (global$2 ? ($8 | 0) == 17 : 1) {
        VariableStackFrameAdd($4, $11, $3);
        $9 = 17;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        $3 = HEAP32[HEAP32[$0 >> 2] + 1304 >> 2];
        HEAP32[$3 + 48 >> 2] = $13;
        HEAP32[$3 + 56 >> 2] = $1;
        HEAP32[$0 + 40 >> 2] = -1;
        $1 = HEAP32[HEAP32[$6 + 140 >> 2] + 4 >> 2];
        $3 = HEAP32[$1 + 4 >> 2] >= 1;
       }
       if ((global$2 | 0) == 2 | $3) {
        while (1) {
         if (!global$2) {
          $3 = HEAP32[$0 >> 2];
          $4 = HEAP32[$1 + 16 >> 2];
          $1 = $7 << 2;
          $4 = HEAP32[$4 + $1 >> 2];
          $1 = HEAP32[$1 + $10 >> 2];
         }
         if (global$2 ? ($8 | 0) == 18 : 1) {
          $5 = VariableDefine($3, $0, $4, $1, 0, 1);
          $9 = 18;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $1 = $5;
         }
         if (!global$2) {
          $7 = $7 + 1 | 0;
          $1 = HEAP32[HEAP32[$6 + 140 >> 2] + 4 >> 2];
          $3 = ($7 | 0) < HEAP32[$1 + 4 >> 2];
          if ($3) {
           continue
          }
         }
         break;
        }
       }
       if (!global$2) {
        HEAP32[$0 + 40 >> 2] = $12;
        $1 = $6 + 88 | 0;
       }
       if (global$2 ? ($8 | 0) == 19 : 1) {
        $5 = ParseStatement($1, 1);
        $9 = 19;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $1 = $5;
       }
       $1 = global$2 ? $1 : ($1 | 0) != 2;
       if ($1 | (global$2 | 0) == 2) {
        $1 = global$2 ? $1 : $6 + 88 | 0;
        if (global$2 ? ($8 | 0) == 20 : 1) {
         ProgramFail($1, 3533, 0);
         $9 = 20;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
       }
       if (!global$2) {
        $1 = HEAP32[$6 + 104 >> 2];
        $3 = $1 >>> 0 > 6;
       }
       label$80 : {
        if (!global$2) {
         if ($3) {
          break label$80
         }
         $3 = $1 - 1 | 0;
        }
        label$82 : {
         if (global$2) {
          $5 = $3
         } else {
          label$85 : {
           switch ($3 | 0) {
           case 0:
           case 1:
           case 2:
           case 3:
           case 4:
            break label$80;
           case 5:
            break label$82;
           default:
            break label$85;
           };
          }
          $7 = HEAP32[HEAP32[HEAP32[$6 + 140 >> 2] + 4 >> 2] >> 2];
          $5 = ($7 | 0) != (HEAP32[$0 >> 2] + 1808 | 0);
         }
         if ($5 | (global$2 | 0) == 2) {
          if (!global$2) {
           $1 = !strcmp($2, 3556);
           if ($1) {
            break label$80
           }
           HEAP32[$6 + 16 >> 2] = $7;
           $2 = $6 + 16 | 0;
           $1 = $6 + 88 | 0;
          }
          if (global$2 ? ($8 | 0) == 21 : 1) {
           ProgramFail($1, 3561, $2);
           $9 = 21;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (global$2 ? ($8 | 0) == 22 : 1) {
           VariableStackFramePop($0);
           $9 = 22;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (!global$2) {
           break label$54
          }
         }
         if (!global$2) {
          $1 = ($1 | 0) != 6;
          if ($1) {
           break label$80
          }
         }
        }
        if (!global$2) {
         HEAP32[$6 >> 2] = HEAP32[$6 + 112 >> 2];
         $1 = $6 + 88 | 0;
        }
        if (global$2 ? ($8 | 0) == 23 : 1) {
         ProgramFail($1, 3608, $6);
         $9 = 23;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
       }
       if (global$2 ? ($8 | 0) == 24 : 1) {
        VariableStackFramePop($0);
        $9 = 24;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        break label$54
       }
      }
      if (global$2 ? ($8 | 0) == 25 : 1) {
       FUNCTION_TABLE[$7]($0, $13, $10, $1);
       $9 = 25;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     if (!global$2) {
      HeapPopStackFrame(HEAP32[$0 >> 2])
     }
    }
    if (!global$2) {
     HEAP32[$0 + 16 >> 2] = $14
    }
   }
   if (!global$2) {
    global$0 = $6 + 144 | 0
   }
   return;
  }
  $5 = $9;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[$5 + 20 >> 2] = $6;
  HEAP32[$5 + 24 >> 2] = $7;
  HEAP32[$5 + 28 >> 2] = $10;
  HEAP32[$5 + 32 >> 2] = $11;
  HEAP32[$5 + 36 >> 2] = $12;
  HEAP32[$5 + 40 >> 2] = $13;
  HEAP32[$5 + 44 >> 2] = $14;
  HEAP32[$5 + 48 >> 2] = $15;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 52;
 }
 
 function ExpressionParseMacroCall($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -40;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $6 = HEAP32[$4 + 20 >> 2];
   $9 = HEAP32[$4 + 24 >> 2];
   $10 = HEAP32[$4 + 28 >> 2];
   $11 = HEAP32[$4 + 32 >> 2];
   $12 = HEAP32[$4 + 36 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $7 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if (!global$2) {
    $6 = global$0 - 96 | 0;
    global$0 = $6;
    $5 = !HEAP32[$0 + 16 >> 2];
   }
   label$4 : {
    if ((global$2 | 0) == 2 | $5) {
     $5 = global$2 ? $5 : HEAP32[$0 >> 2] + 1764 | 0;
     if (global$2 ? !$7 : 1) {
      $4 = ExpressionStackPushValueByType($0, $1, $5);
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $5 = $4;
     }
     if (!global$2) {
      $11 = HEAP32[HEAP32[$1 >> 2] + 4 >> 2];
      HeapPushStackFrame(HEAP32[$0 >> 2]);
      $1 = HEAP32[$0 >> 2];
      $5 = HEAP32[$3 >> 2] << 2;
      $10 = HeapAllocStack($1, $5);
      if ($10) {
       break label$4
      }
      $10 = 0;
     }
     if (global$2 ? ($7 | 0) == 1 : 1) {
      ProgramFail($0, 3396, 0);
      $8 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      break label$4
     }
    }
    $11 = global$2 ? $11 : 0;
    if (global$2 ? ($7 | 0) == 2 : 1) {
     ExpressionPushInt($0, $1, 0);
     $8 = 2;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    $10 = global$2 ? $10 : 0;
   }
   $5 = global$2 ? $5 : 0;
   while (1) {
    $1 = global$2 ? $1 : $6 + 92 | 0;
    if (global$2 ? ($7 | 0) == 3 : 1) {
     $4 = ExpressionParse($0, $1);
     $8 = 3;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $1 = $4;
    }
    label$15 : {
     if ((global$2 | 0) == 2 | $1) {
      $1 = global$2 ? $1 : HEAP32[$0 + 16 >> 2];
      label$18 : {
       if (!global$2) {
        if ($1) {
         break label$18
        }
        if (($5 | 0) < HEAP32[$3 >> 2]) {
         $1 = ($5 << 2) + $10 | 0;
         $9 = HEAP32[$6 + 92 >> 2];
         HEAP32[$1 >> 2] = $9;
         break label$18;
        }
        HEAP32[$6 + 32 >> 2] = $2;
        $1 = $6 + 32 | 0;
       }
       if (global$2 ? ($7 | 0) == 4 : 1) {
        ProgramFail($0, 3410, $1);
        $8 = 4;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
      }
      $5 = global$2 ? $5 : $5 + 1 | 0;
      if (global$2 ? ($7 | 0) == 5 : 1) {
       $4 = LexGetToken($0, 0, 1);
       $8 = 5;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $1 = $4;
      }
      if (!global$2) {
       $9 = ($1 | 0) == 1;
       if ($9) {
        break label$15
       }
       $9 = ($1 | 0) == 44;
       if ($9) {
        break label$15
       }
      }
      if (global$2 ? ($7 | 0) == 6 : 1) {
       ProgramFail($0, 3437, 0);
       $8 = 6;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       break label$15
      }
     }
     if (global$2 ? ($7 | 0) == 7 : 1) {
      $4 = LexGetToken($0, 0, 1);
      $8 = 7;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $4;
     }
    }
    if (!global$2) {
     $1 = ($1 | 0) != 44;
     if ($1) {
      continue
     }
    }
    break;
   };
   $1 = global$2 ? $1 : !HEAP32[$0 + 16 >> 2];
   if ($1 | (global$2 | 0) == 2) {
    $1 = global$2 ? $1 : ($5 | 0) < HEAP32[$3 >> 2];
    if ($1 | (global$2 | 0) == 2) {
     if (!global$2) {
      HEAP32[$6 + 16 >> 2] = $2;
      $1 = $6 + 16 | 0;
     }
     if (global$2 ? ($7 | 0) == 8 : 1) {
      ProgramFail($0, 3452, $1);
      $8 = 8;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (!global$2) {
     $9 = !HEAP32[$3 + 12 >> 2];
     $1 = $3 + 8 | 0;
    }
    if ((global$2 | 0) == 2 | $9) {
     if (!global$2) {
      HEAP32[$6 >> 2] = $2
     }
     if (global$2 ? ($7 | 0) == 9 : 1) {
      ProgramFail($0, 3481, $6);
      $8 = 9;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (!global$2) {
     $9 = $6 + 48 | 0;
     ParserCopy($9, $1);
     $1 = HEAP32[$0 + 16 >> 2];
     HEAP32[$6 + 64 >> 2] = $1;
    }
    if (global$2 ? ($7 | 0) == 10 : 1) {
     VariableStackFrameAdd($0, $2, 0);
     $8 = 10;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (!global$2) {
     $1 = HEAP32[HEAP32[$0 >> 2] + 1304 >> 2];
     HEAP32[$1 + 48 >> 2] = $11;
     HEAP32[$1 + 56 >> 2] = $5;
     $1 = HEAP32[$3 >> 2] >= 1;
    }
    if ((global$2 | 0) == 2 | $1) {
     $1 = global$2 ? $1 : 0;
     while (1) {
      if (!global$2) {
       $9 = HEAP32[$0 >> 2];
       $5 = $1 << 2;
       $12 = HEAP32[$5 + HEAP32[$3 + 4 >> 2] >> 2];
       $5 = HEAP32[$5 + $10 >> 2];
      }
      if (global$2 ? ($7 | 0) == 11 : 1) {
       VariableDefine($9, $0, $12, $5, 0, 1);
       $8 = 11;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       $1 = $1 + 1 | 0;
       $5 = ($1 | 0) < HEAP32[$3 >> 2];
       if ($5) {
        continue
       }
      }
      break;
     };
    }
    if (!global$2) {
     $3 = $6 + 44 | 0;
     $1 = $6 + 48 | 0;
    }
    if (global$2 ? ($7 | 0) == 12 : 1) {
     $4 = ExpressionParse($1, $3);
     $8 = 12;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $1 = $4;
    }
    $1 = global$2 ? $1 : HEAP32[$6 + 44 >> 2];
    if (global$2 ? ($7 | 0) == 13 : 1) {
     ExpressionAssign($0, $11, $1, 1, $2, 0, 0);
     $8 = 13;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (global$2 ? ($7 | 0) == 14 : 1) {
     VariableStackFramePop($0);
     $8 = 14;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (!global$2) {
     HeapPopStackFrame(HEAP32[$0 >> 2])
    }
   }
   if (!global$2) {
    global$0 = $6 + 96 | 0
   }
   return;
  }
  $4 = $8;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  HEAP32[$4 + 20 >> 2] = $6;
  HEAP32[$4 + 24 >> 2] = $9;
  HEAP32[$4 + 28 >> 2] = $10;
  HEAP32[$4 + 32 >> 2] = $11;
  HEAP32[$4 + 36 >> 2] = $12;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 40;
 }
 
 function ExpressionParseInt($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $3 = HEAP32[$1 + 8 >> 2];
   $4 = HEAP32[$1 + 12 >> 2];
   $7 = HEAP32[$1 + 16 >> 2];
   $5 = HEAP32[$1 + 20 >> 2];
   $2 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = global$0 - 16 | 0;
   global$0 = $3;
   $2 = $3 + 12 | 0;
  }
  label$2 : {
   if (global$2 ? !$6 : 1) {
    $1 = ExpressionParse($0, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $1;
   }
   $2 = global$2 ? $2 : !$2;
   if ($2 | (global$2 | 0) == 2) {
    if (global$2 ? ($6 | 0) == 1 : 1) {
     ProgramFail($0, 3296, 0);
     $8 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $4 = !HEAP32[$0 + 16 >> 2];
    $2 = 0;
   }
   if ((global$2 | 0) == 2 | $4) {
    if (!global$2) {
     $4 = HEAP32[$3 + 12 >> 2];
     $5 = HEAP32[$4 >> 2];
     $2 = HEAP32[$5 >> 2];
     $7 = $2 + -1 >>> 0 < 8;
    }
    label$12 : {
     if (!global$2) {
      if ($7) {
       break label$12
      }
      $2 = 1 << $2 & 12800 ? $2 >>> 0 <= 13 : 0;
      if ($2) {
       break label$12
      }
      HEAP32[$3 >> 2] = $5;
     }
     if (global$2 ? ($6 | 0) == 2 : 1) {
      ProgramFail($0, 3638, $3);
      $8 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (!global$2) {
     $2 = ExpressionCoerceInteger($4)
    }
    if (global$2 ? ($6 | 0) == 3 : 1) {
     VariableStackPop($0, $4);
     $8 = 3;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    global$0 = $3 + 16 | 0;
    return $2;
   }
   abort();
  }
  $1 = $8;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP32[$1 + 8 >> 2] = $3;
  HEAP32[$1 + 12 >> 2] = $4;
  HEAP32[$1 + 16 >> 2] = $7;
  HEAP32[$1 + 20 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  return 0;
 }
 
 function HeapInit($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $5 = dlmalloc($1);
  HEAP32[$0 + 1328 >> 2] = 0;
  HEAP32[$0 + 1320 >> 2] = 0;
  HEAP32[$0 + 1324 >> 2] = 0;
  HEAP32[$0 + 1316 >> 2] = $5;
  while (1) {
   $4 = $2;
   $2 = $4 + 1 | 0;
   $3 = $5 + $4 | 0;
   if ($3 & 7) {
    continue
   }
   break;
  };
  HEAP32[$0 + 1328 >> 2] = $3;
  HEAP32[$0 + 1324 >> 2] = $3;
  HEAP32[$3 >> 2] = 0;
  $2 = $0 + 1332 | 0;
  HEAP32[$2 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 0;
  $2 = $0 + 1340 | 0;
  HEAP32[$2 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 0;
  $2 = $0 + 1348 | 0;
  HEAP32[$2 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 0;
  $2 = $0 + 1356 | 0;
  HEAP32[$2 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 0;
  HEAP32[$0 + 1364 >> 2] = 0;
  HEAP32[$0 + 1320 >> 2] = (HEAP32[$0 + 1316 >> 2] + ($1 + $4 | 0) | 0) + -8;
 }
 
 function HeapCleanup($0) {
  dlfree(HEAP32[$0 + 1316 >> 2]);
 }
 
 function HeapAllocStack($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = HEAP32[$0 + 1328 >> 2];
  $3 = $2 + ($1 + 7 & -8) | 0;
  if ($3 >>> 0 <= HEAPU32[$0 + 1320 >> 2]) {
   HEAP32[$0 + 1328 >> 2] = $3;
   $0 = memset($2, 0, $1);
  } else {
   $0 = 0
  }
  return $0;
 }
 
 function HeapUnpopStack($0, $1) {
  HEAP32[$0 + 1328 >> 2] = HEAP32[$0 + 1328 >> 2] + ($1 + 7 & -8);
 }
 
 function HeapPopStack($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $2 = $2 + 7 & -8;
  $3 = HEAP32[$0 + 1328 >> 2];
  label$1 : {
   if (($2 | 0) > ($3 - HEAP32[$0 + 1316 >> 2] | 0)) {
    break label$1
   }
   $2 = $3 - $2 | 0;
   HEAP32[$0 + 1328 >> 2] = $2;
   $4 = 1;
   if (!$1 | ($1 | 0) == ($2 | 0)) {
    break label$1
   }
   __assert_fail(4168, 4209, 102, 4216);
   abort();
  }
  return $4;
 }
 
 function HeapPushStackFrame($0) {
  var $1 = 0;
  HEAP32[HEAP32[$0 + 1328 >> 2] >> 2] = HEAP32[$0 + 1324 >> 2];
  $1 = HEAP32[$0 + 1328 >> 2];
  HEAP32[$0 + 1324 >> 2] = $1;
  HEAP32[$0 + 1328 >> 2] = $1 + 8;
 }
 
 function HeapPopStackFrame($0) {
  var $1 = 0;
  $1 = HEAP32[$0 + 1324 >> 2];
  if (!HEAP32[$1 >> 2]) {
   return 0
  }
  HEAP32[$0 + 1328 >> 2] = $1;
  HEAP32[$0 + 1324 >> 2] = HEAP32[HEAP32[$0 + 1324 >> 2] >> 2];
  return 1;
 }
 
 function HeapAllocMem($0, $1) {
  return dlcalloc($1, 1);
 }
 
 function HeapFreeMem($0, $1) {
  dlfree($1);
 }
 
 function TypeAdd($0, $1, $2, $3, $4, $5, $6, $7) {
  var $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -32;
   $7 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$7 >> 2];
   $1 = HEAP32[$7 + 4 >> 2];
   $2 = HEAP32[$7 + 8 >> 2];
   $3 = HEAP32[$7 + 12 >> 2];
   $4 = HEAP32[$7 + 16 >> 2];
   $5 = HEAP32[$7 + 20 >> 2];
   $6 = HEAP32[$7 + 24 >> 2];
   $7 = HEAP32[$7 + 28 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $8 = 0
  }
  label$2 : {
   if (global$2 ? !$8 : 1) {
    $8 = VariableAlloc($0, $1, 44, 1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $8;
   }
   if (!global$2) {
    HEAP32[$0 + 16 >> 2] = $5;
    HEAP32[$0 + 12 >> 2] = $7;
    HEAP32[$0 + 8 >> 2] = $6;
    HEAP32[$0 + 4 >> 2] = $4;
    HEAP32[$0 >> 2] = $3;
    HEAP32[$0 + 32 >> 2] = 0;
    HEAP32[$0 + 36 >> 2] = 1;
    HEAP32[$0 + 24 >> 2] = 0;
    HEAP32[$0 + 20 >> 2] = $2;
    HEAP32[$0 + 28 >> 2] = HEAP32[$2 + 24 >> 2];
    HEAP32[$2 + 24 >> 2] = $0;
    return $0;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $8 = HEAP32[global$3 >> 2];
  HEAP32[$8 >> 2] = $0;
  HEAP32[$8 + 4 >> 2] = $1;
  HEAP32[$8 + 8 >> 2] = $2;
  HEAP32[$8 + 12 >> 2] = $3;
  HEAP32[$8 + 16 >> 2] = $4;
  HEAP32[$8 + 20 >> 2] = $5;
  HEAP32[$8 + 24 >> 2] = $6;
  HEAP32[$8 + 28 >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 32;
  return 0;
 }
 
 function TypeGetMatching($0, $1, $2, $3, $4, $5, $6) {
  var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -40;
   $7 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$7 >> 2];
   $1 = HEAP32[$7 + 4 >> 2];
   $2 = HEAP32[$7 + 8 >> 2];
   $3 = HEAP32[$7 + 12 >> 2];
   $4 = HEAP32[$7 + 16 >> 2];
   $5 = HEAP32[$7 + 20 >> 2];
   $6 = HEAP32[$7 + 24 >> 2];
   $9 = HEAP32[$7 + 28 >> 2];
   $10 = HEAP32[$7 + 32 >> 2];
   $7 = HEAP32[$7 + 36 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $7 = global$0 - 16 | 0;
   global$0 = $7;
   $9 = HEAP32[$2 + 24 >> 2];
   $10 = !$9;
  }
  label$2 : {
   label$5 : {
    label$6 : {
     if (!global$2) {
      if ($10) {
       break label$6
      }
      while (1) {
       if (!(HEAP32[$9 + 16 >> 2] == ($5 | 0) ? !(HEAP32[$9 >> 2] != ($3 | 0) | HEAP32[$9 + 4 >> 2] != ($4 | 0)) : 0)) {
        $9 = HEAP32[$9 + 28 >> 2];
        if ($9) {
         continue
        }
        break label$6;
       }
       break;
      };
      if ($6) {
       break label$5
      }
      HEAP32[$7 >> 2] = $5;
     }
     if (global$2 ? !$8 : 1) {
      ProgramFail($1, 4229, $7);
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (!global$2) {
     $9 = 0;
     $10 = $3 + -12 | 0;
     label$13 : {
      if ($10 >>> 0 > 4) {
       $6 = 0;
       break label$13;
      }
      $6 = 0;
      label$15 : {
       switch ($10 - 1 | 0) {
       default:
        $9 = 4;
        $6 = HEAPU8[21728] ? 4 : 0;
        break label$13;
       case 0:
        $9 = Math_imul(HEAP32[$2 + 8 >> 2], $4);
        $6 = HEAP32[$2 + 12 >> 2];
        break label$13;
       case 1:
       case 2:
        break label$13;
       case 3:
        break label$15;
       };
      }
      $9 = 4;
      $6 = HEAPU8[21732] ? 4 : 0;
     }
    }
    if (global$2 ? ($8 | 0) == 1 : 1) {
     $8 = TypeAdd($0, $1, $2, $3, $4, $5, $9, $6);
     $11 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $9 = $8;
    }
   }
   if (!global$2) {
    global$0 = $7 + 16 | 0;
    return $9;
   }
   abort();
  }
  $8 = $11;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $8;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $8 = HEAP32[global$3 >> 2];
  HEAP32[$8 >> 2] = $0;
  HEAP32[$8 + 4 >> 2] = $1;
  HEAP32[$8 + 8 >> 2] = $2;
  HEAP32[$8 + 12 >> 2] = $3;
  HEAP32[$8 + 16 >> 2] = $4;
  HEAP32[$8 + 20 >> 2] = $5;
  HEAP32[$8 + 24 >> 2] = $6;
  HEAP32[$8 + 28 >> 2] = $9;
  HEAP32[$8 + 32 >> 2] = $10;
  HEAP32[$8 + 36 >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 40;
  return 0;
 }
 
 function TypeStackSizeValue($0) {
  var $1 = 0;
  if (!(!$0 | !HEAPU8[$0 + 13 | 0])) {
   $1 = TypeSizeValue($0, 0)
  }
  return $1;
 }
 
 function TypeSizeValue($0, $1) {
  var $2 = 0;
  label$1 : {
   label$2 : {
    $0 = HEAP32[$0 >> 2];
    $2 = HEAP32[$0 >> 2];
    if ($2) {
     if (!$1) {
      $1 = 8;
      if ($2 >>> 0 < 9) {
       break label$1
      }
     }
     if (($2 | 0) == 13) {
      break label$2
     }
    }
    return HEAP32[$0 + 8 >> 2];
   }
   $1 = Math_imul(HEAP32[HEAP32[$0 + 20 >> 2] + 8 >> 2], HEAP32[$0 + 4 >> 2]);
  }
  return $1;
 }
 
 function TypeSize($0, $1, $2) {
  var $3 = 0;
  label$1 : {
   label$2 : {
    $3 = HEAP32[$0 >> 2];
    if ($3) {
     if (!$2) {
      $2 = 8;
      if ($3 >>> 0 < 9) {
       break label$1
      }
     }
     if (($3 | 0) == 13) {
      break label$2
     }
    }
    return HEAP32[$0 + 8 >> 2];
   }
   $2 = Math_imul(HEAP32[HEAP32[$0 + 20 >> 2] + 8 >> 2], $1);
  }
  return $2;
 }
 
 function TypeAddBaseType($0, $1, $2, $3, $4) {
  HEAP32[$1 + 12 >> 2] = $4;
  HEAP32[$1 + 8 >> 2] = $3;
  HEAP32[$1 + 4 >> 2] = 0;
  HEAP32[$1 >> 2] = $2;
  HEAP32[$1 + 16 >> 2] = HEAP32[$0 + 2756 >> 2];
  HEAP32[$1 + 32 >> 2] = 0;
  HEAP32[$1 + 36 >> 2] = 0;
  HEAP32[$1 + 20 >> 2] = 0;
  HEAP32[$1 + 24 >> 2] = 0;
  $0 = $0 + 1392 | 0;
  HEAP32[$1 + 28 >> 2] = HEAP32[$0 >> 2];
  HEAP32[$0 >> 2] = $1;
 }
 
 function TypeInit($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $3 = HEAP32[$1 + 4 >> 2];
   $4 = HEAP32[$1 + 12 >> 2];
   $5 = HEAP32[$1 + 16 >> 2];
   $2 = HEAP32[$1 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   HEAP8[21728] = 1;
   HEAP8[21732] = 1;
   HEAP32[$0 + 1392 >> 2] = 0;
   TypeAddBaseType($0, $0 + 1412 | 0, 1, 4, 4);
   TypeAddBaseType($0, $0 + 1456 | 0, 2, 2, 2);
   $2 = $0 + 1500 | 0;
   TypeAddBaseType($0, $2, 3, 1, 1);
   TypeAddBaseType($0, $0 + 1544 | 0, 4, 4, 4);
   TypeAddBaseType($0, $0 + 1588 | 0, 5, 4, HEAPU8[21732] ? 4 : 0);
   TypeAddBaseType($0, $0 + 1632 | 0, 6, 2, 2);
   TypeAddBaseType($0, $0 + 1676 | 0, 8, 4, 4);
   TypeAddBaseType($0, $0 + 1720 | 0, 7, 1, 1);
   $5 = $0 + 1808 | 0;
   TypeAddBaseType($0, $5, 0, 0, 1);
   TypeAddBaseType($0, $0 + 1896 | 0, 10, 4, HEAPU8[21732] ? 4 : 0);
   $4 = HEAPU8[21732] ? 4 : 0;
   TypeAddBaseType($0, $0 + 1940 | 0, 11, 4, $4);
   TypeAddBaseType($0, $0 + 2028 | 0, 17, 0, 1);
   TypeAddBaseType($0, $0 + 1764 | 0, 9, 8, 8);
   TypeAddBaseType($0, $0 + 1852 | 0, 18, 8, 8);
   $3 = HEAP32[$0 + 2756 >> 2];
  }
  label$2 : {
   if (global$2 ? !$6 : 1) {
    $1 = TypeAdd($0, 0, $2, 13, 0, $3, 1, 1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $1;
   }
   if (!global$2) {
    HEAP32[$0 + 2080 >> 2] = $3;
    $4 = HEAPU8[21728] ? 4 : 0;
    $3 = HEAP32[$0 + 2756 >> 2];
   }
   if (global$2 ? ($6 | 0) == 1 : 1) {
    $1 = TypeAdd($0, 0, $2, 12, 0, $3, 4, $4);
    $7 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $1;
   }
   if (!global$2) {
    HEAP32[$0 + 2072 >> 2] = $2;
    $4 = HEAPU8[21728] ? 4 : 0;
    $3 = HEAP32[$0 + 2756 >> 2];
   }
   if (global$2 ? ($6 | 0) == 2 : 1) {
    $1 = TypeAdd($0, 0, $2, 12, 0, $3, 4, $4);
    $7 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $1;
   }
   if (!global$2) {
    HEAP32[$0 + 2076 >> 2] = $2;
    $3 = HEAPU8[21728] ? 4 : 0;
    $2 = HEAP32[$0 + 2756 >> 2];
   }
   if (global$2 ? ($6 | 0) == 3 : 1) {
    $1 = TypeAdd($0, 0, $5, 12, 0, $2, 4, $3);
    $7 = 3;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $1;
   }
   if (!global$2) {
    HEAP32[$0 + 2084 >> 2] = $2
   }
   return;
  }
  $1 = $7;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $3;
  HEAP32[$1 + 8 >> 2] = $2;
  HEAP32[$1 + 12 >> 2] = $4;
  HEAP32[$1 + 16 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function TypeCleanupNode($0, $1) {
  var $2 = 0, $3 = 0;
  $1 = HEAP32[$1 + 24 >> 2];
  if ($1) {
   while (1) {
    $3 = HEAP32[$1 + 28 >> 2];
    TypeCleanupNode($0, $1);
    if (HEAP32[$1 + 36 >> 2]) {
     $2 = HEAP32[$1 + 32 >> 2];
     if ($2) {
      VariableTableCleanup($0, $2);
      HeapFreeMem($0, HEAP32[$1 + 32 >> 2]);
     }
     HeapFreeMem($0, $1);
    }
    $1 = $3;
    if ($1) {
     continue
    }
    break;
   }
  }
 }
 
 function TypeCleanup($0) {
  TypeCleanupNode($0, $0 + 1368 | 0);
 }
 
 function TypeParseStruct($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -44;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $8 = HEAP32[$4 + 20 >> 2];
   $9 = HEAP32[$4 + 24 >> 2];
   $10 = HEAP32[$4 + 28 >> 2];
   $11 = HEAP32[$4 + 32 >> 2];
   $12 = HEAP32[$4 + 36 >> 2];
   $13 = HEAP32[$4 + 40 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if (!global$2) {
    $8 = global$0 - 32 | 0;
    global$0 = $8;
    $10 = HEAP32[$0 >> 2];
    $3 = $8 + 28 | 0;
   }
   $14 = $3;
   if (global$2 ? !$6 : 1) {
    $4 = LexGetToken($0, $3, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $5 = $4;
   }
   $3 = global$2 ? $14 : ($5 | 0) == 45;
   label$4 : {
    if ($3 | (global$2 | 0) == 2) {
     $3 = global$2 ? $3 : $8 + 28 | 0;
     if (global$2 ? ($6 | 0) == 1 : 1) {
      $4 = LexGetToken($0, $3, 1);
      $7 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $4;
     }
     $3 = global$2 ? $3 : HEAP32[HEAP32[HEAP32[$8 + 28 >> 2] + 4 >> 2] >> 2];
     if (global$2 ? ($6 | 0) == 2 : 1) {
      $4 = LexGetToken($0, 0, 0);
      $7 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $5 = $4;
     }
     if (!global$2) {
      break label$4
     }
    }
    if (global$2 ? ($6 | 0) == 3 : 1) {
     $4 = PlatformMakeTempName($10, 18776);
     $7 = 3;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $3 = $4;
    }
   }
   if (!global$2) {
    $11 = $2 ? 14 : 15;
    $9 = HEAP32[$0 >> 2] + 1368 | 0;
   }
   if (global$2 ? ($6 | 0) == 4 : 1) {
    $4 = TypeGetMatching($10, $0, $9, $11, 0, $3, 1);
    $7 = 4;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $4;
   }
   if (!global$2) {
    HEAP32[$1 >> 2] = $3;
    $5 = ($5 | 0) != 52;
   }
   label$17 : {
    if (!global$2) {
     if ($5) {
      break label$17
     }
     $5 = !HEAP32[$3 + 32 >> 2];
     if ($5) {
      break label$17
     }
     HEAP32[$8 + 16 >> 2] = $3;
     $3 = $8 + 16 | 0;
    }
    if (global$2 ? ($6 | 0) == 5 : 1) {
     ProgramFail($0, 4263, $3);
     $7 = 5;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (global$2 ? ($6 | 0) == 6 : 1) {
    $4 = LexGetToken($0, 0, 0);
    $7 = 6;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $4;
   }
   $3 = global$2 ? $3 : ($3 | 0) == 52;
   if ($3 | (global$2 | 0) == 2) {
    $3 = global$2 ? $3 : HEAP32[$10 + 1304 >> 2];
    if ($3 | (global$2 | 0) == 2) {
     if (global$2 ? ($6 | 0) == 7 : 1) {
      ProgramFail($0, 4297, 0);
      $7 = 7;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (global$2 ? ($6 | 0) == 8 : 1) {
     $4 = LexGetToken($0, 0, 1);
     $7 = 8;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $3 = $4;
    }
    if (global$2 ? ($6 | 0) == 9 : 1) {
     $4 = VariableAlloc($10, $0, 228, 1);
     $7 = 9;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $5 = $4;
    }
    if (!global$2) {
     HEAP32[HEAP32[$1 >> 2] + 32 >> 2] = $5;
     $5 = HEAP32[HEAP32[$1 >> 2] + 32 >> 2];
     $3 = $5 + 8 | 0;
     HEAP32[$5 + 4 >> 2] = $3;
     $5 = HEAP32[HEAP32[$1 >> 2] + 32 >> 2];
     $3 = $5 + 8 | 0;
     TableInitTable($5, $3, 11, 1);
    }
    while (1) {
     if (!global$2) {
      $5 = $8 + 20 | 0;
      $3 = $8 + 24 | 0;
     }
     if (global$2 ? ($6 | 0) == 10 : 1) {
      TypeParse($0, $3, $5, 0);
      $7 = 10;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     $3 = global$2 ? $3 : HEAP32[$8 + 24 >> 2];
     label$34 : {
      if (!global$2) {
       if ($3) {
        $5 = HEAP32[$8 + 20 >> 2];
        if ($5) {
         break label$34
        }
       }
      }
      if (global$2 ? ($6 | 0) == 11 : 1) {
       ProgramFail($0, 4342, 0);
       $7 = 11;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     if (global$2 ? ($6 | 0) == 12 : 1) {
      $4 = VariableAllocValueAndData($10, $0, 4, 0, 0, 1);
      $7 = 12;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $5 = $4;
     }
     if (!global$2) {
      HEAP32[$5 >> 2] = $3;
      label$40 : {
       if ($2) {
        $9 = HEAP32[$1 >> 2];
        $11 = HEAP32[$9 + 8 >> 2];
        $3 = HEAP32[$3 + 12 >> 2];
        $12 = $11 & $3 + -1;
        if ($12) {
         HEAP32[$9 + 8 >> 2] = ($3 + $11 | 0) - $12
        }
        HEAP32[HEAP32[$5 + 4 >> 2] >> 2] = HEAP32[$9 + 8 >> 2];
        $3 = HEAP32[$1 >> 2];
        $9 = HEAP32[$3 + 8 >> 2];
        HEAP32[$3 + 8 >> 2] = TypeSizeValue($5, 1) + $9;
        break label$40;
       }
       HEAP32[HEAP32[$5 + 4 >> 2] >> 2] = 0;
       $3 = HEAP32[$1 >> 2];
       if (HEAP32[HEAP32[$5 >> 2] + 8 >> 2] <= HEAP32[$3 + 8 >> 2]) {
        break label$40
       }
       HEAP32[$3 + 8 >> 2] = TypeSizeValue($5, 1);
      }
      $3 = HEAP32[$1 >> 2];
      $9 = HEAP32[HEAP32[$5 >> 2] + 12 >> 2];
      if (HEAP32[$3 + 12 >> 2] < ($9 | 0)) {
       HEAP32[$3 + 12 >> 2] = $9
      }
      $9 = HEAP32[$8 + 20 >> 2];
      $11 = HEAP32[$0 + 8 >> 2];
      $12 = HEAP16[$0 + 12 >> 1];
      $13 = HEAP16[$0 + 14 >> 1];
      $3 = HEAP32[$3 + 32 >> 2];
     }
     if (global$2 ? ($6 | 0) == 13 : 1) {
      $4 = TableSet($10, $3, $9, $5, $11, $12, $13);
      $7 = 13;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $4;
     }
     $3 = global$2 ? $3 : !$3;
     if ($3 | (global$2 | 0) == 2) {
      if (!global$2) {
       $3 = $8 + 20 | 0;
       HEAP32[$8 >> 2] = $3;
      }
      if (global$2 ? ($6 | 0) == 14 : 1) {
       ProgramFail($0, 4365, $8);
       $7 = 14;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     if (global$2 ? ($6 | 0) == 15 : 1) {
      $4 = LexGetToken($0, 0, 1);
      $7 = 15;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $4;
     }
     $3 = global$2 ? $3 : ($3 | 0) != 50;
     if ($3 | (global$2 | 0) == 2) {
      if (global$2 ? ($6 | 0) == 16 : 1) {
       ProgramFail($0, 4393, 0);
       $7 = 16;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     if (global$2 ? ($6 | 0) == 17 : 1) {
      $4 = LexGetToken($0, 0, 0);
      $7 = 17;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $4;
     }
     if (!global$2) {
      $3 = ($3 | 0) != 53;
      if ($3) {
       continue
      }
     }
     break;
    };
    if (!global$2) {
     $5 = HEAP32[$1 >> 2];
     $1 = HEAP32[$5 + 8 >> 2];
     $3 = HEAP32[$5 + 12 >> 2];
     $10 = $1 & $3 + -1;
     if ($10) {
      HEAP32[$5 + 8 >> 2] = ($1 + $3 | 0) - $10
     }
    }
    if (global$2 ? ($6 | 0) == 18 : 1) {
     LexGetToken($0, 0, 1);
     $7 = 18;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    global$0 = $8 + 32 | 0
   }
   return;
  }
  $4 = $7;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  HEAP32[$4 + 20 >> 2] = $8;
  HEAP32[$4 + 24 >> 2] = $9;
  HEAP32[$4 + 28 >> 2] = $10;
  HEAP32[$4 + 32 >> 2] = $11;
  HEAP32[$4 + 36 >> 2] = $12;
  HEAP32[$4 + 40 >> 2] = $13;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 44;
 }
 
 function TypeParse($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $6 = HEAP32[$4 + 20 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $7 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = global$0 - 16 | 0;
   global$0 = $5;
   $6 = $5 + 12 | 0;
  }
  label$2 : {
   if (global$2 ? !$7 : 1) {
    $4 = TypeParseFront($0, $6, $3);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $4;
   }
   $3 = global$2 ? $3 : HEAP32[$5 + 12 >> 2];
   if (global$2 ? ($7 | 0) == 1 : 1) {
    TypeParseIdentPart($0, $3, $1, $2);
    $8 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    global$0 = $5 + 16 | 0
   }
   return;
  }
  $4 = $8;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  HEAP32[$4 + 20 >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
 }
 
 function TypeParseFront($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -32;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $5 = HEAP32[$3 + 16 >> 2];
   $6 = HEAP32[$3 + 20 >> 2];
   $7 = HEAP32[$3 + 24 >> 2];
   $8 = HEAP32[$3 + 28 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $9 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $8 = global$0 + -64 | 0;
   global$0 = $8;
   $6 = HEAP32[$0 >> 2];
   $4 = 0;
   HEAP32[$1 >> 2] = 0;
   ParserCopy($8 + 16 | 0, $0);
   $5 = $8 + 12 | 0;
  }
  $11 = $7;
  label$2 : {
   if (global$2 ? !$9 : 1) {
    $3 = LexGetToken($0, $5, 1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $5 = $3;
   }
   $7 = global$2 ? $11 : $5 + -63 >>> 0 <= 3;
   if ($7 | (global$2 | 0) == 2) {
    while (1) {
     if (!global$2) {
      $4 = ($5 | 0) == 63 ? 1 : $4;
      $5 = $8 + 12 | 0;
     }
     if (global$2 ? ($9 | 0) == 1 : 1) {
      $3 = LexGetToken($0, $5, 1);
      $10 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $5 = $3;
     }
     if (!global$2) {
      $7 = $5 + -63 >>> 0 < 4;
      if ($7) {
       continue
      }
     }
     break;
    }
   }
   if (!global$2) {
    if ($2) {
     HEAP32[$2 >> 2] = $4
    }
    $4 = $5 + -61 | 0;
    $7 = $4 >>> 0 > 8;
    $2 = 0;
   }
   label$14 : {
    label$15 : {
     if (!global$2) {
      if ($7) {
       break label$15
      }
      label$17 : {
       $4 = $4 - 1 | 0;
       switch ($4 | 0) {
       case 0:
       case 1:
       case 2:
       case 3:
       case 4:
       case 5:
       case 6:
        break label$15;
       default:
        break label$17;
       };
      }
      $4 = $8 + 12 | 0;
      $2 = 0;
     }
     if (global$2 ? ($9 | 0) == 2 : 1) {
      $3 = LexGetToken($0, $4, 0);
      $10 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $4 = $3;
     }
     if (!global$2) {
      $4 = $4 + -54 | 0;
      $7 = $4 >>> 0 <= 8;
      $4 = !(1 << $4 & 323 ? $7 : 0);
     }
     label$20 : {
      if (!global$2) {
       if ($4) {
        $4 = ($5 | 0) == 69 ? $6 + 1588 | 0 : $6 + 1412 | 0;
        HEAP32[$1 >> 2] = $4;
        $7 = $5;
        break label$20;
       }
       $2 = $8 + 12 | 0;
      }
      if (global$2 ? ($9 | 0) == 3 : 1) {
       $3 = LexGetToken($0, $2, 1);
       $10 = 3;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $7 = $3;
      }
      $2 = global$2 ? $2 : 1;
     }
     if (!global$2) {
      $4 = 1;
      $3 = 1;
      if (!$2) {
       break label$14
      }
      $2 = ($5 | 0) == 69;
      $5 = $7;
     }
    }
    if (!global$2) {
     $4 = $5 + -45 | 0;
     $7 = $4 >>> 0 > 23;
    }
    label$26 : {
     if (!global$2) {
      if ($7) {
       break label$26
      }
      $4 = $4 - 1 | 0;
     }
     label$28 : {
      label$29 : {
       if (!global$2) {
        label$32 : {
         switch ($4 | 0) {
         case 8:
          HEAP32[$1 >> 2] = $2 ? $6 + 1588 | 0 : $6 + 1412 | 0;
          $3 = 1;
          break label$14;
         case 16:
          HEAP32[$1 >> 2] = $2 ? $6 + 1632 | 0 : $6 + 1456 | 0;
          $3 = 1;
          break label$14;
         case 9:
          HEAP32[$1 >> 2] = $2 ? $6 + 1720 | 0 : $6 + 1500 | 0;
          $3 = 1;
          break label$14;
         case 14:
          HEAP32[$1 >> 2] = $2 ? $6 + 1676 | 0 : $6 + 1544 | 0;
          $3 = 1;
          break label$14;
         case 10:
         case 11:
          HEAP32[$1 >> 2] = $6 + 1764;
          $3 = 1;
          break label$14;
         case 12:
          HEAP32[$1 >> 2] = $6 + 1808;
          $3 = 1;
          break label$14;
         case 0:
         case 1:
         case 2:
         case 3:
         case 4:
         case 5:
         case 6:
         case 7:
         case 15:
         case 17:
         case 18:
         case 19:
         case 20:
          break label$26;
         case 13:
          break label$29;
         case 21:
         case 22:
          break label$32;
         default:
          break label$28;
         };
        }
        $2 = HEAP32[$1 >> 2];
       }
       if ((global$2 | 0) == 2 | $2) {
        if (global$2 ? ($9 | 0) == 4 : 1) {
         ProgramFail($0, 4508, 0);
         $10 = 4;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
       }
       $2 = global$2 ? $2 : ($5 | 0) == 67;
       if (global$2 ? ($9 | 0) == 5 : 1) {
        TypeParseStruct($0, $1, $2);
        $10 = 5;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       $3 = 1;
       if (!global$2) {
        break label$14
       }
      }
      $2 = global$2 ? $2 : HEAP32[$1 >> 2];
      if ($2 | (global$2 | 0) == 2) {
       if (global$2 ? ($9 | 0) == 6 : 1) {
        ProgramFail($0, 4508, 0);
        $10 = 6;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
      }
      if (global$2 ? ($9 | 0) == 7 : 1) {
       TypeParseEnum($0, $1);
       $10 = 7;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      $3 = 1;
      if (!global$2) {
       break label$14
      }
     }
     if (!global$2) {
      $4 = $8 + 8 | 0;
      $2 = HEAP32[HEAP32[HEAP32[$8 + 12 >> 2] + 4 >> 2] >> 2];
     }
     if (global$2 ? ($9 | 0) == 8 : 1) {
      VariableGet($6, $0, $2, $4);
      $10 = 8;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      HEAP32[$1 >> 2] = HEAP32[HEAP32[HEAP32[$8 + 8 >> 2] + 4 >> 2] >> 2];
      $3 = 1;
      break label$14;
     }
    }
    if (global$2) {
     $3 = $4
    } else {
     ParserCopy($0, $8 + 16 | 0);
     $3 = 0;
    }
   }
   $4 = $3;
   if (!global$2) {
    global$0 = $8 - -64 | 0;
    return $4;
   }
   abort();
  }
  $3 = $10;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[$3 + 16 >> 2] = $5;
  HEAP32[$3 + 20 >> 2] = $6;
  HEAP32[$3 + 24 >> 2] = $7;
  HEAP32[$3 + 28 >> 2] = $8;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 32;
  return 0;
 }
 
 function TypeParseIdentPart($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -32;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $7 = HEAP32[$4 + 16 >> 2];
   $8 = HEAP32[$4 + 20 >> 2];
   $9 = HEAP32[$4 + 24 >> 2];
   $10 = HEAP32[$4 + 28 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $7 = global$0 + -64 | 0;
   global$0 = $7;
   HEAP32[$2 >> 2] = $1;
   $1 = HEAP32[HEAP32[$0 >> 2] + 2756 >> 2];
   HEAP32[$3 >> 2] = $1;
   $8 = 0;
  }
  label$2 : {
   while (1) {
    if (!global$2) {
     ParserCopy($7 + 16 | 0, $0);
     $1 = $7 + 12 | 0;
    }
    if (global$2 ? !$5 : 1) {
     $4 = LexGetToken($0, $1, 1);
     $6 = 0;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $1 = $4;
    }
    if (!global$2) {
     $1 = $1 + -30 | 0;
     $9 = $1 >>> 0 > 15;
    }
    label$9 : {
     label$10 : {
      label$11 : {
       if (!global$2) {
        if ($9) {
         break label$11
        }
        $1 = $1 - 1 | 0;
       }
       label$13 : {
        label$14 : {
         if (!global$2) {
          label$17 : {
           switch ($1 | 0) {
           case 0:
           case 1:
           case 2:
           case 3:
           case 4:
           case 5:
           case 6:
           case 7:
           case 8:
           case 9:
           case 10:
           case 11:
           case 13:
            break label$11;
           case 14:
            break label$13;
           case 12:
            break label$17;
           default:
            break label$14;
           };
          }
          $1 = HEAP32[$2 >> 2];
         }
         if ((global$2 | 0) == 2 | $1) {
          if (global$2 ? ($5 | 0) == 1 : 1) {
           ProgramFail($0, 4508, 0);
           $6 = 1;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
         }
         if (global$2 ? ($5 | 0) == 2 : 1) {
          TypeParse($0, $2, $3, 0);
          $6 = 2;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (global$2 ? ($5 | 0) == 3 : 1) {
          $4 = LexGetToken($0, 0, 1);
          $6 = 3;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $1 = $4;
         }
         if (!global$2) {
          $1 = ($1 | 0) == 44;
          if ($1) {
           break label$9
          }
         }
         if (global$2 ? ($5 | 0) == 4 : 1) {
          ProgramFail($0, 4542, 0);
          $6 = 4;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          break label$9
         }
        }
        $1 = global$2 ? $1 : !HEAP32[$2 >> 2];
        if ($1 | (global$2 | 0) == 2) {
         if (global$2 ? ($5 | 0) == 5 : 1) {
          ProgramFail($0, 4508, 0);
          $6 = 5;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
        }
        if (!global$2) {
         $1 = HEAP32[$0 >> 2];
         $10 = HEAP32[$1 + 2756 >> 2];
         $9 = HEAP32[$2 >> 2];
        }
        if (global$2 ? ($5 | 0) == 6 : 1) {
         $4 = TypeGetMatching($1, $0, $9, 12, 0, $10, 1);
         $6 = 6;
         if ((global$2 | 0) == 1) {
          break label$2
         }
         $1 = $4;
        }
        if (!global$2) {
         HEAP32[$2 >> 2] = $1;
         break label$9;
        }
       }
       $1 = global$2 ? $1 : HEAP32[$2 >> 2];
       label$32 : {
        if (!global$2) {
         if ($1) {
          $8 = HEAP32[HEAP32[$0 >> 2] + 2756 >> 2];
          $1 = ($8 | 0) == HEAP32[$3 >> 2];
          if ($1) {
           break label$32
          }
         }
        }
        if (global$2 ? ($5 | 0) == 7 : 1) {
         ProgramFail($0, 4508, 0);
         $6 = 7;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
       }
       if (!global$2) {
        $1 = HEAP32[HEAP32[HEAP32[$7 + 12 >> 2] + 4 >> 2] >> 2];
        HEAP32[$3 >> 2] = $1;
        break label$10;
       }
      }
      if (!global$2) {
       $1 = $7 + 16 | 0;
       ParserCopy($0, $1);
      }
     }
     $8 = global$2 ? $8 : 1;
    }
    if (!global$2) {
     $1 = !$8;
     if ($1) {
      continue
     }
    }
    break;
   };
   $1 = global$2 ? $1 : !HEAP32[$2 >> 2];
   if ($1 | (global$2 | 0) == 2) {
    if (global$2 ? ($5 | 0) == 8 : 1) {
     ProgramFail($0, 4508, 0);
     $6 = 8;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   $1 = global$2 ? $1 : HEAP32[$3 >> 2] != HEAP32[HEAP32[$0 >> 2] + 2756 >> 2];
   if ($1 | (global$2 | 0) == 2) {
    $1 = global$2 ? $1 : HEAP32[$2 >> 2];
    if (global$2 ? ($5 | 0) == 9 : 1) {
     $4 = TypeParseBack($0, $1);
     $6 = 9;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $0 = $4;
    }
    if (!global$2) {
     HEAP32[$2 >> 2] = $0
    }
   }
   if (!global$2) {
    global$0 = $7 - -64 | 0
   }
   return;
  }
  $4 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $7;
  HEAP32[$4 + 20 >> 2] = $8;
  HEAP32[$4 + 24 >> 2] = $9;
  HEAP32[$4 + 28 >> 2] = $10;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 32;
 }
 
 function TypeCreateOpaqueStruct($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  $5 = global$2 ? $5 : $0 + 1368 | 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$6 : 1) {
    $4 = TypeGetMatching($0, $1, $5, 14, 0, $2, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (global$2 ? ($6 | 0) == 1 : 1) {
    $4 = VariableAlloc($0, $1, 228, 1);
    $7 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $4;
   }
   if (!global$2) {
    HEAP32[$2 + 32 >> 2] = $0;
    HEAP32[$0 + 4 >> 2] = $0 + 8;
    $0 = HEAP32[$2 + 32 >> 2];
    $1 = $0 + 8 | 0;
    TableInitTable($0, $1, 11, 1);
    HEAP32[$2 + 8 >> 2] = $3;
    return $2;
   }
   abort();
  }
  $4 = $7;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
  return 0;
 }
 
 function TypeParseEnum($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -32;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $3 = HEAP32[$2 + 8 >> 2];
   $4 = HEAP32[$2 + 12 >> 2];
   $7 = HEAP32[$2 + 16 >> 2];
   $8 = HEAP32[$2 + 20 >> 2];
   $9 = HEAP32[$2 + 24 >> 2];
   $10 = HEAP32[$2 + 28 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $4 = global$0 - 48 | 0;
   global$0 = $4;
   HEAP32[$4 + 12 >> 2] = 0;
   $7 = HEAP32[$0 >> 2];
   $3 = $4 + 44 | 0;
  }
  label$2 : {
   $11 = $8;
   if (global$2 ? !$5 : 1) {
    $2 = LexGetToken($0, $3, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $2;
   }
   $8 = global$2 ? $11 : ($3 | 0) == 45;
   label$5 : {
    if ($8 | (global$2 | 0) == 2) {
     $3 = global$2 ? $3 : $4 + 44 | 0;
     if (global$2 ? ($5 | 0) == 1 : 1) {
      $2 = LexGetToken($0, $3, 1);
      $6 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $2;
     }
     if (!global$2) {
      $3 = HEAP32[HEAP32[$4 + 44 >> 2] + 4 >> 2];
      $8 = HEAP32[$3 >> 2];
     }
     if (global$2 ? ($5 | 0) == 2 : 1) {
      $2 = LexGetToken($0, 0, 0);
      $6 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $2;
     }
     if (!global$2) {
      break label$5
     }
    }
    if (global$2 ? ($5 | 0) == 3 : 1) {
     $2 = PlatformMakeTempName($7, 18783);
     $6 = 3;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $8 = $2;
    }
   }
   if (!global$2) {
    $10 = ($3 | 0) != 52;
    $9 = $7 + 1368 | 0;
   }
   if (global$2 ? ($5 | 0) == 4 : 1) {
    $2 = TypeGetMatching($7, $0, $9, 16, 0, $8, $10);
    $6 = 4;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $9 = $2;
   }
   if (!global$2) {
    $9 = $7 + 1412 | 0;
    HEAP32[$1 >> 2] = $9;
    $3 = ($3 | 0) != 52;
   }
   label$15 : {
    if ((global$2 | 0) == 2 | $3) {
     if (!global$2) {
      $1 = HEAP32[$7 + 1444 >> 2];
      if ($1) {
       break label$15
      }
      HEAP32[$4 >> 2] = $8;
     }
     if (global$2 ? ($5 | 0) == 5 : 1) {
      ProgramFail($0, 4412, $4);
      $6 = 5;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      break label$15
     }
    }
    $3 = global$2 ? $3 : HEAP32[$7 + 1304 >> 2];
    if ($3 | (global$2 | 0) == 2) {
     if (global$2 ? ($5 | 0) == 6 : 1) {
      ProgramFail($0, 4436, 0);
      $6 = 6;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (global$2 ? ($5 | 0) == 7 : 1) {
     $2 = LexGetToken($0, 0, 1);
     $6 = 7;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $3 = $2;
    }
    if (!global$2) {
     HEAP32[HEAP32[$1 >> 2] + 32 >> 2] = $7;
     HEAP32[$4 + 32 >> 2] = 0;
     HEAP32[$4 + 36 >> 2] = 0;
     HEAP32[$4 + 24 >> 2] = 0;
     HEAP32[$4 + 28 >> 2] = 0;
     HEAP32[$4 + 16 >> 2] = 0;
     HEAP32[$4 + 20 >> 2] = 0;
     HEAP32[$4 + 16 >> 2] = $9;
     $1 = $4 + 12 | 0;
     HEAP32[$4 + 20 >> 2] = $1;
    }
    while (1) {
     $1 = global$2 ? $1 : $4 + 44 | 0;
     if (global$2 ? ($5 | 0) == 8 : 1) {
      $2 = LexGetToken($0, $1, 1);
      $6 = 8;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $2;
     }
     $1 = global$2 ? $1 : ($1 | 0) != 45;
     if ($1 | (global$2 | 0) == 2) {
      if (global$2 ? ($5 | 0) == 9 : 1) {
       ProgramFail($0, 4473, 0);
       $6 = 9;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     if (!global$2) {
      $1 = HEAP32[HEAP32[$4 + 44 >> 2] + 4 >> 2];
      $3 = HEAP32[$1 >> 2];
     }
     if (global$2 ? ($5 | 0) == 10 : 1) {
      $2 = LexGetToken($0, 0, 0);
      $6 = 10;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $2;
     }
     $1 = global$2 ? $1 : ($1 | 0) == 2;
     if ($1 | (global$2 | 0) == 2) {
      if (global$2 ? ($5 | 0) == 11 : 1) {
       $2 = LexGetToken($0, 0, 1);
       $6 = 11;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $1 = $2;
      }
      if (global$2 ? ($5 | 0) == 12 : 1) {
       $2 = ExpressionParseInt($0);
       $6 = 12;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $1 = $2;
      }
      if (!global$2) {
       HEAP32[$4 + 12 >> 2] = $1
      }
     }
     $1 = global$2 ? $1 : $4 + 16 | 0;
     if (global$2 ? ($5 | 0) == 13 : 1) {
      $2 = VariableDefine($7, $0, $3, $1, 0, 0);
      $6 = 13;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $2;
     }
     $11 = $3;
     if (global$2 ? ($5 | 0) == 14 : 1) {
      $2 = LexGetToken($0, 0, 1);
      $6 = 14;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $2;
     }
     $3 = global$2 ? $11 : ($1 | 0) == 1;
     if (!(($1 | 0) == 53 | $3 ? !global$2 : 0)) {
      if (global$2 ? ($5 | 0) == 15 : 1) {
       ProgramFail($0, 4493, 0);
       $6 = 15;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     if (!global$2) {
      $1 = HEAP32[$4 + 12 >> 2] + 1 | 0;
      HEAP32[$4 + 12 >> 2] = $1;
      if ($3) {
       continue
      }
     }
     break;
    };
   }
   if (!global$2) {
    global$0 = $4 + 48 | 0
   }
   return;
  }
  $2 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 8 >> 2] = $3;
  HEAP32[$2 + 12 >> 2] = $4;
  HEAP32[$2 + 16 >> 2] = $7;
  HEAP32[$2 + 20 >> 2] = $8;
  HEAP32[$2 + 24 >> 2] = $9;
  HEAP32[$2 + 28 >> 2] = $10;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 32;
 }
 
 function TypeParseBack($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $3 = HEAP32[$2 + 8 >> 2];
   $6 = HEAP32[$2 + 12 >> 2];
   $7 = HEAP32[$2 + 16 >> 2];
   $8 = HEAP32[$2 + 20 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $7 = global$0 - 48 | 0;
   global$0 = $7;
   ParserCopy($7, $0);
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $2 = LexGetToken($0, 0, 1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $2;
   }
   $3 = global$2 ? $3 : ($3 | 0) == 39;
   label$5 : {
    if ($3 | (global$2 | 0) == 2) {
     if (global$2 ? ($4 | 0) == 1 : 1) {
      $2 = LexGetToken($0, 0, 0);
      $5 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $2;
     }
     $3 = global$2 ? $3 : ($3 | 0) == 40;
     if ($3 | (global$2 | 0) == 2) {
      if (global$2 ? ($4 | 0) == 2 : 1) {
       $2 = LexGetToken($0, 0, 1);
       $5 = 2;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $3 = $2;
      }
      $3 = global$2 ? $3 : HEAP32[$0 >> 2];
      if (global$2 ? ($4 | 0) == 3 : 1) {
       $2 = TypeParseBack($0, $1);
       $5 = 3;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $1 = $2;
      }
      $6 = global$2 ? $6 : HEAP32[HEAP32[$0 >> 2] + 2756 >> 2];
      if (global$2 ? ($4 | 0) == 4 : 1) {
       $2 = TypeGetMatching($3, $0, $1, 12, 0, $6, 1);
       $5 = 4;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $1 = $2;
      }
      if (!global$2) {
       break label$5
      }
     }
     if (!global$2) {
      $3 = HEAP32[$0 + 16 >> 2];
      HEAP32[$0 + 16 >> 2] = 0;
     }
     if (global$2 ? ($4 | 0) == 5 : 1) {
      $2 = ExpressionParseInt($0);
      $5 = 5;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $6 = $2;
     }
     if (!global$2) {
      HEAP32[$0 + 16 >> 2] = $3
     }
     if (global$2 ? ($4 | 0) == 6 : 1) {
      $2 = LexGetToken($0, 0, 1);
      $5 = 6;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $2;
     }
     $3 = global$2 ? $3 : ($3 | 0) != 40;
     if ($3 | (global$2 | 0) == 2) {
      if (global$2 ? ($4 | 0) == 7 : 1) {
       ProgramFail($0, 4529, 0);
       $5 = 7;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     $3 = global$2 ? $3 : HEAP32[$0 >> 2];
     if (global$2 ? ($4 | 0) == 8 : 1) {
      $2 = TypeParseBack($0, $1);
      $5 = 8;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $2;
     }
     $8 = global$2 ? $8 : HEAP32[HEAP32[$0 >> 2] + 2756 >> 2];
     if (global$2 ? ($4 | 0) == 9 : 1) {
      $2 = TypeGetMatching($3, $0, $1, 13, $6, $8, 1);
      $5 = 9;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $2;
     }
     if (!global$2) {
      break label$5
     }
    }
    if (!global$2) {
     ParserCopy($0, $7)
    }
   }
   if (!global$2) {
    global$0 = $7 + 48 | 0;
    return $1;
   }
   abort();
  }
  $2 = $5;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 8 >> 2] = $3;
  HEAP32[$2 + 12 >> 2] = $6;
  HEAP32[$2 + 16 >> 2] = $7;
  HEAP32[$2 + 20 >> 2] = $8;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  return 0;
 }
 
 function TypeIsForwardDeclared($0, $1) {
  var $2 = 0;
  label$1 : {
   $2 = HEAP32[$1 >> 2] + -13 | 0;
   if ($2 >>> 0 > 2) {
    break label$1
   }
   label$2 : {
    switch ($2 - 1 | 0) {
    default:
     return TypeIsForwardDeclared($0, HEAP32[$1 + 20 >> 2]);
    case 0:
    case 1:
     break label$2;
    };
   }
   if (HEAP32[$1 + 32 >> 2]) {
    break label$1
   }
   return 1;
  }
  return 0;
 }
 
 function VariableInit($0) {
  TableInitTable($0, $0 + 12 | 0, 97, 1);
  TableInitTable($0 + 908 | 0, $0 + 916 | 0, 97, 1);
  HEAP32[$0 + 1304 >> 2] = 0;
 }
 
 function VariableFree($0, $1) {
  var $2 = 0;
  label$1 : {
   if (HEAPU8[$1 + 14 | 0] ? 0 : !HEAPU8[$1 + 12 | 0]) {
    break label$1
   }
   label$3 : {
    if (HEAP32[$1 >> 2] != ($0 + 1896 | 0)) {
     break label$3
    }
    $2 = HEAP32[$1 + 4 >> 2];
    if (HEAP32[$2 + 20 >> 2]) {
     break label$3
    }
    $2 = HEAP32[$2 + 28 >> 2];
    if (!$2) {
     break label$3
    }
    HeapFreeMem($0, $2);
   }
   if (HEAP32[$1 >> 2] == ($0 + 1940 | 0)) {
    HeapFreeMem($0, HEAP32[HEAP32[$1 + 4 >> 2] + 12 >> 2])
   }
   if (!HEAPU8[$1 + 14 | 0]) {
    break label$1
   }
   HeapFreeMem($0, HEAP32[$1 + 4 >> 2]);
  }
  if (HEAPU8[$1 + 12 | 0]) {
   HeapFreeMem($0, $1)
  }
 }
 
 function VariableTableCleanup($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  if (HEAP16[$1 >> 1] >= 1) {
   while (1) {
    $2 = HEAP32[HEAP32[$1 + 4 >> 2] + ($3 << 2) >> 2];
    if ($2) {
     while (1) {
      $4 = HEAP32[$2 >> 2];
      VariableFree($0, HEAP32[$2 + 16 >> 2]);
      HeapFreeMem($0, $2);
      $2 = $4;
      if ($2) {
       continue
      }
      break;
     }
    }
    $3 = $3 + 1 | 0;
    if (($3 | 0) < HEAP16[$1 >> 1]) {
     continue
    }
    break;
   }
  }
 }
 
 function VariableCleanup($0) {
  VariableTableCleanup($0, $0);
  VariableTableCleanup($0, $0 + 908 | 0);
 }
 
 function VariableAlloc($0, $1, $2, $3) {
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   label$5 : {
    if ($3) {
     $3 = HeapAllocMem($0, $2);
     break label$5;
    }
    $3 = HeapAllocStack($0, $2);
   }
   $0 = !$3;
  }
  label$2 : {
   if ((global$2 | 0) == 2 | $0) {
    if (global$2 ? !$4 : 1) {
     ProgramFail($1, 4555, 0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    return $3
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function VariableAllocValueAndData($0, $1, $2, $3, $4, $5) {
  var $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $5 = HEAP32[$5 + 20 >> 2];
  }
  $2 = global$2 ? $2 : $2 + 24 | 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $6 = 0
  }
  label$2 : {
   if (global$2 ? !$6 : 1) {
    $6 = VariableAlloc($0, $1, $2, $5);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $6;
   }
   if (!global$2) {
    HEAP8[$0 + 14 | 0] = 0;
    HEAP8[$0 + 12 | 0] = $5;
    HEAP8[$0 + 15 | 0] = $3;
    HEAP8[$0 + 13 | 0] = !$5;
    HEAP32[$0 + 8 >> 2] = $4;
    HEAP32[$0 + 4 >> 2] = $0 + 24;
    if ($1) {
     HEAP32[$0 + 16 >> 2] = HEAP32[$1 + 40 >> 2]
    }
    HEAP8[$0 + 20 | 0] = 0;
    return $0;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $4;
  HEAP32[$6 + 20 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  return 0;
 }
 
 function VariableAllocValueFromType($0, $1, $2, $3, $4, $5) {
  var $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -28;
   $6 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$6 >> 2];
   $1 = HEAP32[$6 + 4 >> 2];
   $2 = HEAP32[$6 + 8 >> 2];
   $3 = HEAP32[$6 + 12 >> 2];
   $4 = HEAP32[$6 + 16 >> 2];
   $5 = HEAP32[$6 + 20 >> 2];
   $6 = HEAP32[$6 + 24 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $7 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = TypeSize($2, HEAP32[$2 + 4 >> 2], 0)
  }
  label$2 : {
   if (global$2 ? !$7 : 1) {
    $7 = VariableAllocValueAndData($0, $1, $6, $3, $4, $5);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $7;
   }
   if (!global$2) {
    if (!(($0 + 1808 | 0) == ($2 | 0) | ($6 | 0) > -1)) {
     __assert_fail(4569, 4603, 111, 4614);
     abort();
    }
    HEAP32[$1 >> 2] = $2;
    return $1;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $7 = HEAP32[global$3 >> 2];
  HEAP32[$7 >> 2] = $0;
  HEAP32[$7 + 4 >> 2] = $1;
  HEAP32[$7 + 8 >> 2] = $2;
  HEAP32[$7 + 12 >> 2] = $3;
  HEAP32[$7 + 16 >> 2] = $4;
  HEAP32[$7 + 20 >> 2] = $5;
  HEAP32[$7 + 24 >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 28;
  return 0;
 }
 
 function VariableAllocValueAndCopy($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -32;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $6 = HEAP32[$4 + 16 >> 2];
   $7 = HEAP32[$4 + 20 >> 2];
   $8 = HEAP32[$4 + 24 >> 2];
   $4 = HEAP32[$4 + 28 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = global$0 - 256 | 0;
   global$0 = $6;
   $8 = HEAP32[$2 >> 2];
   $7 = TypeSizeValue($2, 1);
   if (($7 | 0) >= 257) {
    __assert_fail(4641, 4603, 125, 4670);
    abort();
   }
   $6 = memcpy($6, HEAP32[$2 + 4 >> 2], $7);
   $4 = HEAP8[$2 + 15 | 0];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = VariableAllocValueAndData($0, $1, $7, $4, $2, $3);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if (!global$2) {
    HEAP32[$2 >> 2] = $8;
    memcpy(HEAP32[$2 + 4 >> 2], $6, $7);
    global$0 = $6 + 256 | 0;
    return $2;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $6;
  HEAP32[$5 + 20 >> 2] = $7;
  HEAP32[$5 + 24 >> 2] = $8;
  HEAP32[$5 + 28 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 32;
  return 0;
 }
 
 function VariableAllocValueFromExistingData($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $5 = HEAP32[$5 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $5 = global$2 ? $5 : HEAP32[$0 >> 2];
  label$2 : {
   if (global$2 ? !$6 : 1) {
    $6 = VariableAlloc($5, $0, 24, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $6;
   }
   if (!global$2) {
    HEAP8[$0 + 14 | 0] = 0;
    HEAP32[$0 + 4 >> 2] = $2;
    HEAP32[$0 >> 2] = $1;
    HEAP8[$0 + 15 | 0] = $3;
    HEAP16[$0 + 12 >> 1] = 0;
    HEAP32[$0 + 8 >> 2] = $4;
    return $0;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $4;
  HEAP32[$6 + 20 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  return 0;
 }
 
 function VariableAllocValueShared($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $4 = HEAP32[$2 + 8 >> 2];
   $5 = HEAP32[$2 + 12 >> 2];
   $2 = HEAP32[$2 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $4 = HEAP32[$1 >> 2];
   $5 = HEAP32[$1 + 4 >> 2];
   $2 = HEAP8[$1 + 15 | 0];
   $1 = $2 ? $1 : 0;
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    $3 = VariableAllocValueFromExistingData($0, $4, $5, $2, $1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $3;
   }
   if (!global$2) {
    return $0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $4;
  HEAP32[$3 + 12 >> 2] = $5;
  HEAP32[$3 + 16 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
  return 0;
 }
 
 function VariableRealloc($0, $1, $2) {
  var $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   if (HEAPU8[$1 + 14 | 0]) {
    HeapFreeMem(HEAP32[$0 >> 2], HEAP32[$1 + 4 >> 2])
   }
   $3 = HEAP32[$0 >> 2];
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = VariableAlloc($3, $0, $2, 1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $4;
   }
   if (!global$2) {
    HEAP8[$1 + 14 | 0] = 1;
    HEAP32[$1 + 4 >> 2] = $0;
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function VariableScopeBegin($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $4 = HEAP32[$0 + 40 >> 2];
  if (($4 | 0) != -1) {
   $3 = HEAP32[$0 >> 2];
   $2 = HEAP32[$3 + 1304 >> 2];
   HEAP32[$1 >> 2] = $4;
   HEAP32[$0 + 40 >> 2] = Math_imul(HEAP32[$0 + 28 >> 2], HEAP32[$0 + 4 >> 2] >>> 2 | 0);
   $5 = $2 ? $2 + 60 | 0 : $3;
   if (HEAP16[$5 >> 1] >= 1) {
    $3 = 0;
    while (1) {
     $2 = HEAP32[HEAP32[$5 + 4 >> 2] + ($3 << 2) >> 2];
     if ($2) {
      while (1) {
       $1 = $2;
       $2 = HEAP32[$2 >> 2];
       $4 = HEAP32[$1 + 16 >> 2];
       if (!(HEAP32[$4 + 16 >> 2] != HEAP32[$0 + 40 >> 2] | !HEAPU8[$4 + 20 | 0])) {
        HEAP8[$4 + 20 | 0] = 0;
        HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] & -2;
       }
       if ($2) {
        continue
       }
       break;
      }
     }
     $3 = $3 + 1 | 0;
     if (($3 | 0) < HEAP16[$5 >> 1]) {
      continue
     }
     break;
    };
   }
   $0 = HEAP32[$0 + 40 >> 2];
  } else {
   $0 = -1
  }
  return $0;
 }
 
 function VariableScopeEnd($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if (($1 | 0) != -1) {
   $3 = HEAP32[$0 >> 2];
   $4 = HEAP32[$3 + 1304 >> 2];
   $5 = $4 ? $4 + 60 | 0 : $3;
   if (HEAP16[$5 >> 1] >= 1) {
    while (1) {
     $3 = HEAP32[HEAP32[$5 + 4 >> 2] + ($6 << 2) >> 2];
     if ($3) {
      while (1) {
       $4 = $3;
       $3 = HEAP32[$4 >> 2];
       $7 = HEAP32[$4 + 16 >> 2];
       if (!(HEAP32[$7 + 16 >> 2] != ($1 | 0) | HEAPU8[$7 + 20 | 0])) {
        HEAP8[$7 + 20 | 0] = 1;
        HEAP32[$4 + 12 >> 2] = HEAP32[$4 + 12 >> 2] | 1;
       }
       if ($3) {
        continue
       }
       break;
      }
     }
     $6 = $6 + 1 | 0;
     if (($6 | 0) < HEAP16[$5 >> 1]) {
      continue
     }
     break;
    }
   }
   HEAP32[$0 + 40 >> 2] = $2;
  }
 }
 
 function VariableDefinedAndOutOfScope($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $2 = HEAP32[$0 + 1304 >> 2];
  $3 = $2 ? $2 + 60 | 0 : $0;
  if (HEAP16[$3 >> 1] >= 1) {
   $4 = HEAP32[$3 + 4 >> 2];
   $2 = 0;
   while (1) {
    $0 = HEAP32[($2 << 2) + $4 >> 2];
    if ($0) {
     while (1) {
      if (!(!HEAPU8[HEAP32[$0 + 16 >> 2] + 20 | 0] | (HEAP32[$0 + 12 >> 2] & -2) != ($1 | 0))) {
       return 1
      }
      $0 = HEAP32[$0 >> 2];
      if ($0) {
       continue
      }
      break;
     }
    }
    $2 = $2 + 1 | 0;
    if (($2 | 0) < HEAP16[$3 >> 1]) {
     continue
    }
    break;
   };
  }
  return 0;
 }
 
 function VariableDefine($0, $1, $2, $3, $4, $5) {
  var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -44;
   $6 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$6 >> 2];
   $2 = HEAP32[$6 + 8 >> 2];
   $3 = HEAP32[$6 + 12 >> 2];
   $4 = HEAP32[$6 + 16 >> 2];
   $5 = HEAP32[$6 + 20 >> 2];
   $7 = HEAP32[$6 + 24 >> 2];
   $10 = HEAP32[$6 + 28 >> 2];
   $8 = HEAP32[$6 + 32 >> 2];
   $9 = HEAP32[$6 + 36 >> 2];
   $12 = HEAP32[$6 + 40 >> 2];
   $1 = HEAP32[$6 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $11 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $9 = global$0 - 16 | 0;
   global$0 = $9;
   $8 = HEAP32[$0 + 1304 >> 2];
   $7 = !$8;
   $10 = $1 ? HEAP32[$1 + 40 >> 2] : -1;
  }
  label$2 : {
   label$7 : {
    if ((global$2 | 0) == 2 | $3) {
     if (global$2 ? !$11 : 1) {
      $6 = VariableAllocValueAndCopy($0, $1, $3, $7);
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $6;
     }
     if (!global$2) {
      break label$7
     }
    }
    if (global$2 ? ($11 | 0) == 1 : 1) {
     $6 = VariableAllocValueFromType($0, $1, $4, $5, 0, $7);
     $13 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $3 = $6;
    }
   }
   if (!global$2) {
    $7 = 0;
    HEAP8[$3 + 20 | 0] = 0;
    HEAP32[$3 + 16 >> 2] = $10;
    HEAP8[$3 + 15 | 0] = $5;
    $5 = 0;
    $4 = $0;
    $8 = $8 ? $8 + 60 | 0 : $0;
    $0 = $2;
    $12 = $3;
    $5 = $1 ? HEAP32[$1 + 8 >> 2] : $5;
    $7 = $1 ? HEAP16[$1 + 12 >> 1] : $7;
    $10 = $1 ? HEAP16[$1 + 14 >> 1] : 0;
   }
   if (global$2 ? ($11 | 0) == 2 : 1) {
    $6 = TableSet($4, $8, $0, $12, $5, $7, $10);
    $13 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $6;
   }
   if ((global$2 | 0) == 2 | (global$2 ? $0 : !$0)) {
    if (!global$2) {
     HEAP32[$9 >> 2] = $2
    }
    if (global$2 ? ($11 | 0) == 3 : 1) {
     ProgramFail($1, 4696, $9);
     $13 = 3;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    global$0 = $9 + 16 | 0;
    return $3;
   }
   abort();
  }
  $6 = $13;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $4;
  HEAP32[$6 + 20 >> 2] = $5;
  HEAP32[$6 + 24 >> 2] = $7;
  HEAP32[$6 + 28 >> 2] = $10;
  HEAP32[$6 + 32 >> 2] = $8;
  HEAP32[$6 + 36 >> 2] = $9;
  HEAP32[$6 + 40 >> 2] = $12;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 44;
  return 0;
 }
 
 function VariableDefineButIgnoreIdentical($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -40;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $6 = HEAP32[$5 + 20 >> 2];
   $7 = HEAP32[$5 + 24 >> 2];
   $8 = HEAP32[$5 + 28 >> 2];
   $9 = HEAP32[$5 + 32 >> 2];
   $10 = HEAP32[$5 + 36 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $11 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = global$0 - 288 | 0;
   global$0 = $6;
   $8 = HEAP32[$0 >> 2];
   $7 = TypeIsForwardDeclared($0, $2);
  }
  label$2 : {
   if ((global$2 | 0) == 2 | $7) {
    if (!global$2) {
     HEAP32[$6 >> 2] = $2
    }
    if (global$2 ? !$11 : 1) {
     ProgramFail($0, 4720, $6);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   label$8 : {
    if ((global$2 | 0) == 2 | $3) {
     if (!global$2) {
      memset($6 + 16 | 0, 0, 256);
      HEAP8[$6 + 16 | 0] = 47;
      $3 = strncpy($6 + 16 | 1, HEAP32[$0 + 8 >> 2], 254);
      $7 = strlen($3);
      $3 = $3 + $7 | 0;
      $7 = $6 + 271 | 0;
      $5 = $7;
      $9 = HEAP32[$8 + 1304 >> 2];
      if ($9) {
       if (($7 - $3 | 0) >= 1) {
        HEAP8[$3 | 0] = 47;
        $3 = $3 + 1 | 0;
       }
       $3 = strncpy($3, HEAP32[HEAP32[$8 + 1304 >> 2] + 44 >> 2], $7 - $3 | 0);
       $9 = strlen($3);
       $3 = $3 + $9 | 0;
      }
      $10 = ($5 - $3 | 0) >= 1;
      if ($10) {
       HEAP8[$3 | 0] = 47;
       $3 = $3 + 1 | 0;
      }
      $7 = $7 - $3 | 0;
      strncpy($3, $1, $7);
      $3 = $6 + 16 | 0;
     }
     if (global$2 ? ($11 | 0) == 1 : 1) {
      $5 = TableStrRegister($8, $3);
      $12 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $5;
     }
     if (!global$2) {
      $10 = $6 + 280 | 0;
      $9 = $6 + 276 | 0;
      $7 = !TableGet($8, $3, $6 + 284 | 0, $10, $9, $6 + 272 | 0);
     }
     if ((global$2 | 0) == 2 | $7) {
      $7 = global$2 ? $7 : HEAP32[$0 >> 2];
      if (global$2 ? ($11 | 0) == 2 : 1) {
       $5 = VariableAllocValueFromType($7, $0, $2, 1, 0, 1);
       $12 = 2;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $2 = $5;
      }
      if (!global$2) {
       HEAP32[$6 + 284 >> 2] = $2;
       $10 = HEAP16[$0 + 12 >> 1];
       $9 = HEAP16[$0 + 14 >> 1];
       $7 = HEAP32[$0 + 8 >> 2];
      }
      if (global$2 ? ($11 | 0) == 3 : 1) {
       $5 = TableSet($8, $8, $3, $2, $7, $10, $9);
       $12 = 3;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $2 = $5;
      }
      if (!global$2) {
       HEAP32[$4 >> 2] = 1
      }
     }
     if (!global$2) {
      $3 = HEAP32[$6 + 284 >> 2];
      $4 = HEAP32[$3 >> 2];
      $3 = HEAP32[$3 + 4 >> 2];
      $2 = HEAP32[$0 >> 2];
     }
     if (global$2 ? ($11 | 0) == 4 : 1) {
      VariableDefinePlatformVar($2, $0, $1, $4, $3, 1);
      $12 = 4;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     $5 = HEAP32[$6 + 284 >> 2];
     if (!global$2) {
      break label$8
     }
    }
    if (!global$2) {
     label$29 : {
      if (!HEAPU16[$0 + 12 >> 1]) {
       break label$29
      }
      $3 = HEAP32[$8 + 1304 >> 2];
      if (!TableGet($3 ? $3 + 60 | 0 : $8, $1, $6 + 284 | 0, $6 + 280 | 0, $6 + 276 | 0, $6 + 272 | 0) | HEAP32[$6 + 280 >> 2] != HEAP32[$0 + 8 >> 2] | (HEAP32[$6 + 276 >> 2] != HEAP16[$0 + 12 >> 1] | HEAP32[$6 + 272 >> 2] != HEAP16[$0 + 14 >> 1])) {
       break label$29
      }
      $5 = HEAP32[$6 + 284 >> 2];
      break label$8;
     }
     $3 = HEAP32[$0 >> 2];
    }
    if (global$2 ? ($11 | 0) == 5 : 1) {
     $5 = VariableDefine($3, $0, $1, 0, $2, 1);
     $12 = 5;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $0 = $5;
    }
    $5 = $0;
   }
   $0 = $5;
   if (!global$2) {
    global$0 = $6 + 288 | 0;
    return $0;
   }
   abort();
  }
  $5 = $12;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[$5 + 20 >> 2] = $6;
  HEAP32[$5 + 24 >> 2] = $7;
  HEAP32[$5 + 28 >> 2] = $8;
  HEAP32[$5 + 32 >> 2] = $9;
  HEAP32[$5 + 36 >> 2] = $10;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 40;
  return 0;
 }
 
 function VariableDefinePlatformVar($0, $1, $2, $3, $4, $5) {
  var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -40;
   $6 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$6 >> 2];
   $2 = HEAP32[$6 + 8 >> 2];
   $3 = HEAP32[$6 + 12 >> 2];
   $4 = HEAP32[$6 + 16 >> 2];
   $5 = HEAP32[$6 + 20 >> 2];
   $8 = HEAP32[$6 + 24 >> 2];
   $7 = HEAP32[$6 + 28 >> 2];
   $9 = HEAP32[$6 + 32 >> 2];
   $11 = HEAP32[$6 + 36 >> 2];
   $1 = HEAP32[$6 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $10 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $7 = global$0 - 16 | 0;
   global$0 = $7;
   $8 = 0;
  }
  label$2 : {
   if (global$2 ? !$10 : 1) {
    $6 = VariableAllocValueAndData($0, 0, 0, $5, 0, 1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $5 = $6;
   }
   if (!global$2) {
    HEAP32[$5 + 4 >> 2] = $4;
    HEAP32[$5 >> 2] = $3;
    $4 = 0;
    $11 = $0;
    $3 = HEAP32[$0 + 1304 >> 2];
    $9 = $3 + 60 | 0;
    $3 = $3 ? $9 : $0;
   }
   if (global$2 ? ($10 | 0) == 1 : 1) {
    $6 = TableStrRegister($0, $2);
    $12 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $9 = $6;
   }
   if (!global$2) {
    $4 = $1 ? HEAP32[$1 + 8 >> 2] : $4;
    $8 = $1 ? HEAP16[$1 + 12 >> 1] : $8;
    $0 = $1 ? HEAP16[$1 + 14 >> 1] : 0;
   }
   if (global$2 ? ($10 | 0) == 2 : 1) {
    $6 = TableSet($11, $3, $9, $5, $4, $8, $0);
    $12 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $6;
   }
   if ((global$2 | 0) == 2 | (global$2 ? $0 : !$0)) {
    if (!global$2) {
     HEAP32[$7 >> 2] = $2
    }
    if (global$2 ? ($10 | 0) == 3 : 1) {
     ProgramFail($1, 4696, $7);
     $12 = 3;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    global$0 = $7 + 16 | 0
   }
   return;
  }
  $6 = $12;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $4;
  HEAP32[$6 + 20 >> 2] = $5;
  HEAP32[$6 + 24 >> 2] = $8;
  HEAP32[$6 + 28 >> 2] = $7;
  HEAP32[$6 + 32 >> 2] = $9;
  HEAP32[$6 + 36 >> 2] = $11;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 40;
 }
 
 function VariableDefined($0, $1) {
  var $2 = 0, $3 = 0;
  $3 = global$0 - 16 | 0;
  global$0 = $3;
  $2 = HEAP32[$0 + 1304 >> 2];
  label$1 : {
   label$2 : {
    if ($2) {
     if (TableGet($2 + 60 | 0, $1, $3 + 12 | 0, 0, 0, 0)) {
      break label$2
     }
    }
    $0 = !TableGet($0, $1, $3 + 12 | 0, 0, 0, 0);
    $2 = 0;
    if ($0) {
     break label$1
    }
   }
   $2 = 1;
  }
  global$0 = $3 + 16 | 0;
  return $2;
 }
 
 function VariableGet($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $6 = HEAP32[$4 + 16 >> 2];
   $4 = HEAP32[$4 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = global$0 - 32 | 0;
   global$0 = $6;
   $4 = HEAP32[$0 + 1304 >> 2];
  }
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($4) {
      if (TableGet($4 + 60 | 0, $2, $3, 0, 0, 0)) {
       break label$5
      }
     }
     if (TableGet($0, $2, $3, 0, 0, 0)) {
      break label$5
     }
     $0 = VariableDefinedAndOutOfScope($0, $2);
    }
    if ((global$2 | 0) == 2 | $0) {
     if (!global$2) {
      HEAP32[$6 + 16 >> 2] = $2;
      $0 = $6 + 16 | 0;
     }
     if (global$2 ? !$5 : 1) {
      ProgramFail($1, 4744, $0);
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      break label$5
     }
    }
    if (!global$2) {
     HEAP32[$6 >> 2] = $2
    }
    if (global$2 ? ($5 | 0) == 1 : 1) {
     ProgramFail($1, 4765, $6);
     $7 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    global$0 = $6 + 32 | 0
   }
   return;
  }
  $5 = $7;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $6;
  HEAP32[$5 + 20 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
 }
 
 function VariableStackPop($0, $1) {
  var $2 = 0, $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if (!global$2) {
    label$5 : {
     if (HEAPU8[$1 + 12 | 0]) {
      $2 = HEAP32[$1 + 4 >> 2];
      if ($2) {
       HeapFreeMem(HEAP32[$0 >> 2], $2)
      }
      $1 = HeapPopStack(HEAP32[$0 >> 2], $1, 24);
      break label$5;
     }
     $2 = HEAP32[$0 >> 2];
     if (HEAPU8[$1 + 13 | 0]) {
      $1 = HeapPopStack($2, $1, TypeSizeValue($1, 0) + 24 | 0);
      break label$5;
     }
     $1 = HeapPopStack($2, $1, 24);
    }
    $1 = !$1;
   }
   if ((global$2 | 0) == 2 | $1) {
    if (global$2 ? !$3 : 1) {
     ProgramFail($0, 4783, 0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
 }
 
 function VariableStackFrameAdd($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $4 = HEAP32[$4 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if (!global$2) {
    HeapPushStackFrame(HEAP32[$0 >> 2]);
    $3 = HeapAllocStack(HEAP32[$0 >> 2], ($2 << 2) + 116 | 0);
    $4 = !$3;
   }
   if ((global$2 | 0) == 2 | $4) {
    if (global$2 ? !$5 : 1) {
     ProgramFail($0, 4555, 0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    ParserCopy($3, $0);
    HEAP32[$3 + 44 >> 2] = $1;
    HEAP32[$3 + 52 >> 2] = ($2 | 0) > 0 ? $3 + 116 | 0 : 0;
    TableInitTable($3 + 60 | 0, $3 + 68 | 0, 11, 0);
    $0 = HEAP32[$0 >> 2];
    HEAP32[$3 + 112 >> 2] = HEAP32[$0 + 1304 >> 2];
    HEAP32[$0 + 1304 >> 2] = $3;
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function VariableStackFramePop($0) {
  var $1 = 0, $2 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2 | (global$2 ? $1 : !HEAP32[HEAP32[$0 >> 2] + 1304 >> 2])) {
    if (global$2 ? !$2 : 1) {
     ProgramFail($0, 4798, 0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    ParserCopy($0, HEAP32[HEAP32[$0 >> 2] + 1304 >> 2]);
    $0 = HEAP32[$0 >> 2];
    $1 = HEAP32[HEAP32[$0 + 1304 >> 2] + 112 >> 2];
    HEAP32[$0 + 1304 >> 2] = $1;
    HeapPopStackFrame($0);
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function VariableStringLiteralGet($0, $1) {
  var $2 = 0;
  $2 = global$0 - 16 | 0;
  global$0 = $2;
  HEAP32[$2 + 12 >> 2] = 0;
  $1 = TableGet($0 + 908 | 0, $1, $2 + 12 | 0, 0, 0, 0);
  global$0 = $2 + 16 | 0;
  $0 = HEAP32[$2 + 12 >> 2];
  return $1 ? $0 : 0;
 }
 
 function VariableStringLiteralDefine($0, $1, $2) {
  var $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  } else {
   $3 = 0
  }
  $3 = global$2 ? $3 : $0 + 908 | 0;
  label$1 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   } else {
    $4 = 0
   }
   if (global$2 ? !$4 : 1) {
    TableSet($0, $3, $1, $2, 0, 0, 0);
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function VariableDereferencePointer($0, $1, $2, $3, $4, $5) {
  if ($2) {
   HEAP32[$2 >> 2] = 0
  }
  if ($4) {
   HEAP32[$4 >> 2] = HEAP32[HEAP32[$1 >> 2] + 20 >> 2]
  }
  if ($3) {
   HEAP32[$3 >> 2] = 0
  }
  if ($5) {
   HEAP32[$5 >> 2] = 1
  }
  return HEAP32[HEAP32[$1 + 4 >> 2] >> 2];
 }
 
 function LibraryInit($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $4 = HEAP32[$1 + 8 >> 2];
   $2 = HEAP32[$1 + 4 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   }
   if (global$2 ? !$3 : 1) {
    $1 = TableStrRegister($0, 4829);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $1;
   }
   if (!global$2) {
    HEAP32[$0 + 2200 >> 2] = $2;
    $4 = $0 + 2200 | 0;
    $2 = HEAP32[$0 + 2072 >> 2];
   }
   if (global$2 ? ($3 | 0) == 1 : 1) {
    VariableDefinePlatformVar($0, 0, 4844, $2, $4, 0);
    $5 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    HEAP32[5435] = 1;
    HEAP32[5434] = 0;
    $2 = $0 + 1412 | 0;
   }
   if (global$2 ? ($3 | 0) == 2 : 1) {
    VariableDefinePlatformVar($0, 0, 4858, $2, 21736, 0);
    $5 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($3 | 0) == 3 : 1) {
    VariableDefinePlatformVar($0, 0, 4869, $2, 21740, 0);
    $5 = 3;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  $1 = $5;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP32[$1 + 8 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
 }
 
 function LibraryAdd($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -36;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $6 = HEAP32[$4 + 20 >> 2];
   $7 = HEAP32[$4 + 24 >> 2];
   $8 = HEAP32[$4 + 28 >> 2];
   $9 = HEAP32[$4 + 32 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $10 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $1 = global$0;
   $2 = $1 + -64 | 0;
   global$0 = $2;
  }
  label$2 : {
   if (global$2 ? !$10 : 1) {
    $4 = TableStrRegister($0, 4883);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $9 = $4;
   }
   $1 = global$2 ? $1 : HEAP32[$3 + 4 >> 2];
   if ($1 | (global$2 | 0) == 2) {
    if (!global$2) {
     $7 = 0;
     $5 = $3 + 4 | 0;
    }
    while (1) {
     if (!global$2) {
      $6 = strlen($1)
     }
     if (global$2 ? ($10 | 0) == 1 : 1) {
      $4 = LexAnalyse($0, $9, $1, $6, 0);
      $11 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $4;
     }
     if (!global$2) {
      LexInitParser($2 + 16 | 0, $0, HEAP32[$5 >> 2], $1, $9, 1, 0);
      $6 = $2 + 8 | 0;
      $8 = $2 + 12 | 0;
      $5 = $2 + 16 | 0;
     }
     if (global$2 ? ($10 | 0) == 2 : 1) {
      TypeParse($5, $6, $8, 0);
      $11 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      $6 = HEAP32[$2 + 8 >> 2];
      $8 = HEAP32[$2 + 12 >> 2];
      $5 = $2 + 16 | 0;
     }
     if (global$2 ? ($10 | 0) == 3 : 1) {
      $4 = ParseFunctionDefinition($5, $6, $8);
      $11 = 3;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $5 = $4;
     }
     if (!global$2) {
      $6 = HEAP32[($7 << 3) + $3 >> 2];
      HEAP32[HEAP32[$5 + 4 >> 2] + 20 >> 2] = $6;
      HeapFreeMem($0, $1);
      $7 = $7 + 1 | 0;
      $1 = ($7 << 3) + $3 | 0;
      $5 = $1 + 4 | 0;
      $1 = HEAP32[$1 + 4 >> 2];
      if ($1) {
       continue
      }
     }
     break;
    };
   }
   if (!global$2) {
    global$0 = $2 - -64 | 0
   }
   return;
  }
  $4 = $11;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  HEAP32[$4 + 20 >> 2] = $6;
  HEAP32[$4 + 24 >> 2] = $7;
  HEAP32[$4 + 28 >> 2] = $8;
  HEAP32[$4 + 32 >> 2] = $9;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 36;
 }
 
 function PrintType($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
   $4 = HEAP32[$5 + 8 >> 2];
   $5 = HEAP32[$5 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if (global$2) {
    $6 = $5
   } else {
    $4 = HEAP32[$0 >> 2];
    $6 = $4 >>> 0 <= 18;
   }
   if ($6 | (global$2 | 0) == 2) {
    $4 = global$2 ? $4 : $4 - 1 | 0;
    label$7 : {
     label$8 : {
      label$9 : {
       label$10 : {
        label$11 : {
         label$12 : {
          label$13 : {
           label$14 : {
            label$15 : {
             label$16 : {
              label$17 : {
               label$18 : {
                label$19 : {
                 label$20 : {
                  label$21 : {
                   label$22 : {
                    label$23 : {
                     label$24 : {
                      if (!global$2) {
                       label$26 : {
                        switch ($4 | 0) {
                        case 14:
                         break label$10;
                        case 13:
                         break label$11;
                        case 12:
                         break label$12;
                        case 11:
                         break label$13;
                        case 10:
                         break label$14;
                        case 9:
                         break label$15;
                        case 8:
                         break label$16;
                        case 6:
                         break label$17;
                        case 7:
                         break label$18;
                        case 5:
                         break label$19;
                        case 4:
                         break label$20;
                        case 3:
                         break label$21;
                        case 2:
                         break label$22;
                        case 1:
                         break label$23;
                        case 0:
                         break label$24;
                        case 17:
                         break label$7;
                        case 16:
                         break label$8;
                        case 15:
                         break label$9;
                        default:
                         break label$26;
                        };
                       }
                      }
                      if (global$2 ? !$2 : 1) {
                       PrintStr(4893, $1);
                       if ((global$2 | 0) == 1) {
                        break label$2
                       }
                      }
                      if (!global$2) {
                       return
                      }
                     }
                     if (global$2 ? ($2 | 0) == 1 : 1) {
                      PrintStr(4898, $1);
                      $3 = 1;
                      if ((global$2 | 0) == 1) {
                       break label$2
                      }
                     }
                     if (!global$2) {
                      return
                     }
                    }
                    if (global$2 ? ($2 | 0) == 2 : 1) {
                     PrintStr(4902, $1);
                     $3 = 2;
                     if ((global$2 | 0) == 1) {
                      break label$2
                     }
                    }
                    if (!global$2) {
                     return
                    }
                   }
                   if (global$2 ? ($2 | 0) == 3 : 1) {
                    PrintStr(4908, $1);
                    $3 = 3;
                    if ((global$2 | 0) == 1) {
                     break label$2
                    }
                   }
                   if (!global$2) {
                    return
                   }
                  }
                  if (global$2 ? ($2 | 0) == 4 : 1) {
                   PrintStr(4913, $1);
                   $3 = 4;
                   if ((global$2 | 0) == 1) {
                    break label$2
                   }
                  }
                  if (!global$2) {
                   return
                  }
                 }
                 if (global$2 ? ($2 | 0) == 5 : 1) {
                  PrintStr(4918, $1);
                  $3 = 5;
                  if ((global$2 | 0) == 1) {
                   break label$2
                  }
                 }
                 if (!global$2) {
                  return
                 }
                }
                if (global$2 ? ($2 | 0) == 6 : 1) {
                 PrintStr(4931, $1);
                 $3 = 6;
                 if ((global$2 | 0) == 1) {
                  break label$2
                 }
                }
                if (!global$2) {
                 return
                }
               }
               if (global$2 ? ($2 | 0) == 7 : 1) {
                PrintStr(4946, $1);
                $3 = 7;
                if ((global$2 | 0) == 1) {
                 break label$2
                }
               }
               if (!global$2) {
                return
               }
              }
              if (global$2 ? ($2 | 0) == 8 : 1) {
               PrintStr(4960, $1);
               $3 = 8;
               if ((global$2 | 0) == 1) {
                break label$2
               }
              }
              if (!global$2) {
               return
              }
             }
             if (global$2 ? ($2 | 0) == 9 : 1) {
              PrintStr(4974, $1);
              $3 = 9;
              if ((global$2 | 0) == 1) {
               break label$2
              }
             }
             if (!global$2) {
              return
             }
            }
            if (global$2 ? ($2 | 0) == 10 : 1) {
             PrintStr(4981, $1);
             $3 = 10;
             if ((global$2 | 0) == 1) {
              break label$2
             }
            }
            if (!global$2) {
             return
            }
           }
           if (global$2 ? ($2 | 0) == 11 : 1) {
            PrintStr(4990, $1);
            $3 = 11;
            if ((global$2 | 0) == 1) {
             break label$2
            }
           }
           if (!global$2) {
            return
           }
          }
          $0 = global$2 ? $0 : HEAP32[$0 + 20 >> 2];
          if ($0 | (global$2 | 0) == 2) {
           if (global$2 ? ($2 | 0) == 12 : 1) {
            PrintType($0, $1);
            $3 = 12;
            if ((global$2 | 0) == 1) {
             break label$2
            }
           }
          }
          if (global$2 ? ($2 | 0) == 13 : 1) {
           PrintCh(42, $1);
           $3 = 13;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (!global$2) {
           return
          }
         }
         $4 = global$2 ? $4 : HEAP32[$0 + 20 >> 2];
         if (global$2 ? ($2 | 0) == 14 : 1) {
          PrintType($4, $1);
          $3 = 14;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (global$2 ? ($2 | 0) == 15 : 1) {
          PrintCh(91, $1);
          $3 = 15;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         $0 = global$2 ? $0 : HEAP32[$0 + 4 >> 2];
         if ($0 | (global$2 | 0) == 2) {
          if (global$2 ? ($2 | 0) == 16 : 1) {
           PrintSimpleInt($0, $1);
           $3 = 16;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
         }
         if (global$2 ? ($2 | 0) == 17 : 1) {
          PrintCh(93, $1);
          $3 = 17;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          return
         }
        }
        if (global$2 ? ($2 | 0) == 18 : 1) {
         PrintStr(4996, $1);
         $3 = 18;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        $0 = global$2 ? $0 : HEAP32[$0 + 16 >> 2];
        if (global$2 ? ($2 | 0) == 19 : 1) {
         PrintStr($0, $1);
         $3 = 19;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         return
        }
       }
       if (global$2 ? ($2 | 0) == 20 : 1) {
        PrintStr(5004, $1);
        $3 = 20;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       $0 = global$2 ? $0 : HEAP32[$0 + 16 >> 2];
       if (global$2 ? ($2 | 0) == 21 : 1) {
        PrintStr($0, $1);
        $3 = 21;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        return
       }
      }
      if (global$2 ? ($2 | 0) == 22 : 1) {
       PrintStr(5011, $1);
       $3 = 22;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      $0 = global$2 ? $0 : HEAP32[$0 + 16 >> 2];
      if (global$2 ? ($2 | 0) == 23 : 1) {
       PrintStr($0, $1);
       $3 = 23;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       return
      }
     }
     if (global$2 ? ($2 | 0) == 24 : 1) {
      PrintStr(5017, $1);
      $3 = 24;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      return
     }
    }
    if (global$2 ? ($2 | 0) == 25 : 1) {
     PrintStr(5029, $1);
     $3 = 25;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   return;
  }
  $2 = $3;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 8 >> 2] = $4;
  HEAP32[$2 + 12 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function PicocInitialise($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = memset($0, 0, 2760);
   PlatformInit($0);
   BasicIOInit($0);
   HeapInit($0, $1);
  }
  label$2 : {
   if (global$2 ? !$2 : 1) {
    TableInit($0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    VariableInit($0)
   }
   if (global$2 ? ($2 | 0) == 1 : 1) {
    LexInit($0);
    $3 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 2 : 1) {
    TypeInit($0);
    $3 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 3 : 1) {
    IncludeInit($0);
    $3 = 3;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 4 : 1) {
    LibraryInit($0);
    $3 = 4;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 5 : 1) {
    PlatformLibraryInit($0);
    $3 = 5;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    DebugInit($0)
   }
   return;
  }
  $2 = $3;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function PicocCleanup($0) {
  $0 = $0 | 0;
  var $1 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $0 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $1 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   DebugCleanup($0);
   IncludeCleanup($0);
   ParseCleanup($0);
  }
  label$2 : {
   if (global$2 ? !$1 : 1) {
    LexCleanup($0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    VariableCleanup($0);
    TypeCleanup($0);
    TableStrFree($0);
    HeapCleanup($0);
    PlatformCleanup($0);
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
 }
 
 function PicocCallMain($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = global$0 - 16 | 0;
   global$0 = $3;
   HEAP32[$3 + 8 >> 2] = $2;
   HEAP32[$3 + 12 >> 2] = $1;
   HEAP32[$3 + 4 >> 2] = 0;
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $4 = TableStrRegister($0, 5035);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $4;
   }
   if (!global$2) {
    $1 = !VariableDefined($0, $1)
   }
   if ((global$2 | 0) == 2 | $1) {
    if (global$2 ? ($5 | 0) == 1 : 1) {
     ProgramFailNoParser($0, 5040, 0);
     $6 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (global$2 ? ($5 | 0) == 2 : 1) {
    $4 = TableStrRegister($0, 5035);
    $6 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $4;
   }
   $2 = global$2 ? $2 : $3 + 4 | 0;
   if (global$2 ? ($5 | 0) == 3 : 1) {
    VariableGet($0, 0, $1, $2);
    $6 = 3;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   $1 = global$2 ? $1 : HEAP32[HEAP32[HEAP32[$3 + 4 >> 2] >> 2] >> 2] != 10;
   if ($1 | (global$2 | 0) == 2) {
    if (global$2 ? ($5 | 0) == 4 : 1) {
     ProgramFailNoParser($0, 5062, 0);
     $6 = 4;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   $1 = global$2 ? $1 : HEAP32[HEAP32[HEAP32[$3 + 4 >> 2] + 4 >> 2] + 4 >> 2];
   if ($1 | (global$2 | 0) == 2) {
    if (!global$2) {
     $2 = $3 + 12 | 0;
     $1 = $0 + 1412 | 0;
    }
    if (global$2 ? ($5 | 0) == 5 : 1) {
     VariableDefinePlatformVar($0, 0, 5101, $1, $2, 0);
     $6 = 5;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (!global$2) {
     $2 = $3 + 8 | 0;
     $1 = HEAP32[$0 + 2076 >> 2];
    }
    if (global$2 ? ($5 | 0) == 6 : 1) {
     VariableDefinePlatformVar($0, 0, 5108, $1, $2, 0);
     $6 = 6;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $1 = HEAP32[HEAP32[$3 + 4 >> 2] + 4 >> 2];
    $2 = HEAP32[$1 >> 2] == ($0 + 1808 | 0);
   }
   label$22 : {
    if ((global$2 | 0) == 2 | $2) {
     $1 = global$2 ? $1 : !HEAP32[$1 + 4 >> 2];
     if ($1 | (global$2 | 0) == 2) {
      if (global$2 ? ($5 | 0) == 7 : 1) {
       PicocParse($0, 5115, 5123, 7, 1, 1, 0, 1);
       $6 = 7;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       break label$22
      }
     }
     if (global$2 ? ($5 | 0) == 8 : 1) {
      PicocParse($0, 5115, 5131, 20, 1, 1, 0, 1);
      $6 = 8;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      break label$22
     }
    }
    if (!global$2) {
     $2 = $0 + 1308 | 0;
     $1 = $0 + 1412 | 0;
    }
    if (global$2 ? ($5 | 0) == 9 : 1) {
     VariableDefinePlatformVar($0, 0, 5152, $1, $2, 1);
     $6 = 9;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if ((global$2 | 0) == 2 | (global$2 ? $1 : !HEAP32[HEAP32[HEAP32[$3 + 4 >> 2] + 4 >> 2] + 4 >> 2])) {
     if (global$2 ? ($5 | 0) == 10 : 1) {
      PicocParse($0, 5115, 5165, 22, 1, 1, 0, 1);
      $6 = 10;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      break label$22
     }
    }
    if (global$2 ? ($5 | 0) == 11 : 1) {
     PicocParse($0, 5115, 5188, 35, 1, 1, 0, 1);
     $6 = 11;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    global$0 = $3 + 16 | 0
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function ProgramFailNoParser($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $5 = HEAP32[$4 + 12 >> 2];
   $4 = HEAP32[$4 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = global$0 - 16 | 0;
   global$0 = $5;
   HEAP32[$5 + 12 >> 2] = $2;
   $4 = HEAP32[$0 + 2196 >> 2];
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    PlatformVPrintf($4, $1, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   $1 = global$2 ? $1 : HEAP32[$0 + 2196 >> 2];
   if (global$2 ? ($3 | 0) == 1 : 1) {
    PlatformPrintf($1, 5236, 0);
    $6 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    PlatformExit($0, 1);
    global$0 = $5 + 16 | 0;
   }
   return;
  }
  $3 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $5;
  HEAP32[$3 + 16 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function PlatformVPrintf($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0.0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -32;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $2 = HEAP32[$1 + 8 >> 2];
   $4 = HEAP32[$1 + 12 >> 2];
   $6 = HEAP32[$1 + 16 >> 2];
   $7 = HEAP32[$1 + 20 >> 2];
   $5 = HEAP32[$1 + 28 >> 2];
   wasm2js_scratch_store_i32(0, HEAP32[$1 + 24 >> 2]);
   wasm2js_scratch_store_i32(1, $5 | 0);
   $8 = +wasm2js_scratch_load_f64();
   $1 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   while (1) {
    if (!global$2) {
     $4 = HEAPU8[$1 | 0];
     $6 = ($4 | 0) != 37;
    }
    label$5 : {
     label$6 : {
      label$7 : {
       label$8 : {
        label$9 : {
         label$10 : {
          label$11 : {
           label$12 : {
            if ((global$2 | 0) == 2 | $6) {
             if (!global$2) {
              $6 = !$4;
              if ($6) {
               break label$12
              }
              $4 = $4 << 24 >> 24;
             }
             if (global$2 ? !$3 : 1) {
              PrintCh($4, $0);
              $5 = 0;
              if ((global$2 | 0) == 1) {
               break label$2
              }
             }
             if (!global$2) {
              break label$5
             }
            }
            if (!global$2) {
             $4 = $1 + 1 | 0;
             $6 = HEAP8[$1 + 1 | 0];
             $7 = $6 + -99 | 0;
             if ($7 >>> 0 <= 17) {
              break label$11
             }
             $7 = !$6;
             if ($7) {
              break label$5
             }
             $1 = ($6 | 0) != 37;
             if ($1) {
              break label$10
             }
            }
            if (global$2 ? ($3 | 0) == 1 : 1) {
             PrintCh(37, $0);
             $5 = 1;
             if ((global$2 | 0) == 1) {
              break label$2
             }
            }
            if (!global$2) {
             $1 = $4 + 1 | 0;
             continue;
            }
           }
           if (!global$2) {
            return
           }
          }
          if (!global$2) {
           label$23 : {
            $1 = $7 - 1 | 0;
            switch ($1 | 0) {
            case 1:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
             break label$10;
            case 2:
             break label$23;
            case 15:
             break label$6;
            case 0:
             break label$7;
            case 16:
             break label$9;
            default:
             break label$8;
            };
           }
           $1 = $2 + 7 & -8;
           $8 = HEAPF64[$1 >> 3];
          }
          if (global$2 ? ($3 | 0) == 2 : 1) {
           PrintFP($8, $0);
           $5 = 2;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          $2 = global$2 ? $2 : $1 + 8 | 0;
         }
         if (!global$2) {
          $1 = $4 + 1 | 0;
          continue;
         }
        }
        $1 = global$2 ? $1 : HEAP32[$2 >> 2];
        if (global$2 ? ($3 | 0) == 3 : 1) {
         PrintType($1, $0);
         $5 = 3;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         $2 = $2 + 4 | 0;
         $1 = $4 + 1 | 0;
         continue;
        }
       }
       $1 = global$2 ? $1 : HEAP8[$2 | 0];
       if (global$2 ? ($3 | 0) == 4 : 1) {
        PrintCh($1, $0);
        $5 = 4;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        $2 = $2 + 4 | 0;
        $1 = $4 + 1 | 0;
        continue;
       }
      }
      $1 = global$2 ? $1 : HEAP32[$2 >> 2];
      if (global$2 ? ($3 | 0) == 5 : 1) {
       PrintSimpleInt($1, $0);
       $5 = 5;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       $2 = $2 + 4 | 0;
       $1 = $4 + 1 | 0;
       continue;
      }
     }
     $1 = global$2 ? $1 : HEAP32[$2 >> 2];
     if (global$2 ? ($3 | 0) == 6 : 1) {
      PrintStr($1, $0);
      $5 = 6;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      $2 = $2 + 4 | 0;
      $1 = $4 + 1 | 0;
      continue;
     }
    }
    if (!global$2) {
     $1 = $1 + 1 | 0;
     continue;
    }
    break;
   };
   return;
  }
  $3 = $5;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[$3 + 16 >> 2] = $6;
  HEAP32[$3 + 20 >> 2] = $7;
  wasm2js_scratch_store_f64(+$8);
  $5 = wasm2js_scratch_load_i32(1) | 0;
  HEAP32[$3 + 24 >> 2] = wasm2js_scratch_load_i32(0);
  HEAP32[$3 + 28 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 32;
 }
 
 function PlatformPrintf($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = global$0 - 16 | 0;
   global$0 = $3;
   HEAP32[$3 + 12 >> 2] = $2;
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    PlatformVPrintf($0, $1, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    global$0 = $3 + 16 | 0
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function PrintSourceTextErrorLine($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -36;
   $8 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$8 >> 2];
   $1 = HEAP32[$8 + 4 >> 2];
   $2 = HEAP32[$8 + 8 >> 2];
   $3 = HEAP32[$8 + 12 >> 2];
   $4 = HEAP32[$8 + 16 >> 2];
   $5 = HEAP32[$8 + 20 >> 2];
   $6 = HEAP32[$8 + 24 >> 2];
   $9 = HEAP32[$8 + 28 >> 2];
   $8 = HEAP32[$8 + 32 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $7 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = global$0;
   $9 = $6 - 16 | 0;
   global$0 = $9;
  }
  label$2 : {
   label$5 : {
    label$6 : {
     label$7 : {
      if (!global$2) {
       if ($2) {
        $6 = ($3 | 0) < 2;
        if ($6) {
         $6 = $2;
         break label$6;
        }
        $5 = HEAPU8[$2 | 0];
        if ($5) {
         break label$7
        }
        $6 = $2;
        break label$6;
       }
       if (($4 | 0) < -6) {
        break label$5
       }
       $6 = $4 + 6 | 0;
       $5 = ($6 | 0) > 0;
       $5 = $5 ? $6 : 0;
       $2 = 0;
      }
      while (1) {
       if (global$2 ? !$7 : 1) {
        PrintCh(32, $0);
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        $6 = ($2 | 0) != ($5 | 0);
        $2 = $2 + 1 | 0;
        if ($6) {
         continue
        }
       }
       break;
      };
      if (!global$2) {
       break label$5
      }
     }
     if (!global$2) {
      $8 = 1;
      while (1) {
       $6 = $2 + 1 | 0;
       $8 = (($5 & 255) == 10) + $8 | 0;
       $5 = ($8 | 0) >= ($3 | 0);
       if ($5) {
        break label$6
       }
       $5 = HEAPU8[$2 + 1 | 0];
       $2 = $6;
       if ($5 & 255) {
        continue
       }
       break;
      };
     }
    }
    $2 = global$2 ? $2 : $6;
    while (1) {
     label$17 : {
      if (!global$2) {
       label$19 : {
        $5 = HEAPU8[$2 | 0];
        if ($5 >>> 0 > 10) {
         break label$19
        }
        switch ($5 - 1 | 0) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
         break label$19;
        default:
         break label$17;
        };
       }
       $5 = $5 << 24 >> 24;
      }
      if (global$2 ? ($7 | 0) == 1 : 1) {
       PrintCh($5, $0);
       $10 = 1;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       $2 = $2 + 1 | 0;
       continue;
      }
     }
     break;
    };
    if (global$2 ? ($7 | 0) == 2 : 1) {
     PrintCh(10, $0);
     $10 = 2;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    $5 = global$2 ? $5 : 0;
    while (1) {
     if (!global$2) {
      label$25 : {
       $2 = HEAPU8[$6 | 0];
       if ($2 >>> 0 > 10) {
        break label$25
       }
       switch ($2 - 1 | 0) {
       case 0:
       case 1:
       case 2:
       case 3:
       case 4:
       case 5:
       case 6:
       case 7:
       case 8:
        break label$25;
       default:
        break label$5;
       };
      }
      if (($2 | 0) != 32 ? ($5 | 0) >= ($4 | 0) : 0) {
       break label$5
      }
      $2 = ($2 | 0) == 9 ? 9 : 32;
     }
     if (global$2 ? ($7 | 0) == 3 : 1) {
      PrintCh($2, $0);
      $10 = 3;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      $5 = $5 + 1 | 0;
      $6 = $6 + 1 | 0;
      continue;
     }
     break;
    };
   }
   if (!global$2) {
    HEAP32[$9 + 8 >> 2] = $4;
    HEAP32[$9 + 4 >> 2] = $3;
    HEAP32[$9 >> 2] = $1;
   }
   if (global$2 ? ($7 | 0) == 4 : 1) {
    PlatformPrintf($0, 5224, $9);
    $10 = 4;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    global$0 = $9 + 16 | 0
   }
   return;
  }
  $7 = $10;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $7 = HEAP32[global$3 >> 2];
  HEAP32[$7 >> 2] = $0;
  HEAP32[$7 + 4 >> 2] = $1;
  HEAP32[$7 + 8 >> 2] = $2;
  HEAP32[$7 + 12 >> 2] = $3;
  HEAP32[$7 + 16 >> 2] = $4;
  HEAP32[$7 + 20 >> 2] = $5;
  HEAP32[$7 + 24 >> 2] = $6;
  HEAP32[$7 + 28 >> 2] = $9;
  HEAP32[$7 + 32 >> 2] = $8;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 36;
 }
 
 function ProgramFail($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -36;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $5 = HEAP32[$4 + 12 >> 2];
   $6 = HEAP32[$4 + 16 >> 2];
   $7 = HEAP32[$4 + 20 >> 2];
   $8 = HEAP32[$4 + 24 >> 2];
   $9 = HEAP32[$4 + 28 >> 2];
   $4 = HEAP32[$4 + 32 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = global$0 - 16 | 0;
   global$0 = $6;
   $7 = HEAP32[$0 + 8 >> 2];
   $8 = HEAP32[$0 + 28 >> 2];
   $9 = HEAP16[$0 + 12 >> 1];
   $5 = HEAP32[HEAP32[$0 >> 2] + 2196 >> 2];
   $4 = HEAP16[$0 + 14 >> 1];
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    PrintSourceTextErrorLine($5, $7, $8, $9, $4);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    HEAP32[$6 + 12 >> 2] = $2;
    $5 = HEAP32[HEAP32[$0 >> 2] + 2196 >> 2];
   }
   if (global$2 ? ($3 | 0) == 1 : 1) {
    PlatformVPrintf($5, $1, $2);
    $10 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   $1 = global$2 ? $1 : HEAP32[HEAP32[$0 >> 2] + 2196 >> 2];
   if (global$2 ? ($3 | 0) == 2 : 1) {
    PlatformPrintf($1, 5236, 0);
    $10 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    PlatformExit(HEAP32[$0 >> 2], 1);
    global$0 = $6 + 16 | 0;
   }
   return;
  }
  $3 = $10;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $5;
  HEAP32[$3 + 16 >> 2] = $6;
  HEAP32[$3 + 20 >> 2] = $7;
  HEAP32[$3 + 24 >> 2] = $8;
  HEAP32[$3 + 28 >> 2] = $9;
  HEAP32[$3 + 32 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 36;
 }
 
 function AssignFail($0, $1, $2, $3, $4, $5, $6, $7) {
  var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -56;
   $9 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$9 >> 2];
   $1 = HEAP32[$9 + 4 >> 2];
   $2 = HEAP32[$9 + 8 >> 2];
   $3 = HEAP32[$9 + 12 >> 2];
   $4 = HEAP32[$9 + 16 >> 2];
   $5 = HEAP32[$9 + 20 >> 2];
   $6 = HEAP32[$9 + 24 >> 2];
   $7 = HEAP32[$9 + 28 >> 2];
   $10 = HEAP32[$9 + 32 >> 2];
   $11 = HEAP32[$9 + 36 >> 2];
   $12 = HEAP32[$9 + 40 >> 2];
   $14 = HEAP32[$9 + 44 >> 2];
   $15 = HEAP32[$9 + 48 >> 2];
   $9 = HEAP32[$9 + 52 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $10 = global$0 + -64 | 0;
   global$0 = $10;
   $12 = HEAP32[$0 + 8 >> 2];
   $14 = HEAP32[$0 + 28 >> 2];
   $15 = HEAP16[$0 + 12 >> 1];
   $11 = HEAP32[HEAP32[$0 >> 2] + 2196 >> 2];
   $9 = HEAP16[$0 + 14 >> 1];
  }
  label$2 : {
   if (global$2 ? !$8 : 1) {
    PrintSourceTextErrorLine($11, $12, $14, $15, $9);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    HEAP32[$10 + 48 >> 2] = $6 ? 5255 : 5248;
    $12 = $10 + 48 | 0;
   }
   if (global$2 ? ($8 | 0) == 1 : 1) {
    PlatformPrintf($11, 5238, $12);
    $13 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   label$8 : {
    if ((global$2 | 0) == 2 | $2) {
     if (!global$2) {
      HEAP32[$10 + 36 >> 2] = $3;
      HEAP32[$10 + 32 >> 2] = $2;
      $2 = $10 + 32 | 0;
     }
     if (global$2 ? ($8 | 0) == 2 : 1) {
      PlatformPrintf($11, $1, $2);
      $13 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      break label$8
     }
    }
    if (!global$2) {
     HEAP32[$10 + 20 >> 2] = $5;
     HEAP32[$10 + 16 >> 2] = $4;
     $2 = $10 + 16 | 0;
    }
    if (global$2 ? ($8 | 0) == 3 : 1) {
     PlatformPrintf($11, $1, $2);
     $13 = 3;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if ((global$2 | 0) == 2 | $6) {
    if (!global$2) {
     HEAP32[$10 + 4 >> 2] = $6;
     HEAP32[$10 >> 2] = $7;
    }
    if (global$2 ? ($8 | 0) == 4 : 1) {
     PlatformPrintf($11, 5259, $10);
     $13 = 4;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (global$2 ? ($8 | 0) == 5 : 1) {
    PlatformPrintf($11, 5236, 0);
    $13 = 5;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    PlatformExit(HEAP32[$0 >> 2], 1);
    global$0 = $10 - -64 | 0;
   }
   return;
  }
  $8 = $13;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $8;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $8 = HEAP32[global$3 >> 2];
  HEAP32[$8 >> 2] = $0;
  HEAP32[$8 + 4 >> 2] = $1;
  HEAP32[$8 + 8 >> 2] = $2;
  HEAP32[$8 + 12 >> 2] = $3;
  HEAP32[$8 + 16 >> 2] = $4;
  HEAP32[$8 + 20 >> 2] = $5;
  HEAP32[$8 + 24 >> 2] = $6;
  HEAP32[$8 + 28 >> 2] = $7;
  HEAP32[$8 + 32 >> 2] = $10;
  HEAP32[$8 + 36 >> 2] = $11;
  HEAP32[$8 + 40 >> 2] = $12;
  HEAP32[$8 + 44 >> 2] = $14;
  HEAP32[$8 + 48 >> 2] = $15;
  HEAP32[$8 + 52 >> 2] = $9;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 56;
 }
 
 function LexFail($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -36;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $6 = HEAP32[$5 + 16 >> 2];
   $7 = HEAP32[$5 + 20 >> 2];
   $8 = HEAP32[$5 + 24 >> 2];
   $9 = HEAP32[$5 + 28 >> 2];
   $5 = HEAP32[$5 + 32 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = global$0 - 16 | 0;
   global$0 = $6;
   $7 = HEAP32[$0 + 2196 >> 2];
   $8 = HEAP32[$1 + 8 >> 2];
   $9 = HEAP32[$1 + 20 >> 2];
   $5 = HEAP32[$1 + 12 >> 2];
   $1 = HEAP32[$1 + 16 >> 2];
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    PrintSourceTextErrorLine($7, $8, $9, $5, $1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    HEAP32[$6 + 12 >> 2] = $3;
    $1 = HEAP32[$0 + 2196 >> 2];
   }
   if (global$2 ? ($4 | 0) == 1 : 1) {
    PlatformVPrintf($1, $2, $3);
    $10 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   $1 = global$2 ? $1 : HEAP32[$0 + 2196 >> 2];
   if (global$2 ? ($4 | 0) == 2 : 1) {
    PlatformPrintf($1, 5236, 0);
    $10 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    PlatformExit($0, 1);
    global$0 = $6 + 16 | 0;
   }
   return;
  }
  $4 = $10;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $6;
  HEAP32[$4 + 20 >> 2] = $7;
  HEAP32[$4 + 24 >> 2] = $8;
  HEAP32[$4 + 28 >> 2] = $9;
  HEAP32[$4 + 32 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 36;
 }
 
 function PlatformMakeTempName($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $3 = HEAP32[$2 + 8 >> 2];
   $4 = HEAP32[$2 + 12 >> 2];
   $5 = HEAP32[$2 + 16 >> 2];
   $6 = HEAP32[$2 + 20 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $7 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $3 = global$2 ? $3 : 5;
  label$2 : {
   while (1) {
    if (!global$2) {
     $4 = $1 + $3 | 0;
     $5 = HEAP8[$4 | 0];
     $6 = ($5 | 0) <= 56;
    }
    if ((global$2 | 0) == 2 | $6) {
     if (!global$2) {
      $3 = $5 + 1 | 0;
      HEAP8[$4 | 0] = $3;
     }
     if (global$2 ? !$7 : 1) {
      $2 = TableStrRegister($0, $1);
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $0 = $2;
     }
     if (!global$2) {
      return $0
     }
    }
    if (!global$2) {
     HEAP8[$4 | 0] = 48;
     $4 = $3 >>> 0 > 2;
     $3 = $3 + -1 | 0;
     if ($4) {
      continue
     }
    }
    break;
   };
   if (global$2 ? ($7 | 0) == 1 : 1) {
    $2 = TableStrRegister($0, $1);
    $8 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $2;
   }
   if (!global$2) {
    return $0
   }
   abort();
  }
  $2 = $8;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 8 >> 2] = $3;
  HEAP32[$2 + 12 >> 2] = $4;
  HEAP32[$2 + 16 >> 2] = $5;
  HEAP32[$2 + 20 >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  return 0;
 }
 
 function IncludeInit($0) {
  var $1 = 0, $2 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $0 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $1 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   }
   if (global$2 ? !$1 : 1) {
    IncludeRegister($0, 5291, 0, 20368, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 1 : 1) {
    IncludeRegister($0, 5299, 22, 0, 0);
    $2 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 2 : 1) {
    IncludeRegister($0, 5307, 23, 19248, 0);
    $2 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 3 : 1) {
    IncludeRegister($0, 5314, 24, 0, 10320);
    $2 = 3;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 4 : 1) {
    IncludeRegister($0, 5324, 25, 18832, 5696);
    $2 = 4;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 5 : 1) {
    IncludeRegister($0, 5332, 26, 19776, 0);
    $2 = 5;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 6 : 1) {
    IncludeRegister($0, 5341, 27, 19552, 0);
    $2 = 6;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 7 : 1) {
    IncludeRegister($0, 5350, 28, 19936, 8928);
    $2 = 7;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 8 : 1) {
    IncludeRegister($0, 5357, 29, 20512, 10384);
    $2 = 8;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  $1 = $2;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
 }
 
 function IncludeRegister($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $5 = HEAP32[$5 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = HeapAllocMem($0, 20)
  }
  label$2 : {
   if (global$2 ? !$6 : 1) {
    $6 = TableStrRegister($0, $1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $6;
   }
   if (!global$2) {
    HEAP32[$5 + 12 >> 2] = $4;
    HEAP32[$5 + 8 >> 2] = $3;
    HEAP32[$5 + 4 >> 2] = $2;
    HEAP32[$5 >> 2] = $1;
    HEAP32[$5 + 16 >> 2] = HEAP32[$0 + 1312 >> 2];
    HEAP32[$0 + 1312 >> 2] = $5;
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $4;
  HEAP32[$6 + 20 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
 }
 
 function IncludeCleanup($0) {
  var $1 = 0, $2 = 0;
  $1 = HEAP32[$0 + 1312 >> 2];
  if ($1) {
   while (1) {
    $2 = HEAP32[$1 + 16 >> 2];
    HeapFreeMem($0, $1);
    $1 = $2;
    if ($1) {
     continue
    }
    break;
   }
  }
  HEAP32[$0 + 1312 >> 2] = 0;
 }
 
 function PicocIncludeAllSystemHeaders($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $2 = HEAP32[$1 + 4 >> 2];
   $1 = HEAP32[$1 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   $2 = global$2 ? $2 : HEAP32[$0 + 1312 >> 2];
   if ($2 | (global$2 | 0) == 2) {
    while (1) {
     $1 = global$2 ? $1 : HEAP32[$2 >> 2];
     if (global$2 ? !$3 : 1) {
      IncludeFile($0, $1);
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      $2 = HEAP32[$2 + 16 >> 2];
      if ($2) {
       continue
      }
     }
     break;
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
 }
 
 function IncludeFile($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $7 = HEAP32[$3 + 16 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   $4 = global$2 ? $4 : HEAP32[$0 + 1312 >> 2];
   label$4 : {
    if ($4 | (global$2 | 0) == 2) {
     while (1) {
      if (!global$2) {
       $2 = !strcmp(HEAP32[$4 >> 2], $1)
      }
      if ((global$2 | 0) == 2 | $2) {
       if (!global$2) {
        if (VariableDefined($0, $1)) {
         break label$4
        }
        $2 = $0 + 1808 | 0;
       }
       if (global$2 ? !$5 : 1) {
        $3 = VariableDefine($0, 0, $1, 0, $2, 0);
        $6 = 0;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $2 = $3;
       }
       $2 = global$2 ? $2 : HEAP32[$4 + 4 >> 2];
       if ($2 | (global$2 | 0) == 2) {
        if (global$2 ? ($5 | 0) == 1 : 1) {
         FUNCTION_TABLE[$2]($0);
         $6 = 1;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
       }
       $2 = global$2 ? $2 : HEAP32[$4 + 12 >> 2];
       if ($2 | (global$2 | 0) == 2) {
        if (!global$2) {
         $7 = strlen($2)
        }
        if (global$2 ? ($5 | 0) == 2 : 1) {
         PicocParse($0, $1, $2, $7, 1, 1, 0, 0);
         $6 = 2;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
       }
       if (!global$2) {
        $4 = HEAP32[$4 + 8 >> 2];
        $2 = !$4;
        if ($2) {
         break label$4
        }
       }
       if (global$2 ? ($5 | 0) == 3 : 1) {
        LibraryAdd($0, $0, $1, $4);
        $6 = 3;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        return
       }
      }
      if (!global$2) {
       $4 = HEAP32[$4 + 16 >> 2];
       if ($4) {
        continue
       }
      }
      break;
     }
    }
    if (global$2 ? ($5 | 0) == 4 : 1) {
     PicocPlatformScanFile($0, $1);
     $6 = 4;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   return;
  }
  $3 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[$3 + 16 >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function DebugInit($0) {
  TableInitTable($0 + 2088 | 0, $0 + 2096 | 0, 21, 1);
  HEAP32[$0 + 2180 >> 2] = 0;
 }
 
 function DebugCleanup($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  if (HEAP16[$0 + 2088 >> 1] >= 1) {
   while (1) {
    $1 = HEAP32[(($2 << 2) + $0 | 0) + 2096 >> 2];
    if ($1) {
     while (1) {
      $3 = HEAP32[$1 >> 2];
      HeapFreeMem($0, $1);
      $1 = $3;
      if ($1) {
       continue
      }
      break;
     }
    }
    $2 = $2 + 1 | 0;
    if (($2 | 0) < HEAP16[$0 + 2088 >> 1]) {
     continue
    }
    break;
   }
  }
 }
 
 function DebugTableSearchBreakpoint($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $3 = HEAPU16[$0 + 14 >> 1];
  $4 = HEAPU16[$0 + 12 >> 1];
  $2 = HEAP32[$0 >> 2];
  $5 = ((HEAP32[$0 + 8 >> 2] ^ ($3 | $4) << 16) >>> 0) % (HEAP16[$2 + 2088 >> 1] >>> 0) | 0;
  $2 = HEAP32[(($5 << 2) + $2 | 0) + 2096 >> 2];
  label$1 : {
   if ($2) {
    $0 = HEAP32[$0 + 8 >> 2];
    while (1) {
     if (HEAPU16[$2 + 18 >> 1] == ($3 | 0) ? !(HEAP32[$2 + 12 >> 2] != ($0 | 0) | HEAPU16[$2 + 16 >> 1] != ($4 | 0)) : 0) {
      break label$1
     }
     $2 = HEAP32[$2 >> 2];
     if ($2) {
      continue
     }
     break;
    };
   }
   HEAP32[$1 >> 2] = $5;
   $2 = 0;
  }
  return $2;
 }
 
 function DebugCheckStatement($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $3 = HEAP32[$2 + 4 >> 2];
   $4 = HEAP32[$2 + 8 >> 2];
   $5 = HEAP32[$2 + 12 >> 2];
   $2 = HEAP32[$2 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $1 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = global$0 - 16 | 0;
   global$0 = $5;
   $3 = 0;
   $4 = HEAP32[$0 >> 2];
   $2 = !HEAP32[$4 + 2184 >> 2];
  }
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($2) {
      break label$5
     }
     $3 = HEAP32[$4 + 2196 >> 2];
    }
    if (global$2 ? !$1 : 1) {
     PlatformPrintf($3, 5366, 0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (!global$2) {
     HEAP32[$4 + 2184 >> 2] = 0;
     $3 = 1;
    }
   }
   if (!global$2) {
    if (HEAP32[HEAP32[$0 >> 2] + 2180 >> 2]) {
     $0 = DebugTableSearchBreakpoint($0, $5 + 12 | 0);
     $3 = $0 ? 1 : $3;
    }
   }
   if ((global$2 | 0) == 2 | $3) {
    $0 = global$2 ? $0 : HEAP32[$4 + 2196 >> 2];
    if (global$2 ? ($1 | 0) == 1 : 1) {
     PlatformPrintf($0, 5373, 0);
     $6 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (global$2 ? ($1 | 0) == 2 : 1) {
     PicocParseInteractiveNoStartPrompt($4, 0);
     $6 = 2;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    global$0 = $5 + 16 | 0
   }
   return;
  }
  $1 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $3;
  HEAP32[$1 + 8 >> 2] = $4;
  HEAP32[$1 + 12 >> 2] = $5;
  HEAP32[$1 + 16 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function emscripten_sleep_pc($0) {
  var $1 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $0 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $1 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   } else {
    $1 = 0
   }
   if (global$2 ? !$1 : 1) {
    emscripten_sleep_pc_with_intervals($0, 3e3);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
 }
 
 function emscripten_sleep_pc_with_intervals($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   $5 = !global$2;
   if (global$2) {
    $4 = $1
   } else {
    $2 = HEAP32[5436];
    HEAP32[5436] = $2 + 1;
    $4 = ($2 | 0) % ($1 | 0) | 0;
   }
   label$4 : {
    if ($4 ? $5 : 0) {
     break label$4
    }
    if (global$2 ? !$3 : 1) {
     emscripten_sleep(1);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (!global$2) {
     if (!em_stop()) {
      break label$4
     }
     PlatformExit($0, -1);
     abort();
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
 }
 
 function PlatformExit($0, $1) {
  HEAP32[$0 + 1308 >> 2] = $1;
  emscripten_longjmp($0 + 2204 | 0, 1);
  abort();
 }
 
 function PlatformInit($0) {
  HEAP32[5437] = $0;
  signal(2, 30) | 0;
 }
 
 function BreakHandler($0) {
  $0 = $0 | 0;
  HEAP32[HEAP32[5437] + 2184 >> 2] = 1;
 }
 
 function PlatformCleanup($0) {
  
 }
 
 function PlatformGetLine($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $4 = global$0 - 16 | 0;
   global$0 = $4;
  }
  label$2 : {
   if ((global$2 | 0) == 2 | $2) {
    if (!global$2) {
     HEAP32[$4 >> 2] = $2
    }
    if (global$2 ? !$5 : 1) {
     $3 = iprintf(5432, $4);
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $2 = $3;
    }
   }
   $2 = global$2 ? $2 : HEAP32[3226];
   if (global$2 ? ($5 | 0) == 1 : 1) {
    $3 = fflush($2);
    $6 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $3;
   }
   $2 = global$2 ? $2 : HEAP32[3046];
   if (global$2 ? ($5 | 0) == 2 : 1) {
    $3 = fgets($0, $1, $2);
    $6 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $3;
   }
   if (!global$2) {
    global$0 = $4 + 16 | 0;
    return $2;
   }
   abort();
  }
  $3 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function PlatformReadFile($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -28;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $3 = HEAP32[$2 + 8 >> 2];
   $4 = HEAP32[$2 + 12 >> 2];
   $6 = HEAP32[$2 + 16 >> 2];
   $7 = HEAP32[$2 + 20 >> 2];
   $2 = HEAP32[$2 + 24 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $4 = global$0 - 128 | 0;
   global$0 = $4;
   $3 = stat($1, $4 + 40 | 0);
  }
  label$2 : {
   if ((global$2 | 0) == 2 | $3) {
    if (!global$2) {
     HEAP32[$4 + 32 >> 2] = $1;
     $3 = $4 + 32 | 0;
    }
    if (global$2 ? !$8 : 1) {
     ProgramFailNoParser($0, 5435, $3);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $2 = HEAP32[$4 + 80 >> 2];
    $3 = dlmalloc($2 + 1 | 0);
    $6 = !$3;
   }
   if ((global$2 | 0) == 2 | $6) {
    if (global$2 ? ($8 | 0) == 1 : 1) {
     ProgramFailNoParser($0, 5455, 0);
     $9 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    $6 = fopen($1, 5470);
    $7 = !$6;
   }
   if ((global$2 | 0) == 2 | $7) {
    if (!global$2) {
     HEAP32[$4 + 16 >> 2] = $1;
     $7 = $4 + 16 | 0;
    }
    if (global$2 ? ($8 | 0) == 2 : 1) {
     ProgramFailNoParser($0, 5435, $7);
     $9 = 2;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (global$2 ? ($8 | 0) == 3 : 1) {
    $5 = fread($3, 1, $2, $6);
    $9 = 3;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if ((global$2 | 0) == 2 | (global$2 ? $7 : !$2)) {
    if (!global$2) {
     HEAP32[$4 >> 2] = $1
    }
    if (global$2 ? ($8 | 0) == 4 : 1) {
     ProgramFailNoParser($0, 5435, $4);
     $9 = 4;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    HEAP8[$2 + $3 | 0] = 0
   }
   if (global$2 ? ($8 | 0) == 5 : 1) {
    fclose($6);
    $9 = 5;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    label$22 : {
     if (HEAPU8[$3 | 0] != 35 | HEAPU8[$3 + 1 | 0] != 33) {
      break label$22
     }
     $1 = $3;
     while (1) {
      label$24 : {
       $6 = HEAPU8[$1 | 0] + -10 | 0;
       if ($6 >>> 0 > 3) {
        break label$24
       }
       switch ($6 - 1 | 0) {
       case 0:
       case 1:
        break label$24;
       default:
        break label$22;
       };
      }
      HEAP8[$1 | 0] = 32;
      $1 = $1 + 1 | 0;
      continue;
     };
    }
    global$0 = $4 + 128 | 0;
    return $3;
   }
   abort();
  }
  $5 = $9;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $3;
  HEAP32[$5 + 12 >> 2] = $4;
  HEAP32[$5 + 16 >> 2] = $6;
  HEAP32[$5 + 20 >> 2] = $7;
  HEAP32[$5 + 24 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 28;
  return 0;
 }
 
 function PicocPlatformScanFile($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $3 = HEAP32[$2 + 8 >> 2];
   $4 = HEAP32[$2 + 12 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   }
   if (global$2 ? !$5 : 1) {
    $2 = PlatformReadFile($0, $1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $2;
   }
   if (!global$2) {
    if (!(!$3 | HEAPU8[$3 | 0] != 35 | HEAPU8[$3 + 1 | 0] != 33)) {
     HEAP8[$3 | 0] = 12079;
     HEAP8[$3 + 1 | 0] = 47;
    }
    $4 = strlen($3);
   }
   if (global$2 ? ($5 | 0) == 1 : 1) {
    PicocParse($0, $1, $3, $4, 1, 0, 1, 1);
    $6 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  $2 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 8 >> 2] = $3;
  HEAP32[$2 + 12 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function UnixSetupFunc() {
  
 }
 
 function Ctest($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = global$0 - 16 | 0;
   global$0 = $0;
   HEAP32[$0 >> 2] = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    iprintf(5472, $0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2] = 1234;
    global$0 = $0 + 16 | 0;
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function Clineno($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = HEAP16[$0 + 12 >> 1];
 }
 
 function PlatformLibraryInit($0) {
  var $1 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $0 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $1 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   } else {
    $1 = 0
   }
   if (global$2 ? !$1 : 1) {
    IncludeRegister($0, 5512, 31, 18800, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
 }
 
 function em_getchar($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $2 = HEAP32[$1 + 4 >> 2];
   $1 = HEAP32[$1 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $2 = em_getchar_sync() | 0;
   $1 = ($2 | 0) == -2;
  }
  label$2 : {
   if ((global$2 | 0) == 2 | $1) {
    while (1) {
     if (global$2 ? !$3 : 1) {
      emscripten_sleep_pc_with_intervals($0, 100);
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      $2 = em_getchar_sync() | 0;
      if (($2 | 0) == -2) {
       continue
      }
     }
     break;
    }
   }
   if (!global$2) {
    return $2
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $2;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
  return 0;
 }
 
 function em_gets($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -28;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $7 = HEAP32[$4 + 20 >> 2];
   $4 = HEAP32[$4 + 24 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $5 = global$2 ? $5 : 0;
  label$2 : {
   label$4 : {
    while (1) {
     $7 = global$2 ? $7 : $1 + $5 | 0;
     if (global$2 ? !$8 : 1) {
      $6 = em_getchar($0);
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $4 = $6;
     }
     if (!global$2) {
      HEAP8[$7 | 0] = $4;
      $4 = $4 << 24;
      if (($4 | 0) == -16777216) {
       break label$4
      }
      if (($4 | 0) == 167772160) {
       $7 = ((!$3 & ($5 | 0) < ($2 + -1 | 0)) + $5 | 0) + $1 | 0;
       break label$4;
      }
      $5 = $5 + 1 | 0;
      $4 = ($5 | 0) != ($2 | 0);
      if ($4) {
       continue
      }
     }
     break;
    };
    $7 = global$2 ? $7 : ($1 + $2 | 0) + -1 | 0;
   }
   if (!global$2) {
    HEAP8[$7 | 0] = 0;
    return $1;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $5;
  HEAP32[$6 + 20 >> 2] = $7;
  HEAP32[$6 + 24 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 28;
  return 0;
 }
 
 function BasicIOInit($0) {
  var $1 = 0;
  $1 = $0;
  $0 = HEAP32[3226];
  HEAP32[$1 + 2196 >> 2] = $0;
  HEAP32[5439] = $0;
  HEAP32[5438] = HEAP32[3046];
  HEAP32[5440] = HEAP32[3045];
 }
 
 function StdioOutPutc($0, $1) {
  var $2 = 0, $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   $2 = global$2 ? $2 : HEAP32[$1 >> 2];
   label$4 : {
    label$5 : {
     if ($2 | (global$2 | 0) == 2) {
      if (global$2 ? !$3 : 1) {
       $3 = putc($0, $2);
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $0 = $3;
      }
      if (!global$2) {
       break label$5
      }
     }
     if (!global$2) {
      if (HEAPU32[$1 + 8 >> 2] < 2) {
       break label$4
      }
      HEAP8[HEAP32[$1 + 4 >> 2]] = $0;
      HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
      $0 = HEAP32[$1 + 8 >> 2];
      if (($0 | 0) < 2) {
       break label$5
      }
      HEAP32[$1 + 8 >> 2] = $0 + -1;
     }
    }
    if (!global$2) {
     HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] + 1
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
 }
 
 function StdioOutPuts($0, $1) {
  var $2 = 0, $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $2 = HEAP32[$1 >> 2];
   if (!$2) {
    $2 = HEAPU8[$0 | 0];
    if ($2) {
     while (1) {
      if (HEAPU32[$1 + 8 >> 2] >= 2) {
       HEAP8[HEAP32[$1 + 4 >> 2]] = $2;
       HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + 1;
       $2 = HEAP32[$1 + 8 >> 2];
       if (($2 | 0) >= 2) {
        HEAP32[$1 + 8 >> 2] = $2 + -1
       }
       HEAP32[$1 + 12 >> 2] = HEAP32[$1 + 12 >> 2] + 1;
       $0 = $0 + 1 | 0;
      }
      $2 = HEAPU8[$0 | 0];
      if ($2) {
       continue
      }
      break;
     }
    }
    return;
   }
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    fputs($0, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
 }
 
 function StdioFprintfWord($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -28;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $5 = HEAP32[$3 + 16 >> 2];
   $6 = HEAP32[$3 + 20 >> 2];
   $7 = HEAP32[$3 + 24 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if (!global$2) {
    $4 = global$0 - 48 | 0;
    global$0 = $4;
    $5 = HEAP32[$0 >> 2];
   }
   label$4 : {
    if ((global$2 | 0) == 2 | $5) {
     if (!global$2) {
      HEAP32[$4 + 32 >> 2] = $2;
      $2 = $4 + 32 | 0;
     }
     if (global$2 ? !$8 : 1) {
      $3 = fiprintf($5, $1, $2);
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $3;
     }
     if (!global$2) {
      HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + $1;
      break label$4;
     }
    }
    if (!global$2) {
     $6 = HEAP32[$0 + 8 >> 2];
     $7 = ($6 | 0) >= 0;
     $5 = HEAP32[$0 + 4 >> 2];
    }
    if ((global$2 | 0) == 2 | $7) {
     if (!global$2) {
      HEAP32[$4 >> 2] = $2
     }
     if (global$2 ? ($8 | 0) == 1 : 1) {
      $3 = snprintf($5, $6, $1, $4);
      $9 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $3;
     }
     if (!global$2) {
      HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + $1;
      HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] - $1;
      HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + $1;
      break label$4;
     }
    }
    if (!global$2) {
     HEAP32[$4 + 16 >> 2] = $2;
     $2 = $4 + 16 | 0;
    }
    if (global$2 ? ($8 | 0) == 2 : 1) {
     $3 = siprintf($5, $1, $2);
     $9 = 2;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $1 = $3;
    }
    if (!global$2) {
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + $1;
     HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + $1;
    }
   }
   if (!global$2) {
    global$0 = $4 + 48 | 0
   }
   return;
  }
  $3 = $9;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[$3 + 16 >> 2] = $5;
  HEAP32[$3 + 20 >> 2] = $6;
  HEAP32[$3 + 24 >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 28;
 }
 
 function StdioFprintfFP($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -32;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 12 >> 2];
   wasm2js_scratch_store_i32(0, HEAP32[$3 + 8 >> 2]);
   wasm2js_scratch_store_i32(1, $1 | 0);
   $2 = +wasm2js_scratch_load_f64();
   $4 = HEAP32[$3 + 16 >> 2];
   $5 = HEAP32[$3 + 20 >> 2];
   $6 = HEAP32[$3 + 24 >> 2];
   $7 = HEAP32[$3 + 28 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if (!global$2) {
    $4 = global$0 - 48 | 0;
    global$0 = $4;
    $6 = HEAP32[$0 >> 2];
   }
   label$4 : {
    if ((global$2 | 0) == 2 | $6) {
     if (!global$2) {
      HEAPF64[$4 + 32 >> 3] = $2;
      $5 = $4 + 32 | 0;
     }
     if (global$2 ? !$8 : 1) {
      $3 = __small_fprintf($6, $1, $5);
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $3;
     }
     if (!global$2) {
      HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + $1;
      break label$4;
     }
    }
    if (!global$2) {
     $5 = HEAP32[$0 + 8 >> 2];
     $7 = ($5 | 0) >= 0;
     $6 = HEAP32[$0 + 4 >> 2];
    }
    if ((global$2 | 0) == 2 | $7) {
     if (!global$2) {
      HEAPF64[$4 >> 3] = $2
     }
     if (global$2 ? ($8 | 0) == 1 : 1) {
      $3 = snprintf($6, $5, $1, $4);
      $9 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $3;
     }
     if (!global$2) {
      HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + $1;
      HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] - $1;
      HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + $1;
      break label$4;
     }
    }
    if (!global$2) {
     HEAPF64[$4 + 16 >> 3] = $2;
     $5 = $4 + 16 | 0;
    }
    if (global$2 ? ($8 | 0) == 2 : 1) {
     $3 = __small_sprintf($6, $1, $5);
     $9 = 2;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $1 = $3;
    }
    if (!global$2) {
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + $1;
     HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + $1;
    }
   }
   if (!global$2) {
    global$0 = $4 + 48 | 0
   }
   return;
  }
  $3 = $9;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  wasm2js_scratch_store_f64(+$2);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  HEAP32[$3 + 8 >> 2] = wasm2js_scratch_load_i32(0);
  HEAP32[$3 + 12 >> 2] = $1;
  HEAP32[$3 + 16 >> 2] = $4;
  HEAP32[$3 + 20 >> 2] = $5;
  HEAP32[$3 + 24 >> 2] = $6;
  HEAP32[$3 + 28 >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 32;
 }
 
 function StdioFprintfPointer($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -28;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $5 = HEAP32[$3 + 16 >> 2];
   $6 = HEAP32[$3 + 20 >> 2];
   $7 = HEAP32[$3 + 24 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if (!global$2) {
    $4 = global$0 - 48 | 0;
    global$0 = $4;
    $5 = HEAP32[$0 >> 2];
   }
   label$4 : {
    if ((global$2 | 0) == 2 | $5) {
     if (!global$2) {
      HEAP32[$4 + 32 >> 2] = $2;
      $2 = $4 + 32 | 0;
     }
     if (global$2 ? !$8 : 1) {
      $3 = fiprintf($5, $1, $2);
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $3;
     }
     if (!global$2) {
      HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + $1;
      break label$4;
     }
    }
    if (!global$2) {
     $6 = HEAP32[$0 + 8 >> 2];
     $7 = ($6 | 0) >= 0;
     $5 = HEAP32[$0 + 4 >> 2];
    }
    if ((global$2 | 0) == 2 | $7) {
     if (!global$2) {
      HEAP32[$4 >> 2] = $2
     }
     if (global$2 ? ($8 | 0) == 1 : 1) {
      $3 = snprintf($5, $6, $1, $4);
      $9 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $3;
     }
     if (!global$2) {
      HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + $1;
      HEAP32[$0 + 8 >> 2] = HEAP32[$0 + 8 >> 2] - $1;
      HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + $1;
      break label$4;
     }
    }
    if (!global$2) {
     HEAP32[$4 + 16 >> 2] = $2;
     $2 = $4 + 16 | 0;
    }
    if (global$2 ? ($8 | 0) == 2 : 1) {
     $3 = siprintf($5, $1, $2);
     $9 = 2;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $1 = $3;
    }
    if (!global$2) {
     HEAP32[$0 + 12 >> 2] = HEAP32[$0 + 12 >> 2] + $1;
     HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + $1;
    }
   }
   if (!global$2) {
    global$0 = $4 + 48 | 0
   }
   return;
  }
  $3 = $9;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[$3 + 16 >> 2] = $5;
  HEAP32[$3 + 20 >> 2] = $6;
  HEAP32[$3 + 24 >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 28;
 }
 
 function StdioBasePrintf($0, $1, $2, $3, $4, $5) {
  var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0.0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -68;
   $6 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$6 >> 2];
   $2 = HEAP32[$6 + 8 >> 2];
   $3 = HEAP32[$6 + 12 >> 2];
   $4 = HEAP32[$6 + 16 >> 2];
   $5 = HEAP32[$6 + 20 >> 2];
   $7 = HEAP32[$6 + 24 >> 2];
   $8 = HEAP32[$6 + 28 >> 2];
   $9 = HEAP32[$6 + 32 >> 2];
   $10 = HEAP32[$6 + 36 >> 2];
   $13 = HEAP32[$6 + 40 >> 2];
   $12 = HEAP32[$6 + 44 >> 2];
   $14 = HEAP32[$6 + 48 >> 2];
   $15 = HEAP32[$6 + 52 >> 2];
   $16 = HEAP32[$6 + 56 >> 2];
   $1 = HEAP32[$6 + 64 >> 2];
   wasm2js_scratch_store_i32(0, HEAP32[$6 + 60 >> 2]);
   wasm2js_scratch_store_i32(1, $1 | 0);
   $17 = +wasm2js_scratch_load_f64();
   $1 = HEAP32[$6 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $11 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $7 = global$0 - 112 | 0;
   global$0 = $7;
   $9 = HEAP32[HEAP32[$5 >> 2] >> 2];
   $13 = HEAP32[$0 >> 2];
   HEAP32[$7 + 12 >> 2] = 0;
   HEAP32[$7 + 8 >> 2] = $3;
   HEAP32[$7 + 4 >> 2] = $2;
   HEAP32[$7 >> 2] = $1;
   $4 = $4 ? $4 : 5560;
   $15 = $13 + 1764 | 0;
   $14 = $13 + 1412 | 0;
   $10 = 0;
   $0 = $13 + 1808 | 0;
  }
  label$2 : {
   while (1) {
    $1 = global$2 ? $1 : HEAPU8[$4 | 0];
    label$6 : {
     if ($1 | (global$2 | 0) == 2) {
      if (!global$2) {
       $2 = ($1 | 0) != 37;
       if ($2) {
        break label$6
       }
       HEAP8[$7 + 16 | 0] = 37;
       $4 = $4 + 1 | 0;
       $2 = 0;
       $1 = 1;
      }
      while (1) {
       if (!global$2) {
        $3 = HEAP8[$4 | 0];
        label$13 : {
         if ($3 >>> 0 > 120) {
          break label$13
         }
         label$14 : {
          switch ($3 - 1 | 0) {
          case 87:
          case 99:
          case 104:
          case 110:
          case 116:
          case 119:
           $2 = $14;
           break label$13;
          case 68:
          case 69:
          case 70:
          case 100:
          case 101:
          case 102:
           $2 = $15;
           break label$13;
          case 64:
          case 96:
          case 98:
           $2 = $14;
           break label$13;
          case 114:
           $2 = HEAP32[$13 + 2072 >> 2];
           break label$13;
          case 111:
           $2 = HEAP32[$13 + 2084 >> 2];
           break label$13;
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
          case 15:
          case 16:
          case 17:
          case 18:
          case 19:
          case 20:
          case 21:
          case 22:
          case 23:
          case 24:
          case 25:
          case 26:
          case 27:
          case 28:
          case 29:
          case 30:
          case 31:
          case 32:
          case 33:
          case 34:
          case 35:
          case 37:
          case 38:
          case 39:
          case 40:
          case 41:
          case 42:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 58:
          case 59:
          case 60:
          case 61:
          case 62:
          case 63:
          case 65:
          case 66:
          case 67:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 88:
          case 89:
          case 90:
          case 91:
          case 92:
          case 93:
          case 94:
          case 95:
          case 97:
          case 103:
          case 105:
          case 106:
          case 107:
          case 112:
          case 113:
          case 115:
          case 117:
          case 118:
           break label$13;
          default:
           break label$14;
          };
         }
         $2 = $0;
        }
        HEAP8[($7 + 16 | 0) + $1 | 0] = $3;
        $8 = ($0 | 0) != ($2 | 0);
        $3 = $1 + 1 | 0;
       }
       label$20 : {
        if (!global$2) {
         if ($8) {
          break label$20
         }
         $8 = HEAP8[$4 | 0];
         $12 = $8 + -109 | 0;
         $16 = $12 >>> 0 > 1;
        }
        if ((global$2 | 0) == 2 | $16) {
         if ((global$2 | 0) == 2 | $8) {
          if (!global$2) {
           $12 = ($8 | 0) != 37;
           if ($12) {
            break label$20
           }
          }
          if (global$2 ? !$11 : 1) {
           StdioOutPutc($8, $7);
           $6 = 0;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (!global$2) {
           break label$20
          }
         }
         if (!global$2) {
          HEAP8[($7 + 16 | 0) + $3 | 0] = 0;
          $8 = HEAP8[$4 | 0];
         }
         if (global$2 ? ($11 | 0) == 1 : 1) {
          StdioOutPutc($8, $7);
          $6 = 1;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          break label$20
         }
        }
        $8 = global$2 ? $8 : $12 - 1 | 0;
        if ($8 | (global$2 | 0) == 2) {
         if (!global$2) {
          $8 = strerror(HEAP32[__errno_location() >> 2])
         }
         if (global$2 ? ($11 | 0) == 2 : 1) {
          StdioOutPuts($8, $7);
          $6 = 2;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          break label$20
         }
        }
        if (!global$2) {
         $9 = (TypeStackSizeValue($9) + 31 & -8) + $9 | 0;
         $8 = HEAP32[$9 >> 2];
         $12 = HEAP32[$8 >> 2] != 13;
         if ($12) {
          break label$20
         }
         $8 = HEAP32[HEAP32[$8 + 20 >> 2] >> 2] != 1;
         if ($8) {
          break label$20
         }
         $8 = HEAP32[HEAP32[$9 + 4 >> 2] >> 2];
         $12 = HEAP32[$7 + 12 >> 2];
         HEAP32[$8 >> 2] = $12;
        }
       }
       if (!global$2) {
        $4 = $4 + 1 | 0;
        $1 = $1 >>> 0 <= 78;
        if ($1) {
         $1 = $3;
         $8 = !$2;
         if ($8) {
          continue
         }
        }
       }
       break;
      };
      if (!global$2) {
       $1 = ($0 | 0) == ($2 | 0);
       if ($1) {
        continue
       }
       $1 = ($10 | 0) >= HEAP32[$5 + 4 >> 2];
      }
      if ((global$2 | 0) == 2 | $1) {
       if (global$2 ? ($11 | 0) == 3 : 1) {
        StdioOutPuts(5575, $7);
        $6 = 3;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        continue
       }
      }
      if (!global$2) {
       HEAP8[($7 + 16 | 0) + $3 | 0] = 0;
       $9 = (TypeStackSizeValue($9) + 31 & -8) + $9 | 0;
       $1 = ($2 | 0) == ($14 | 0);
      }
      label$40 : {
       label$41 : {
        if ((global$2 | 0) == 2 | $1) {
         if (!global$2) {
          $1 = HEAP32[HEAP32[$9 >> 2] >> 2];
          if ($1 + -1 >>> 0 >= 8) {
           $2 = $1 >>> 0 > 13;
           if ($2) {
            break label$41
           }
           $1 = !(1 << $1 & 12800);
           if ($1) {
            break label$41
           }
          }
          $2 = ExpressionCoerceUnsignedInteger($9);
          $1 = $7 + 16 | 0;
         }
         if (global$2 ? ($11 | 0) == 4 : 1) {
          StdioFprintfWord($7, $1, $2);
          $6 = 4;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          $10 = $10 + 1 | 0;
          continue;
         }
        }
        $1 = global$2 ? $1 : ($2 | 0) == ($15 | 0);
        if ($1 | (global$2 | 0) == 2) {
         if (!global$2) {
          $1 = HEAP32[HEAP32[$9 >> 2] >> 2] + -1 >>> 0 > 8;
          if ($1) {
           break label$41
          }
          $17 = ExpressionCoerceFP($9);
          $1 = $7 + 16 | 0;
         }
         if (global$2 ? ($11 | 0) == 5 : 1) {
          StdioFprintfFP($7, $1, $17);
          $6 = 5;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          $10 = $10 + 1 | 0;
          continue;
         }
        }
        $1 = global$2 ? $1 : HEAP32[$13 + 2072 >> 2] == ($2 | 0);
        if ($1 | (global$2 | 0) == 2) {
         if (!global$2) {
          $2 = HEAP32[$9 >> 2];
          $1 = HEAP32[$2 >> 2] + -12 | 0;
          $3 = $1 >>> 0 > 1;
          if ($3) {
           break label$41
          }
          $1 = $1 - 1 | 0;
         }
         if ((global$2 | 0) == 2 | $1) {
          if (!global$2) {
           $2 = HEAP32[HEAP32[$9 + 4 >> 2] >> 2];
           $1 = $7 + 16 | 0;
          }
          if (global$2 ? ($11 | 0) == 6 : 1) {
           StdioFprintfPointer($7, $1, $2);
           $6 = 6;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (!global$2) {
           $10 = $10 + 1 | 0;
           continue;
          }
         }
         if (!global$2) {
          $1 = HEAP32[HEAP32[$2 + 20 >> 2] >> 2] != 3;
          if ($1) {
           break label$41
          }
          $2 = HEAP32[$9 + 4 >> 2];
          $1 = $7 + 16 | 0;
         }
         if (global$2 ? ($11 | 0) == 7 : 1) {
          StdioFprintfPointer($7, $1, $2);
          $6 = 7;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          $10 = $10 + 1 | 0;
          continue;
         }
        }
        if (!global$2) {
         $1 = HEAP32[$13 + 2084 >> 2] != ($2 | 0);
         if ($1) {
          break label$40
         }
         $1 = HEAP32[HEAP32[$9 >> 2] >> 2] + -12 | 0;
         $2 = $1 >>> 0 > 1;
         if ($2) {
          break label$41
         }
         $1 = $1 - 1 | 0;
        }
        if ((global$2 | 0) == 2 | $1) {
         if (!global$2) {
          $2 = HEAP32[HEAP32[$9 + 4 >> 2] >> 2];
          $1 = $7 + 16 | 0;
         }
         if (global$2 ? ($11 | 0) == 8 : 1) {
          StdioFprintfPointer($7, $1, $2);
          $6 = 8;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          $10 = $10 + 1 | 0;
          continue;
         }
        }
        if (!global$2) {
         $2 = HEAP32[$9 + 4 >> 2];
         $1 = $7 + 16 | 0;
        }
        if (global$2 ? ($11 | 0) == 9 : 1) {
         StdioFprintfPointer($7, $1, $2);
         $6 = 9;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         $10 = $10 + 1 | 0;
         continue;
        }
       }
       if (global$2 ? ($11 | 0) == 10 : 1) {
        StdioOutPuts(5575, $7);
        $6 = 10;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
      }
      if (!global$2) {
       $10 = $10 + 1 | 0;
       continue;
      }
     }
     if (!global$2) {
      $4 = HEAP32[$7 + 4 >> 2];
      if (!(!$4 | HEAP32[$7 + 8 >> 2] < 1)) {
       HEAP8[$4 | 0] = 0
      }
      global$0 = $7 + 112 | 0;
      $4 = HEAP32[$7 + 12 >> 2];
      return $4;
     }
    }
    $1 = global$2 ? $1 : $1 << 24 >> 24;
    if (global$2 ? ($11 | 0) == 11 : 1) {
     StdioOutPutc($1, $7);
     $6 = 11;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (!global$2) {
     $4 = $4 + 1 | 0;
     continue;
    }
    break;
   };
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $4;
  HEAP32[$6 + 20 >> 2] = $5;
  HEAP32[$6 + 24 >> 2] = $7;
  HEAP32[$6 + 28 >> 2] = $8;
  HEAP32[$6 + 32 >> 2] = $9;
  HEAP32[$6 + 36 >> 2] = $10;
  HEAP32[$6 + 40 >> 2] = $13;
  HEAP32[$6 + 44 >> 2] = $12;
  HEAP32[$6 + 48 >> 2] = $14;
  HEAP32[$6 + 52 >> 2] = $15;
  HEAP32[$6 + 56 >> 2] = $16;
  wasm2js_scratch_store_f64(+$17);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  HEAP32[$6 + 60 >> 2] = wasm2js_scratch_load_i32(0);
  HEAP32[$6 + 64 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 68;
  return 0;
 }
 
 function StdioBaseScanf($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -56;
   $7 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$7 >> 2];
   $2 = HEAP32[$7 + 8 >> 2];
   $3 = HEAP32[$7 + 12 >> 2];
   $4 = HEAP32[$7 + 16 >> 2];
   $5 = HEAP32[$7 + 20 >> 2];
   $6 = HEAP32[$7 + 24 >> 2];
   $8 = HEAP32[$7 + 28 >> 2];
   $9 = HEAP32[$7 + 32 >> 2];
   $10 = HEAP32[$7 + 36 >> 2];
   $12 = HEAP32[$7 + 40 >> 2];
   $11 = HEAP32[$7 + 44 >> 2];
   $13 = HEAP32[$7 + 48 >> 2];
   $16 = HEAP32[$7 + 52 >> 2];
   $1 = HEAP32[$7 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $14 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = global$0 - 1248 | 0;
   global$0 = $5;
   $6 = HEAP32[$4 >> 2];
   $10 = HEAP32[$6 >> 2];
   $12 = strlen($3);
   $8 = 0;
  }
  label$2 : {
   while (1) {
    if (!global$2) {
     $6 = $3 + $8 | 0;
     $11 = HEAPU8[$6 | 0];
     $9 = ($11 | 0) != 37;
    }
    label$6 : {
     if ((global$2 | 0) == 2 | $9) {
      if (!global$2) {
       if ($11) {
        break label$6
       }
       $11 = dlmalloc($12 + 1 | 0);
       $6 = !$11;
      }
      if ((global$2 | 0) == 2 | $6) {
       if (global$2 ? !$14 : 1) {
        ProgramFail($0, 5579, 0);
        $15 = 0;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
      }
      if (!global$2) {
       $8 = 0;
       $6 = HEAPU8[$3 | 0];
       if ($6) {
        $12 = 0;
        while (1) {
         HEAP8[$8 + $11 | 0] = $6;
         $9 = $8 + 1 | 0;
         $13 = ($6 & 255) != 37;
         $7 = $9;
         label$17 : {
          if ($13) {
           break label$17
          }
          $13 = HEAPU8[($3 + $12 | 0) + 1 | 0] != 102;
          $7 = $9;
          if ($13) {
           break label$17
          }
          HEAP8[$9 + $11 | 0] = 108;
          $7 = $8 + 2 | 0;
         }
         $8 = $7;
         $12 = $12 + 1 | 0;
         $6 = HEAPU8[$12 + $3 | 0];
         if ($6) {
          continue
         }
         break;
        };
       }
       HEAP8[$8 + $11 | 0] = 0;
       $6 = HEAP32[$4 + 4 >> 2] >= 11;
      }
      if ((global$2 | 0) == 2 | $6) {
       if (!global$2) {
        HEAP32[$5 + 160 >> 2] = 10;
        $6 = $5 + 160 | 0;
       }
       if (global$2 ? ($14 | 0) == 1 : 1) {
        ProgramFail($0, 5593, $6);
        $15 = 1;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
      }
      $6 = global$2 ? $6 : HEAP32[$4 + 4 >> 2] >= 1;
      if ($6 | (global$2 | 0) == 2) {
       $8 = global$2 ? $8 : 0;
       while (1) {
        if (!global$2) {
         $10 = (TypeStackSizeValue($10) + 31 & -8) + $10 | 0;
         $6 = HEAP32[HEAP32[$10 >> 2] >> 2] + -12 | 0;
         $9 = $6 >>> 0 <= 1;
        }
        label$26 : {
         if (!global$2) {
          if ($9) {
           if ($6 - 1) {
            $6 = ($5 + 1200 | 0) + ($8 << 2) | 0;
            $9 = HEAP32[HEAP32[$10 + 4 >> 2] >> 2];
            HEAP32[$6 >> 2] = $9;
            break label$26;
           }
           $6 = ($5 + 1200 | 0) + ($8 << 2) | 0;
           $9 = HEAP32[$10 + 4 >> 2];
           HEAP32[$6 >> 2] = $9;
           break label$26;
          }
          HEAP32[$5 + 144 >> 2] = $8 + 1;
          $6 = $5 + 144 | 0;
         }
         if (global$2 ? ($14 | 0) == 2 : 1) {
          ProgramFail($0, 5632, $6);
          $15 = 2;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
        }
        if (!global$2) {
         $8 = $8 + 1 | 0;
         $6 = ($8 | 0) < HEAP32[$4 + 4 >> 2];
         if ($6) {
          continue
         }
        }
        break;
       };
      }
      $4 = global$2 ? $4 : HEAP32[3046] == ($1 | 0);
      label$32 : {
       if ($4 | (global$2 | 0) == 2) {
        if (!global$2) {
         $12 = HEAP32[3226];
         $9 = $5 + 16 | 0;
         $4 = $5 + 20 | 0;
         $2 = $5 + 28 | 0;
         $13 = $5 + 32 | 0;
         $16 = $5 + 36 | 0;
         $6 = 0;
         $10 = 0;
         $1 = $5 + 24 | 0;
        }
        while (1) {
         if (global$2 ? ($14 | 0) == 3 : 1) {
          $7 = fflush($12);
          $15 = 3;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $3 = $7;
         }
         if (!global$2) {
          $8 = $5 + 176 | 0;
          $3 = HEAP32[$0 >> 2];
         }
         if (global$2 ? ($14 | 0) == 4 : 1) {
          $7 = em_gets($3, $8, 1024, 0);
          $15 = 4;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $8 = $7;
         }
         if (!global$2) {
          HEAP32[$9 >> 2] = HEAP32[($5 + 1200 | 0) + (($6 + 4 | 0) % 10 << 2) >> 2];
          HEAP32[$4 >> 2] = HEAP32[($5 + 1200 | 0) + (($6 + 5 | 0) % 10 << 2) >> 2];
          HEAP32[$1 >> 2] = HEAP32[($5 + 1200 | 0) + (($6 + 6 | 0) % 10 << 2) >> 2];
          HEAP32[$2 >> 2] = HEAP32[($5 + 1200 | 0) + (($6 + 7 | 0) % 10 << 2) >> 2];
          HEAP32[$13 >> 2] = HEAP32[($5 + 1200 | 0) + (($6 + 8 | 0) % 10 << 2) >> 2];
          HEAP32[$16 >> 2] = HEAP32[($5 + 1200 | 0) + (($6 + 9 | 0) % 10 << 2) >> 2];
          HEAP32[$5 >> 2] = HEAP32[($5 + 1200 | 0) + (($6 | 0) % 10 << 2) >> 2];
          HEAP32[$5 + 4 >> 2] = HEAP32[($5 + 1200 | 0) + (($6 + 1 | 0) % 10 << 2) >> 2];
          HEAP32[$5 + 8 >> 2] = HEAP32[($5 + 1200 | 0) + (($6 + 2 | 0) % 10 << 2) >> 2];
          HEAP32[$5 + 12 >> 2] = HEAP32[($5 + 1200 | 0) + (($6 + 3 | 0) % 10 << 2) >> 2];
          $3 = $10 + $11 | 0;
         }
         if (global$2 ? ($14 | 0) == 5 : 1) {
          $7 = sscanf($8, $3, $5);
          $15 = 5;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $8 = $7;
         }
         if (!global$2) {
          $6 = $6 + $8 | 0;
          while (1) {
           if (($8 | 0) >= 1) {
            $10 = $10 + 1 | 0;
            $3 = HEAPU8[$11 + $10 | 0];
            $8 = $8 - (($3 | 0) == 37) | 0;
            if ($3) {
             continue
            }
           }
           break;
          };
          $3 = HEAPU8[$10 + $11 | 0];
          if ($3) {
           continue
          }
         }
         break;
        };
        if (!global$2) {
         dlfree($11);
         $8 = 0;
         break label$32;
        }
       }
       if (!global$2) {
        $8 = HEAP32[$5 + 1236 >> 2];
        $10 = HEAP32[$5 + 1232 >> 2];
        $11 = HEAP32[$5 + 1228 >> 2];
        $6 = HEAP32[$5 + 1224 >> 2];
        $12 = HEAP32[$5 + 1220 >> 2];
        $9 = HEAP32[$5 + 1216 >> 2];
        $4 = HEAP32[$5 + 1212 >> 2];
        $13 = HEAP32[$5 + 1204 >> 2];
        $16 = HEAP32[$5 + 1200 >> 2];
        $0 = HEAP32[$5 + 1208 >> 2];
       }
       if ((global$2 | 0) == 2 | $1) {
        if (!global$2) {
         HEAP32[$5 + 132 >> 2] = $8;
         HEAP32[$5 + 128 >> 2] = $10;
         HEAP32[$5 + 124 >> 2] = $11;
         HEAP32[$5 + 120 >> 2] = $6;
         HEAP32[$5 + 116 >> 2] = $12;
         HEAP32[$5 + 112 >> 2] = $9;
         HEAP32[$5 + 108 >> 2] = $4;
         HEAP32[$5 + 104 >> 2] = $0;
         HEAP32[$5 + 100 >> 2] = $13;
         HEAP32[$5 + 96 >> 2] = $16;
         $0 = $5 + 96 | 0;
        }
        if (global$2 ? ($14 | 0) == 6 : 1) {
         $7 = fscanf($1, $3, $0);
         $15 = 6;
         if ((global$2 | 0) == 1) {
          break label$2
         }
         $8 = $7;
        }
        if (!global$2) {
         break label$32
        }
       }
       if (!global$2) {
        HEAP32[$5 + 84 >> 2] = $8;
        HEAP32[$5 + 80 >> 2] = $10;
        HEAP32[$5 + 76 >> 2] = $11;
        HEAP32[$5 + 72 >> 2] = $6;
        HEAP32[$5 + 68 >> 2] = $12;
        $1 = $5 - -64 | 0;
        HEAP32[$1 >> 2] = $9;
        HEAP32[$5 + 60 >> 2] = $4;
        HEAP32[$5 + 56 >> 2] = $0;
        HEAP32[$5 + 52 >> 2] = $13;
        HEAP32[$5 + 48 >> 2] = $16;
        $0 = $5 + 48 | 0;
       }
       if (global$2 ? ($14 | 0) == 7 : 1) {
        $7 = sscanf($2, $3, $0);
        $15 = 7;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $8 = $7;
       }
      }
      if (!global$2) {
       global$0 = $5 + 1248 | 0;
       return $8;
      }
     }
     if (!global$2) {
      $6 = HEAPU8[$6 + 1 | 0] == 102;
      $12 = $12 + $6 | 0;
     }
    }
    if (!global$2) {
     $8 = $8 + 1 | 0;
     continue;
    }
    break;
   };
   abort();
  }
  $7 = $15;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $7 = HEAP32[global$3 >> 2];
  HEAP32[$7 >> 2] = $0;
  HEAP32[$7 + 4 >> 2] = $1;
  HEAP32[$7 + 8 >> 2] = $2;
  HEAP32[$7 + 12 >> 2] = $3;
  HEAP32[$7 + 16 >> 2] = $4;
  HEAP32[$7 + 20 >> 2] = $5;
  HEAP32[$7 + 24 >> 2] = $6;
  HEAP32[$7 + 28 >> 2] = $8;
  HEAP32[$7 + 32 >> 2] = $9;
  HEAP32[$7 + 36 >> 2] = $10;
  HEAP32[$7 + 40 >> 2] = $12;
  HEAP32[$7 + 44 >> 2] = $11;
  HEAP32[$7 + 48 >> 2] = $13;
  HEAP32[$7 + 52 >> 2] = $16;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 56;
  return 0;
 }
 
 function StdioFopen($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = fopen(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdioFreopen($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $3 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = freopen($0, $3, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioFclose($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $0 = global$2 ? $0 : HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = fclose($0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioFread($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $4 = HEAP32[$4 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $3 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
   $4 = HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = fread($0, $3, $4, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function StdioFwrite($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $4 = HEAP32[$4 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $3 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
   $4 = HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = fwrite($0, $3, $4, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function StdioFgetc($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $0 = global$2 ? $0 : HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = fgetc($0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioFgets($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if (global$2) {
    $4 = $5
   } else {
    $3 = HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2];
    $4 = ($3 | 0) == HEAP32[3046];
   }
   label$4 : {
    if ($4 | (global$2 | 0) == 2) {
     if (!global$2) {
      $3 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
      $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
      $0 = HEAP32[$0 >> 2];
     }
     if (global$2 ? !$6 : 1) {
      $4 = em_gets($0, $3, $2, 0);
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $2 = $4;
     }
     if (!global$2) {
      break label$4
     }
    }
    if (!global$2) {
     $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
     $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
    }
    if (global$2 ? ($6 | 0) == 1 : 1) {
     $4 = fgets($0, $2, $3);
     $7 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $2 = $4;
    }
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  $4 = $7;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function StdioRemove($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = remove(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdioRename($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = rename(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdioRewind($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $0 = global$2 ? $0 : HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  label$2 : {
   if (global$2 ? !$4 : 1) {
    rewind($0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioTmpfile($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = tmpfile();
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function StdioClearerr($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  clearerr(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdioFeof($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = feof(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdioFerror($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = ferror(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdioFileno($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = fileno(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdioFflush($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $0 = global$2 ? $0 : HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = fflush($0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioFgetpos($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = fgetpos($0, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioFsetpos($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = fsetpos($0, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioFputc($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = fputc($0, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioFputs($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = fputs($0, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioFtell($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $0 = global$2 ? $0 : HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = ftell($0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioFseek($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $3 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = fseek($0, $3, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioPerror($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $0 = global$2 ? $0 : HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  label$2 : {
   if (global$2 ? !$4 : 1) {
    perror($0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioPutc($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = putc($0, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioPutchar($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $0 = global$2 ? $0 : HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $4 = putchar($0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
    $0 = HEAP32[3226];
   }
   if (global$2 ? ($5 | 0) == 1 : 1) {
    fflush($0);
    $6 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  $4 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioSetbuf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  setbuf(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdioSetvbuf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  setvbuf(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdioUngetc($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = ungetc($0, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioPuts($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $0 = global$2 ? $0 : HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $4 = puts($0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
    $0 = HEAP32[3226];
   }
   if (global$2 ? ($5 | 0) == 1 : 1) {
    fflush($0);
    $6 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  $4 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioGets($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $2 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $3 = HEAP32[4706];
   $0 = HEAP32[$0 >> 2];
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = em_gets($0, $2, $3, 1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioGetchar($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $0 = global$2 ? $0 : HEAP32[$0 >> 2];
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = em_getchar($0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdioPrintf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $6 = HEAP32[$4 + 20 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $7 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = global$0 - 16 | 0;
   global$0 = $5;
   HEAP32[$5 + 12 >> 2] = $3 + -1;
   HEAP32[$5 + 8 >> 2] = $2;
   $3 = HEAP32[3226];
   $6 = $5 + 8 | 0;
   $2 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$7 : 1) {
    $4 = StdioBasePrintf($0, $3, 0, 0, $2, $6);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   if (global$2 ? ($7 | 0) == 1 : 1) {
    fflush($3);
    $8 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    global$0 = $5 + 16 | 0
   }
   return;
  }
  $4 = $8;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  HEAP32[$4 + 20 >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
 }
 
 function StdioVprintf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $4 = HEAP32[$4 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = HEAP32[3226];
   $4 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = StdioBasePrintf($0, $3, 0, 0, $4, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function StdioFprintf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $6 = HEAP32[$4 + 16 >> 2];
   $4 = HEAP32[$4 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = global$0 - 16 | 0;
   global$0 = $6;
   HEAP32[$6 + 12 >> 2] = $3 + -2;
   HEAP32[$6 + 8 >> 2] = $2 + 4;
   $3 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $4 = $6 + 8 | 0;
   $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = StdioBasePrintf($0, $3, 0, 0, $2, $4);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
    global$0 = $6 + 16 | 0;
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $6;
  HEAP32[$5 + 20 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
 }
 
 function StdioVfprintf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $4 = HEAP32[$4 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $4 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = StdioBasePrintf($0, $3, 0, 0, $4, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function StdioSprintf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $6 = HEAP32[$4 + 16 >> 2];
   $4 = HEAP32[$4 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = global$0 - 16 | 0;
   global$0 = $6;
   HEAP32[$6 + 12 >> 2] = $3 + -2;
   HEAP32[$6 + 8 >> 2] = $2 + 4;
   $3 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $4 = $6 + 8 | 0;
   $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = StdioBasePrintf($0, 0, $3, -1, $2, $4);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
    global$0 = $6 + 16 | 0;
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $6;
  HEAP32[$5 + 20 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
 }
 
 function StdioSnprintf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -28;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $6 = HEAP32[$4 + 16 >> 2];
   $7 = HEAP32[$4 + 20 >> 2];
   $4 = HEAP32[$4 + 24 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = global$0 - 16 | 0;
   global$0 = $6;
   HEAP32[$6 + 12 >> 2] = $3 + -3;
   HEAP32[$6 + 8 >> 2] = $2 + 8;
   $3 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $7 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
   $4 = $6 + 8 | 0;
   $2 = HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = StdioBasePrintf($0, 0, $3, $7, $2, $4);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
    global$0 = $6 + 16 | 0;
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $6;
  HEAP32[$5 + 20 >> 2] = $7;
  HEAP32[$5 + 24 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 28;
 }
 
 function StdioScanf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $6 = HEAP32[$4 + 16 >> 2];
   $4 = HEAP32[$4 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = global$0 - 16 | 0;
   global$0 = $6;
   HEAP32[$6 + 12 >> 2] = $3 + -1;
   HEAP32[$6 + 8 >> 2] = $2;
   $3 = HEAP32[3046];
   $4 = $6 + 8 | 0;
   $2 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = StdioBaseScanf($0, $3, 0, $2, $4);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
    global$0 = $6 + 16 | 0;
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $6;
  HEAP32[$5 + 20 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
 }
 
 function StdioFscanf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $6 = HEAP32[$4 + 16 >> 2];
   $4 = HEAP32[$4 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = global$0 - 16 | 0;
   global$0 = $6;
   HEAP32[$6 + 12 >> 2] = $3 + -2;
   HEAP32[$6 + 8 >> 2] = $2 + 4;
   $3 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $4 = $6 + 8 | 0;
   $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = StdioBaseScanf($0, $3, 0, $2, $4);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
    global$0 = $6 + 16 | 0;
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $6;
  HEAP32[$5 + 20 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
 }
 
 function StdioSscanf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $6 = HEAP32[$4 + 16 >> 2];
   $4 = HEAP32[$4 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = global$0 - 16 | 0;
   global$0 = $6;
   HEAP32[$6 + 12 >> 2] = $3 + -2;
   HEAP32[$6 + 8 >> 2] = $2 + 4;
   $3 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $4 = $6 + 8 | 0;
   $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = StdioBaseScanf($0, 0, $3, $2, $4);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
    global$0 = $6 + 16 | 0;
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $6;
  HEAP32[$5 + 20 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
 }
 
 function StdioVsprintf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $4 = HEAP32[$4 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $4 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = StdioBasePrintf($0, 0, $3, -1, $4, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function StdioVsnprintf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $6 = HEAP32[$4 + 16 >> 2];
   $4 = HEAP32[$4 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $6 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
   $4 = HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = StdioBasePrintf($0, 0, $3, $6, $4, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $6;
  HEAP32[$5 + 20 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
 }
 
 function StdioVscanf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $4 = HEAP32[$4 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = HEAP32[3046];
   $4 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = StdioBaseScanf($0, $3, 0, $4, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function StdioVfscanf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $4 = HEAP32[$4 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $4 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = StdioBaseScanf($0, $3, 0, $4, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function StdioVsscanf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $4 = HEAP32[$4 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $4 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = StdioBaseScanf($0, 0, $3, $4, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $5;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function StdioSetupFunc($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $5 = HEAP32[$3 + 8 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   }
   if (global$2 ? !$2 : 1) {
    $3 = TableStrRegister($0, 7058);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $3;
   }
   if (global$2 ? ($2 | 0) == 1 : 1) {
    $3 = TypeCreateOpaqueStruct($0, 0, $1, 300);
    $4 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $3;
   }
   $5 = global$2 ? $5 : HEAP32[$0 + 2756 >> 2];
   if (global$2 ? ($2 | 0) == 2 : 1) {
    $3 = TypeGetMatching($0, 0, $1, 12, 0, $5, 1);
    $4 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $5 = $3;
   }
   if (global$2 ? ($2 | 0) == 3 : 1) {
    $3 = TableStrRegister($0, 7071);
    $4 = 3;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $3;
   }
   if (global$2 ? ($2 | 0) == 4 : 1) {
    $3 = TypeCreateOpaqueStruct($0, 0, $1, 300);
    $4 = 4;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   } else {
    $3 = $1
   }
   $1 = global$2 ? $3 : $0 + 1412 | 0;
   if (global$2 ? ($2 | 0) == 5 : 1) {
    VariableDefinePlatformVar($0, 0, 7087, $1, 19216, 0);
    $4 = 5;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 6 : 1) {
    VariableDefinePlatformVar($0, 0, 7091, $1, 21764, 0);
    $4 = 6;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 7 : 1) {
    VariableDefinePlatformVar($0, 0, 7100, $1, 19220, 0);
    $4 = 7;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 8 : 1) {
    VariableDefinePlatformVar($0, 0, 7109, $1, 19224, 0);
    $4 = 8;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 9 : 1) {
    VariableDefinePlatformVar($0, 0, 7118, $1, 19228, 0);
    $4 = 9;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 10 : 1) {
    VariableDefinePlatformVar($0, 0, 7125, $1, 19232, 0);
    $4 = 10;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 11 : 1) {
    VariableDefinePlatformVar($0, 0, 7138, $1, 21768, 0);
    $4 = 11;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 12 : 1) {
    VariableDefinePlatformVar($0, 0, 7145, $1, 19236, 0);
    $4 = 12;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 13 : 1) {
    VariableDefinePlatformVar($0, 0, 7152, $1, 19240, 0);
    $4 = 13;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 14 : 1) {
    VariableDefinePlatformVar($0, 0, 7159, $1, 19244, 0);
    $4 = 14;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 15 : 1) {
    VariableDefinePlatformVar($0, 0, 7168, $1, 18824, 0);
    $4 = 15;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 16 : 1) {
    VariableDefinePlatformVar($0, 0, 7177, $5, 21752, 0);
    $4 = 16;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 17 : 1) {
    VariableDefinePlatformVar($0, 0, 7183, $5, 21756, 0);
    $4 = 17;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 18 : 1) {
    VariableDefinePlatformVar($0, 0, 7190, $5, 21760, 0);
    $4 = 18;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($2 | 0) == 19 : 1) {
    $3 = TableStrRegister($0, 7197);
    $4 = 19;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $5 = $3;
   }
   if (!global$2) {
    $5 = !VariableDefined($0, $5)
   }
   if ((global$2 | 0) == 2 | $5) {
    if (global$2 ? ($2 | 0) == 20 : 1) {
     VariableDefinePlatformVar($0, 0, 7197, $1, 21772, 0);
     $4 = 20;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
 }
 
 function PrintCh($0, $1) {
  var $2 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   } else {
    $2 = 0
   }
   if (global$2 ? !$2 : 1) {
    putc($0, $1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function PrintSimpleInt($0, $1) {
  var $2 = 0, $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $2 = global$0 - 16 | 0;
   global$0 = $2;
   HEAP32[$2 >> 2] = $0;
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    fiprintf($1, 7202, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    global$0 = $2 + 16 | 0
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
 }
 
 function PrintStr($0, $1) {
  var $2 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   } else {
    $2 = 0
   }
   if (global$2 ? !$2 : 1) {
    fputs($0, $1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function PrintFP($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $2 = HEAP32[global$3 >> 2];
   $4 = HEAP32[$2 + 4 >> 2];
   wasm2js_scratch_store_i32(0, HEAP32[$2 >> 2]);
   wasm2js_scratch_store_i32(1, $4 | 0);
   $0 = +wasm2js_scratch_load_f64();
   $1 = HEAP32[$2 + 8 >> 2];
   $2 = HEAP32[$2 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $2 = global$0 - 16 | 0;
   global$0 = $2;
   HEAPF64[$2 >> 3] = $0;
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    __small_fprintf($1, 7206, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    global$0 = $2 + 16 | 0
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  wasm2js_scratch_store_f64(+$0);
  $4 = wasm2js_scratch_load_i32(1) | 0;
  HEAP32[$3 >> 2] = wasm2js_scratch_load_i32(0);
  HEAP32[$3 + 4 >> 2] = $4;
  HEAP32[$3 + 8 >> 2] = $1;
  HEAP32[$3 + 12 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function MathSin($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = sin(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathCos($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = cos(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathTan($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = tan(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathAsin($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = asin(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathAcos($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = acos(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathAtan($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = atan(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathAtan2($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = atan2(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3], HEAPF64[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathSinh($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = sinh(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathCosh($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = cosh(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathTanh($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = tanh(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathExp($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = exp(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathFabs($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = Math_abs(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathFmod($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = fmod(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3], HEAPF64[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathFrexp($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0.0;
  $4 = frexp(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = $4;
 }
 
 function MathLdexp($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = ldexp(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
 }
 
 function MathLog($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = log(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathLog10($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = log10(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathModf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0.0;
  $2 = HEAP32[HEAP32[$2 >> 2] + 4 >> 2];
  $4 = modf(HEAPF64[$2 >> 3], HEAP32[$2 >> 2]);
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = $4;
 }
 
 function MathPow($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = pow(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3], HEAPF64[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathSqrt($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = Math_sqrt(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathRound($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = Math_ceil(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3] + -.5);
 }
 
 function MathCeil($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = Math_ceil(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathFloor($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = Math_floor(HEAPF64[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 3]);
 }
 
 function MathSetupFunc($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  } else {
   $1 = 0
  }
  $1 = global$2 ? $1 : $0 + 1764 | 0;
  label$1 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   }
   if (global$2 ? !$2 : 1) {
    VariableDefinePlatformVar($0, 0, 7687, $1, 19440, 0);
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   if (global$2 ? ($2 | 0) == 1 : 1) {
    VariableDefinePlatformVar($0, 0, 7691, $1, 19448, 0);
    $3 = 1;
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   if (global$2 ? ($2 | 0) == 2 : 1) {
    VariableDefinePlatformVar($0, 0, 7699, $1, 19456, 0);
    $3 = 2;
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   if (global$2 ? ($2 | 0) == 3 : 1) {
    VariableDefinePlatformVar($0, 0, 7708, $1, 19464, 0);
    $3 = 3;
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   if (global$2 ? ($2 | 0) == 4 : 1) {
    VariableDefinePlatformVar($0, 0, 7714, $1, 19472, 0);
    $3 = 4;
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   if (global$2 ? ($2 | 0) == 5 : 1) {
    VariableDefinePlatformVar($0, 0, 7721, $1, 19480, 0);
    $3 = 5;
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   if (global$2 ? ($2 | 0) == 6 : 1) {
    VariableDefinePlatformVar($0, 0, 7726, $1, 19488, 0);
    $3 = 6;
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   if (global$2 ? ($2 | 0) == 7 : 1) {
    VariableDefinePlatformVar($0, 0, 7733, $1, 19496, 0);
    $3 = 7;
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   if (global$2 ? ($2 | 0) == 8 : 1) {
    VariableDefinePlatformVar($0, 0, 7740, $1, 19504, 0);
    $3 = 8;
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   if (global$2 ? ($2 | 0) == 9 : 1) {
    VariableDefinePlatformVar($0, 0, 7747, $1, 19512, 0);
    $3 = 9;
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   if (global$2 ? ($2 | 0) == 10 : 1) {
    VariableDefinePlatformVar($0, 0, 7754, $1, 19520, 0);
    $3 = 10;
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   if (global$2 ? ($2 | 0) == 11 : 1) {
    VariableDefinePlatformVar($0, 0, 7765, $1, 19528, 0);
    $3 = 11;
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   if (global$2 ? ($2 | 0) == 12 : 1) {
    VariableDefinePlatformVar($0, 0, 7773, $1, 19536, 0);
    $3 = 12;
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   return;
  }
  $2 = $3;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function StringStrcpy($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = strcpy(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StringStrncpy($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = strncpy(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StringStrcmp($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = strcmp(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StringStrncmp($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = strncmp(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StringStrcat($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = strcat(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StringStrncat($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = strncat(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StringIndex($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = index(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StringRindex($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = rindex(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StringStrlen($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = strlen(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StringMemset($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = memset(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StringMemcpy($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = memcpy(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StringMemcmp($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = memcmp(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StringMemmove($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = memmove(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StringMemchr($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = memchr(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StringStrchr($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = strchr(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StringStrrchr($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = strrchr(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StringStrcoll($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = strcoll(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StringStrerror($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = strerror(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StringStrspn($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = strspn(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StringStrcspn($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = strcspn(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StringStrpbrk($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = strpbrk(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StringStrstr($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = strstr(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StringStrtok($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = strtok(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StringStrxfrm($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = strxfrm(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StringStrdup($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = __strdup(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StringStrtok_r($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = strtok_r(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StringSetupFunc($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $2 = HEAP32[$1 + 4 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   }
   if (global$2 ? !$3 : 1) {
    $1 = TableStrRegister($0, 8535);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $1;
   }
   if (!global$2) {
    $2 = !VariableDefined($0, $2)
   }
   if ((global$2 | 0) == 2 | $2) {
    $2 = global$2 ? $2 : $0 + 1412 | 0;
    if (global$2 ? ($3 | 0) == 1 : 1) {
     VariableDefinePlatformVar($0, 0, 8535, $2, 21776, 0);
     $4 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   return;
  }
  $1 = $4;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function StdlibAtof($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0.0, $6 = 0, $7 = 0.0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $1 = HEAP32[$4 + 20 >> 2];
   wasm2js_scratch_store_i32(0, HEAP32[$4 + 16 >> 2]);
   wasm2js_scratch_store_i32(1, $1 | 0);
   $5 = +wasm2js_scratch_load_f64();
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = HEAP32[$1 + 4 >> 2];
   $1 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$6 : 1) {
    $7 = atof($1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $5 = $7;
   }
   if (!global$2) {
    HEAPF64[$0 >> 3] = $5
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  wasm2js_scratch_store_f64(+$5);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  HEAP32[$4 + 16 >> 2] = wasm2js_scratch_load_i32(0);
  HEAP32[$4 + 20 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
 }
 
 function StdlibAtoi($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = atoi(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdlibAtol($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = atol(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdlibStrtod($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0, $5 = 0.0, $6 = 0, $7 = 0.0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $1 = HEAP32[$4 + 20 >> 2];
   wasm2js_scratch_store_i32(0, HEAP32[$4 + 16 >> 2]);
   wasm2js_scratch_store_i32(1, $1 | 0);
   $5 = +wasm2js_scratch_load_f64();
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$6 : 1) {
    $7 = strtod($0, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $5 = $7;
   }
   if (!global$2) {
    HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = $5
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  wasm2js_scratch_store_f64(+$5);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  HEAP32[$4 + 16 >> 2] = wasm2js_scratch_load_i32(0);
  HEAP32[$4 + 20 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
 }
 
 function StdlibStrtol($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $3 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = strtol($0, $3, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdlibStrtoul($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $3 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = strtoul($0, $3, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdlibMalloc($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = dlmalloc(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdlibCalloc($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = dlcalloc(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdlibRealloc($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = dlrealloc(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdlibFree($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  dlfree(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdlibRand($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = rand();
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function StdlibSrand($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  srand(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdlibAbort($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   } else {
    $4 = 0
   }
   if (global$2 ? !$4 : 1) {
    ProgramFail($0, 8540, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function StdlibExit($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  PlatformExit(HEAP32[$0 >> 2], HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdlibGetenv($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = getenv(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdlibSystem($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = system(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdlibAbs($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $3 = HEAP32[$1 + 4 >> 2];
  $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  $1 = $0 >> 31;
  HEAP32[$3 >> 2] = $1 ^ $0 + $1;
 }
 
 function StdlibLabs($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $3 = HEAP32[$1 + 4 >> 2];
  $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  $1 = $0 >> 31;
  HEAP32[$3 >> 2] = $1 ^ $0 + $1;
 }
 
 function StdlibSetupFunc($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $2 = HEAP32[$1 + 4 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   }
   if (global$2 ? !$3 : 1) {
    $1 = TableStrRegister($0, 8915);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $1;
   }
   if (!global$2) {
    $2 = !VariableDefined($0, $2)
   }
   if ((global$2 | 0) == 2 | $2) {
    $2 = global$2 ? $2 : $0 + 1412 | 0;
    if (global$2 ? ($3 | 0) == 1 : 1) {
     VariableDefinePlatformVar($0, 0, 8915, $2, 21780, 0);
     $4 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   return;
  }
  $1 = $4;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function StdAsctime($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = asctime(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdClock($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = clock() | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function StdCtime($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = ctime(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdDifftime($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0.0;
  $4 = +difftime(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAPF64[HEAP32[$1 + 4 >> 2] >> 3] = $4;
 }
 
 function StdGmtime($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = gmtime(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdLocaltime($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = localtime(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdMktime($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = mktime(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdTime($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = time(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdStrftime($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = strftime(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 12 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdStrptime($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = strptime(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdGmtime_r($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = gmtime_r(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdTimegm($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = timegm(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function StdTimeSetupFunc($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $2 = HEAP32[$1 + 4 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   }
   if (global$2 ? !$3 : 1) {
    $1 = TableStrRegister($0, 9319);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $1;
   }
   if (global$2 ? ($3 | 0) == 1 : 1) {
    $1 = TypeCreateOpaqueStruct($0, 0, $2, 44);
    $4 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   } else {
    $1 = $2
   }
   $2 = global$2 ? $1 : $0 + 1412 | 0;
   if (global$2 ? ($3 | 0) == 2 : 1) {
    VariableDefinePlatformVar($0, 0, 9322, $2, 20040, 0);
    $4 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  $1 = $4;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function StdErrnoSetupFunc($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 4 >> 2];
   $4 = HEAP32[$4 + 8 >> 2];
  }
  $2 = global$2 ? $2 : $0 + 1412 | 0;
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $1 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   }
   if (global$2 ? !$1 : 1) {
    VariableDefinePlatformVar($0, 0, 9337, $2, 20044, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 1 : 1) {
    VariableDefinePlatformVar($0, 0, 9344, $2, 20048, 0);
    $3 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 2 : 1) {
    VariableDefinePlatformVar($0, 0, 9355, $2, 20052, 0);
    $3 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 3 : 1) {
    VariableDefinePlatformVar($0, 0, 9369, $2, 20056, 0);
    $3 = 3;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 4 : 1) {
    VariableDefinePlatformVar($0, 0, 9382, $2, 20060, 0);
    $3 = 4;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 5 : 1) {
    VariableDefinePlatformVar($0, 0, 9389, $2, 20064, 0);
    $3 = 5;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 6 : 1) {
    VariableDefinePlatformVar($0, 0, 9398, $2, 20068, 0);
    $3 = 6;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 7 : 1) {
    VariableDefinePlatformVar($0, 0, 9404, $2, 20072, 0);
    $3 = 7;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 8 : 1) {
    VariableDefinePlatformVar($0, 0, 9412, $2, 20076, 0);
    $3 = 8;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 9 : 1) {
    VariableDefinePlatformVar($0, 0, 9418, $2, 20080, 0);
    $3 = 9;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 10 : 1) {
    VariableDefinePlatformVar($0, 0, 9428, $2, 20084, 0);
    $3 = 10;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 11 : 1) {
    VariableDefinePlatformVar($0, 0, 9435, $2, 20088, 0);
    $3 = 11;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 12 : 1) {
    VariableDefinePlatformVar($0, 0, 9448, $2, 20092, 0);
    $3 = 12;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 13 : 1) {
    VariableDefinePlatformVar($0, 0, 9461, $2, 20096, 0);
    $3 = 13;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 14 : 1) {
    VariableDefinePlatformVar($0, 0, 9472, $2, 20100, 0);
    $3 = 14;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 15 : 1) {
    VariableDefinePlatformVar($0, 0, 9480, $2, 20104, 0);
    $3 = 15;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 16 : 1) {
    VariableDefinePlatformVar($0, 0, 9493, $2, 20108, 0);
    $3 = 16;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 17 : 1) {
    VariableDefinePlatformVar($0, 0, 9498, $2, 20112, 0);
    $3 = 17;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 18 : 1) {
    VariableDefinePlatformVar($0, 0, 9505, $2, 20116, 0);
    $3 = 18;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 19 : 1) {
    VariableDefinePlatformVar($0, 0, 9512, $2, 20120, 0);
    $3 = 19;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 20 : 1) {
    VariableDefinePlatformVar($0, 0, 9519, $2, 20124, 0);
    $3 = 20;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 21 : 1) {
    VariableDefinePlatformVar($0, 0, 9525, $2, 20128, 0);
    $3 = 21;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 22 : 1) {
    VariableDefinePlatformVar($0, 0, 9538, $2, 20132, 0);
    $3 = 22;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 23 : 1) {
    VariableDefinePlatformVar($0, 0, 9544, $2, 20136, 0);
    $3 = 23;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 24 : 1) {
    VariableDefinePlatformVar($0, 0, 9551, $2, 20140, 0);
    $3 = 24;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 25 : 1) {
    VariableDefinePlatformVar($0, 0, 9563, $2, 20144, 0);
    $3 = 25;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 26 : 1) {
    VariableDefinePlatformVar($0, 0, 9569, $2, 20148, 0);
    $3 = 26;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 27 : 1) {
    VariableDefinePlatformVar($0, 0, 9576, $2, 20152, 0);
    $3 = 27;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 28 : 1) {
    VariableDefinePlatformVar($0, 0, 9580, $2, 20156, 0);
    $3 = 28;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 29 : 1) {
    VariableDefinePlatformVar($0, 0, 9588, $2, 20160, 0);
    $3 = 29;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 30 : 1) {
    VariableDefinePlatformVar($0, 0, 9595, $2, 20164, 0);
    $3 = 30;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 31 : 1) {
    VariableDefinePlatformVar($0, 0, 9601, $2, 20168, 0);
    $3 = 31;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 32 : 1) {
    VariableDefinePlatformVar($0, 0, 9608, $2, 20172, 0);
    $3 = 32;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 33 : 1) {
    VariableDefinePlatformVar($0, 0, 9615, $2, 20176, 0);
    $3 = 33;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 34 : 1) {
    VariableDefinePlatformVar($0, 0, 9624, $2, 20180, 0);
    $3 = 34;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 35 : 1) {
    VariableDefinePlatformVar($0, 0, 9634, $2, 20184, 0);
    $3 = 35;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 36 : 1) {
    VariableDefinePlatformVar($0, 0, 9647, $2, 20188, 0);
    $3 = 36;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 37 : 1) {
    VariableDefinePlatformVar($0, 0, 9656, $2, 20192, 0);
    $3 = 37;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 38 : 1) {
    VariableDefinePlatformVar($0, 0, 9666, $2, 20196, 0);
    $3 = 38;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 39 : 1) {
    VariableDefinePlatformVar($0, 0, 9678, $2, 20200, 0);
    $3 = 39;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 40 : 1) {
    VariableDefinePlatformVar($0, 0, 9685, $2, 20204, 0);
    $3 = 40;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 41 : 1) {
    VariableDefinePlatformVar($0, 0, 9693, $2, 20208, 0);
    $3 = 41;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 42 : 1) {
    VariableDefinePlatformVar($0, 0, 9701, $2, 20212, 0);
    $3 = 42;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 43 : 1) {
    VariableDefinePlatformVar($0, 0, 9708, $2, 20216, 0);
    $3 = 43;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 44 : 1) {
    VariableDefinePlatformVar($0, 0, 9715, $2, 20220, 0);
    $3 = 44;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 45 : 1) {
    VariableDefinePlatformVar($0, 0, 9723, $2, 20224, 0);
    $3 = 45;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 46 : 1) {
    VariableDefinePlatformVar($0, 0, 9730, $2, 20228, 0);
    $3 = 46;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 47 : 1) {
    VariableDefinePlatformVar($0, 0, 9738, $2, 20232, 0);
    $3 = 47;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 48 : 1) {
    VariableDefinePlatformVar($0, 0, 9745, $2, 20236, 0);
    $3 = 48;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 49 : 1) {
    VariableDefinePlatformVar($0, 0, 9752, $2, 20240, 0);
    $3 = 49;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 50 : 1) {
    VariableDefinePlatformVar($0, 0, 9764, $2, 20244, 0);
    $3 = 50;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 51 : 1) {
    VariableDefinePlatformVar($0, 0, 9771, $2, 20248, 0);
    $3 = 51;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 52 : 1) {
    VariableDefinePlatformVar($0, 0, 9777, $2, 20252, 0);
    $3 = 52;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 53 : 1) {
    VariableDefinePlatformVar($0, 0, 9784, $2, 20256, 0);
    $3 = 53;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 54 : 1) {
    VariableDefinePlatformVar($0, 0, 9791, $2, 20260, 0);
    $3 = 54;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 55 : 1) {
    VariableDefinePlatformVar($0, 0, 9800, $2, 20264, 0);
    $3 = 55;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 56 : 1) {
    VariableDefinePlatformVar($0, 0, 9808, $2, 20268, 0);
    $3 = 56;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 57 : 1) {
    VariableDefinePlatformVar($0, 0, 9818, $2, 20272, 0);
    $3 = 57;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 58 : 1) {
    VariableDefinePlatformVar($0, 0, 9834, $2, 20276, 0);
    $3 = 58;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 59 : 1) {
    VariableDefinePlatformVar($0, 0, 9843, $2, 20280, 0);
    $3 = 59;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 60 : 1) {
    VariableDefinePlatformVar($0, 0, 9851, $2, 20284, 0);
    $3 = 60;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 61 : 1) {
    VariableDefinePlatformVar($0, 0, 9858, $2, 20288, 0);
    $3 = 61;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 62 : 1) {
    VariableDefinePlatformVar($0, 0, 9864, $2, 20292, 0);
    $3 = 62;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 63 : 1) {
    VariableDefinePlatformVar($0, 0, 9875, $2, 20296, 0);
    $3 = 63;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 64 : 1) {
    VariableDefinePlatformVar($0, 0, 9885, $2, 20300, 0);
    $3 = 64;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 65 : 1) {
    VariableDefinePlatformVar($0, 0, 9896, $2, 20304, 0);
    $3 = 65;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 66 : 1) {
    VariableDefinePlatformVar($0, 0, 9902, $2, 20308, 0);
    $3 = 66;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 67 : 1) {
    VariableDefinePlatformVar($0, 0, 9908, $2, 20312, 0);
    $3 = 67;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 68 : 1) {
    VariableDefinePlatformVar($0, 0, 9915, $2, 20316, 0);
    $3 = 68;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 69 : 1) {
    VariableDefinePlatformVar($0, 0, 9931, $2, 20320, 0);
    $3 = 69;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 70 : 1) {
    VariableDefinePlatformVar($0, 0, 9942, $2, 20324, 0);
    $3 = 70;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 71 : 1) {
    VariableDefinePlatformVar($0, 0, 9949, $2, 20328, 0);
    $3 = 71;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 72 : 1) {
    VariableDefinePlatformVar($0, 0, 9955, $2, 20332, 0);
    $3 = 72;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 73 : 1) {
    VariableDefinePlatformVar($0, 0, 9962, $2, 20336, 0);
    $3 = 73;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 74 : 1) {
    VariableDefinePlatformVar($0, 0, 9968, $2, 20340, 0);
    $3 = 74;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 75 : 1) {
    VariableDefinePlatformVar($0, 0, 9975, $2, 20344, 0);
    $3 = 75;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 76 : 1) {
    VariableDefinePlatformVar($0, 0, 9981, $2, 20348, 0);
    $3 = 76;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 77 : 1) {
    VariableDefinePlatformVar($0, 0, 9991, $2, 20352, 0);
    $3 = 77;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 78 : 1) {
    VariableDefinePlatformVar($0, 0, 9999, $2, 20356, 0);
    $3 = 78;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($1 | 0) == 79 : 1) {
    VariableDefinePlatformVar($0, 0, 10011, $2, 20360, 0);
    $3 = 79;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    $4 = __errno_location()
   }
   if (global$2 ? ($1 | 0) == 80 : 1) {
    VariableDefinePlatformVar($0, 0, 10017, $2, $4, 1);
    $3 = 80;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  $1 = $3;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP32[$1 + 8 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
 }
 
 function StdIsalnum($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = isalnum(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdIsalpha($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = isalpha(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdIsblank($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = HEAP32[$1 + 4 >> 2];
  $1 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  $2 = ($1 | 0) == 32;
  HEAP32[$0 >> 2] = $2 | ($1 | 0) == 9;
 }
 
 function StdIscntrl($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = iscntrl(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdIsdigit($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2] + -48 >>> 0 < 10;
 }
 
 function StdIsgraph($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = isgraph(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdIslower($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = islower(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdIsprint($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = isprint(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdIspunct($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = ispunct(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdIsspace($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = isspace(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdIsupper($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = isupper(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdIsxdigit($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = isxdigit(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdTolower($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = tolower(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdToupper($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = toupper(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
 }
 
 function StdIsascii($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = HEAPU32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2] < 128;
 }
 
 function StdToascii($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2] & 127;
 }
 
 function StdboolSetupFunc($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  } else {
   $1 = 0
  }
  $1 = global$2 ? $1 : $0 + 1412 | 0;
  label$1 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   }
   if (global$2 ? !$2 : 1) {
    VariableDefinePlatformVar($0, 0, 10338, $1, 20504, 0);
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   if (global$2 ? ($2 | 0) == 1 : 1) {
    VariableDefinePlatformVar($0, 0, 10343, $1, 21784, 0);
    $3 = 1;
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   if (global$2 ? ($2 | 0) == 2 : 1) {
    VariableDefinePlatformVar($0, 0, 10349, $1, 20504, 0);
    $3 = 2;
    if ((global$2 | 0) == 1) {
     break label$1
    }
   }
   return;
  }
  $2 = $3;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function UnistdAccess($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = access(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdAlarm($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = alarm(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdChdir($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = chdir(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdChroot($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = chroot(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdChown($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = chown(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdClose($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = close(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdConfstr($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = confstr(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdCtermid($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = ctermid(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdDup($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = dup(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdDup2($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = dup2(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function Unistd_Exit($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  _exit(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  abort();
 }
 
 function UnistdFchown($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = fchown(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdFchdir($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = fchdir(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdFdatasync($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = fdatasync(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdFork($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = fork() | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function UnistdFpathconf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = fpathconf(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdFsync($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $0 = global$2 ? $0 : HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = fsync($0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function UnistdFtruncate($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  $2 = ftruncate(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], $0, $0 >> 31);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdGetcwd($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = getcwd(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdGetdtablesize($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = 0;
 }
 
 function UnistdGetegid($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = getegid();
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function UnistdGeteuid($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = geteuid();
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function UnistdGetgid($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = getgid();
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function UnistdGethostid($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = gethostid();
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function UnistdGetlogin($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = getlogin();
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function UnistdGetlogin_r($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = getlogin_r(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdGetpagesize($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = getpagesize();
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function UnistdGetpass($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = 0;
 }
 
 function UnistdGetpgrp($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = getpgrp();
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function UnistdGetpid($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = getpid();
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function UnistdGetppid($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = getppid();
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function UnistdGetuid($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = getuid();
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function UnistdGetwd($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = getcwd(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], 4096);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdIsatty($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = isatty(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdLchown($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = lchown(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdLink($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = link(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdLockf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2];
  $2 = lockf(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], $0, $0 >> 31);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdLseek($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  $3 = $0 >> 31;
  $3 = lseek(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], $0, $3, HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $3;
 }
 
 function UnistdNice($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = nice(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdPathconf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = pathconf(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdPause($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = pause();
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function UnistdRead($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = read(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdReadlink($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = readlink(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdRmdir($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = rmdir(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdSbrk($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = sbrk(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdSetgid($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $0 = global$2 ? $0 : HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = setgid($0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function UnistdSetpgid($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = setpgid(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdSetpgrp($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = setpgrp();
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function UnistdSetregid($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = setregid($0, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function UnistdSetreuid($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $0 = HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
   $2 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = setreuid($0, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function UnistdSetsid($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = setsid();
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function UnistdSetuid($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $0 = global$2 ? $0 : HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2];
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = setuid($0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function UnistdSleep($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = sleep(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdSymlink($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = symlink(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdSync($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  sync();
 }
 
 function UnistdSysconf($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = sysconf(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdTcgetpgrp($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = tcgetpgrp(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdTcsetpgrp($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = tcsetpgrp(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdTruncate($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2];
  $2 = truncate(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], $0, $0 >> 31);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdTtyname($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = ttyname(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdTtyname_r($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = ttyname_r(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdUalarm($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = ualarm(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdUnlink($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = unlink(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdUsleep($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = usleep(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2]) | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdVfork($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $0 = vfork() | 0;
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $0;
 }
 
 function UnistdWrite($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $2 = write(HEAP32[HEAP32[HEAP32[$2 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 4 >> 2] + 4 >> 2] >> 2], HEAP32[HEAP32[HEAP32[$2 + 8 >> 2] + 4 >> 2] >> 2]);
  HEAP32[HEAP32[$1 + 4 >> 2] >> 2] = $2;
 }
 
 function UnistdSetupFunc($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   }
   if (global$2 ? !$3 : 1) {
    $2 = TableStrRegister($0, 12147);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $2;
   }
   if (!global$2) {
    $1 = !VariableDefined($0, $1)
   }
   if ((global$2 | 0) == 2 | $1) {
    $1 = global$2 ? $1 : $0 + 1412 | 0;
    if (global$2 ? ($3 | 0) == 1 : 1) {
     VariableDefinePlatformVar($0, 0, 12147, $1, 21788, 0);
     $4 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   $1 = global$2 ? $1 : HEAP32[$0 + 2072 >> 2];
   if (global$2 ? ($3 | 0) == 2 : 1) {
    VariableDefinePlatformVar($0, 0, 12152, $1, 23964, 1);
    $4 = 2;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   $1 = global$2 ? $1 : $0 + 1412 | 0;
   if (global$2 ? ($3 | 0) == 3 : 1) {
    VariableDefinePlatformVar($0, 0, 12159, $1, 21484, 1);
    $4 = 3;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($3 | 0) == 4 : 1) {
    VariableDefinePlatformVar($0, 0, 12166, $1, 21488, 1);
    $4 = 4;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($3 | 0) == 5 : 1) {
    VariableDefinePlatformVar($0, 0, 12173, $1, 23968, 1);
    $4 = 5;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function fscanf($0, $1, $2) {
  var $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = global$0 - 16 | 0;
   global$0 = $3;
   HEAP32[$3 + 12 >> 2] = $2;
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = vfscanf($0, $1, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    global$0 = $3 + 16 | 0;
    return $2;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function ferror($0) {
  var $1 = 0, $2 = 0;
  if (HEAP32[$0 + 76 >> 2] <= -1) {
   return HEAP32[$0 >> 2] >>> 5 & 1
  }
  $1 = __lockfile($0);
  $2 = HEAP32[$0 >> 2] >>> 5 & 1;
  if ($1) {
   __unlockfile($0)
  }
  return $2;
 }
 
 function fputc($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $2 = global$2 ? $2 : HEAP32[$1 + 76 >> 2] >= 0;
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($2) {
      $2 = __lockfile($1);
      if ($2) {
       break label$5
      }
     }
     label$8 : {
      $4 = $0 & 255;
      $2 = ($4 | 0) == HEAP8[$1 + 75 | 0];
      if ($2) {
       break label$8
      }
      $2 = HEAP32[$1 + 20 >> 2];
      if ($2 >>> 0 >= HEAPU32[$1 + 16 >> 2]) {
       break label$8
      }
      HEAP32[$1 + 20 >> 2] = $2 + 1;
      HEAP8[$2 | 0] = $0;
      return $4;
     }
    }
    if (global$2 ? !$5 : 1) {
     $3 = __overflow($1, $0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $0 = $3;
    }
    if (!global$2) {
     return $0
    }
   }
   if (!global$2) {
    $4 = $0 & 255;
    $2 = ($4 | 0) == HEAP8[$1 + 75 | 0];
   }
   label$12 : {
    if (!global$2) {
     label$14 : {
      if ($2) {
       break label$14
      }
      $2 = HEAP32[$1 + 20 >> 2];
      if ($2 >>> 0 >= HEAPU32[$1 + 16 >> 2]) {
       break label$14
      }
      HEAP32[$1 + 20 >> 2] = $2 + 1;
      HEAP8[$2 | 0] = $0;
      break label$12;
     }
    }
    if (global$2 ? ($5 | 0) == 1 : 1) {
     $3 = __overflow($1, $0);
     $6 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $4 = $3;
    }
   }
   if (!global$2) {
    __unlockfile($1);
    return $4;
   }
   abort();
  }
  $3 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function __fmodeflags($0) {
  var $1 = 0;
  $1 = 2;
  if (!strchr($0, 43)) {
   $1 = HEAPU8[$0 | 0] != 114
  }
  $1 = strchr($0, 120) ? $1 | 128 : $1;
  $1 = strchr($0, 101) ? $1 | 524288 : $1;
  $0 = HEAPU8[$0 | 0];
  $1 = ($0 | 0) == 114 ? $1 : $1 | 64;
  $1 = ($0 | 0) == 119 ? $1 | 512 : $1;
  return ($0 | 0) == 97 ? $1 | 1024 : $1;
 }
 
 function freopen($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -28;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $6 = HEAP32[$3 + 16 >> 2];
   $5 = HEAP32[$3 + 20 >> 2];
   $7 = HEAP32[$3 + 24 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = global$0 - 16 | 0;
   global$0 = $5;
   $7 = __fmodeflags($1);
   $4 = HEAP32[$2 + 76 >> 2] >= 0;
   if ($4) {
    $6 = __lockfile($2)
   } else {
    $6 = 0
   }
  }
  label$2 : {
   if (global$2 ? !$8 : 1) {
    $3 = fflush($2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   } else {
    $3 = $4
   }
   $4 = global$2 ? $3 : !$0;
   label$9 : {
    label$10 : {
     label$11 : {
      label$12 : {
       if (!global$2) {
        if ($4) {
         $0 = HEAP32[$2 + 60 >> 2];
         HEAP32[$5 >> 2] = $7 & -524481;
         $0 = (__syscall_ret(__syscall221($0 | 0, 4, $5 | 0) | 0) | 0) >= 0;
         if ($0) {
          break label$12
         }
         break label$10;
        }
        $0 = fopen($0, $1);
        if (!$0) {
         break label$10
        }
        $1 = HEAP32[$0 + 60 >> 2];
        $4 = HEAP32[$2 + 60 >> 2];
        label$15 : {
         if (($1 | 0) == ($4 | 0)) {
          HEAP32[$0 + 60 >> 2] = -1;
          break label$15;
         }
         if ((__dup3($1, $4, $7 & 524288) | 0) < 0) {
          break label$11
         }
        }
        HEAP32[$2 >> 2] = HEAP32[$0 >> 2] | HEAP32[$2 >> 2] & 1;
        HEAP32[$2 + 32 >> 2] = HEAP32[$0 + 32 >> 2];
        HEAP32[$2 + 36 >> 2] = HEAP32[$0 + 36 >> 2];
        HEAP32[$2 + 40 >> 2] = HEAP32[$0 + 40 >> 2];
        HEAP32[$2 + 12 >> 2] = HEAP32[$0 + 12 >> 2];
       }
       if (global$2 ? ($8 | 0) == 1 : 1) {
        $3 = fclose($0);
        $9 = 1;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $0 = $3;
       }
      }
      if (!global$2) {
       if (!$6) {
        break label$9
       }
       __unlockfile($2);
       break label$9;
      }
     }
     if (global$2 ? ($8 | 0) == 2 : 1) {
      fclose($0);
      $9 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
    }
    if (global$2 ? ($8 | 0) == 3 : 1) {
     fclose($2);
     $9 = 3;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    $2 = global$2 ? $2 : 0;
   }
   if (!global$2) {
    global$0 = $5 + 16 | 0;
    return $2;
   }
   abort();
  }
  $3 = $9;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[$3 + 16 >> 2] = $6;
  HEAP32[$3 + 20 >> 2] = $5;
  HEAP32[$3 + 24 >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 28;
  return 0;
 }
 
 function fsetpos($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $3 = HEAP32[$2 + 8 >> 2];
   $4 = HEAP32[$2 + 12 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $4 = HEAP32[$1 + 4 >> 2];
   $3 = HEAP32[$1 >> 2];
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $2 = __fseeko($0, $3, $4, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $2;
   }
   if (!global$2) {
    return $0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 8 >> 2] = $3;
  HEAP32[$2 + 12 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function fgetpos($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $4 = HEAP32[$1 + 8 >> 2];
   $3 = HEAP32[$1 + 12 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $2 = 0
  }
  label$2 : {
   if (global$2 ? !$2 : 1) {
    $5 = __ftello($0);
    $2 = i64toi32_i32$HIGH_BITS;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $4 = $5;
    $3 = $2;
   }
   if (!global$2) {
    if (($3 | 0) < 0 ? 1 : ($3 | 0) <= 0 ? ($4 >>> 0 >= 0 ? 0 : 1) : 0) {
     return -1
    }
    HEAP32[$1 >> 2] = $4;
    HEAP32[$1 + 4 >> 2] = $3;
    return 0;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 8 >> 2] = $4;
  HEAP32[$2 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function __fseeko_unlocked($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $4 = $5;
   $6 = HEAP32[$4 + 4 >> 2];
   $1 = $6;
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $7 = HEAP32[$4 + 8 >> 2];
   $2 = $7;
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = HEAPU32[$0 + 20 >> 2] > HEAPU32[$0 + 28 >> 2];
   if (($3 | 0) == 1) {
    $6 = HEAP32[$0 + 8 >> 2] - HEAP32[$0 + 4 >> 2] | 0;
    $7 = $6 >> 31;
    $9 = $6;
    $4 = $1;
    $6 = $7 + ($4 >>> 0 < $9 >>> 0) | 0;
    $1 = $4 - $9 | 0;
    $7 = $2;
    $6 = $7 - $6 | 0;
   } else {
    $6 = $2
   }
   $2 = $6;
  }
  label$2 : {
   label$7 : {
    if ((global$2 | 0) == 2 | $5) {
     $5 = global$2 ? $5 : HEAP32[$0 + 36 >> 2];
     if (global$2 ? !$8 : 1) {
      $4 = FUNCTION_TABLE[$5]($0, 0, 0) | 0;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $5 = $4;
     }
     if (!global$2) {
      $5 = !HEAP32[$0 + 20 >> 2];
      if ($5) {
       break label$7
      }
     }
    }
    if (!global$2) {
     HEAP32[$0 + 28 >> 2] = 0;
     $4 = $0;
     HEAP32[$4 + 16 >> 2] = 0;
     HEAP32[$4 + 20 >> 2] = 0;
     $5 = HEAP32[$4 + 40 >> 2];
    }
    if (global$2 ? ($8 | 0) == 1 : 1) {
     $6 = $2;
     $6 = FUNCTION_TABLE[$5]($0, $1, $6, $3) | 0;
     $4 = i64toi32_i32$HIGH_BITS;
     $10 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $2 = $4;
     $1 = $6;
    }
    if (!global$2) {
     $7 = $1;
     $4 = $2;
     if (($4 | 0) < 0 ? 1 : ($4 | 0) <= 0 ? ($7 >>> 0 >= 0 ? 0 : 1) : 0) {
      break label$7
     }
     $4 = $0;
     HEAP32[$4 + 4 >> 2] = 0;
     HEAP32[$4 + 8 >> 2] = 0;
     HEAP32[$4 >> 2] = HEAP32[$4 >> 2] & -17;
     return 0;
    }
   }
   if (!global$2) {
    return -1
   }
   abort();
  }
  $4 = $10;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  $7 = $2;
  HEAP32[$4 + 8 >> 2] = $7;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
  return 0;
 }
 
 function __fseeko($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $5 = global$2 ? $5 : HEAP32[$0 + 76 >> 2] <= -1;
  label$2 : {
   if ($5 | (global$2 | 0) == 2) {
    if (global$2 ? !$6 : 1) {
     $4 = __fseeko_unlocked($0, $1, $2, $3);
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $0 = $4;
    }
    if (!global$2) {
     return $0
    }
   }
   if (!global$2) {
    $5 = __lockfile($0)
   }
   if (global$2 ? ($6 | 0) == 1 : 1) {
    $4 = __fseeko_unlocked($0, $1, $2, $3);
    $7 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $4;
   }
   if (!global$2) {
    if ($5) {
     __unlockfile($0)
    }
    return $3;
   }
   abort();
  }
  $4 = $7;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
  return 0;
 }
 
 function fseek($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $5 = HEAP32[$3 + 16 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  $3 = global$2;
  $4 = $3 ? $4 : $1;
  $5 = $3 ? $5 : $1 >> 31;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $3 = 0
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    $3 = __fseeko($0, $4, $5, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $3;
   }
   if (!global$2) {
    return $0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[$3 + 16 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
  return 0;
 }
 
 function fileno($0) {
  label$1 : {
   if (HEAP32[$0 + 76 >> 2] < 0) {
    break label$1
   }
   if (!__lockfile($0)) {
    break label$1
   }
   __unlockfile($0);
  }
  return HEAP32[$0 + 60 >> 2];
 }
 
 function clearerr($0) {
  var $1 = 0;
  label$1 : {
   if (HEAP32[$0 + 76 >> 2] >= 0) {
    $1 = __lockfile($0);
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] & -49;
    if (!$1) {
     break label$1
    }
    __unlockfile($0);
    return;
   }
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] & -49;
  }
 }
 
 function __vfprintf_internal($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -44;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $6 = HEAP32[$5 + 20 >> 2];
   $7 = HEAP32[$5 + 24 >> 2];
   $8 = HEAP32[$5 + 28 >> 2];
   $9 = HEAP32[$5 + 32 >> 2];
   $10 = HEAP32[$5 + 36 >> 2];
   $12 = HEAP32[$5 + 40 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $11 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = global$0 - 208 | 0;
   global$0 = $6;
   HEAP32[$6 + 204 >> 2] = $2;
   memset($6 + 160 | 0, 0, 40);
   HEAP32[$6 + 200 >> 2] = HEAP32[$6 + 204 >> 2];
   $7 = $6 + 200 | 0;
   $8 = $6 + 80 | 0;
   $9 = $6 + 160 | 0;
   $2 = 0;
  }
  label$2 : {
   if (global$2 ? !$11 : 1) {
    $5 = printf_core(0, $1, $7, $8, $9, $3, $4);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $7 = $5;
   }
   $7 = global$2 ? $7 : ($7 | 0) < 0;
   label$7 : {
    if (!global$2) {
     if ($7) {
      $1 = -1;
      break label$7;
     }
     if (HEAP32[$0 + 76 >> 2] >= 0) {
      $2 = __lockfile($0)
     }
     $7 = HEAP32[$0 >> 2];
     if (HEAP8[$0 + 74 | 0] <= 0) {
      HEAP32[$0 >> 2] = $7 & -33
     }
     $8 = HEAP32[$0 + 48 >> 2];
     $7 = $7 & 32;
    }
    label$12 : {
     if ((global$2 | 0) == 2 | $8) {
      if (!global$2) {
       $9 = $6 + 80 | 0;
       $10 = $6 + 160 | 0;
       $8 = $6 + 200 | 0;
      }
      if (global$2 ? ($11 | 0) == 1 : 1) {
       $5 = printf_core($0, $1, $8, $9, $10, $3, $4);
       $13 = 1;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $3 = $5;
      }
      if (!global$2) {
       break label$12
      }
     }
     if (!global$2) {
      HEAP32[$0 + 48 >> 2] = 80;
      HEAP32[$0 + 16 >> 2] = $6 + 80;
      HEAP32[$0 + 28 >> 2] = $6;
      HEAP32[$0 + 20 >> 2] = $6;
      $8 = HEAP32[$0 + 44 >> 2];
      HEAP32[$0 + 44 >> 2] = $6;
      $10 = $6 + 80 | 0;
      $12 = $6 + 160 | 0;
      $9 = $6 + 200 | 0;
     }
     if (global$2 ? ($11 | 0) == 2 : 1) {
      $5 = printf_core($0, $1, $9, $10, $12, $3, $4);
      $13 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $1 = $5;
     }
     if (!global$2) {
      $3 = $1;
      if (!$8) {
       break label$12
      }
      $3 = HEAP32[$0 + 36 >> 2];
     }
     if (global$2 ? ($11 | 0) == 3 : 1) {
      $5 = FUNCTION_TABLE[$3]($0, 0, 0) | 0;
      $13 = 3;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $5;
     }
     if (!global$2) {
      HEAP32[$0 + 48 >> 2] = 0;
      HEAP32[$0 + 44 >> 2] = $8;
      HEAP32[$0 + 28 >> 2] = 0;
      HEAP32[$0 + 16 >> 2] = 0;
      $3 = HEAP32[$0 + 20 >> 2];
      HEAP32[$0 + 20 >> 2] = 0;
      $3 = $3 ? $1 : -1;
     }
    }
    if (!global$2) {
     $1 = $3;
     $3 = HEAP32[$0 >> 2];
     HEAP32[$0 >> 2] = $7 | $3;
     $1 = $3 & 32 ? -1 : $1;
     if (!$2) {
      break label$7
     }
     __unlockfile($0);
    }
   }
   if (!global$2) {
    global$0 = $6 + 208 | 0;
    return $1;
   }
   abort();
  }
  $5 = $13;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[$5 + 20 >> 2] = $6;
  HEAP32[$5 + 24 >> 2] = $7;
  HEAP32[$5 + 28 >> 2] = $8;
  HEAP32[$5 + 32 >> 2] = $9;
  HEAP32[$5 + 36 >> 2] = $10;
  HEAP32[$5 + 40 >> 2] = $12;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 44;
  return 0;
 }
 
 function printf_core($0, $1, $2, $3, $4, $5, $6) {
  var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0.0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -104;
   $15 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$15 >> 2];
   $1 = HEAP32[$15 + 4 >> 2];
   $2 = HEAP32[$15 + 8 >> 2];
   $3 = HEAP32[$15 + 12 >> 2];
   $4 = HEAP32[$15 + 16 >> 2];
   $5 = HEAP32[$15 + 20 >> 2];
   $6 = HEAP32[$15 + 24 >> 2];
   $7 = HEAP32[$15 + 28 >> 2];
   $8 = HEAP32[$15 + 32 >> 2];
   $11 = HEAP32[$15 + 36 >> 2];
   $12 = HEAP32[$15 + 40 >> 2];
   $13 = HEAP32[$15 + 44 >> 2];
   $14 = HEAP32[$15 + 48 >> 2];
   $17 = HEAP32[$15 + 52 >> 2];
   $20 = HEAP32[$15 + 56 >> 2];
   $9 = HEAP32[$15 + 60 >> 2];
   $16 = $9;
   $10 = HEAP32[$15 + 64 >> 2];
   $21 = $10;
   $22 = HEAP32[$15 + 68 >> 2];
   $19 = HEAP32[$15 + 72 >> 2];
   $18 = HEAP32[$15 + 76 >> 2];
   $25 = HEAP32[$15 + 80 >> 2];
   $23 = HEAP32[$15 + 84 >> 2];
   $26 = HEAP32[$15 + 88 >> 2];
   $9 = HEAP32[$15 + 96 >> 2];
   $10 = HEAP32[$15 + 92 >> 2];
   wasm2js_scratch_store_i32(0, $10 | 0);
   wasm2js_scratch_store_i32(1, $9 | 0);
   $27 = +wasm2js_scratch_load_f64();
   $15 = HEAP32[$15 + 100 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $24 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $7 = global$0;
   $8 = $7 - 80 | 0;
   global$0 = $8;
   HEAP32[$8 + 76 >> 2] = $1;
   $15 = $8 + 55 | 0;
   $25 = $8 + 56 | 0;
   $26 = 0;
   $19 = 0;
   $1 = 0;
  }
  label$2 : {
   label$5 : {
    label$6 : {
     label$7 : while (1) {
      label$11 : {
       if (!global$2) {
        $7 = ($19 | 0) < 0;
        label$9 : {
         if ($7) {
          break label$9
         }
         $7 = ($1 | 0) > (2147483647 - $19 | 0);
         if ($7) {
          HEAP32[__errno_location() >> 2] = 61;
          $19 = -1;
          break label$9;
         }
         $19 = $1 + $19 | 0;
        }
        $14 = HEAP32[$8 + 76 >> 2];
        $1 = $14;
        $11 = HEAPU8[$1 | 0];
       }
       label$12 : {
        label$13 : {
         label$14 : {
          label$15 : {
           label$16 : {
            label$17 : {
             label$18 : {
              label$19 : {
               label$20 : {
                label$21 : {
                 label$22 : {
                  label$23 : {
                   if ((global$2 | 0) == 2 | $11) {
                    while (1) {
                     label$26 : {
                      if (!global$2) {
                       $11 = $11 & 255;
                       $7 = !$11;
                      }
                      label$28 : {
                       if (!global$2) {
                        label$30 : {
                         if ($7) {
                          $11 = $1;
                          break label$30;
                         }
                         $7 = ($11 | 0) != 37;
                         if ($7) {
                          break label$28
                         }
                         $11 = $1;
                         while (1) {
                          $7 = HEAPU8[$1 + 1 | 0] != 37;
                          if ($7) {
                           break label$30
                          }
                          $7 = $1 + 2 | 0;
                          HEAP32[$8 + 76 >> 2] = $7;
                          $11 = $11 + 1 | 0;
                          $13 = HEAPU8[$1 + 2 | 0];
                          $1 = $7;
                          $7 = ($13 | 0) == 37;
                          if ($7) {
                           continue
                          }
                          break;
                         };
                        }
                        $1 = $11 - $14 | 0;
                       }
                       if ((global$2 | 0) == 2 | $0) {
                        if (global$2 ? !$24 : 1) {
                         out($0, $14, $1);
                         $10 = 0;
                         if ((global$2 | 0) == 1) {
                          break label$2
                         }
                        }
                       }
                       if (!global$2) {
                        if ($1) {
                         continue label$7
                        }
                        $22 = -1;
                        $11 = 1;
                        $7 = isdigit(HEAP8[HEAP32[$8 + 76 >> 2] + 1 | 0]);
                        $1 = HEAP32[$8 + 76 >> 2];
                        if (!(!$7 | HEAPU8[$1 + 2 | 0] != 36)) {
                         $22 = HEAP8[$1 + 1 | 0] + -48 | 0;
                         $26 = 1;
                         $11 = 3;
                        }
                        $1 = $1 + $11 | 0;
                        HEAP32[$8 + 76 >> 2] = $1;
                        $11 = 0;
                        $18 = HEAP8[$1 | 0];
                        $13 = $18 + -32 | 0;
                        label$37 : {
                         if ($13 >>> 0 > 31) {
                          $7 = $1;
                          break label$37;
                         }
                         $7 = $1;
                         $13 = 1 << $13;
                         if (!($13 & 75913)) {
                          break label$37
                         }
                         while (1) {
                          $7 = $1 + 1 | 0;
                          HEAP32[$8 + 76 >> 2] = $7;
                          $11 = $11 | $13;
                          $18 = HEAP8[$1 + 1 | 0];
                          $13 = $18 + -32 | 0;
                          if ($13 >>> 0 > 31) {
                           break label$37
                          }
                          $1 = $7;
                          $13 = 1 << $13;
                          if ($13 & 75913) {
                           continue
                          }
                          break;
                         };
                        }
                        label$40 : {
                         if (($18 | 0) == 42) {
                          $9 = $8;
                          label$42 : {
                           label$43 : {
                            if (!isdigit(HEAP8[$7 + 1 | 0])) {
                             break label$43
                            }
                            $7 = HEAP32[$8 + 76 >> 2];
                            if (HEAPU8[$7 + 2 | 0] != 36) {
                             break label$43
                            }
                            HEAP32[((HEAP8[$7 + 1 | 0] << 2) + $4 | 0) + -192 >> 2] = 10;
                            $20 = HEAP32[((HEAP8[$7 + 1 | 0] << 3) + $3 | 0) + -384 >> 2];
                            $26 = 1;
                            $1 = $7 + 3 | 0;
                            break label$42;
                           }
                           if ($26) {
                            break label$6
                           }
                           $26 = 0;
                           $20 = 0;
                           if ($0) {
                            $1 = HEAP32[$2 >> 2];
                            HEAP32[$2 >> 2] = $1 + 4;
                            $20 = HEAP32[$1 >> 2];
                           }
                           $1 = HEAP32[$8 + 76 >> 2] + 1 | 0;
                          }
                          HEAP32[$9 + 76 >> 2] = $1;
                          if (($20 | 0) > -1) {
                           break label$40
                          }
                          $20 = 0 - $20 | 0;
                          $11 = $11 | 8192;
                          break label$40;
                         }
                         $20 = getint($8 + 76 | 0);
                         if (($20 | 0) < 0) {
                          break label$6
                         }
                         $1 = HEAP32[$8 + 76 >> 2];
                        }
                        $12 = -1;
                        label$45 : {
                         if (HEAPU8[$1 | 0] != 46) {
                          break label$45
                         }
                         if (HEAPU8[$1 + 1 | 0] == 42) {
                          label$47 : {
                           if (!isdigit(HEAP8[$1 + 2 | 0])) {
                            break label$47
                           }
                           $1 = HEAP32[$8 + 76 >> 2];
                           if (HEAPU8[$1 + 3 | 0] != 36) {
                            break label$47
                           }
                           HEAP32[((HEAP8[$1 + 2 | 0] << 2) + $4 | 0) + -192 >> 2] = 10;
                           $12 = HEAP32[((HEAP8[$1 + 2 | 0] << 3) + $3 | 0) + -384 >> 2];
                           $1 = $1 + 4 | 0;
                           HEAP32[$8 + 76 >> 2] = $1;
                           break label$45;
                          }
                          if ($26) {
                           break label$6
                          }
                          if ($0) {
                           $1 = HEAP32[$2 >> 2];
                           HEAP32[$2 >> 2] = $1 + 4;
                           $12 = HEAP32[$1 >> 2];
                          } else {
                           $12 = 0
                          }
                          $1 = HEAP32[$8 + 76 >> 2] + 2 | 0;
                          HEAP32[$8 + 76 >> 2] = $1;
                          break label$45;
                         }
                         HEAP32[$8 + 76 >> 2] = $1 + 1;
                         $12 = getint($8 + 76 | 0);
                         $1 = HEAP32[$8 + 76 >> 2];
                        }
                        $7 = 0;
                        while (1) {
                         $13 = $7;
                         $17 = -1;
                         if (HEAP8[$1 | 0] + -65 >>> 0 > 57) {
                          break label$5
                         }
                         $18 = $1 + 1 | 0;
                         HEAP32[$8 + 76 >> 2] = $18;
                         $7 = HEAP8[$1 | 0];
                         $1 = $18;
                         $7 = HEAPU8[(Math_imul($13, 58) + $7 | 0) + 12143 | 0];
                         $23 = $7 + -1 >>> 0 < 8;
                         if ($23) {
                          continue
                         }
                         break;
                        };
                        if (!$7) {
                         break label$5
                        }
                        $1 = ($7 | 0) == 19;
                       }
                       label$51 : {
                        if (!global$2) {
                         label$53 : {
                          label$54 : {
                           if ($1) {
                            $17 = -1;
                            if (($22 | 0) <= -1) {
                             break label$54
                            }
                            break label$5;
                           }
                           if (($22 | 0) < 0) {
                            break label$53
                           }
                           HEAP32[($22 << 2) + $4 >> 2] = $7;
                           $1 = ($22 << 3) + $3 | 0;
                           $9 = HEAP32[$1 >> 2];
                           $16 = $9;
                           $10 = HEAP32[$1 + 4 >> 2];
                           $21 = $10;
                           HEAP32[$8 + 64 >> 2] = $16;
                           HEAP32[$8 + 68 >> 2] = $10;
                          }
                          $1 = 0;
                          $7 = !$0;
                          if ($7) {
                           continue label$7
                          }
                          break label$51;
                         }
                         if (!$0) {
                          break label$11
                         }
                         $1 = $8 - -64 | 0;
                        }
                        if (global$2 ? ($24 | 0) == 1 : 1) {
                         pop_arg($1, $7, $2, $6);
                         $10 = 1;
                         if ((global$2 | 0) == 1) {
                          break label$2
                         }
                        }
                        $18 = global$2 ? $18 : HEAP32[$8 + 76 >> 2];
                       }
                       if (!global$2) {
                        $23 = $11 & -65537;
                        $11 = $11 & 8192 ? $23 : $11;
                        $17 = 0;
                        $22 = 12188;
                        $7 = $25;
                        $1 = HEAP8[$18 + -1 | 0];
                        $1 = $13 ? (($1 & 15) == 3 ? $1 & -33 : $1) : $1;
                        $18 = $1 + -88 | 0;
                        if ($18 >>> 0 <= 32) {
                         break label$26
                        }
                        $13 = $1 + -65 | 0;
                        $23 = $13 >>> 0 > 6;
                       }
                       label$59 : {
                        label$60 : {
                         label$61 : {
                          if (!global$2) {
                           label$63 : {
                            if ($23) {
                             $1 = ($1 | 0) != 83;
                             if ($1) {
                              break label$12
                             }
                             $1 = !$12;
                             if ($1) {
                              break label$63
                             }
                             $7 = HEAP32[$8 + 64 >> 2];
                             break label$60;
                            }
                            $23 = $13 - 1 | 0;
                            switch ($23 | 0) {
                            case 0:
                            case 2:
                             break label$12;
                            case 1:
                             break label$61;
                            default:
                             break label$23;
                            };
                           }
                           $1 = 0;
                          }
                          if (global$2 ? ($24 | 0) == 2 : 1) {
                           pad($0, 32, $20, 0, $11);
                           $10 = 2;
                           if ((global$2 | 0) == 1) {
                            break label$2
                           }
                          }
                          if (!global$2) {
                           break label$59
                          }
                         }
                         if (!global$2) {
                          HEAP32[$8 + 12 >> 2] = 0;
                          $9 = HEAP32[$8 + 68 >> 2];
                          $21 = $9;
                          $10 = HEAP32[$8 + 64 >> 2];
                          $16 = $10;
                          HEAP32[$8 + 8 >> 2] = $16;
                          $1 = $8 + 8 | 0;
                          HEAP32[$8 + 64 >> 2] = $1;
                          $12 = -1;
                          $7 = $8 + 8 | 0;
                         }
                        }
                        if (!global$2) {
                         $1 = 0;
                         label$69 : {
                          while (1) {
                           $13 = HEAP32[$7 >> 2];
                           $14 = !$13;
                           if ($14) {
                            break label$69
                           }
                           label$71 : {
                            $13 = wctomb($8 + 4 | 0, $13);
                            $14 = ($13 | 0) < 0;
                            if ($14) {
                             break label$71
                            }
                            $23 = $13 >>> 0 > $12 - $1 >>> 0;
                            if ($23) {
                             break label$71
                            }
                            $7 = $7 + 4 | 0;
                            $1 = $1 + $13 | 0;
                            $14 = $12 >>> 0 > $1 >>> 0;
                            if ($14) {
                             continue
                            }
                            break label$69;
                           }
                           break;
                          };
                          $17 = -1;
                          if ($14) {
                           break label$5
                          }
                         }
                        }
                        if (global$2 ? ($24 | 0) == 3 : 1) {
                         pad($0, 32, $20, $1, $11);
                         $10 = 3;
                         if ((global$2 | 0) == 1) {
                          break label$2
                         }
                        }
                        if (!global$2) {
                         $7 = !$1;
                         if ($7) {
                          $1 = 0;
                          break label$59;
                         }
                         $13 = 0;
                         $7 = HEAP32[$8 + 64 >> 2];
                        }
                        while (1) {
                         if (!global$2) {
                          $14 = HEAP32[$7 >> 2];
                          $12 = !$14;
                          if ($12) {
                           break label$59
                          }
                          $14 = wctomb($8 + 4 | 0, $14);
                          $13 = $14 + $13 | 0;
                          $12 = ($13 | 0) > ($1 | 0);
                          if ($12) {
                           break label$59
                          }
                          $12 = $8 + 4 | 0;
                         }
                         if (global$2 ? ($24 | 0) == 4 : 1) {
                          out($0, $12, $14);
                          $10 = 4;
                          if ((global$2 | 0) == 1) {
                           break label$2
                          }
                         }
                         if (!global$2) {
                          $7 = $7 + 4 | 0;
                          $14 = $13 >>> 0 < $1 >>> 0;
                          if ($14) {
                           continue
                          }
                         }
                         break;
                        };
                       }
                       $7 = global$2 ? $7 : $11 ^ 8192;
                       if (global$2 ? ($24 | 0) == 5 : 1) {
                        pad($0, 32, $20, $1, $7);
                        $10 = 5;
                        if ((global$2 | 0) == 1) {
                         break label$2
                        }
                       }
                       if (!global$2) {
                        $7 = ($20 | 0) > ($1 | 0);
                        $1 = $7 ? $20 : $1;
                        continue label$7;
                       }
                      }
                      if (!global$2) {
                       $7 = $1 + 1 | 0;
                       HEAP32[$8 + 76 >> 2] = $7;
                       $11 = HEAPU8[$1 + 1 | 0];
                       $1 = $7;
                       continue;
                      }
                     }
                     break;
                    };
                    if (!global$2) {
                     $18 = $18 - 1 | 0;
                     switch ($18 | 0) {
                     case 0:
                     case 1:
                     case 2:
                     case 3:
                     case 4:
                     case 5:
                     case 6:
                     case 7:
                     case 9:
                     case 15:
                     case 17:
                     case 18:
                     case 19:
                     case 20:
                     case 24:
                     case 25:
                     case 27:
                     case 29:
                     case 30:
                      break label$12;
                     case 28:
                      break label$15;
                     case 21:
                      break label$16;
                     case 23:
                      break label$18;
                     case 22:
                      break label$19;
                     case 11:
                     case 16:
                      break label$20;
                     case 10:
                      break label$21;
                     case 26:
                      break label$22;
                     case 8:
                     case 12:
                     case 13:
                     case 14:
                      break label$23;
                     default:
                      break label$17;
                     };
                    }
                   }
                   if (!global$2) {
                    $17 = $19;
                    if ($0) {
                     break label$5
                    }
                    $0 = !$26;
                    if ($0) {
                     break label$11
                    }
                    $1 = 1;
                   }
                   while (1) {
                    if (!global$2) {
                     $0 = ($1 << 2) + $4 | 0;
                     $11 = HEAP32[$0 >> 2];
                    }
                    if ((global$2 | 0) == 2 | $11) {
                     $0 = global$2 ? $0 : ($1 << 3) + $3 | 0;
                     if (global$2 ? ($24 | 0) == 6 : 1) {
                      pop_arg($0, $11, $2, $6);
                      $10 = 6;
                      if ((global$2 | 0) == 1) {
                       break label$2
                      }
                     }
                     if (!global$2) {
                      $17 = 1;
                      $1 = $1 + 1 | 0;
                      $0 = ($1 | 0) != 10;
                      if ($0) {
                       continue
                      }
                      break label$5;
                     }
                    }
                    break;
                   };
                   if (!global$2) {
                    $17 = 1;
                    if ($1 >>> 0 > 9) {
                     break label$5
                    }
                    while (1) {
                     $11 = $1;
                     $1 = $1 + 1 | 0;
                     if (HEAP32[($1 << 2) + $4 >> 2] ? 0 : ($1 | 0) != 10) {
                      continue
                     }
                     break;
                    };
                    $17 = $11 >>> 0 < 9 ? -1 : 1;
                    break label$5;
                   }
                  }
                  $27 = global$2 ? $27 : HEAPF64[$8 + 64 >> 3];
                  if (global$2 ? ($24 | 0) == 7 : 1) {
                   $9 = FUNCTION_TABLE[$5]($0, $27, $20, $12, $11, $1) | 0;
                   $10 = 7;
                   if ((global$2 | 0) == 1) {
                    break label$2
                   }
                   $1 = $9;
                  }
                  if (!global$2) {
                   continue
                  }
                 }
                 if (!global$2) {
                  $17 = 0;
                  $1 = HEAP32[$8 + 64 >> 2];
                  $14 = $1 ? $1 : 12198;
                  $1 = memchr($14, 0, $12);
                  $7 = $1 ? $1 : $12 + $14 | 0;
                  $11 = $23;
                  $23 = $1 - $14 | 0;
                  $12 = $1 ? $23 : $12;
                  break label$12;
                 }
                }
                if (!global$2) {
                 $10 = HEAP32[$8 + 68 >> 2];
                 $21 = $10;
                 $9 = HEAP32[$8 + 64 >> 2];
                 $16 = $9;
                 HEAP8[$8 + 55 | 0] = $16;
                 $12 = 1;
                 $14 = $15;
                 $7 = $25;
                 $11 = $23;
                 break label$12;
                }
               }
               if (!global$2) {
                $10 = HEAP32[$8 + 64 >> 2];
                $16 = $10;
                $9 = HEAP32[$8 + 68 >> 2];
                $21 = $9;
                $1 = ($9 | 0) < -1 ? 1 : ($9 | 0) <= -1 ? ($16 >>> 0 > 4294967295 ? 0 : 1) : 0;
                if ($1) {
                 $10 = $16;
                 $16 = 0 - $16 | 0;
                 $9 = $21;
                 $9 = $9 + (0 < $10 >>> 0) | 0;
                 $9 = 0 - $9 | 0;
                 $21 = $9;
                 HEAP32[$8 + 64 >> 2] = $16;
                 HEAP32[$8 + 68 >> 2] = $9;
                 $17 = 1;
                 $22 = 12188;
                 break label$14;
                }
                $1 = $11 & 2048;
                if ($1) {
                 $17 = 1;
                 $22 = 12189;
                 break label$14;
                }
                $17 = $11 & 1;
                $22 = $17 ? 12190 : 12188;
                break label$14;
               }
              }
              if (!global$2) {
               $17 = 0;
               $22 = 12188;
               $10 = HEAP32[$8 + 68 >> 2];
               $21 = $10;
               $9 = HEAP32[$8 + 64 >> 2];
               $16 = $9;
               $14 = fmt_o($16, $10, $25);
               $1 = !($11 & 8);
               if ($1) {
                break label$13
               }
               $1 = $25 - $14 | 0;
               $7 = $1 + 1 | 0;
               $1 = ($12 | 0) > ($1 | 0);
               $12 = $1 ? $12 : $7;
               break label$13;
              }
             }
             if (!global$2) {
              $12 = $12 >>> 0 > 8 ? $12 : 8;
              $11 = $11 | 8;
              $1 = 120;
             }
            }
            if (!global$2) {
             $17 = 0;
             $22 = 12188;
             $9 = HEAP32[$8 + 68 >> 2];
             $21 = $9;
             $10 = HEAP32[$8 + 64 >> 2];
             $16 = $10;
             $14 = fmt_x($16, $9, $25, $1 & 32);
             $7 = !($11 & 8);
             if ($7) {
              break label$13
             }
             $10 = HEAP32[$8 + 68 >> 2];
             $21 = $10;
             $9 = HEAP32[$8 + 64 >> 2];
             $16 = $9;
             $7 = !($10 | $16);
             if ($7) {
              break label$13
             }
             $1 = $1 >>> 4 | 0;
             $22 = $1 + 12188 | 0;
             $17 = 2;
             break label$13;
            }
           }
           if (!global$2) {
            $1 = 0;
            $11 = $13 & 255;
            $7 = $11 >>> 0 > 7;
            if ($7) {
             continue
            }
            label$104 : {
             label$105 : {
              label$106 : {
               label$107 : {
                label$108 : {
                 label$109 : {
                  label$110 : {
                   $7 = $11 - 1 | 0;
                   switch ($7 | 0) {
                   case 6:
                    break label$104;
                   case 5:
                    break label$105;
                   case 3:
                    break label$106;
                   case 2:
                    break label$107;
                   case 1:
                    break label$108;
                   case 0:
                    break label$109;
                   case 4:
                    continue;
                   default:
                    break label$110;
                   };
                  }
                  $7 = HEAP32[$8 + 64 >> 2];
                  HEAP32[$7 >> 2] = $19;
                  continue;
                 }
                 $7 = HEAP32[$8 + 64 >> 2];
                 HEAP32[$7 >> 2] = $19;
                 continue;
                }
                $10 = $19 >> 31;
                $21 = $10;
                $7 = HEAP32[$8 + 64 >> 2];
                $16 = $19;
                HEAP32[$7 >> 2] = $16;
                HEAP32[$7 + 4 >> 2] = $10;
                continue;
               }
               $7 = HEAP32[$8 + 64 >> 2];
               HEAP16[$7 >> 1] = $19;
               continue;
              }
              $7 = HEAP32[$8 + 64 >> 2];
              HEAP8[$7 | 0] = $19;
              continue;
             }
             $7 = HEAP32[$8 + 64 >> 2];
             HEAP32[$7 >> 2] = $19;
             continue;
            }
            $10 = $19 >> 31;
            $21 = $10;
            $7 = HEAP32[$8 + 64 >> 2];
            $16 = $19;
            HEAP32[$7 >> 2] = $16;
            HEAP32[$7 + 4 >> 2] = $10;
            continue;
           }
          }
          if (!global$2) {
           $10 = HEAP32[$8 + 64 >> 2];
           $16 = $10;
           $9 = HEAP32[$8 + 68 >> 2];
           $21 = $9;
           $22 = 12188;
           $17 = 0;
          }
         }
         if (!global$2) {
          $9 = $21;
          $14 = fmt_u($16, $9, $25);
         }
        }
        if (!global$2) {
         $11 = ($12 | 0) > -1 ? $11 & -65537 : $11;
         $9 = HEAP32[$8 + 64 >> 2];
         $16 = $9;
         $10 = HEAP32[$8 + 68 >> 2];
         $21 = $10;
         label$114 : {
          label$115 : {
           if ($12) {
            break label$115
           }
           $10 = $21;
           $1 = !!($10 | $16);
           if ($1) {
            break label$115
           }
           $14 = $25;
           $12 = 0;
           break label$114;
          }
          $10 = $21;
          $1 = !($10 | $16) + ($25 - $14 | 0) | 0;
          $7 = ($12 | 0) > ($1 | 0);
          $12 = $7 ? $12 : $1;
         }
         $7 = $25;
        }
       }
       if (!global$2) {
        $13 = $7 - $14 | 0;
        $1 = ($12 | 0) < ($13 | 0);
        $18 = $1 ? $13 : $12;
        $7 = $18 + $17 | 0;
        $1 = ($20 | 0) < ($7 | 0);
        $1 = $1 ? $7 : $20;
       }
       if (global$2 ? ($24 | 0) == 8 : 1) {
        pad($0, 32, $1, $7, $11);
        $10 = 8;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (global$2 ? ($24 | 0) == 9 : 1) {
        out($0, $22, $17);
        $10 = 9;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       $12 = global$2 ? $12 : $11 ^ 65536;
       if (global$2 ? ($24 | 0) == 10 : 1) {
        pad($0, 48, $1, $7, $12);
        $10 = 10;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (global$2 ? ($24 | 0) == 11 : 1) {
        pad($0, 48, $18, $13, 0);
        $10 = 11;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (global$2 ? ($24 | 0) == 12 : 1) {
        out($0, $14, $13);
        $10 = 12;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       $11 = global$2 ? $11 : $11 ^ 8192;
       if (global$2 ? ($24 | 0) == 13 : 1) {
        pad($0, 32, $1, $7, $11);
        $10 = 13;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        continue
       }
      }
      break;
     };
     if (!global$2) {
      $17 = 0;
      break label$5;
     }
    }
    $17 = global$2 ? $17 : -1;
   }
   if (!global$2) {
    global$0 = $8 + 80 | 0;
    return $17;
   }
   abort();
  }
  $9 = $10;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $9;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $9 = HEAP32[global$3 >> 2];
  HEAP32[$9 >> 2] = $0;
  HEAP32[$9 + 4 >> 2] = $1;
  HEAP32[$9 + 8 >> 2] = $2;
  HEAP32[$9 + 12 >> 2] = $3;
  HEAP32[$9 + 16 >> 2] = $4;
  HEAP32[$9 + 20 >> 2] = $5;
  HEAP32[$9 + 24 >> 2] = $6;
  HEAP32[$9 + 28 >> 2] = $7;
  HEAP32[$9 + 32 >> 2] = $8;
  HEAP32[$9 + 36 >> 2] = $11;
  HEAP32[$9 + 40 >> 2] = $12;
  HEAP32[$9 + 44 >> 2] = $13;
  HEAP32[$9 + 48 >> 2] = $14;
  HEAP32[$9 + 52 >> 2] = $17;
  HEAP32[$9 + 56 >> 2] = $20;
  HEAP32[$9 + 60 >> 2] = $16;
  $10 = $21;
  HEAP32[$9 + 64 >> 2] = $10;
  HEAP32[$9 + 68 >> 2] = $22;
  HEAP32[$9 + 72 >> 2] = $19;
  HEAP32[$9 + 76 >> 2] = $18;
  HEAP32[$9 + 80 >> 2] = $25;
  HEAP32[$9 + 84 >> 2] = $23;
  HEAP32[$9 + 88 >> 2] = $26;
  wasm2js_scratch_store_f64(+$27);
  $10 = wasm2js_scratch_load_i32(1) | 0;
  HEAP32[$9 + 92 >> 2] = wasm2js_scratch_load_i32(0);
  HEAP32[$9 + 96 >> 2] = $10;
  HEAP32[$9 + 100 >> 2] = $15;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 104;
  return 0;
 }
 
 function out($0, $1, $2) {
  var $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2 | (global$2 ? $3 : !(HEAPU8[$0 | 0] & 32))) {
    if (global$2 ? !$4 : 1) {
     __fwritex($1, $2, $0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function getint($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  if (isdigit(HEAP8[HEAP32[$0 >> 2]])) {
   while (1) {
    $1 = HEAP32[$0 >> 2];
    $3 = HEAP8[$1 | 0];
    HEAP32[$0 >> 2] = $1 + 1;
    $2 = (Math_imul($2, 10) + $3 | 0) + -48 | 0;
    if (isdigit(HEAP8[$1 + 1 | 0])) {
     continue
    }
    break;
   }
  }
  return $2;
 }
 
 function pop_arg($0, $1, $2, $3) {
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   label$4 : {
    if (!global$2) {
     if ($1 >>> 0 > 20) {
      break label$4
     }
     $1 = $1 + -9 | 0;
     if ($1 >>> 0 > 9) {
      break label$4
     }
     label$6 : {
      switch ($1 - 1 | 0) {
      default:
       $1 = HEAP32[$2 >> 2];
       HEAP32[$2 >> 2] = $1 + 4;
       HEAP32[$0 >> 2] = HEAP32[$1 >> 2];
       return;
      case 0:
       $1 = HEAP32[$2 >> 2];
       HEAP32[$2 >> 2] = $1 + 4;
       $2 = HEAP32[$1 >> 2];
       $3 = $2 >> 31;
       HEAP32[$0 >> 2] = $2;
       HEAP32[$0 + 4 >> 2] = $3;
       return;
      case 1:
       $1 = HEAP32[$2 >> 2];
       HEAP32[$2 >> 2] = $1 + 4;
       $3 = HEAP32[$1 >> 2];
       HEAP32[$0 >> 2] = $3;
       HEAP32[$0 + 4 >> 2] = 0;
       return;
      case 2:
       $1 = HEAP32[$2 >> 2] + 7 & -8;
       HEAP32[$2 >> 2] = $1 + 8;
       $3 = HEAP32[$1 + 4 >> 2];
       $2 = HEAP32[$1 >> 2];
       HEAP32[$0 >> 2] = $2;
       HEAP32[$0 + 4 >> 2] = $3;
       return;
      case 3:
       $1 = HEAP32[$2 >> 2];
       HEAP32[$2 >> 2] = $1 + 4;
       $3 = HEAP16[$1 >> 1];
       $2 = $3 >> 31;
       HEAP32[$0 >> 2] = $3;
       HEAP32[$0 + 4 >> 2] = $2;
       return;
      case 4:
       $1 = HEAP32[$2 >> 2];
       HEAP32[$2 >> 2] = $1 + 4;
       $2 = HEAPU16[$1 >> 1];
       HEAP32[$0 >> 2] = $2;
       HEAP32[$0 + 4 >> 2] = 0;
       return;
      case 5:
       $1 = HEAP32[$2 >> 2];
       HEAP32[$2 >> 2] = $1 + 4;
       $3 = HEAP8[$1 | 0];
       $2 = $3 >> 31;
       HEAP32[$0 >> 2] = $3;
       HEAP32[$0 + 4 >> 2] = $2;
       return;
      case 6:
       $1 = HEAP32[$2 >> 2];
       HEAP32[$2 >> 2] = $1 + 4;
       $2 = HEAPU8[$1 | 0];
       HEAP32[$0 >> 2] = $2;
       HEAP32[$0 + 4 >> 2] = 0;
       return;
      case 7:
       $1 = HEAP32[$2 >> 2] + 7 & -8;
       HEAP32[$2 >> 2] = $1 + 8;
       $2 = HEAP32[$1 + 4 >> 2];
       $3 = HEAP32[$1 >> 2];
       HEAP32[$0 >> 2] = $3;
       HEAP32[$0 + 4 >> 2] = $2;
       return;
      case 8:
       break label$6;
      };
     }
    }
    if (global$2 ? !$4 : 1) {
     FUNCTION_TABLE[$3]($0, $2);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function pad($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -28;
   $6 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$6 >> 2];
   $1 = HEAP32[$6 + 4 >> 2];
   $2 = HEAP32[$6 + 8 >> 2];
   $3 = HEAP32[$6 + 12 >> 2];
   $4 = HEAP32[$6 + 16 >> 2];
   $7 = HEAP32[$6 + 20 >> 2];
   $6 = HEAP32[$6 + 24 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $7 = global$0 - 256 | 0;
   global$0 = $7;
   $6 = ($2 | 0) <= ($3 | 0);
  }
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($4 & 73728 | $6) {
      break label$5
     }
     $2 = $2 - $3 | 0;
     $3 = $2 >>> 0 < 256;
     memset($7, $1, $3 ? $2 : 256);
     $1 = !$3;
    }
    if ((global$2 | 0) == 2 | $1) {
     while (1) {
      if (global$2 ? !$5 : 1) {
       out($0, $7, 256);
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
      if (!global$2) {
       $2 = $2 + -256 | 0;
       if ($2 >>> 0 > 255) {
        continue
       }
      }
      break;
     }
    }
    if (global$2 ? ($5 | 0) == 1 : 1) {
     out($0, $7, $2);
     $8 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    global$0 = $7 + 256 | 0
   }
   return;
  }
  $5 = $8;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[$5 + 20 >> 2] = $7;
  HEAP32[$5 + 24 >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 28;
 }
 
 function fmt_o($0, $1, $2) {
  if ($0 | $1) {
   while (1) {
    $2 = $2 + -1 | 0;
    HEAP8[$2 | 0] = $0 & 7 | 48;
    $0 = ($1 & 7) << 29 | $0 >>> 3;
    $1 = $1 >>> 3 | 0;
    if ($0 | $1) {
     continue
    }
    break;
   }
  }
  return $2;
 }
 
 function fmt_x($0, $1, $2, $3) {
  if ($0 | $1) {
   while (1) {
    $2 = $2 + -1 | 0;
    HEAP8[$2 | 0] = HEAPU8[($0 & 15) + 12672 | 0] | $3;
    $0 = ($1 & 15) << 28 | $0 >>> 4;
    $1 = $1 >>> 4 | 0;
    if ($0 | $1) {
     continue
    }
    break;
   }
  }
  return $2;
 }
 
 function fmt_u($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  $3 = $0;
  label$1 : {
   if (($1 | 0) == 1 & $3 >>> 0 < 0 | $1 >>> 0 < 1) {
    $5 = $0;
    $3 = $1;
    $6 = $3;
    break label$1;
   }
   while (1) {
    $2 = $2 + -1 | 0;
    $3 = $1;
    $5 = __wasm_i64_udiv($0, $3, 10, 0);
    $3 = i64toi32_i32$HIGH_BITS;
    $6 = $3;
    $3 = __wasm_i64_mul($5, $3, 10, 0);
    HEAP8[$2 | 0] = $0 - $3 | 48;
    $3 = $0;
    $4 = ($1 | 0) == 9 & $3 >>> 0 > 4294967295 | $1 >>> 0 > 9;
    $0 = $5;
    $3 = $6;
    $1 = $3;
    if ($4) {
     continue
    }
    break;
   };
  }
  $4 = $5;
  if ($4) {
   while (1) {
    $2 = $2 + -1 | 0;
    $0 = ($4 >>> 0) / 10 | 0;
    HEAP8[$2 | 0] = $4 - Math_imul($0, 10) | 48;
    $1 = $4 >>> 0 > 9;
    $4 = $0;
    if ($1) {
     continue
    }
    break;
   }
  }
  return $2;
 }
 
 function vfprintf($0, $1, $2) {
  var $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $3 = 0
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    $3 = __vfprintf_internal($0, $1, $2, 244, 245);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $3;
   }
   if (!global$2) {
    return $0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
  return 0;
 }
 
 function fmt_fp($0, $1, $2, $3, $4, $5) {
  $0 = $0 | 0;
  $1 = +$1;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0.0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -132;
   $21 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$21 >> 2];
   $9 = $21;
   $16 = HEAP32[$9 + 4 >> 2];
   $18 = HEAP32[$9 + 8 >> 2];
   wasm2js_scratch_store_i32(0, $16 | 0);
   wasm2js_scratch_store_i32(1, $18 | 0);
   $1 = +wasm2js_scratch_load_f64();
   $2 = HEAP32[$9 + 12 >> 2];
   $3 = HEAP32[$9 + 16 >> 2];
   $4 = HEAP32[$9 + 20 >> 2];
   $5 = HEAP32[$9 + 24 >> 2];
   $6 = HEAP32[$9 + 28 >> 2];
   $7 = HEAP32[$9 + 32 >> 2];
   $8 = HEAP32[$9 + 36 >> 2];
   $11 = HEAP32[$9 + 40 >> 2];
   $12 = HEAP32[$9 + 44 >> 2];
   $14 = HEAP32[$9 + 48 >> 2];
   $15 = HEAP32[$9 + 52 >> 2];
   $17 = HEAP32[$9 + 56 >> 2];
   $19 = HEAP32[$9 + 60 >> 2];
   $20 = HEAP32[$9 + 64 >> 2];
   $22 = HEAP32[$9 + 68 >> 2];
   $16 = HEAP32[$9 + 76 >> 2];
   $18 = HEAP32[$9 + 72 >> 2];
   wasm2js_scratch_store_i32(0, $18 | 0);
   wasm2js_scratch_store_i32(1, $16 | 0);
   $23 = +wasm2js_scratch_load_f64();
   $24 = HEAP32[$9 + 84 >> 2];
   $16 = HEAP32[$9 + 88 >> 2];
   $28 = $16;
   $18 = HEAP32[$9 + 92 >> 2];
   $30 = $18;
   $25 = HEAP32[$9 + 96 >> 2];
   $26 = HEAP32[$9 + 100 >> 2];
   $29 = HEAP32[$9 + 104 >> 2];
   $18 = HEAP32[$9 + 108 >> 2];
   $31 = $18;
   $16 = HEAP32[$9 + 112 >> 2];
   $34 = $16;
   $16 = HEAP32[$9 + 116 >> 2];
   $35 = $16;
   $18 = HEAP32[$9 + 120 >> 2];
   $32 = $18;
   $33 = HEAP32[$9 + 124 >> 2];
   $21 = HEAP32[$9 + 128 >> 2];
   $27 = HEAP32[$9 + 80 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $10 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $12 = global$0 - 560 | 0;
   global$0 = $12;
   HEAP32[$12 + 44 >> 2] = 0;
   $18 = __DOUBLE_BITS($1);
   $28 = $18;
   $16 = i64toi32_i32$HIGH_BITS;
   $30 = $16;
   $9 = $28;
   label$5 : {
    if (($16 | 0) < -1 ? 1 : ($16 | 0) <= -1 ? ($9 >>> 0 > 4294967295 ? 0 : 1) : 0) {
     $27 = 1;
     $1 = -$1;
     $9 = __DOUBLE_BITS($1);
     $28 = $9;
     $16 = i64toi32_i32$HIGH_BITS;
     $30 = $16;
     $29 = 12688;
     break label$5;
    }
    if ($4 & 2048) {
     $27 = 1;
     $29 = 12691;
     break label$5;
    }
    $27 = $4 & 1;
    $29 = $27 ? 12694 : 12689;
   }
   $16 = $30;
   $9 = $16 & 2146435072;
   $16 = 0;
   $6 = !$16 & ($9 | 0) == 2146435072;
  }
  label$2 : {
   label$8 : {
    if ((global$2 | 0) == 2 | $6) {
     if (!global$2) {
      $14 = $27 + 3 | 0;
      $3 = $4 & -65537;
     }
     if (global$2 ? !$10 : 1) {
      pad($0, 32, $2, $14, $3);
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (global$2 ? ($10 | 0) == 1 : 1) {
      out($0, $29, $27);
      $13 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      $6 = $5 >>> 5 & 1;
      $8 = $6 ? 12715 : 12719;
      $5 = $6 ? 12707 : 12711;
      $3 = $1 != $1 ? $8 : $5;
     }
     if (global$2 ? ($10 | 0) == 2 : 1) {
      out($0, $3, 3);
      $13 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     $3 = global$2 ? $3 : $4 ^ 8192;
     if (global$2 ? ($10 | 0) == 3 : 1) {
      pad($0, 32, $2, $14, $3);
      $13 = 3;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      break label$8
     }
    }
    if (!global$2) {
     $22 = $12 + 16 | 0;
     $1 = frexp($1, $12 + 44 | 0);
     $1 = $1 + $1;
     $6 = $1 != 0.0;
    }
    label$17 : {
     if (!global$2) {
      label$19 : {
       label$20 : {
        if ($6) {
         $6 = HEAP32[$12 + 44 >> 2];
         HEAP32[$12 + 44 >> 2] = $6 + -1;
         $25 = $5 | 32;
         $8 = ($25 | 0) != 97;
         if ($8) {
          break label$20
         }
         break label$17;
        }
        $25 = $5 | 32;
        $6 = ($25 | 0) == 97;
        if ($6) {
         break label$17
        }
        $11 = HEAP32[$12 + 44 >> 2];
        $15 = ($3 | 0) < 0 ? 6 : $3;
        break label$19;
       }
       $11 = $6 + -29 | 0;
       HEAP32[$12 + 44 >> 2] = $11;
       $1 = $1 * 268435456.0;
       $15 = ($3 | 0) < 0 ? 6 : $3;
      }
      $19 = ($11 | 0) < 0 ? $12 + 48 | 0 : $12 + 336 | 0;
      $8 = $19;
      while (1) {
       $3 = $8;
       if ($1 < 4294967296.0 & $1 >= 0.0) {
        $6 = ~~$1 >>> 0
       } else {
        $6 = 0
       }
       HEAP32[$3 >> 2] = $6;
       $8 = $8 + 4 | 0;
       $1 = ($1 - +($6 >>> 0)) * 1.0e9;
       if ($1 != 0.0) {
        continue
       }
       break;
      };
      label$25 : {
       if (($11 | 0) < 1) {
        $6 = $8;
        $7 = $19;
        break label$25;
       }
       $7 = $19;
       while (1) {
        $11 = ($11 | 0) < 29 ? $11 : 29;
        $6 = $8 + -4 | 0;
        label$28 : {
         if ($6 >>> 0 < $7 >>> 0) {
          break label$28
         }
         $31 = $11;
         $34 = 0;
         $28 = 0;
         while (1) {
          $18 = $28;
          $9 = 0;
          $3 = $9;
          $9 = HEAP32[$6 >> 2];
          $16 = $9;
          $21 = $31;
          $13 = $21 & 31;
          if (32 <= ($21 & 63) >>> 0) {
           $9 = $16 << $13;
           $21 = 0;
          } else {
           $9 = (1 << $13) - 1 & $16 >>> 32 - $13;
           $21 = $16 << $13;
          }
          $16 = $9;
          $9 = $3;
          $3 = $16 + $9 | 0;
          $13 = $18 + $21 | 0;
          if ($13 >>> 0 < $21 >>> 0) {
           $3 = $3 + 1 | 0
          }
          $35 = $13;
          $32 = $3;
          $18 = __wasm_i64_udiv($13, $3, 1e9, 0);
          $28 = $18;
          $3 = i64toi32_i32$HIGH_BITS;
          $30 = $3;
          $18 = __wasm_i64_mul($28, $3, 1e9, 0);
          $3 = i64toi32_i32$HIGH_BITS;
          $17 = $3;
          $9 = $13;
          $21 = $18;
          $16 = $9 - $18 | 0;
          $3 = $32;
          $18 = $17;
          $13 = $18 + ($9 >>> 0 < $21 >>> 0) | 0;
          HEAP32[$6 >> 2] = $16;
          $6 = $6 + -4 | 0;
          if ($6 >>> 0 >= $7 >>> 0) {
           continue
          }
          break;
         };
         $6 = $28;
         if (!$6) {
          break label$28
         }
         $7 = $7 + -4 | 0;
         HEAP32[$7 >> 2] = $6;
        }
        while (1) {
         $6 = $8;
         if ($6 >>> 0 > $7 >>> 0) {
          $8 = $6 + -4 | 0;
          if (!HEAP32[$8 >> 2]) {
           continue
          }
         }
         break;
        };
        $11 = HEAP32[$12 + 44 >> 2] - $11 | 0;
        HEAP32[$12 + 44 >> 2] = $11;
        $8 = $6;
        if (($11 | 0) > 0) {
         continue
        }
        break;
       };
      }
      if (($11 | 0) <= -1) {
       $24 = (($15 + 25 | 0) / 9 | 0) + 1 | 0;
       $26 = ($25 | 0) == 102;
       while (1) {
        $14 = ($11 | 0) < -9 ? 9 : 0 - $11 | 0;
        label$34 : {
         if ($7 >>> 0 >= $6 >>> 0) {
          $7 = HEAP32[$7 >> 2] ? $7 : $7 + 4 | 0;
          break label$34;
         }
         $17 = 1e9 >>> $14 | 0;
         $20 = -1 << $14 ^ -1;
         $11 = 0;
         $8 = $7;
         while (1) {
          $3 = HEAP32[$8 >> 2];
          HEAP32[$8 >> 2] = ($3 >>> $14 | 0) + $11;
          $11 = Math_imul($3 & $20, $17);
          $8 = $8 + 4 | 0;
          if ($8 >>> 0 < $6 >>> 0) {
           continue
          }
          break;
         };
         $7 = HEAP32[$7 >> 2] ? $7 : $7 + 4 | 0;
         if (!$11) {
          break label$34
         }
         HEAP32[$6 >> 2] = $11;
         $6 = $6 + 4 | 0;
        }
        $11 = HEAP32[$12 + 44 >> 2] + $14 | 0;
        HEAP32[$12 + 44 >> 2] = $11;
        $8 = $26 ? $19 : $7;
        $6 = $6 - $8 >> 2 > ($24 | 0) ? $8 + ($24 << 2) | 0 : $6;
        if (($11 | 0) < 0) {
         continue
        }
        break;
       };
      }
      $8 = 0;
      label$37 : {
       if ($7 >>> 0 >= $6 >>> 0) {
        break label$37
       }
       $8 = Math_imul($19 - $7 >> 2, 9);
       $11 = 10;
       $3 = HEAP32[$7 >> 2];
       if ($3 >>> 0 < 10) {
        break label$37
       }
       while (1) {
        $8 = $8 + 1 | 0;
        $11 = Math_imul($11, 10);
        if ($3 >>> 0 >= $11 >>> 0) {
         continue
        }
        break;
       };
      }
      $11 = ($15 - (($25 | 0) == 102 ? 0 : $8) | 0) - (($25 | 0) == 103 & ($15 | 0) != 0) | 0;
      if (($11 | 0) < (Math_imul($6 - $19 >> 2, 9) + -9 | 0)) {
       $3 = $11 + 9216 | 0;
       $17 = ($3 | 0) / 9 | 0;
       $14 = (($17 << 2) + $19 | 0) + -4092 | 0;
       $11 = 10;
       $3 = $3 - Math_imul($17, 9) | 0;
       if (($3 | 0) <= 7) {
        while (1) {
         $11 = Math_imul($11, 10);
         $3 = $3 + 1 | 0;
         if (($3 | 0) != 8) {
          continue
         }
         break;
        }
       }
       $17 = HEAP32[$14 >> 2];
       $20 = ($17 >>> 0) / ($11 >>> 0) | 0;
       $3 = Math_imul($20, $11);
       $24 = $14 + 4 | 0;
       $3 = $17 - $3 | 0;
       label$42 : {
        if ($3 ? 0 : ($24 | 0) == ($6 | 0)) {
         break label$42
        }
        $26 = $11 >>> 1 | 0;
        $23 = $3 >>> 0 < $26 >>> 0 ? .5 : ($6 | 0) == ($24 | 0) ? (($26 | 0) == ($3 | 0) ? 1.0 : 1.5) : 1.5;
        $1 = $20 & 1 ? 9007199254740994.0 : 9007199254740992.0;
        if (!(!$27 | HEAPU8[$29 | 0] != 45)) {
         $23 = -$23;
         $1 = -$1;
        }
        $3 = $17 - $3 | 0;
        HEAP32[$14 >> 2] = $3;
        if ($1 + $23 == $1) {
         break label$42
        }
        $8 = $3 + $11 | 0;
        HEAP32[$14 >> 2] = $8;
        if ($8 >>> 0 >= 1e9) {
         while (1) {
          HEAP32[$14 >> 2] = 0;
          $14 = $14 + -4 | 0;
          if ($14 >>> 0 < $7 >>> 0) {
           $7 = $7 + -4 | 0;
           HEAP32[$7 >> 2] = 0;
          }
          $8 = HEAP32[$14 >> 2] + 1 | 0;
          HEAP32[$14 >> 2] = $8;
          if ($8 >>> 0 > 999999999) {
           continue
          }
          break;
         }
        }
        $8 = Math_imul($19 - $7 >> 2, 9);
        $11 = 10;
        $3 = HEAP32[$7 >> 2];
        if ($3 >>> 0 < 10) {
         break label$42
        }
        while (1) {
         $8 = $8 + 1 | 0;
         $11 = Math_imul($11, 10);
         if ($3 >>> 0 >= $11 >>> 0) {
          continue
         }
         break;
        };
       }
       $11 = $14 + 4 | 0;
       $3 = $6 >>> 0 > $11 >>> 0;
       $6 = $3 ? $11 : $6;
      }
      label$48 : {
       while (1) {
        $11 = $6;
        $26 = 0;
        if ($6 >>> 0 <= $7 >>> 0) {
         break label$48
        }
        $6 = $11 + -4 | 0;
        if (!HEAP32[$6 >> 2]) {
         continue
        }
        break;
       };
       $26 = 1;
      }
      label$50 : {
       if (($25 | 0) != 103) {
        $20 = $4 & 8;
        break label$50;
       }
       $6 = $15 ? $15 : 1;
       $3 = ($8 | 0) > -5 & ($6 | 0) > ($8 | 0);
       $15 = $3 ? $8 ^ -1 : -1;
       $15 = $6 + $15 | 0;
       $5 = ($3 ? -1 : -2) + $5 | 0;
       $20 = $4 & 8;
       if ($20) {
        break label$50
       }
       $6 = 9;
       label$52 : {
        if (!$26) {
         break label$52
        }
        $14 = HEAP32[$11 + -4 >> 2];
        if (!$14) {
         break label$52
        }
        $3 = 10;
        $6 = 0;
        if (($14 >>> 0) % 10) {
         break label$52
        }
        while (1) {
         $6 = $6 + 1 | 0;
         $3 = Math_imul($3, 10);
         if (!(($14 >>> 0) % ($3 >>> 0))) {
          continue
         }
         break;
        };
       }
       $3 = Math_imul($11 - $19 >> 2, 9) + -9 | 0;
       if (($5 | 32) == 102) {
        $20 = 0;
        $6 = $3 - $6 | 0;
        $3 = ($6 | 0) > 0;
        $6 = $3 ? $6 : 0;
        $3 = ($15 | 0) < ($6 | 0);
        $15 = $3 ? $15 : $6;
        break label$50;
       }
       $20 = 0;
       $6 = ($3 + $8 | 0) - $6 | 0;
       $3 = ($6 | 0) > 0;
       $6 = $3 ? $6 : 0;
       $3 = ($15 | 0) < ($6 | 0);
       $15 = $3 ? $15 : $6;
      }
      $25 = $15 | $20;
      $3 = ($25 | 0) != 0;
      $33 = $0;
      $21 = $2;
      $6 = ($8 | 0) > 0 ? $8 : 0;
      $17 = $5 | 32;
      if (($17 | 0) != 102) {
       $6 = $8 >> 31;
       $14 = $8 + $6 | 0;
       $6 = fmt_u($6 ^ $14, 0, $22);
       if (($22 - $6 | 0) <= 1) {
        while (1) {
         $6 = $6 + -1 | 0;
         HEAP8[$6 | 0] = 48;
         if (($22 - $6 | 0) < 2) {
          continue
         }
         break;
        }
       }
       $24 = $6 + -2 | 0;
       HEAP8[$24 | 0] = $5;
       HEAP8[$6 + -1 | 0] = ($8 | 0) < 0 ? 45 : 43;
       $6 = $22 - $24 | 0;
      }
      $5 = $15 + $27 | 0;
      $3 = ($5 + $3 | 0) + $6 | 0;
      $14 = $3 + 1 | 0;
     }
     if (global$2 ? ($10 | 0) == 4 : 1) {
      pad($33, 32, $21, $14, $4);
      $13 = 4;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (global$2 ? ($10 | 0) == 5 : 1) {
      out($0, $29, $27);
      $13 = 5;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     $3 = global$2 ? $3 : $4 ^ 65536;
     if (global$2 ? ($10 | 0) == 6 : 1) {
      pad($0, 48, $2, $14, $3);
      $13 = 6;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     $3 = global$2 ? $3 : ($17 | 0) == 102;
     label$61 : {
      label$62 : {
       label$63 : {
        if ($3 | (global$2 | 0) == 2) {
         if (!global$2) {
          $17 = $12 + 16 | 8;
          $8 = $12 + 16 | 9;
          $3 = $7 >>> 0 > $19 >>> 0 ? $19 : $7;
          $7 = $3;
         }
         while (1) {
          if (!global$2) {
           $13 = HEAP32[$7 >> 2];
           $6 = fmt_u($13, 0, $8);
           label$68 : {
            if (($3 | 0) != ($7 | 0)) {
             if ($6 >>> 0 <= $12 + 16 >>> 0) {
              break label$68
             }
             while (1) {
              $6 = $6 + -1 | 0;
              HEAP8[$6 | 0] = 48;
              if ($6 >>> 0 > $12 + 16 >>> 0) {
               continue
              }
              break;
             };
             break label$68;
            }
            if (($6 | 0) != ($8 | 0)) {
             break label$68
            }
            HEAP8[$12 + 24 | 0] = 48;
            $6 = $17;
           }
           $5 = $8 - $6 | 0;
          }
          if (global$2 ? ($10 | 0) == 7 : 1) {
           out($0, $6, $5);
           $13 = 7;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (!global$2) {
           $7 = $7 + 4 | 0;
           $5 = $7 >>> 0 <= $19 >>> 0;
           if ($5) {
            continue
           }
          }
          break;
         };
         if ((global$2 | 0) == 2 | $25) {
          if (global$2 ? ($10 | 0) == 8 : 1) {
           out($0, 12723, 1);
           $13 = 8;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
         }
         if (!global$2) {
          $3 = $7 >>> 0 >= $11 >>> 0;
          if ($3) {
           break label$63
          }
          $3 = ($15 | 0) < 1;
          if ($3) {
           break label$63
          }
         }
         while (1) {
          if (!global$2) {
           $9 = HEAP32[$7 >> 2];
           $6 = fmt_u($9, 0, $8);
           if ($6 >>> 0 > $12 + 16 >>> 0) {
            while (1) {
             $6 = $6 + -1 | 0;
             HEAP8[$6 | 0] = 48;
             if ($6 >>> 0 > $12 + 16 >>> 0) {
              continue
             }
             break;
            }
           }
           $3 = ($15 | 0) < 9 ? $15 : 9;
          }
          if (global$2 ? ($10 | 0) == 9 : 1) {
           out($0, $6, $3);
           $13 = 9;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (!global$2) {
           $6 = $15 + -9 | 0;
           $7 = $7 + 4 | 0;
           $3 = $7 >>> 0 >= $11 >>> 0;
           if ($3) {
            break label$62
           }
           $3 = ($15 | 0) > 9;
           $15 = $6;
           if ($3) {
            continue
           }
          }
          break;
         };
         if (!global$2) {
          break label$62
         }
        }
        $3 = global$2 ? $3 : ($15 | 0) < 0;
        label$82 : {
         if (!global$2) {
          if ($3) {
           break label$82
          }
          $17 = $26 ? $11 : $7 + 4 | 0;
          $19 = $12 + 16 | 8;
          $3 = $12 + 16 | 0;
          $11 = $3 | 9;
          $8 = $7;
         }
         while (1) {
          if (!global$2) {
           $13 = HEAP32[$8 >> 2];
           $6 = fmt_u($13, 0, $11);
           if (($11 | 0) == ($6 | 0)) {
            HEAP8[$12 + 24 | 0] = 48;
            $6 = $19;
           }
           $3 = ($7 | 0) != ($8 | 0);
          }
          label$87 : {
           if (!global$2) {
            if ($3) {
             $3 = $6 >>> 0 <= $12 + 16 >>> 0;
             if ($3) {
              break label$87
             }
             while (1) {
              $6 = $6 + -1 | 0;
              HEAP8[$6 | 0] = 48;
              $3 = $6 >>> 0 > $12 + 16 >>> 0;
              if ($3) {
               continue
              }
              break;
             };
             break label$87;
            }
           }
           if (global$2 ? ($10 | 0) == 10 : 1) {
            out($0, $6, 1);
            $13 = 10;
            if ((global$2 | 0) == 1) {
             break label$2
            }
           }
           if (!global$2) {
            $6 = $6 + 1 | 0;
            $5 = !$20;
            $3 = ($15 | 0) < 1 ? $5 : 0;
            if ($3) {
             break label$87
            }
           }
           if (global$2 ? ($10 | 0) == 11 : 1) {
            out($0, 12723, 1);
            $13 = 11;
            if ((global$2 | 0) == 1) {
             break label$2
            }
           }
          }
          if (!global$2) {
           $3 = $11 - $6 | 0;
           $5 = ($15 | 0) > ($3 | 0);
           $5 = $5 ? $3 : $15;
          }
          if (global$2 ? ($10 | 0) == 12 : 1) {
           out($0, $6, $5);
           $13 = 12;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          }
          if (!global$2) {
           $15 = $15 - $3 | 0;
           $8 = $8 + 4 | 0;
           $3 = $8 >>> 0 >= $17 >>> 0;
           if ($3) {
            break label$82
           }
           $3 = ($15 | 0) > -1;
           if ($3) {
            continue
           }
          }
          break;
         };
        }
        $3 = global$2 ? $3 : $15 + 18 | 0;
        if (global$2 ? ($10 | 0) == 13 : 1) {
         pad($0, 48, $3, 18, 0);
         $13 = 13;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        $3 = global$2 ? $3 : $22 - $24 | 0;
        if (global$2 ? ($10 | 0) == 14 : 1) {
         out($0, $24, $3);
         $13 = 14;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        }
        if (!global$2) {
         break label$61
        }
       }
       $6 = global$2 ? $6 : $15;
      }
      $3 = global$2 ? $3 : $6 + 9 | 0;
      if (global$2 ? ($10 | 0) == 15 : 1) {
       pad($0, 48, $3, 9, 0);
       $13 = 15;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      }
     }
     $3 = global$2 ? $3 : $4 ^ 8192;
     if (global$2 ? ($10 | 0) == 16 : 1) {
      pad($0, 32, $2, $14, $3);
      $13 = 16;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      break label$8
     }
    }
    if (!global$2) {
     $8 = $5 & 32;
     $15 = $8 ? $29 + 9 | 0 : $29;
     label$102 : {
      if ($3 >>> 0 > 11) {
       break label$102
      }
      $6 = 12 - $3 | 0;
      if (!$6) {
       break label$102
      }
      $23 = 8.0;
      while (1) {
       $23 = $23 * 16.0;
       $6 = $6 + -1 | 0;
       if ($6) {
        continue
       }
       break;
      };
      if (HEAPU8[$15 | 0] == 45) {
       $1 = -($23 + (-$1 - $23));
       break label$102;
      }
      $1 = $1 + $23 - $23;
     }
     $6 = HEAP32[$12 + 44 >> 2];
     $7 = $6;
     $6 = $6 >> 31;
     $7 = $7 + $6 | 0;
     $6 = fmt_u($6 ^ $7, 0, $22);
     if (($22 | 0) == ($6 | 0)) {
      HEAP8[$12 + 15 | 0] = 48;
      $6 = $12 + 15 | 0;
     }
     $20 = $27 | 2;
     $7 = HEAP32[$12 + 44 >> 2];
     $17 = $6 + -2 | 0;
     HEAP8[$17 | 0] = $5 + 15;
     HEAP8[$6 + -1 | 0] = ($7 | 0) < 0 ? 45 : 43;
     $11 = $4 & 8;
     $7 = $12 + 16 | 0;
     while (1) {
      $6 = $7;
      $5 = $6;
      if (Math_abs($1) < 2147483648.0) {
       $7 = ~~$1
      } else {
       $7 = -2147483648
      }
      HEAP8[$5 | 0] = HEAPU8[$7 + 12672 | 0] | $8;
      $1 = ($1 - +($7 | 0)) * 16.0;
      $7 = $6 + 1 | 0;
      if (!(($7 - ($12 + 16 | 0) | 0) != 1 | ($1 == 0.0 ? !(($3 | 0) > 0 | $11) : 0))) {
       HEAP8[$6 + 1 | 0] = 46;
       $7 = $6 + 2 | 0;
      }
      if ($1 != 0.0) {
       continue
      }
      break;
     };
     $19 = $0;
     $8 = $2;
     $5 = $20;
     $9 = $5;
     label$111 : {
      if (!(!$3 | (($7 - $12 | 0) + -18 | 0) >= ($3 | 0))) {
       $3 = ($3 + $22 | 0) - $17 | 0;
       $6 = $3 + 2 | 0;
       break label$111;
      }
      $3 = ($22 - ($12 + 16 | 0) | 0) - $17 | 0;
      $6 = $7 + $3 | 0;
     }
     $14 = $9 + $6 | 0;
    }
    if (global$2 ? ($10 | 0) == 17 : 1) {
     pad($19, 32, $8, $14, $4);
     $13 = 17;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (global$2 ? ($10 | 0) == 18 : 1) {
     out($0, $15, $20);
     $13 = 18;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    $3 = global$2 ? $3 : $4 ^ 65536;
    if (global$2 ? ($10 | 0) == 19 : 1) {
     pad($0, 48, $2, $14, $3);
     $13 = 19;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (!global$2) {
     $3 = $12 + 16 | 0;
     $7 = $7 - $3 | 0;
     $5 = $12 + 16 | 0;
    }
    if (global$2 ? ($10 | 0) == 20 : 1) {
     out($0, $5, $7);
     $13 = 20;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (!global$2) {
     $8 = $22 - $17 | 0;
     $3 = $6 - ($8 + $7 | 0) | 0;
    }
    if (global$2 ? ($10 | 0) == 21 : 1) {
     pad($0, 48, $3, 0, 0);
     $13 = 21;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (global$2 ? ($10 | 0) == 22 : 1) {
     out($0, $17, $8);
     $13 = 22;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    $3 = global$2 ? $3 : $4 ^ 8192;
    if (global$2 ? ($10 | 0) == 23 : 1) {
     pad($0, 32, $2, $14, $3);
     $13 = 23;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    global$0 = $12 + 560 | 0;
    return (($14 | 0) < ($2 | 0) ? $2 : $14) | 0;
   }
   abort();
  }
  $10 = $13;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $10;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $10 = HEAP32[global$3 >> 2];
  HEAP32[$10 >> 2] = $0;
  wasm2js_scratch_store_f64(+$1);
  $9 = wasm2js_scratch_load_i32(1) | 0;
  $0 = wasm2js_scratch_load_i32(0) | 0;
  HEAP32[$10 + 4 >> 2] = $0;
  HEAP32[$10 + 8 >> 2] = $9;
  HEAP32[$10 + 12 >> 2] = $2;
  HEAP32[$10 + 16 >> 2] = $3;
  HEAP32[$10 + 20 >> 2] = $4;
  HEAP32[$10 + 24 >> 2] = $5;
  HEAP32[$10 + 28 >> 2] = $6;
  HEAP32[$10 + 32 >> 2] = $7;
  HEAP32[$10 + 36 >> 2] = $8;
  HEAP32[$10 + 40 >> 2] = $11;
  HEAP32[$10 + 44 >> 2] = $12;
  HEAP32[$10 + 48 >> 2] = $14;
  HEAP32[$10 + 52 >> 2] = $15;
  HEAP32[$10 + 56 >> 2] = $17;
  HEAP32[$10 + 60 >> 2] = $19;
  HEAP32[$10 + 64 >> 2] = $20;
  HEAP32[$10 + 68 >> 2] = $22;
  wasm2js_scratch_store_f64(+$23);
  $9 = wasm2js_scratch_load_i32(1) | 0;
  HEAP32[$10 + 72 >> 2] = wasm2js_scratch_load_i32(0);
  HEAP32[$10 + 76 >> 2] = $9;
  HEAP32[$10 + 80 >> 2] = $27;
  HEAP32[$10 + 84 >> 2] = $24;
  HEAP32[$10 + 88 >> 2] = $28;
  $9 = $30;
  HEAP32[$10 + 92 >> 2] = $9;
  HEAP32[$10 + 96 >> 2] = $25;
  HEAP32[$10 + 100 >> 2] = $26;
  HEAP32[$10 + 104 >> 2] = $29;
  HEAP32[$10 + 108 >> 2] = $31;
  $9 = $34;
  HEAP32[$10 + 112 >> 2] = $9;
  HEAP32[$10 + 116 >> 2] = $35;
  $9 = $32;
  HEAP32[$10 + 120 >> 2] = $9;
  HEAP32[$10 + 124 >> 2] = $33;
  HEAP32[$10 + 128 >> 2] = $21;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 132;
  return 0;
 }
 
 function pop_arg_long_double($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  $2 = $1;
  $1 = HEAP32[$1 >> 2] + 15 & -16;
  HEAP32[$2 >> 2] = $1 + 16;
  HEAPF64[$0 >> 3] = __trunctfdf2(HEAP32[$1 >> 2], HEAP32[$1 + 4 >> 2], HEAP32[$1 + 8 >> 2], HEAP32[$1 + 12 >> 2]);
 }
 
 function __DOUBLE_BITS($0) {
  var $1 = 0, $2 = 0;
  wasm2js_scratch_store_f64(+$0);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  $2 = wasm2js_scratch_load_i32(0) | 0;
  i64toi32_i32$HIGH_BITS = $1;
  return $2;
 }
 
 function vfiprintf($0, $1, $2) {
  var $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $3 = 0
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    $3 = __vfprintf_internal($0, $1, $2, 0, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $3;
   }
   if (!global$2) {
    return $0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
  return 0;
 }
 
 function __small_vfprintf($0, $1, $2) {
  var $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $3 = 0
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    $3 = __vfprintf_internal($0, $1, $2, 244, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $3;
   }
   if (!global$2) {
    return $0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
  return 0;
 }
 
 function vsnprintf($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $5 = HEAP32[$5 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $4 = global$0 - 160 | 0;
   global$0 = $4;
   memcpy($4 + 8 | 0, 12728, 144);
   $5 = $1 + -1 >>> 0 >= 2147483647;
  }
  label$2 : {
   label$5 : {
    label$6 : {
     if (!global$2) {
      if ($5) {
       if ($1) {
        break label$6
       }
       $1 = 1;
       $0 = $4 + 159 | 0;
      }
      HEAP32[$4 + 52 >> 2] = $0;
      HEAP32[$4 + 28 >> 2] = $0;
      $5 = -2 - $0 | 0;
      $1 = $1 >>> 0 > $5 >>> 0 ? $5 : $1;
      HEAP32[$4 + 56 >> 2] = $1;
      $0 = $0 + $1 | 0;
      HEAP32[$4 + 36 >> 2] = $0;
      HEAP32[$4 + 24 >> 2] = $0;
      $0 = $4 + 8 | 0;
     }
     if (global$2 ? !$6 : 1) {
      $6 = vfprintf($0, $2, $3);
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $0 = $6;
     }
     if (!global$2) {
      if (!$1) {
       break label$5
      }
      $1 = HEAP32[$4 + 28 >> 2];
      $2 = ($1 | 0) == HEAP32[$4 + 24 >> 2];
      HEAP8[$1 - $2 | 0] = 0;
      break label$5;
     }
    }
    if (!global$2) {
     HEAP32[__errno_location() >> 2] = 61;
     $0 = -1;
    }
   }
   if (!global$2) {
    global$0 = $4 + 160 | 0;
    return $0;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $4;
  HEAP32[$6 + 20 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  return 0;
 }
 
 function sn_write($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0;
  $3 = HEAP32[$0 + 20 >> 2];
  $4 = $3;
  $3 = HEAP32[$0 + 16 >> 2] - $3 | 0;
  $3 = $3 >>> 0 > $2 >>> 0 ? $2 : $3;
  memcpy($4, $1, $3);
  HEAP32[$0 + 20 >> 2] = HEAP32[$0 + 20 >> 2] + $3;
  return $2 | 0;
 }
 
 function vsniprintf($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $5 = HEAP32[$5 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $4 = global$0 - 160 | 0;
   global$0 = $4;
   memcpy($4 + 8 | 0, 12728, 144);
   $5 = $1 + -1 >>> 0 >= 2147483647;
  }
  label$2 : {
   label$5 : {
    label$6 : {
     if (!global$2) {
      if ($5) {
       if ($1) {
        break label$6
       }
       $1 = 1;
       $0 = $4 + 159 | 0;
      }
      HEAP32[$4 + 52 >> 2] = $0;
      HEAP32[$4 + 28 >> 2] = $0;
      $5 = -2 - $0 | 0;
      $1 = $1 >>> 0 > $5 >>> 0 ? $5 : $1;
      HEAP32[$4 + 56 >> 2] = $1;
      $0 = $0 + $1 | 0;
      HEAP32[$4 + 36 >> 2] = $0;
      HEAP32[$4 + 24 >> 2] = $0;
      $0 = $4 + 8 | 0;
     }
     if (global$2 ? !$6 : 1) {
      $6 = vfiprintf($0, $2, $3);
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $0 = $6;
     }
     if (!global$2) {
      if (!$1) {
       break label$5
      }
      $1 = HEAP32[$4 + 28 >> 2];
      $2 = ($1 | 0) == HEAP32[$4 + 24 >> 2];
      HEAP8[$1 - $2 | 0] = 0;
      break label$5;
     }
    }
    if (!global$2) {
     HEAP32[__errno_location() >> 2] = 61;
     $0 = -1;
    }
   }
   if (!global$2) {
    global$0 = $4 + 160 | 0;
    return $0;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $4;
  HEAP32[$6 + 20 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  return 0;
 }
 
 function __small_vsnprintf($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $5 = HEAP32[$5 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $4 = global$0 - 160 | 0;
   global$0 = $4;
   memcpy($4 + 8 | 0, 12728, 144);
   $5 = $1 + -1 >>> 0 >= 2147483647;
  }
  label$2 : {
   label$5 : {
    label$6 : {
     if (!global$2) {
      if ($5) {
       if ($1) {
        break label$6
       }
       $1 = 1;
       $0 = $4 + 159 | 0;
      }
      HEAP32[$4 + 52 >> 2] = $0;
      HEAP32[$4 + 28 >> 2] = $0;
      $5 = -2 - $0 | 0;
      $1 = $1 >>> 0 > $5 >>> 0 ? $5 : $1;
      HEAP32[$4 + 56 >> 2] = $1;
      $0 = $0 + $1 | 0;
      HEAP32[$4 + 36 >> 2] = $0;
      HEAP32[$4 + 24 >> 2] = $0;
      $0 = $4 + 8 | 0;
     }
     if (global$2 ? !$6 : 1) {
      $6 = __small_vfprintf($0, $2, $3);
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $0 = $6;
     }
     if (!global$2) {
      if (!$1) {
       break label$5
      }
      $1 = HEAP32[$4 + 28 >> 2];
      $2 = ($1 | 0) == HEAP32[$4 + 24 >> 2];
      HEAP8[$1 - $2 | 0] = 0;
      break label$5;
     }
    }
    if (!global$2) {
     HEAP32[__errno_location() >> 2] = 61;
     $0 = -1;
    }
   }
   if (!global$2) {
    global$0 = $4 + 160 | 0;
    return $0;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $4;
  HEAP32[$6 + 20 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  return 0;
 }
 
 function snprintf($0, $1, $2, $3) {
  var $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $4 = HEAP32[$4 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $4 = global$0 - 16 | 0;
   global$0 = $4;
   HEAP32[$4 + 12 >> 2] = $3;
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = vsnprintf($0, $1, $2, $3);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $5;
   }
   if (!global$2) {
    global$0 = $4 + 16 | 0;
    return $3;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
  return 0;
 }
 
 function __stdio_read($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  $3 = global$0 - 32 | 0;
  global$0 = $3;
  HEAP32[$3 + 16 >> 2] = $1;
  $4 = HEAP32[$0 + 48 >> 2];
  HEAP32[$3 + 20 >> 2] = $2 - (($4 | 0) != 0);
  $5 = HEAP32[$0 + 44 >> 2];
  HEAP32[$3 + 28 >> 2] = $4;
  HEAP32[$3 + 24 >> 2] = $5;
  label$1 : {
   label$2 : {
    label$3 : {
     if (__wasi_syscall_ret(__wasi_fd_read(HEAP32[$0 + 60 >> 2], $3 + 16 | 0, 2, $3 + 12 | 0) | 0)) {
      HEAP32[$3 + 12 >> 2] = -1;
      $2 = -1;
      break label$3;
     }
     $4 = HEAP32[$3 + 12 >> 2];
     if (($4 | 0) > 0) {
      break label$2
     }
     $2 = $4;
    }
    HEAP32[$0 >> 2] = HEAP32[$0 >> 2] | $2 & 48 ^ 16;
    break label$1;
   }
   $6 = HEAP32[$3 + 20 >> 2];
   if ($4 >>> 0 <= $6 >>> 0) {
    $2 = $4;
    break label$1;
   }
   $5 = HEAP32[$0 + 44 >> 2];
   HEAP32[$0 + 4 >> 2] = $5;
   HEAP32[$0 + 8 >> 2] = ($4 - $6 | 0) + $5;
   if (!HEAP32[$0 + 48 >> 2]) {
    break label$1
   }
   HEAP32[$0 + 4 >> 2] = $5 + 1;
   HEAP8[($1 + $2 | 0) + -1 | 0] = HEAPU8[$5 | 0];
  }
  global$0 = $3 + 32 | 0;
  return $2 | 0;
 }
 
 function feof($0) {
  var $1 = 0, $2 = 0;
  if (HEAP32[$0 + 76 >> 2] <= -1) {
   return HEAP32[$0 >> 2] >>> 4 & 1
  }
  $1 = __lockfile($0);
  $2 = HEAP32[$0 >> 2] >>> 4 & 1;
  if ($1) {
   __unlockfile($0)
  }
  return $2;
 }
 
 function __fdopen($0, $1) {
  var $2 = 0, $3 = 0;
  $3 = global$0 - 32 | 0;
  global$0 = $3;
  label$1 : {
   label$2 : {
    label$3 : {
     if (!strchr(12872, HEAP8[$1 | 0])) {
      HEAP32[__errno_location() >> 2] = 28;
      break label$3;
     }
     $2 = dlmalloc(1176);
     if ($2) {
      break label$2
     }
    }
    $2 = 0;
    break label$1;
   }
   memset($2, 0, 144);
   if (!strchr($1, 43)) {
    HEAP32[$2 >> 2] = HEAPU8[$1 | 0] == 114 ? 8 : 4
   }
   label$6 : {
    if (HEAPU8[$1 | 0] != 97) {
     $1 = HEAP32[$2 >> 2];
     break label$6;
    }
    $1 = __syscall221($0 | 0, 3, 0) | 0;
    if (!($1 & 1024)) {
     HEAP32[$3 + 16 >> 2] = $1 | 1024;
     __syscall221($0 | 0, 4, $3 + 16 | 0) | 0;
    }
    $1 = HEAP32[$2 >> 2] | 128;
    HEAP32[$2 >> 2] = $1;
   }
   HEAP8[$2 + 75 | 0] = 255;
   HEAP32[$2 + 48 >> 2] = 1024;
   HEAP32[$2 + 60 >> 2] = $0;
   HEAP32[$2 + 44 >> 2] = $2 + 152;
   label$9 : {
    if ($1 & 8) {
     break label$9
    }
    HEAP32[$3 >> 2] = $3 + 24;
    if (__syscall54($0 | 0, 21523, $3 | 0)) {
     break label$9
    }
    HEAP8[$2 + 75 | 0] = 10;
   }
   HEAP32[$2 + 40 >> 2] = 242;
   HEAP32[$2 + 36 >> 2] = 241;
   HEAP32[$2 + 32 >> 2] = 243;
   HEAP32[$2 + 12 >> 2] = 240;
   if (!HEAP32[5974]) {
    HEAP32[$2 + 76 >> 2] = -1
   }
   $2 = __ofl_add($2);
  }
  global$0 = $3 + 32 | 0;
  return $2;
 }
 
 function tmpfile() {
  var $0 = 0, $1 = 0, $2 = 0, $3 = 0;
  $0 = global$0 - 48 | 0;
  global$0 = $0;
  HEAP32[$0 + 32 >> 2] = HEAP32[3224];
  $1 = HEAP32[3223];
  $3 = HEAP32[3222];
  HEAP32[$0 + 24 >> 2] = $3;
  HEAP32[$0 + 28 >> 2] = $1;
  $3 = HEAP32[3221];
  $1 = HEAP32[3220];
  HEAP32[$0 + 16 >> 2] = $1;
  HEAP32[$0 + 20 >> 2] = $3;
  $3 = $0 + 16 | 13;
  label$1 : {
   label$2 : {
    while (1) {
     label$4 : {
      __randname($3);
      HEAP32[$0 >> 2] = 384;
      $1 = __syscall_ret(__syscall5($0 + 16 | 0, 32962, $0 | 0) | 0);
      if (($1 | 0) >= 0) {
       break label$4
      }
      $2 = $2 + 1 | 0;
      if (($2 | 0) != 100) {
       continue
      }
      break label$2;
     }
     break;
    };
    __syscall10($0 + 16 | 0) | 0;
    $2 = __fdopen($1, 12900);
    if ($2) {
     break label$1
    }
    __wasi_fd_close($1 | 0) | 0;
   }
   $2 = 0;
  }
  global$0 = $0 + 48 | 0;
  return $2;
 }
 
 function __stdio_seek($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  $4 = global$0 - 16 | 0;
  global$0 = $4;
  __wasi_syscall_ret(legalfunc$__wasi_fd_seek(HEAP32[$0 + 60 >> 2], $1, $2, $3 & 255, $4 + 8 | 0));
  $2 = HEAP32[$4 + 12 >> 2];
  global$0 = $4 + 16 | 0;
  i64toi32_i32$HIGH_BITS = $2;
  $1 = HEAP32[$4 + 8 >> 2];
  return $1 | 0;
 }
 
 function fread($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -36;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $6 = HEAP32[$4 + 20 >> 2];
   $8 = HEAP32[$4 + 24 >> 2];
   $7 = HEAP32[$4 + 28 >> 2];
   $9 = HEAP32[$4 + 32 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $10 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $8 = 0;
   if (HEAP32[$3 + 76 >> 2] >= 0) {
    $8 = __lockfile($3)
   }
   $6 = HEAPU8[$3 + 74 | 0];
   HEAP8[$3 + 74 | 0] = $6 | $6 + -1;
   $7 = Math_imul($1, $2);
   $5 = $7;
   $9 = HEAP32[$3 + 4 >> 2];
   $6 = HEAP32[$3 + 8 >> 2] - $9 | 0;
   if (($6 | 0) >= 1) {
    $5 = $6 >>> 0 < $7 >>> 0 ? $6 : $7;
    memcpy($0, $9, $5);
    HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] + $5;
    $0 = $0 + $5 | 0;
    $5 = $7 - $5 | 0;
   }
   $6 = $5;
  }
  label$2 : {
   if ((global$2 | 0) == 2 | $5) {
    while (1) {
     if (global$2 ? !$10 : 1) {
      $4 = __toread($3);
      $11 = 0;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $5 = $4;
     }
     $5 = global$2 ? $5 : !$5;
     label$9 : {
      if ($5 | (global$2 | 0) == 2) {
       $5 = global$2 ? $5 : HEAP32[$3 + 32 >> 2];
       if (global$2 ? ($10 | 0) == 1 : 1) {
        $4 = FUNCTION_TABLE[$5]($3, $0, $6) | 0;
        $11 = 1;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $5 = $4;
       }
       if ($5 + 1 >>> 0 > 1 ? !global$2 : 0) {
        break label$9
       }
      }
      if (!global$2) {
       if ($8) {
        __unlockfile($3)
       }
       return ($7 - $6 >>> 0) / ($1 >>> 0) | 0;
      }
     }
     if (!global$2) {
      $0 = $0 + $5 | 0;
      $6 = $6 - $5 | 0;
      if ($6) {
       continue
      }
     }
     break;
    }
   }
   if (!global$2) {
    $0 = $1 ? $2 : 0;
    if ($8) {
     __unlockfile($3)
    }
    return $0;
   }
   abort();
  }
  $4 = $11;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  HEAP32[$4 + 20 >> 2] = $6;
  HEAP32[$4 + 24 >> 2] = $8;
  HEAP32[$4 + 28 >> 2] = $7;
  HEAP32[$4 + 32 >> 2] = $9;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 36;
  return 0;
 }
 
 function remove($0) {
  var $1 = 0;
  $1 = __syscall10($0 | 0) | 0;
  if (($1 | 0) == -31) {
   $1 = __syscall40($0 | 0) | 0
  }
  return __syscall_ret($1);
 }
 
 function perror($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $3 = HEAP32[$1 + 8 >> 2];
   $5 = HEAP32[$1 + 12 >> 2];
   $6 = HEAP32[$1 + 16 >> 2];
   $2 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = 0;
   $6 = strerror(HEAP32[__errno_location() >> 2]);
   $2 = HEAP32[3045];
   if (HEAP32[$2 + 76 >> 2] >= 0) {
    $5 = __lockfile($2)
   }
   $3 = !$0;
  }
  label$2 : {
   label$6 : {
    if (!global$2) {
     if (!HEAPU8[$0 | 0] | $3) {
      break label$6
     }
     $3 = strlen($0);
    }
    if (global$2 ? !$4 : 1) {
     $1 = fwrite($0, $3, 1, $2);
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $0 = $1;
    }
    if (global$2 ? ($4 | 0) == 1 : 1) {
     $1 = fputc(58, $2);
     $7 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $0 = $1;
    }
    if (global$2 ? ($4 | 0) == 2 : 1) {
     $1 = fputc(32, $2);
     $7 = 2;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $0 = $1;
    }
   }
   if (!global$2) {
    $0 = strlen($6)
   }
   if (global$2 ? ($4 | 0) == 3 : 1) {
    fwrite($6, $0, 1, $2);
    $7 = 3;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (global$2 ? ($4 | 0) == 4 : 1) {
    fputc(10, $2);
    $7 = 4;
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    if ($5) {
     __unlockfile($2)
    }
   }
   return;
  }
  $1 = $7;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP32[$1 + 8 >> 2] = $3;
  HEAP32[$1 + 12 >> 2] = $5;
  HEAP32[$1 + 16 >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function setbuf($0, $1) {
  setvbuf($0, $1, !$1 << 1, 1024);
 }
 
 function __emscripten_stdout_close($0) {
  $0 = $0 | 0;
  return 0;
 }
 
 function __emscripten_stdout_seek($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  i64toi32_i32$HIGH_BITS = 0;
  return 0;
 }
 
 function __ftello_unlocked($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $6 = HEAP32[$3 + 4 >> 2];
   $1 = HEAP32[$3 + 8 >> 2];
   $5 = $1;
   $4 = HEAP32[$3 + 12 >> 2];
   $7 = $4;
   $8 = HEAP32[$3 + 16 >> 2];
   $3 = HEAP32[$3 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $8 = HEAP32[$0 + 40 >> 2];
   $3 = $0;
   $6 = HEAPU8[$0 | 0] & 128 ? (HEAPU32[$0 + 20 >> 2] > HEAPU32[$0 + 28 >> 2] ? 2 : 1) : 1;
  }
  label$2 : {
   if (global$2 ? !$2 : 1) {
    $4 = FUNCTION_TABLE[$8]($3, 0, 0, $6) | 0;
    $1 = i64toi32_i32$HIGH_BITS;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $5 = $4;
    $7 = $1;
   }
   if (!global$2) {
    $2 = $5;
    $1 = $7;
    if (($1 | 0) > 0 ? 1 : ($1 | 0) >= 0 ? ($2 >>> 0 < 0 ? 0 : 1) : 0) {
     $1 = HEAP32[$0 + 20 >> 2] - HEAP32[$0 + 28 >> 2] | 0;
     $2 = $1 >> 31;
     $3 = $1;
     $9 = $2;
     $1 = HEAP32[$0 + 8 >> 2] - HEAP32[$0 + 4 >> 2] | 0;
     $2 = $1 >> 31;
     $6 = $2;
     $4 = $1;
     $0 = $5 - $1 | 0;
     $8 = $0;
     $2 = $7;
     $1 = $6;
     $0 = $9 + ($2 - ($1 + ($5 >>> 0 < $4 >>> 0) | 0) | 0) | 0;
     $4 = $8;
     $2 = $3;
     $1 = $4 + $2 | 0;
     if ($1 >>> 0 < $4 >>> 0) {
      $0 = $0 + 1 | 0
     }
    } else {
     $1 = $5;
     $0 = $7;
    }
    i64toi32_i32$HIGH_BITS = $0;
    $2 = $1;
    return $2;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $6;
  $0 = $2;
  HEAP32[$0 + 8 >> 2] = $5;
  $2 = $7;
  HEAP32[$0 + 12 >> 2] = $2;
  HEAP32[$0 + 16 >> 2] = $8;
  HEAP32[$0 + 20 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  i64toi32_i32$HIGH_BITS = 0;
  return 0;
 }
 
 function __ftello($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $3 = HEAP32[$1 + 8 >> 2];
   $4 = HEAP32[$1 + 12 >> 2];
   $2 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $2 = global$2 ? $2 : HEAP32[$0 + 76 >> 2] <= -1;
  label$2 : {
   if ($2 | (global$2 | 0) == 2) {
    if (global$2 ? !$6 : 1) {
     $1 = __ftello_unlocked($0);
     $5 = i64toi32_i32$HIGH_BITS;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $4 = $5;
     $3 = $1;
    }
    if (!global$2) {
     i64toi32_i32$HIGH_BITS = $4;
     return $3;
    }
   }
   if (!global$2) {
    $2 = __lockfile($0)
   }
   if (global$2 ? ($6 | 0) == 1 : 1) {
    $1 = __ftello_unlocked($0);
    $5 = i64toi32_i32$HIGH_BITS;
    $7 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $4 = $5;
    $3 = $1;
   }
   if (!global$2) {
    if ($2) {
     __unlockfile($0)
    }
    i64toi32_i32$HIGH_BITS = $4;
    return $3;
   }
   abort();
  }
  $1 = $7;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP32[$1 + 8 >> 2] = $3;
  HEAP32[$1 + 12 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  i64toi32_i32$HIGH_BITS = 0;
  return 0;
 }
 
 function ftell($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $2 = HEAP32[$1 + 8 >> 2];
   $3 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $1 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $1 = 0
  }
  label$2 : {
   if (global$2 ? !$1 : 1) {
    $4 = __ftello($0);
    $1 = i64toi32_i32$HIGH_BITS;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $1;
    $3 = $4;
   }
   if (!global$2) {
    if (($2 | 0) > 0 ? 1 : ($2 | 0) >= 0 ? ($3 >>> 0 < 2147483648 ? 0 : 1) : 0) {
     HEAP32[__errno_location() >> 2] = 61;
     return -1;
    }
    return $3;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $3;
  HEAP32[$1 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
  return 0;
 }
 
 function setvbuf($0, $1, $2, $3) {
  HEAP8[$0 + 75 | 0] = 255;
  $2 = $2 + -1 | 0;
  label$1 : {
   if ($2 >>> 0 > 1) {
    break label$1
   }
   if (!($2 - 1)) {
    HEAP32[$0 + 48 >> 2] = 0;
    break label$1;
   }
   HEAP8[$0 + 75 | 0] = 10;
  }
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] | 64;
  return 0;
 }
 
 function rewind($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   $1 = global$2 ? $1 : HEAP32[$0 + 76 >> 2] >= 0;
   label$4 : {
    if ($1 | (global$2 | 0) == 2) {
     if (!global$2) {
      $1 = __lockfile($0)
     }
     if (global$2 ? !$2 : 1) {
      __fseeko_unlocked($0, 0, 0, 0);
      if ((global$2 | 0) == 1) {
       break label$2
      }
     }
     if (!global$2) {
      HEAP32[$0 >> 2] = HEAP32[$0 >> 2] & -33;
      if (!$1) {
       break label$4
      }
      __unlockfile($0);
      return;
     }
    }
    if (global$2 ? ($2 | 0) == 1 : 1) {
     __fseeko_unlocked($0, 0, 0, 0);
     $3 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
    if (!global$2) {
     HEAP32[$0 >> 2] = HEAP32[$0 >> 2] & -33
    }
   }
   return;
  }
  $2 = $3;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function fclose($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $2 = HEAP32[$1 + 8 >> 2];
   $4 = HEAP32[$1 + 12 >> 2];
   $5 = HEAP32[$1 + 16 >> 2];
   $6 = HEAP32[$1 + 20 >> 2];
   $3 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $7 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = 0;
   if (HEAP32[$0 + 76 >> 2] >= 0) {
    $5 = __lockfile($0)
   }
   __unlist_locked_file($0);
   $6 = HEAP32[$0 >> 2] & 1;
   $3 = !$6;
   if ($3) {
    $3 = __ofl_lock();
    $4 = HEAP32[$0 + 52 >> 2];
    if ($4) {
     HEAP32[$4 + 56 >> 2] = HEAP32[$0 + 56 >> 2]
    }
    $2 = HEAP32[$0 + 56 >> 2];
    if ($2) {
     HEAP32[$2 + 52 >> 2] = $4
    }
    $4 = HEAP32[$3 >> 2] == ($0 | 0);
    if ($4) {
     HEAP32[$3 >> 2] = $2
    }
    __ofl_unlock();
   }
  }
  label$2 : {
   if (global$2 ? !$7 : 1) {
    $1 = fflush($0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $1;
   }
   $2 = global$2 ? $2 : HEAP32[$0 + 12 >> 2];
   if (global$2 ? ($7 | 0) == 1 : 1) {
    $1 = FUNCTION_TABLE[$2]($0) | 0;
    $8 = 1;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $4 = $1;
   }
   if (!global$2) {
    $2 = HEAP32[$0 + 96 >> 2];
    if ($2) {
     dlfree($2)
    }
    $3 = $3 | $4;
    if (!$6) {
     dlfree($0);
     return $3;
    }
    if ($5) {
     __unlockfile($0)
    }
    return $3;
   }
   abort();
  }
  $1 = $8;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $3;
  HEAP32[$1 + 8 >> 2] = $2;
  HEAP32[$1 + 12 >> 2] = $4;
  HEAP32[$1 + 16 >> 2] = $5;
  HEAP32[$1 + 20 >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  return 0;
 }
 
 function vsiprintf($0, $1, $2) {
  var $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $3 = 0
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    $3 = vsniprintf($0, 2147483647, $1, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $3;
   }
   if (!global$2) {
    return $0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
  return 0;
 }
 
 function __small_vsprintf($0, $1, $2) {
  var $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $3 = 0
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    $3 = __small_vsnprintf($0, 2147483647, $1, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $3;
   }
   if (!global$2) {
    return $0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
  return 0;
 }
 
 function siprintf($0, $1, $2) {
  var $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = global$0 - 16 | 0;
   global$0 = $3;
   HEAP32[$3 + 12 >> 2] = $2;
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = vsiprintf($0, $1, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    global$0 = $3 + 16 | 0;
    return $2;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function __small_sprintf($0, $1, $2) {
  var $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = global$0 - 16 | 0;
   global$0 = $3;
   HEAP32[$3 + 12 >> 2] = $2;
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = __small_vsprintf($0, $1, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    global$0 = $3 + 16 | 0;
    return $2;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function __stdio_write($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  $3 = global$0 - 32 | 0;
  global$0 = $3;
  $4 = HEAP32[$0 + 28 >> 2];
  HEAP32[$3 + 16 >> 2] = $4;
  $5 = HEAP32[$0 + 20 >> 2];
  HEAP32[$3 + 28 >> 2] = $2;
  HEAP32[$3 + 24 >> 2] = $1;
  $1 = $5 - $4 | 0;
  HEAP32[$3 + 20 >> 2] = $1;
  $5 = $1 + $2 | 0;
  $7 = 2;
  $1 = $3 + 16 | 0;
  label$1 : {
   label$2 : {
    label$3 : {
     if (!__wasi_syscall_ret(__wasi_fd_write(HEAP32[$0 + 60 >> 2], $3 + 16 | 0, 2, $3 + 12 | 0) | 0)) {
      while (1) {
       $4 = HEAP32[$3 + 12 >> 2];
       if (($5 | 0) == ($4 | 0)) {
        break label$3
       }
       if (($4 | 0) <= -1) {
        break label$2
       }
       $6 = HEAP32[$1 + 4 >> 2];
       $8 = $4 >>> 0 > $6 >>> 0;
       $1 = $8 ? $1 + 8 | 0 : $1;
       $6 = $4 - ($8 ? $6 : 0) | 0;
       HEAP32[$1 >> 2] = $6 + HEAP32[$1 >> 2];
       HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] - $6;
       $5 = $5 - $4 | 0;
       $7 = $7 - $8 | 0;
       if (!__wasi_syscall_ret(__wasi_fd_write(HEAP32[$0 + 60 >> 2], $1 | 0, $7 | 0, $3 + 12 | 0) | 0)) {
        continue
       }
       break;
      }
     }
     HEAP32[$3 + 12 >> 2] = -1;
     if (($5 | 0) != -1) {
      break label$2
     }
    }
    $1 = HEAP32[$0 + 44 >> 2];
    HEAP32[$0 + 28 >> 2] = $1;
    HEAP32[$0 + 20 >> 2] = $1;
    HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 48 >> 2] + $1;
    $0 = $2;
    break label$1;
   }
   HEAP32[$0 + 28 >> 2] = 0;
   HEAP32[$0 + 16 >> 2] = 0;
   HEAP32[$0 + 20 >> 2] = 0;
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] | 32;
   $0 = 0;
   if (($7 | 0) == 2) {
    break label$1
   }
   $0 = $2 - HEAP32[$1 + 4 >> 2] | 0;
  }
  global$0 = $3 + 32 | 0;
  return $0 | 0;
 }
 
 function putchar($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $1 = global$2 ? $1 : HEAP32[3226];
  label$2 : {
   if (global$2 ? !$2 : 1) {
    $2 = fputc($0, $1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $2;
   }
   if (!global$2) {
    return $0 | 0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
  return 0;
 }
 
 function vfscanf($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -96;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $6 = HEAP32[$4 + 16 >> 2];
   $9 = HEAP32[$4 + 20 >> 2];
   $10 = HEAP32[$4 + 24 >> 2];
   $11 = HEAP32[$4 + 28 >> 2];
   $12 = HEAP32[$4 + 32 >> 2];
   $15 = HEAP32[$4 + 36 >> 2];
   $14 = HEAP32[$4 + 40 >> 2];
   $16 = HEAP32[$4 + 44 >> 2];
   $7 = HEAP32[$4 + 48 >> 2];
   $19 = $7;
   $5 = HEAP32[$4 + 52 >> 2];
   $18 = $5;
   $5 = HEAP32[$4 + 56 >> 2];
   $21 = $5;
   $7 = HEAP32[$4 + 60 >> 2];
   $22 = $7;
   $20 = HEAP32[$4 + 64 >> 2];
   $23 = HEAP32[$4 + 68 >> 2];
   $25 = HEAP32[$4 + 72 >> 2];
   $26 = HEAP32[$4 + 76 >> 2];
   $7 = HEAP32[$4 + 80 >> 2];
   $27 = $7;
   $5 = HEAP32[$4 + 84 >> 2];
   $28 = $5;
   $30 = HEAP32[$4 + 88 >> 2];
   $29 = HEAP32[$4 + 92 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $24 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $11 = global$0 - 304 | 0;
   global$0 = $11;
   $23 = 0;
   $30 = 0;
   if (HEAP32[$0 + 76 >> 2] >= 0) {
    $30 = __lockfile($0)
   }
   $6 = HEAPU8[$1 | 0];
   $3 = !$6;
  }
  label$2 : {
   label$6 : {
    if (!global$2) {
     if ($3) {
      break label$6
     }
     $21 = 0;
     $22 = 0;
     $23 = 0;
     $15 = $0 + 4 | 0;
    }
    label$8 : {
     while (1) {
      label$10 : {
       if (!global$2) {
        $3 = isspace($6 & 255)
       }
       label$12 : {
        if ((global$2 | 0) == 2 | $3) {
         if (!global$2) {
          while (1) {
           $6 = $1;
           $1 = $1 + 1 | 0;
           $3 = isspace(HEAPU8[$6 + 1 | 0]);
           if ($3) {
            continue
           }
           break;
          };
          __shlim($0, 0, 0);
         }
         while (1) {
          if (!global$2) {
           $1 = HEAP32[$0 + 4 >> 2];
           $3 = $1 >>> 0 < HEAPU32[$0 + 104 >> 2];
          }
          label$18 : {
           if (!global$2) {
            if ($3) {
             $3 = $1 + 1 | 0;
             HEAP32[$15 >> 2] = $3;
             $1 = HEAPU8[$1 | 0];
             break label$18;
            }
           }
           if (global$2 ? !$24 : 1) {
            $4 = __shgetc($0);
            $5 = 0;
            if ((global$2 | 0) == 1) {
             break label$2
            }
            $1 = $4;
           }
          }
          if (!global$2) {
           $1 = isspace($1);
           if ($1) {
            continue
           }
          }
          break;
         };
         if (!global$2) {
          label$25 : {
           if (!HEAP32[$0 + 104 >> 2]) {
            $1 = HEAP32[$15 >> 2];
            break label$25;
           }
           $1 = HEAP32[$15 >> 2] + -1 | 0;
           HEAP32[$15 >> 2] = $1;
          }
          $3 = HEAP32[$0 + 8 >> 2];
          $7 = $1 - $3 | 0;
          $5 = $7 >> 31;
          $19 = $7;
          $18 = $5;
          $7 = HEAP32[$0 + 124 >> 2];
          $1 = $7;
          $13 = $21;
          $5 = HEAP32[$0 + 120 >> 2];
          $17 = $5;
          $8 = $13 + $5 | 0;
          $7 = $22;
          $5 = $1;
          $4 = $7 + $5 | 0;
          $1 = $8;
          $4 = $8 >>> 0 < $17 >>> 0 ? $4 + 1 | 0 : $4;
          $13 = $4;
          $4 = $18;
          $8 = $13 + $4 | 0;
          $7 = $19;
          $17 = $1;
          $5 = $7 + $17 | 0;
          if ($5 >>> 0 < $17 >>> 0) {
           $8 = $8 + 1 | 0
          }
          $21 = $5;
          $22 = $8;
          break label$12;
         }
        }
        if (!global$2) {
         $6 = HEAPU8[$1 | 0];
         $3 = ($6 | 0) == 37;
        }
        label$28 : {
         label$29 : {
          label$30 : {
           if (!global$2) {
            if ($3) {
             $3 = HEAPU8[$1 + 1 | 0];
             $14 = ($3 | 0) == 42;
             if ($14) {
              break label$30
             }
             $14 = ($3 | 0) != 37;
             if ($14) {
              break label$29
             }
            }
            __shlim($0, 0, 0);
            $6 = (($6 | 0) == 37) + $1 | 0;
            $1 = HEAP32[$0 + 4 >> 2];
            $3 = $1 >>> 0 < HEAPU32[$0 + 104 >> 2];
           }
           label$33 : {
            if (!global$2) {
             if ($3) {
              $3 = $1 + 1 | 0;
              HEAP32[$15 >> 2] = $3;
              $1 = HEAPU8[$1 | 0];
              break label$33;
             }
            }
            if (global$2 ? ($24 | 0) == 1 : 1) {
             $4 = __shgetc($0);
             $5 = 1;
             if ((global$2 | 0) == 1) {
              break label$2
             }
             $1 = $4;
            }
           }
           if (!global$2) {
            $3 = HEAPU8[$6 | 0] != ($1 | 0);
            if ($3) {
             if (HEAP32[$0 + 104 >> 2]) {
              HEAP32[$15 >> 2] = HEAP32[$15 >> 2] + -1
             }
             $25 = 0;
             if (($1 | 0) >= 0) {
              break label$6
             }
             break label$10;
            }
            $8 = $22;
            $5 = $8;
            $4 = $21;
            $13 = $4 + 1 | 0;
            if ($13 >>> 0 < 1) {
             $5 = $5 + 1 | 0
            }
            $21 = $13;
            $22 = $5;
            break label$12;
           }
          }
          if (!global$2) {
           $6 = $1 + 2 | 0;
           $14 = 0;
           break label$28;
          }
         }
         if (!global$2) {
          label$43 : {
           $3 = !isdigit($3);
           if ($3) {
            break label$43
           }
           $3 = HEAPU8[$1 + 2 | 0] != 36;
           if ($3) {
            break label$43
           }
           $6 = $1 + 3 | 0;
           $1 = HEAPU8[$1 + 1 | 0] + -48 | 0;
           $14 = arg_n($2, $1);
           break label$28;
          }
          $6 = $1 + 1 | 0;
          $14 = HEAP32[$2 >> 2];
          $2 = $2 + 4 | 0;
         }
        }
        if (!global$2) {
         $25 = 0;
         $1 = 0;
         if (isdigit(HEAPU8[$6 | 0])) {
          while (1) {
           $1 = (HEAPU8[$6 | 0] + Math_imul($1, 10) | 0) + -48 | 0;
           $3 = HEAPU8[$6 + 1 | 0];
           $6 = $6 + 1 | 0;
           if (isdigit($3)) {
            continue
           }
           break;
          }
         }
         $3 = $6;
         $9 = HEAPU8[$3 | 0];
         if (($9 | 0) == 109) {
          $10 = 0;
          $25 = ($14 | 0) != 0;
          $9 = HEAPU8[$6 + 1 | 0];
          $16 = 0;
          $3 = $6 + 1 | 0;
         }
         $12 = ($9 & 255) + -65 | 0;
         if ($12 >>> 0 > 57) {
          break label$10
         }
         $6 = $3 + 1 | 0;
         $9 = 3;
         label$48 : {
          label$49 : {
           switch ($12 - 1 | 0) {
           case 38:
            $5 = $3 + 2 | 0;
            $3 = HEAPU8[$3 + 1 | 0] == 104;
            $6 = $3 ? $5 : $6;
            $9 = $3 ? -2 : -1;
            break label$48;
           case 42:
            $5 = $3 + 2 | 0;
            $3 = HEAPU8[$3 + 1 | 0] == 108;
            $6 = $3 ? $5 : $6;
            $9 = $3 ? 3 : 1;
            break label$48;
           case 50:
           case 56:
            $9 = 1;
            break label$48;
           case 10:
            $9 = 2;
            break label$48;
           case 0:
           case 2:
           case 6:
           case 7:
           case 8:
           case 9:
           case 11:
           case 12:
           case 13:
           case 14:
           case 15:
           case 16:
           case 18:
           case 19:
           case 20:
           case 21:
           case 23:
           case 24:
           case 26:
           case 27:
           case 28:
           case 29:
           case 30:
           case 32:
           case 41:
           case 43:
           case 47:
           case 48:
           case 52:
           case 53:
           case 55:
            break label$10;
           case 40:
            break label$48;
           default:
            break label$49;
           };
          }
          $9 = 0;
          $6 = $3;
         }
         $3 = HEAPU8[$6 | 0];
         $12 = ($3 & 47) == 3;
         $26 = $12 ? 1 : $9;
         $20 = $12 ? $3 | 32 : $3;
         $3 = ($20 | 0) == 91;
        }
        label$54 : {
         if (!global$2) {
          if ($3) {
           break label$54
          }
          label$56 : {
           $3 = ($20 | 0) != 110;
           if ($3) {
            $3 = ($20 | 0) != 99;
            if ($3) {
             break label$56
            }
            $3 = ($1 | 0) > 1;
            $1 = $3 ? $1 : 1;
            break label$54;
           }
           $5 = $22;
           store_int($14, $26, $21, $5);
           break label$12;
          }
          __shlim($0, 0, 0);
         }
         while (1) {
          if (!global$2) {
           $3 = HEAP32[$0 + 4 >> 2];
           $12 = $3 >>> 0 < HEAPU32[$0 + 104 >> 2];
          }
          label$60 : {
           if (!global$2) {
            if ($12) {
             $12 = $3 + 1 | 0;
             HEAP32[$15 >> 2] = $12;
             $4 = HEAPU8[$3 | 0];
             break label$60;
            }
           }
           if (global$2 ? ($24 | 0) == 2 : 1) {
            $4 = __shgetc($0);
            $5 = 2;
            if ((global$2 | 0) == 1) {
             break label$2
            }
           } else {
            $4 = $3
           }
          }
          $3 = $4;
          if (!global$2) {
           $3 = isspace($3);
           if ($3) {
            continue
           }
          }
          break;
         };
         if (!global$2) {
          label$67 : {
           if (!HEAP32[$0 + 104 >> 2]) {
            $3 = HEAP32[$15 >> 2];
            break label$67;
           }
           $3 = HEAP32[$15 >> 2] + -1 | 0;
           HEAP32[$15 >> 2] = $3;
          }
          $12 = HEAP32[$0 + 8 >> 2];
          $3 = $3 - $12 | 0;
          $19 = $3;
          $5 = $3 >> 31;
          $18 = $5;
          $5 = HEAP32[$0 + 120 >> 2];
          $17 = $5;
          $8 = $21;
          $7 = $5 + $8 | 0;
          $4 = HEAP32[$0 + 124 >> 2];
          $5 = $4;
          $4 = $22;
          $13 = $5 + $4 | 0;
          $5 = $7;
          $13 = $7 >>> 0 < $17 >>> 0 ? $13 + 1 | 0 : $13;
          $8 = $13;
          $13 = $18;
          $7 = $13 + $8 | 0;
          $17 = $5;
          $5 = $17 + $3 | 0;
          if ($5 >>> 0 < $17 >>> 0) {
           $7 = $7 + 1 | 0
          }
          $21 = $5;
          $22 = $7;
         }
        }
        if (!global$2) {
         $7 = $1 >> 31;
         $18 = $7;
         $19 = $1;
         __shlim($0, $1, $7);
         $9 = HEAP32[$0 + 4 >> 2];
         $3 = HEAP32[$0 + 104 >> 2];
         $12 = $9 >>> 0 < $3 >>> 0;
        }
        label$70 : {
         if (!global$2) {
          if ($12) {
           $12 = $9 + 1 | 0;
           HEAP32[$15 >> 2] = $12;
           break label$70;
          }
         }
         if (global$2 ? ($24 | 0) == 3 : 1) {
          $4 = __shgetc($0);
          $5 = 3;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $3 = $4;
         }
         if (!global$2) {
          if (($3 | 0) < 0) {
           break label$10
          }
          $3 = HEAP32[$0 + 104 >> 2];
         }
        }
        if (!global$2) {
         if ($3) {
          HEAP32[$15 >> 2] = HEAP32[$15 >> 2] + -1
         }
         $3 = $20 + -88 | 0;
         $12 = $3 >>> 0 > 32;
        }
        label$77 : {
         label$78 : {
          if (!global$2) {
           if ($12) {
            $1 = $20 + -65 | 0;
            $3 = $1 >>> 0 > 6;
            if ($3 | !(1 << $1 & 113)) {
             break label$77
            }
            break label$78;
           }
           $9 = 16;
           $3 = $3 - 1 | 0;
          }
          label$81 : {
           if (!global$2) {
            label$83 : {
             label$84 : {
              switch ($3 | 0) {
              case 16:
               $9 = 0;
               break label$83;
              case 11:
              case 28:
               $9 = 10;
               break label$83;
              case 0:
              case 1:
              case 3:
              case 4:
              case 5:
              case 6:
              case 7:
              case 9:
              case 15:
              case 17:
              case 18:
              case 19:
              case 20:
              case 21:
              case 24:
              case 25:
              case 27:
              case 29:
              case 30:
               break label$77;
              case 8:
              case 12:
              case 13:
              case 14:
               break label$78;
              case 2:
              case 10:
              case 26:
               break label$81;
              case 22:
               break label$84;
              default:
               break label$83;
              };
             }
             $9 = 8;
            }
           }
           if (global$2 ? ($24 | 0) == 4 : 1) {
            $7 = __intscan($0, $9, 0, -1, -1);
            $4 = i64toi32_i32$HIGH_BITS;
            $5 = 4;
            if ((global$2 | 0) == 1) {
             break label$2
            }
            $18 = $4;
            $19 = $7;
           }
           if (!global$2) {
            $4 = HEAP32[$0 + 120 >> 2];
            $31 = $4;
            $7 = HEAP32[$0 + 124 >> 2];
            $1 = $7;
            $3 = HEAP32[$0 + 8 >> 2];
            $4 = HEAP32[$0 + 4 >> 2] - $3 | 0;
            $7 = $4 >> 31;
            $17 = $4;
            $8 = 0 - $4 | 0;
            $4 = $7;
            $5 = $4 + (0 < $17 >>> 0) | 0;
            $5 = 0 - $5 | 0;
            $13 = $5;
            $7 = $31;
            $5 = $1;
            if (($7 | 0) == ($8 | 0) & ($5 | 0) == ($13 | 0)) {
             break label$8
            }
            if (!(!$14 | ($20 | 0) != 112)) {
             HEAP32[$14 >> 2] = $19;
             break label$77;
            }
            $7 = $18;
            store_int($14, $26, $19, $7);
            break label$77;
           }
          }
          if (!global$2) {
           label$91 : {
            if (($20 | 16) == 115) {
             memset($11 + 32 | 0, -1, 257);
             HEAP8[$11 + 32 | 0] = 0;
             $3 = ($20 | 0) != 115;
             if ($3) {
              break label$91
             }
             HEAP8[$11 + 65 | 0] = 0;
             HEAP8[$11 + 46 | 0] = 0;
             HEAP16[$11 + 42 >> 1] = 0;
             HEAP16[$11 + 44 >> 1] = 0;
             break label$91;
            }
            $9 = HEAPU8[$6 + 1 | 0];
            $3 = ($9 | 0) == 94;
            memset($11 + 32 | 0, $3, 257);
            HEAP8[$11 + 32 | 0] = 0;
            $12 = $3 ? $6 + 2 | 0 : $6 + 1 | 0;
            label$93 : {
             label$94 : {
              label$95 : {
               $6 = HEAPU8[($3 ? 2 : 1) + $6 | 0];
               if (($6 | 0) != 45) {
                if (($6 | 0) == 93) {
                 break label$95
                }
                $9 = ($9 | 0) != 94;
                $6 = $12;
                break label$93;
               }
               $9 = ($9 | 0) != 94;
               HEAP8[$11 + 78 | 0] = $9;
               break label$94;
              }
              $9 = ($9 | 0) != 94;
              HEAP8[$11 + 126 | 0] = $9;
             }
             $6 = $12 + 1 | 0;
            }
            while (1) {
             $3 = HEAPU8[$6 | 0];
             label$98 : {
              if (($3 | 0) != 45) {
               if (!$3) {
                break label$10
               }
               if (($3 | 0) != 93) {
                break label$98
               }
               break label$91;
              }
              $3 = 45;
              $29 = HEAPU8[$6 + 1 | 0];
              if (!$29 | ($29 | 0) == 93) {
               break label$98
              }
              $12 = $6 + 1 | 0;
              $6 = HEAPU8[$6 + -1 | 0];
              label$100 : {
               if ($6 >>> 0 >= $29 >>> 0) {
                $3 = $29;
                break label$100;
               }
               while (1) {
                $6 = $6 + 1 | 0;
                HEAP8[$6 + ($11 + 32 | 0) | 0] = $9;
                $3 = HEAPU8[$12 | 0];
                if ($6 >>> 0 < $3 >>> 0) {
                 continue
                }
                break;
               };
              }
              $6 = $12;
             }
             HEAP8[($3 + $11 | 0) + 33 | 0] = $9;
             $6 = $6 + 1 | 0;
             continue;
            };
           }
           $12 = ($20 | 0) == 99;
           $9 = $12 ? $1 + 1 | 0 : 31;
           $20 = ($26 | 0) != 1;
           $1 = !$20;
          }
          label$103 : {
           label$104 : {
            label$105 : {
             if ((global$2 | 0) == 2 | $1) {
              if (!global$2) {
               $3 = $14;
               if ($25) {
                $3 = dlmalloc($9 << 2);
                if (!$3) {
                 break label$103
                }
               }
               $5 = $11;
               HEAP32[$5 + 296 >> 2] = 0;
               HEAP32[$5 + 300 >> 2] = 0;
               $1 = 0;
              }
              while (1) {
               $16 = global$2 ? $16 : $3;
               label$110 : {
                while (1) {
                 if (!global$2) {
                  $3 = HEAP32[$0 + 4 >> 2];
                  $10 = $3 >>> 0 < HEAPU32[$0 + 104 >> 2];
                 }
                 label$113 : {
                  if (!global$2) {
                   if ($10) {
                    $10 = $3 + 1 | 0;
                    HEAP32[$15 >> 2] = $10;
                    $4 = HEAPU8[$3 | 0];
                    break label$113;
                   }
                  }
                  if (global$2 ? ($24 | 0) == 5 : 1) {
                   $4 = __shgetc($0);
                   $5 = 5;
                   if ((global$2 | 0) == 1) {
                    break label$2
                   }
                  } else {
                   $4 = $3
                  }
                 }
                 $3 = $4;
                 if (!global$2) {
                  $10 = !HEAPU8[($3 + $11 | 0) + 33 | 0];
                  if ($10) {
                   break label$110
                  }
                  HEAP8[$11 + 27 | 0] = $3;
                  $3 = mbrtowc($11 + 28 | 0, $11 + 27 | 0, 1, $11 + 296 | 0);
                  $10 = ($3 | 0) == -2;
                  if ($10) {
                   continue
                  }
                  $3 = ($3 | 0) == -1;
                  if ($3) {
                   break label$104
                  }
                  if ($16) {
                   $10 = HEAP32[$11 + 28 >> 2];
                   HEAP32[($1 << 2) + $16 >> 2] = $10;
                   $1 = $1 + 1 | 0;
                  }
                  $3 = !$25;
                  if ($3) {
                   continue
                  }
                  $3 = ($1 | 0) != ($9 | 0);
                  if ($3) {
                   continue
                  }
                 }
                 break;
                };
                if (!global$2) {
                 $9 = $9 << 1 | 1;
                 $3 = dlrealloc($16, $9 << 2);
                 if ($3) {
                  continue
                 }
                 break label$104;
                }
               }
               break;
              };
              if (!global$2) {
               $3 = !mbsinit($11 + 296 | 0);
               if ($3) {
                break label$104
               }
               $10 = 0;
               break label$105;
              }
             }
             if ((global$2 | 0) == 2 | $25) {
              if (!global$2) {
               $1 = 0;
               $3 = dlmalloc($9);
               $10 = !$3;
               if ($10) {
                break label$103
               }
              }
              while (1) {
               $10 = global$2 ? $10 : $3;
               while (1) {
                if (!global$2) {
                 $3 = HEAP32[$0 + 4 >> 2];
                 $16 = $3 >>> 0 < HEAPU32[$0 + 104 >> 2];
                }
                label$127 : {
                 if (!global$2) {
                  if ($16) {
                   $16 = $3 + 1 | 0;
                   HEAP32[$15 >> 2] = $16;
                   $4 = HEAPU8[$3 | 0];
                   break label$127;
                  }
                 }
                 if (global$2 ? ($24 | 0) == 6 : 1) {
                  $4 = __shgetc($0);
                  $5 = 6;
                  if ((global$2 | 0) == 1) {
                   break label$2
                  }
                 } else {
                  $4 = $3
                 }
                }
                $3 = $4;
                if (!global$2) {
                 if (!HEAPU8[($3 + $11 | 0) + 33 | 0]) {
                  $16 = 0;
                  break label$105;
                 }
                 $16 = $1 + $10 | 0;
                 HEAP8[$16 | 0] = $3;
                 $1 = $1 + 1 | 0;
                 $3 = ($9 | 0) != ($1 | 0);
                 if ($3) {
                  continue
                 }
                }
                break;
               };
               if (!global$2) {
                $16 = 0;
                $9 = $9 << 1 | 1;
                $3 = dlrealloc($10, $9);
                if ($3) {
                 continue
                }
               }
               break;
              };
              if (!global$2) {
               break label$10
              }
             }
             $1 = global$2 ? $1 : 0;
             if ((global$2 | 0) == 2 | $14) {
              while (1) {
               if (!global$2) {
                $3 = HEAP32[$0 + 4 >> 2];
                $10 = $3 >>> 0 < HEAPU32[$0 + 104 >> 2];
               }
               label$138 : {
                if (!global$2) {
                 if ($10) {
                  $10 = $3 + 1 | 0;
                  HEAP32[$15 >> 2] = $10;
                  $4 = HEAPU8[$3 | 0];
                  break label$138;
                 }
                }
                if (global$2 ? ($24 | 0) == 7 : 1) {
                 $4 = __shgetc($0);
                 $5 = 7;
                 if ((global$2 | 0) == 1) {
                  break label$2
                 }
                } else {
                 $4 = $3
                }
               }
               $3 = $4;
               if (!global$2) {
                if (HEAPU8[($3 + $11 | 0) + 33 | 0]) {
                 $10 = $1 + $14 | 0;
                 HEAP8[$10 | 0] = $3;
                 $1 = $1 + 1 | 0;
                 continue;
                } else {
                 $16 = 0;
                 $10 = $14;
                 break label$105;
                }
               }
               break;
              }
             }
             while (1) {
              if (!global$2) {
               $1 = HEAP32[$0 + 4 >> 2];
               $3 = $1 >>> 0 < HEAPU32[$0 + 104 >> 2];
              }
              label$148 : {
               if (!global$2) {
                if ($3) {
                 $3 = $1 + 1 | 0;
                 HEAP32[$15 >> 2] = $3;
                 $1 = HEAPU8[$1 | 0];
                 break label$148;
                }
               }
               if (global$2 ? ($24 | 0) == 8 : 1) {
                $4 = __shgetc($0);
                $5 = 8;
                if ((global$2 | 0) == 1) {
                 break label$2
                }
                $1 = $4;
               }
              }
              if (!global$2) {
               $1 = HEAPU8[($1 + $11 | 0) + 33 | 0];
               if ($1) {
                continue
               }
              }
              break;
             };
             if (!global$2) {
              $10 = 0;
              $16 = 0;
              $1 = 0;
             }
            }
            if (!global$2) {
             label$156 : {
              if (!HEAP32[$0 + 104 >> 2]) {
               $3 = HEAP32[$15 >> 2];
               break label$156;
              }
              $3 = HEAP32[$15 >> 2] + -1 | 0;
              HEAP32[$15 >> 2] = $3;
             }
             $7 = HEAP32[$0 + 120 >> 2];
             $17 = $7;
             $5 = HEAP32[$0 + 124 >> 2];
             $4 = $5;
             $7 = $3 - HEAP32[$0 + 8 >> 2] | 0;
             $5 = $7 >> 31;
             $13 = $7;
             $7 = $5;
             $5 = $4;
             $8 = $7 + $5 | 0;
             $4 = $13 + $17 | 0;
             if ($4 >>> 0 < $13 >>> 0) {
              $8 = $8 + 1 | 0
             }
             $27 = $4;
             $28 = $8;
             if (!($8 | $4)) {
              break label$8
             }
             $5 = $19;
             $13 = $27;
             $17 = $28;
             $8 = $18;
             if ($12 ? ($5 | 0) != ($13 | 0) | ($17 | 0) != ($8 | 0) : 0) {
              break label$8
             }
             $3 = !$25;
             label$158 : {
              if ($3) {
               break label$158
              }
              $3 = !$20;
              if ($3) {
               HEAP32[$14 >> 2] = $16;
               break label$158;
              }
              HEAP32[$14 >> 2] = $10;
             }
             if ($12) {
              break label$77
             }
             if ($16) {
              HEAP32[($1 << 2) + $16 >> 2] = 0
             }
             $3 = !$10;
             if ($3) {
              $10 = 0;
              break label$77;
             }
             HEAP8[$1 + $10 | 0] = 0;
             break label$77;
            }
           }
           if (!global$2) {
            $10 = 0;
            break label$10;
           }
          }
          if (!global$2) {
           $10 = 0;
           $16 = 0;
           break label$10;
          }
         }
         if (global$2 ? ($24 | 0) == 9 : 1) {
          __floatscan($11, $0, $26, 0);
          $5 = 9;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          $5 = HEAP32[$0 + 120 >> 2];
          $19 = $5;
          $8 = HEAP32[$0 + 124 >> 2];
          $18 = $8;
          $3 = HEAP32[$0 + 8 >> 2];
          $5 = HEAP32[$0 + 4 >> 2] - $3 | 0;
          $8 = $5 >> 31;
          $17 = $5;
          $7 = 0 - $5 | 0;
          $5 = $8;
          $4 = $5 + (0 < $17 >>> 0) | 0;
          $4 = 0 - $4 | 0;
          $8 = $19;
          $13 = $4;
          $4 = $18;
          if (($7 | 0) == ($8 | 0) & ($13 | 0) == ($4 | 0)) {
           break label$8
          }
          if (!$14 | $26 >>> 0 > 2) {
           break label$77
          }
          $8 = HEAP32[$11 + 8 >> 2];
          $19 = $8;
          $4 = HEAP32[$11 + 12 >> 2];
          $18 = $4;
          $4 = HEAP32[$11 >> 2];
          $27 = $4;
          $8 = HEAP32[$11 + 4 >> 2];
          $28 = $8;
          label$166 : {
           switch ($26 - 1 | 0) {
           default:
            $8 = $28;
            $4 = $18;
            HEAPF32[$14 >> 2] = __trunctfsf2($27, $8, $19, $4);
            break label$77;
           case 0:
            $4 = $28;
            $8 = $18;
            HEAPF64[$14 >> 3] = __trunctfdf2($27, $4, $19, $8);
            break label$77;
           case 1:
            break label$166;
           };
          }
          $4 = $14;
          HEAP32[$4 >> 2] = $27;
          $8 = $28;
          HEAP32[$4 + 4 >> 2] = $8;
          HEAP32[$4 + 8 >> 2] = $19;
          $8 = $18;
          HEAP32[$4 + 12 >> 2] = $8;
         }
        }
        if (!global$2) {
         $23 = (($14 | 0) != 0) + $23 | 0;
         $3 = HEAP32[$0 + 8 >> 2];
         $4 = HEAP32[$0 + 4 >> 2] - $3 | 0;
         $8 = $4 >> 31;
         $19 = $4;
         $18 = $8;
         $8 = HEAP32[$0 + 120 >> 2];
         $13 = $8;
         $17 = $21;
         $5 = $8 + $17 | 0;
         $4 = HEAP32[$0 + 124 >> 2];
         $8 = $4;
         $4 = $22;
         $7 = $8 + $4 | 0;
         $1 = $5;
         $7 = $5 >>> 0 < $13 >>> 0 ? $7 + 1 | 0 : $7;
         $17 = $7;
         $7 = $18;
         $5 = $7 + $17 | 0;
         $13 = $1;
         $4 = $19;
         $8 = $13 + $4 | 0;
         if ($8 >>> 0 < $13 >>> 0) {
          $5 = $5 + 1 | 0
         }
         $21 = $8;
         $22 = $5;
        }
       }
       if (!global$2) {
        $1 = $6 + 1 | 0;
        $6 = HEAPU8[$6 + 1 | 0];
        if ($6) {
         continue
        }
        break label$6;
       }
      }
      break;
     };
     $23 = global$2 ? $23 : $23 ? $23 : -1;
    }
    if (!global$2) {
     if (!$25) {
      break label$6
     }
     dlfree($10);
     dlfree($16);
    }
   }
   if (!global$2) {
    if ($30) {
     __unlockfile($0)
    }
    global$0 = $11 + 304 | 0;
    return $23;
   }
   abort();
  }
  $4 = $5;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $6;
  HEAP32[$4 + 20 >> 2] = $9;
  HEAP32[$4 + 24 >> 2] = $10;
  HEAP32[$4 + 28 >> 2] = $11;
  HEAP32[$4 + 32 >> 2] = $12;
  HEAP32[$4 + 36 >> 2] = $15;
  HEAP32[$4 + 40 >> 2] = $14;
  HEAP32[$4 + 44 >> 2] = $16;
  HEAP32[$4 + 48 >> 2] = $19;
  $5 = $18;
  HEAP32[$4 + 52 >> 2] = $5;
  HEAP32[$4 + 56 >> 2] = $21;
  $5 = $22;
  HEAP32[$4 + 60 >> 2] = $5;
  HEAP32[$4 + 64 >> 2] = $20;
  HEAP32[$4 + 68 >> 2] = $23;
  HEAP32[$4 + 72 >> 2] = $25;
  HEAP32[$4 + 76 >> 2] = $26;
  HEAP32[$4 + 80 >> 2] = $27;
  $5 = $28;
  HEAP32[$4 + 84 >> 2] = $5;
  HEAP32[$4 + 88 >> 2] = $30;
  HEAP32[$4 + 92 >> 2] = $29;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 96;
  return 0;
 }
 
 function arg_n($0, $1) {
  var $2 = 0;
  $2 = global$0 - 16 | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  $0 = (($1 << 2) - ((($1 | 0) != 0) << 2) | 0) + $0 | 0;
  HEAP32[$2 + 8 >> 2] = $0 + 4;
  return HEAP32[$0 >> 2];
 }
 
 function store_int($0, $1, $2, $3) {
  label$1 : {
   if (!$0) {
    break label$1
   }
   $1 = $1 + 2 | 0;
   if ($1 >>> 0 > 5) {
    break label$1
   }
   label$2 : {
    switch ($1 - 1 | 0) {
    default:
     HEAP8[$0 | 0] = $2;
     return;
    case 0:
     HEAP16[$0 >> 1] = $2;
     return;
    case 1:
    case 2:
     HEAP32[$0 >> 2] = $2;
     return;
    case 3:
     break label$1;
    case 4:
     break label$2;
    };
   }
   HEAP32[$0 >> 2] = $2;
   HEAP32[$0 + 4 >> 2] = $3;
  }
 }
 
 function __uflow($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $4 = HEAP32[$1 + 4 >> 2];
   $5 = HEAP32[$1 + 16 >> 2];
   $3 = HEAP32[$1 + 8 >> 2];
   $2 = HEAP32[$1 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $2 = global$0 - 16 | 0;
   global$0 = $2;
   $4 = -1;
  }
  label$2 : {
   if (global$2 ? !$6 : 1) {
    $1 = __toread($0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $1;
   }
   label$6 : {
    if (!global$2) {
     if ($3) {
      break label$6
     }
     $5 = HEAP32[$0 + 32 >> 2];
     $3 = $2 + 15 | 0;
    }
    if (global$2 ? ($6 | 0) == 1 : 1) {
     $1 = FUNCTION_TABLE[$5]($0, $3, 1) | 0;
     $7 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $0 = $1;
    }
    if (!global$2) {
     if (($0 | 0) != 1) {
      break label$6
     }
     $4 = HEAPU8[$2 + 15 | 0];
    }
   }
   if (!global$2) {
    global$0 = $2 + 16 | 0;
    return $4;
   }
   abort();
  }
  $1 = $7;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $4;
  HEAP32[$1 + 8 >> 2] = $3;
  HEAP32[$1 + 12 >> 2] = $2;
  HEAP32[$1 + 16 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
  return 0;
 }
 
 function fgets($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -32;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $6 = HEAP32[$4 + 20 >> 2];
   $7 = HEAP32[$4 + 24 >> 2];
   $8 = HEAP32[$4 + 28 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $9 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $7 = 0;
   $3 = HEAP32[$2 + 76 >> 2] >= 0;
   if ($3) {
    $7 = __lockfile($2)
   }
   $5 = $1 + -1 | 0;
   $1 = ($1 | 0) >= 2;
  }
  label$2 : {
   label$6 : {
    if ((global$2 | 0) == 2 | $1) {
     $1 = global$2 ? $1 : $0;
     label$8 : {
      while (1) {
       label$10 : {
        if (!global$2) {
         $3 = !$5;
         if ($3) {
          break label$10
         }
         $3 = HEAP32[$2 + 4 >> 2];
         $6 = HEAP32[$2 + 8 >> 2] - $3 | 0;
         $8 = memchr($3, 10, $6);
         label$12 : {
          if ($8) {
           $6 = HEAP32[$2 + 4 >> 2];
           $3 = ($8 - $6 | 0) + 1 | 0;
           break label$12;
          }
          $6 = HEAP32[$2 + 4 >> 2];
          $3 = HEAP32[$2 + 8 >> 2] - $6 | 0;
         }
         $3 = $3 >>> 0 < $5 >>> 0 ? $3 : $5;
         memcpy($1, $6, $3);
         $6 = HEAP32[$2 + 4 >> 2] + $3 | 0;
         HEAP32[$2 + 4 >> 2] = $6;
         $1 = $1 + $3 | 0;
         if ($8) {
          break label$10
         }
         $5 = $5 - $3 | 0;
         $3 = !$5;
         if ($3) {
          break label$10
         }
         $3 = $6 >>> 0 < HEAPU32[$2 + 8 >> 2];
        }
        label$14 : {
         if (!global$2) {
          if ($3) {
           HEAP32[$2 + 4 >> 2] = $6 + 1;
           $3 = HEAPU8[$6 | 0];
           break label$14;
          }
         }
         if (global$2 ? !$9 : 1) {
          $4 = __uflow($2);
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $3 = $4;
         }
         if (!global$2) {
          $6 = ($3 | 0) > -1;
          if ($6) {
           break label$14
          }
          $3 = 0;
          $5 = ($0 | 0) == ($1 | 0);
          if ($5) {
           break label$8
          }
          $5 = !(HEAPU8[$2 | 0] & 16);
          if ($5) {
           break label$8
          }
          break label$10;
         }
        }
        if (!global$2) {
         HEAP8[$1 | 0] = $3;
         $1 = $1 + 1 | 0;
         $5 = $5 + -1 | 0;
         $3 = ($3 & 255) != 10;
         if ($3) {
          continue
         }
        }
       }
       break;
      };
      if (!global$2) {
       if (!$0) {
        $3 = 0;
        break label$8;
       }
       HEAP8[$1 | 0] = 0;
       $3 = $0;
      }
     }
     if (!global$2) {
      if (!$7) {
       break label$6
      }
      __unlockfile($2);
      break label$6;
     }
    }
    if (!global$2) {
     $1 = HEAPU8[$2 + 74 | 0];
     $3 = $1 + -1 | 0;
     HEAP8[$2 + 74 | 0] = $1 | $3;
     if ($7) {
      __unlockfile($2)
     }
     $3 = 0;
     if ($5) {
      break label$6
     }
     HEAP8[$0 | 0] = 0;
     return $0;
    }
   }
   if (!global$2) {
    return $3
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  HEAP32[$4 + 20 >> 2] = $6;
  HEAP32[$4 + 24 >> 2] = $7;
  HEAP32[$4 + 28 >> 2] = $8;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 32;
  return 0;
 }
 
 function fflush($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $3 = HEAP32[$1 + 8 >> 2];
   $4 = HEAP32[$1 + 12 >> 2];
   $2 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   label$4 : {
    if ((global$2 | 0) == 2 | $0) {
     $2 = global$2 ? $2 : HEAP32[$0 + 76 >> 2] <= -1;
     if ($2 | (global$2 | 0) == 2) {
      if (global$2 ? !$5 : 1) {
       $1 = __fflush_unlocked($0);
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $0 = $1;
      }
      if (!global$2) {
       return $0 | 0
      }
     }
     if (!global$2) {
      $3 = __lockfile($0)
     }
     if (global$2 ? ($5 | 0) == 1 : 1) {
      $1 = __fflush_unlocked($0);
      $6 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $2 = $1;
     }
     if (!global$2) {
      if (!$3) {
       break label$4
      }
      __unlockfile($0);
      return $2 | 0;
     }
    }
    if (!global$2) {
     $2 = 0;
     $0 = HEAP32[5370];
    }
    if ((global$2 | 0) == 2 | $0) {
     $0 = global$2 ? $0 : HEAP32[5370];
     if (global$2 ? ($5 | 0) == 2 : 1) {
      $1 = fflush($0);
      $6 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $2 = $1;
     }
    }
    if (!global$2) {
     $0 = HEAP32[__ofl_lock() >> 2]
    }
    if ((global$2 | 0) == 2 | $0) {
     while (1) {
      if (!global$2) {
       $3 = 0;
       if (HEAP32[$0 + 76 >> 2] >= 0) {
        $3 = __lockfile($0)
       }
       $4 = HEAPU32[$0 + 20 >> 2] > HEAPU32[$0 + 28 >> 2];
      }
      if ((global$2 | 0) == 2 | $4) {
       $7 = $2;
       if (global$2 ? ($5 | 0) == 3 : 1) {
        $1 = __fflush_unlocked($0);
        $6 = 3;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $4 = $1;
       }
       $2 = global$2 ? $7 : $2 | $4;
      }
      if (!global$2) {
       if ($3) {
        __unlockfile($0)
       }
       $0 = HEAP32[$0 + 56 >> 2];
       if ($0) {
        continue
       }
      }
      break;
     }
    }
    if (!global$2) {
     __ofl_unlock()
    }
   }
   if (!global$2) {
    return $2 | 0
   }
   abort();
  }
  $1 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP32[$1 + 8 >> 2] = $3;
  HEAP32[$1 + 12 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function __fflush_unlocked($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $5 = HEAP32[$1 + 8 >> 2];
   $3 = HEAP32[$1 + 12 >> 2];
   $6 = $3;
   $4 = HEAP32[$1 + 16 >> 2];
   $3 = $4;
   $7 = HEAP32[$1 + 20 >> 2];
   $2 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = HEAP32[$0 + 28 >> 2];
   $2 = HEAPU32[$0 + 20 >> 2] <= $5 >>> 0;
  }
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($2) {
      break label$5
     }
     $2 = HEAP32[$0 + 36 >> 2];
    }
    if (global$2 ? !$8 : 1) {
     $1 = FUNCTION_TABLE[$2]($0, 0, 0) | 0;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $2 = $1;
    }
    if (!global$2) {
     $2 = HEAP32[$0 + 20 >> 2];
     if ($2) {
      break label$5
     }
     return -1;
    }
   }
   if (global$2) {
    $4 = $7
   } else {
    $2 = HEAP32[$0 + 4 >> 2];
    $5 = HEAP32[$0 + 8 >> 2];
    $4 = $2 >>> 0 < $5 >>> 0;
   }
   if ($4 | (global$2 | 0) == 2) {
    if (!global$2) {
     $3 = $2 - $5 | 0;
     $4 = $3 >> 31;
     $6 = $3;
     $3 = $4;
     $2 = HEAP32[$0 + 40 >> 2];
    }
    if (global$2 ? ($8 | 0) == 1 : 1) {
     $4 = $3;
     FUNCTION_TABLE[$2]($0, $6, $4, 1) | 0;
     $9 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    HEAP32[$0 + 28 >> 2] = 0;
    HEAP32[$0 + 16 >> 2] = 0;
    HEAP32[$0 + 20 >> 2] = 0;
    HEAP32[$0 + 4 >> 2] = 0;
    HEAP32[$0 + 8 >> 2] = 0;
    return 0;
   }
   abort();
  }
  $1 = $9;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP32[$1 + 8 >> 2] = $5;
  HEAP32[$1 + 12 >> 2] = $6;
  HEAP32[$1 + 16 >> 2] = $3;
  HEAP32[$1 + 20 >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  return 0;
 }
 
 function fgetc($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $3 = HEAP32[$2 + 8 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $1 = global$2 ? $1 : HEAP32[$0 + 76 >> 2] >= 0;
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($1) {
      $1 = __lockfile($0);
      if ($1) {
       break label$5
      }
     }
     $1 = HEAP32[$0 + 4 >> 2];
     $3 = $1 >>> 0 < HEAPU32[$0 + 8 >> 2];
     if ($3) {
      HEAP32[$0 + 4 >> 2] = $1 + 1;
      return HEAPU8[$1 | 0];
     }
    }
    if (global$2 ? !$4 : 1) {
     $2 = __uflow($0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $0 = $2;
    }
    if (!global$2) {
     return $0
    }
   }
   if (!global$2) {
    $1 = HEAP32[$0 + 4 >> 2];
    $3 = $1 >>> 0 < HEAPU32[$0 + 8 >> 2];
   }
   label$12 : {
    if (!global$2) {
     if ($3) {
      HEAP32[$0 + 4 >> 2] = $1 + 1;
      $2 = HEAPU8[$1 | 0];
      break label$12;
     }
    }
    if (global$2 ? ($4 | 0) == 1 : 1) {
     $2 = __uflow($0);
     $5 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    } else {
     $2 = $1
    }
   }
   $1 = $2;
   if (!global$2) {
    __unlockfile($0);
    return $1;
   }
   abort();
  }
  $2 = $5;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 8 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
  return 0;
 }
 
 function fiprintf($0, $1, $2) {
  var $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = global$0 - 16 | 0;
   global$0 = $3;
   HEAP32[$3 + 12 >> 2] = $2;
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = vfiprintf($0, $1, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    global$0 = $3 + 16 | 0;
    return $2;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function __small_fprintf($0, $1, $2) {
  var $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = global$0 - 16 | 0;
   global$0 = $3;
   HEAP32[$3 + 12 >> 2] = $2;
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = __small_vfprintf($0, $1, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    global$0 = $3 + 16 | 0;
    return $2;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function fopen($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $2 = global$0 - 16 | 0;
  global$0 = $2;
  label$1 : {
   label$2 : {
    if (!strchr(12908, HEAP8[$1 | 0])) {
     HEAP32[__errno_location() >> 2] = 28;
     break label$2;
    }
    $4 = __fmodeflags($1);
    HEAP32[$2 >> 2] = 438;
    $0 = __syscall_ret(__syscall5($0 | 0, $4 | 32768, $2 | 0) | 0);
    if (($0 | 0) < 0) {
     break label$1
    }
    $3 = __fdopen($0, $1);
    if ($3) {
     break label$1
    }
    __wasi_fd_close($0 | 0) | 0;
   }
   $3 = 0;
  }
  global$0 = $2 + 16 | 0;
  return $3;
 }
 
 function putc($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  $2 = global$2 ? $2 : HEAP32[$1 + 76 >> 2] >= 0;
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($2) {
      $2 = __lockfile($1);
      if ($2) {
       break label$5
      }
     }
     label$8 : {
      $4 = $0 & 255;
      $2 = ($4 | 0) == HEAP8[$1 + 75 | 0];
      if ($2) {
       break label$8
      }
      $2 = HEAP32[$1 + 20 >> 2];
      if ($2 >>> 0 >= HEAPU32[$1 + 16 >> 2]) {
       break label$8
      }
      HEAP32[$1 + 20 >> 2] = $2 + 1;
      HEAP8[$2 | 0] = $0;
      return $4;
     }
    }
    if (global$2 ? !$5 : 1) {
     $3 = __overflow($1, $0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $0 = $3;
    }
    if (!global$2) {
     return $0
    }
   }
   if (!global$2) {
    $4 = $0 & 255;
    $2 = ($4 | 0) == HEAP8[$1 + 75 | 0];
   }
   label$12 : {
    if (!global$2) {
     label$14 : {
      if ($2) {
       break label$14
      }
      $2 = HEAP32[$1 + 20 >> 2];
      if ($2 >>> 0 >= HEAPU32[$1 + 16 >> 2]) {
       break label$14
      }
      HEAP32[$1 + 20 >> 2] = $2 + 1;
      HEAP8[$2 | 0] = $0;
      break label$12;
     }
    }
    if (global$2 ? ($5 | 0) == 1 : 1) {
     $3 = __overflow($1, $0);
     $6 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $4 = $3;
    }
   }
   if (!global$2) {
    __unlockfile($1);
    return $4;
   }
   abort();
  }
  $3 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function __toread($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $1 = HEAPU8[$0 + 74 | 0];
   $2 = $1 + -1 | 0;
   HEAP8[$0 + 74 | 0] = $1 | $2;
   $1 = HEAPU32[$0 + 20 >> 2] > HEAPU32[$0 + 28 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2 | $1) {
    $1 = global$2 ? $1 : HEAP32[$0 + 36 >> 2];
    if (global$2 ? !$3 : 1) {
     FUNCTION_TABLE[$1]($0, 0, 0) | 0;
     if ((global$2 | 0) == 1) {
      break label$2
     }
    }
   }
   if (!global$2) {
    HEAP32[$0 + 28 >> 2] = 0;
    HEAP32[$0 + 16 >> 2] = 0;
    HEAP32[$0 + 20 >> 2] = 0;
    $1 = HEAP32[$0 >> 2];
    if ($1 & 4) {
     HEAP32[$0 >> 2] = $1 | 32;
     return -1;
    }
    $2 = HEAP32[$0 + 44 >> 2] + HEAP32[$0 + 48 >> 2] | 0;
    HEAP32[$0 + 8 >> 2] = $2;
    HEAP32[$0 + 4 >> 2] = $2;
    return $1 << 27 >> 31;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
  return 0;
 }
 
 function __ofl_lock() {
  __lock(23880);
  return 23888;
 }
 
 function __ofl_unlock() {
  __unlock(23880);
 }
 
 function dummy($0) {
  return $0;
 }
 
 function __stdio_close($0) {
  $0 = $0 | 0;
  return __wasi_fd_close(dummy(HEAP32[$0 + 60 >> 2]) | 0) | 0;
 }
 
 function __string_read($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0;
  $4 = HEAP32[$0 + 84 >> 2];
  $3 = $2 + 256 | 0;
  $5 = memchr($4, 0, $3);
  $3 = $5 ? $5 - $4 | 0 : $3;
  $5 = $3 >>> 0 < $2 >>> 0;
  $2 = $5 ? $3 : $2;
  memcpy($1, $4, $2);
  $3 = $3 + $4 | 0;
  HEAP32[$0 + 84 >> 2] = $3;
  HEAP32[$0 + 8 >> 2] = $3;
  HEAP32[$0 + 4 >> 2] = $2 + $4;
  return $2;
 }
 
 function vsscanf($0, $1, $2) {
  var $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = global$0 - 144 | 0;
   global$0 = $3;
   $3 = memset($3, 0, 144);
   HEAP32[$3 + 76 >> 2] = -1;
   HEAP32[$3 + 44 >> 2] = $0;
   HEAP32[$3 + 32 >> 2] = 249;
   HEAP32[$3 + 84 >> 2] = $0;
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = vfscanf($3, $1, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $4;
   }
   if (!global$2) {
    global$0 = $3 + 144 | 0;
    return $0;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function do_read($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  return __string_read($0, $1, $2) | 0;
 }
 
 function sscanf($0, $1, $2) {
  var $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = global$0 - 16 | 0;
   global$0 = $3;
   HEAP32[$3 + 12 >> 2] = $2;
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = vsscanf($0, $1, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $2 = $4;
   }
   if (!global$2) {
    global$0 = $3 + 16 | 0;
    return $2;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function __ofl_add($0) {
  var $1 = 0, $2 = 0;
  $1 = __ofl_lock();
  HEAP32[$0 + 56 >> 2] = HEAP32[$1 >> 2];
  $2 = HEAP32[$1 >> 2];
  if ($2) {
   HEAP32[$2 + 52 >> 2] = $0
  }
  HEAP32[$1 >> 2] = $0;
  __ofl_unlock();
  return $0;
 }
 
 function rename($0, $1) {
  return __syscall_ret(__syscall38($0 | 0, $1 | 0) | 0);
 }
 
 function ungetc($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $3 = HEAP32[$2 + 8 >> 2];
   $5 = HEAP32[$2 + 12 >> 2];
   $6 = HEAP32[$2 + 16 >> 2];
   $2 = HEAP32[$2 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = -1;
   $3 = ($0 | 0) == -1;
  }
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($3) {
      break label$5
     }
     $6 = 0;
     if (HEAP32[$1 + 76 >> 2] >= 0) {
      $6 = __lockfile($1)
     }
     $3 = HEAP32[$1 + 4 >> 2];
     $2 = !$3;
    }
    label$8 : {
     label$9 : {
      if ((global$2 | 0) == 2 | $2) {
       if (global$2 ? !$4 : 1) {
        $4 = __toread($1);
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $3 = $4;
       }
       if (!global$2) {
        $3 = HEAP32[$1 + 4 >> 2];
        if (!$3) {
         break label$9
        }
       }
      }
      if ($3 >>> 0 > HEAP32[$1 + 44 >> 2] + -8 >>> 0 ? !global$2 : 0) {
       break label$8
      }
     }
     if (!global$2) {
      if (!$6) {
       break label$5
      }
      __unlockfile($1);
      return -1;
     }
    }
    if (!global$2) {
     $5 = $3 + -1 | 0;
     HEAP32[$1 + 4 >> 2] = $5;
     HEAP8[$5 | 0] = $0;
     HEAP32[$1 >> 2] = HEAP32[$1 >> 2] & -17;
     if ($6) {
      __unlockfile($1)
     }
     $5 = $0;
    }
   }
   if (!global$2) {
    return $5
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $3;
  HEAP32[$4 + 12 >> 2] = $5;
  HEAP32[$4 + 16 >> 2] = $6;
  HEAP32[$4 + 20 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  return 0;
 }
 
 function atol($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  while (1) {
   $1 = $0;
   $0 = $1 + 1 | 0;
   if (isspace(HEAP8[$1 | 0])) {
    continue
   }
   break;
  };
  $2 = HEAP8[$1 | 0];
  $4 = $2 + -43 | 0;
  label$2 : {
   if ($4 >>> 0 > 2) {
    break label$2
   }
   label$4 : {
    switch ($4 - 1 | 0) {
    case 1:
     $5 = 1;
     break;
    case 0:
     break label$2;
    default:
     break label$4;
    };
   }
   $2 = HEAP8[$0 | 0];
   $1 = $0;
   $6 = $5;
  }
  if (isdigit($2)) {
   while (1) {
    $3 = (Math_imul($3, 10) - HEAP8[$1 | 0] | 0) + 48 | 0;
    $0 = HEAP8[$1 + 1 | 0];
    $1 = $1 + 1 | 0;
    if (isdigit($0)) {
     continue
    }
    break;
   }
  }
  return $6 ? $3 : 0 - $3 | 0;
 }
 
 function strtox($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0, $7 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $5 = HEAP32[$5 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = global$0 - 144 | 0;
   global$0 = $5;
   HEAP32[$5 + 44 >> 2] = $0;
   HEAP32[$5 + 4 >> 2] = $0;
   HEAP32[$5 >> 2] = 0;
   HEAP32[$5 + 76 >> 2] = -1;
   HEAP32[$5 + 8 >> 2] = ($0 | 0) < 0 ? -1 : $0 + 2147483647 | 0;
   __shlim($5, 0, 0);
  }
  label$2 : {
   if (global$2 ? !$6 : 1) {
    $6 = __intscan($5, $2, 1, $3, $4);
    $7 = i64toi32_i32$HIGH_BITS;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $4 = $7;
    $3 = $6;
   }
   if (!global$2) {
    if ($1) {
     HEAP32[$1 >> 2] = ((HEAP32[$5 + 4 >> 2] + HEAP32[$5 + 120 >> 2] | 0) - HEAP32[$5 + 8 >> 2] | 0) + $0
    }
    global$0 = $5 + 144 | 0;
    i64toi32_i32$HIGH_BITS = $4;
    return $3;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $4;
  HEAP32[$6 + 20 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  i64toi32_i32$HIGH_BITS = 0;
  return 0;
 }
 
 function strtoul($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $5 = HEAP32[$3 + 16 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $3 = 0
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    $6 = strtox($0, $1, $2, -1, 0);
    $3 = i64toi32_i32$HIGH_BITS;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $4 = $6;
   }
   if (!global$2) {
    return $4
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[$3 + 16 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
  return 0;
 }
 
 function strtol($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $4 = HEAP32[$3 + 12 >> 2];
   $5 = HEAP32[$3 + 16 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $3 = 0
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    $6 = strtox($0, $1, $2, -2147483648, 0);
    $3 = i64toi32_i32$HIGH_BITS;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $4 = $6;
   }
   if (!global$2) {
    return $4
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[$3 + 12 >> 2] = $4;
  HEAP32[$3 + 16 >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
  return 0;
 }
 
 function atoi($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  while (1) {
   $1 = $0;
   $0 = $1 + 1 | 0;
   if (isspace(HEAP8[$1 | 0])) {
    continue
   }
   break;
  };
  $2 = HEAP8[$1 | 0];
  $4 = $2 + -43 | 0;
  label$2 : {
   if ($4 >>> 0 > 2) {
    break label$2
   }
   label$4 : {
    switch ($4 - 1 | 0) {
    case 1:
     $5 = 1;
     break;
    case 0:
     break label$2;
    default:
     break label$4;
    };
   }
   $2 = HEAP8[$0 | 0];
   $1 = $0;
   $6 = $5;
  }
  if (isdigit($2)) {
   while (1) {
    $3 = (Math_imul($3, 10) - HEAP8[$1 | 0] | 0) + 48 | 0;
    $0 = HEAP8[$1 + 1 | 0];
    $1 = $1 + 1 | 0;
    if (isdigit($0)) {
     continue
    }
    break;
   }
  }
  return ($6 ? $3 : 0 - $3 | 0) | 0;
 }
 
 function atof($0) {
  var $1 = 0, $2 = 0, $3 = 0.0, $4 = 0.0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $2 = HEAP32[$1 + 8 >> 2];
   wasm2js_scratch_store_i32(0, HEAP32[$1 + 4 >> 2]);
   wasm2js_scratch_store_i32(1, $2 | 0);
   $3 = +wasm2js_scratch_load_f64();
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $1 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $1 = 0
  }
  label$2 : {
   if (global$2 ? !$1 : 1) {
    $4 = strtod($0, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $4;
   }
   if (!global$2) {
    return $3
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  wasm2js_scratch_store_f64(+$3);
  $2 = wasm2js_scratch_load_i32(1) | 0;
  HEAP32[$1 + 4 >> 2] = wasm2js_scratch_load_i32(0);
  HEAP32[$1 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
  return 0.0;
 }
 
 function strtox_1($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -48;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $7 = HEAP32[$4 + 16 >> 2];
   $8 = HEAP32[$4 + 20 >> 2];
   $5 = HEAP32[$4 + 24 >> 2];
   $10 = $5;
   $6 = HEAP32[$4 + 28 >> 2];
   $11 = $6;
   $6 = HEAP32[$4 + 32 >> 2];
   $12 = $6;
   $5 = HEAP32[$4 + 36 >> 2];
   $13 = $5;
   $5 = HEAP32[$4 + 40 >> 2];
   $6 = HEAP32[$4 + 44 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $9 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $7 = global$0 - 160 | 0;
   global$0 = $7;
   memset($7 + 16 | 0, 0, 144);
   HEAP32[$7 + 92 >> 2] = -1;
   HEAP32[$7 + 60 >> 2] = $1;
   HEAP32[$7 + 24 >> 2] = -1;
   HEAP32[$7 + 20 >> 2] = $1;
   __shlim($7 + 16 | 0, 0, 0);
   $8 = $7 + 16 | 0;
  }
  label$2 : {
   if (global$2 ? !$9 : 1) {
    __floatscan($7, $8, $3, 1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    $4 = $7;
    $6 = HEAP32[$4 + 8 >> 2];
    $10 = $6;
    $5 = HEAP32[$4 + 12 >> 2];
    $11 = $5;
    $5 = HEAP32[$4 >> 2];
    $12 = $5;
    $6 = HEAP32[$4 + 4 >> 2];
    $13 = $6;
    if ($2) {
     $6 = HEAP32[$7 + 136 >> 2];
     $3 = $6;
     $5 = HEAP32[$4 + 140 >> 2];
     $8 = $5;
     $6 = HEAP32[$4 + 20 >> 2] - HEAP32[$4 + 24 >> 2] | 0;
     $5 = $6 >> 31;
     $9 = $6;
     $6 = $5;
     $14 = $2;
     $5 = $8;
     $2 = $5 + $6 | 0;
     $4 = $3;
     $5 = $9 + $4 | 0;
     if ($5 >>> 0 < $9 >>> 0) {
      $2 = $2 + 1 | 0
     }
     HEAP32[$14 >> 2] = $2 | $5 ? $5 + $1 | 0 : $1;
    }
    $4 = $0;
    HEAP32[$4 >> 2] = $12;
    $2 = $13;
    HEAP32[$4 + 4 >> 2] = $2;
    HEAP32[$4 + 8 >> 2] = $10;
    $2 = $11;
    HEAP32[$4 + 12 >> 2] = $2;
    global$0 = $7 + 160 | 0;
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $7;
  HEAP32[$4 + 20 >> 2] = $8;
  HEAP32[$4 + 24 >> 2] = $10;
  $2 = $11;
  HEAP32[$4 + 28 >> 2] = $2;
  HEAP32[$4 + 32 >> 2] = $12;
  $2 = $13;
  HEAP32[$4 + 36 >> 2] = $2;
  HEAP32[$4 + 40 >> 2] = $5;
  $2 = $6;
  HEAP32[$4 + 44 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 48;
 }
 
 function strtod($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0.0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $3 = HEAP32[$2 + 8 >> 2];
   $1 = HEAP32[$2 + 16 >> 2];
   $4 = HEAP32[$2 + 12 >> 2];
   wasm2js_scratch_store_i32(0, $4 | 0);
   wasm2js_scratch_store_i32(1, $1 | 0);
   $5 = +wasm2js_scratch_load_f64();
   $1 = HEAP32[$2 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = global$0 - 16 | 0;
   global$0 = $3;
  }
  label$2 : {
   if (global$2 ? !$6 : 1) {
    strtox_1($3, $0, $1, 1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    $1 = HEAP32[$3 >> 2];
    $2 = $1;
    $1 = HEAP32[$3 + 12 >> 2];
    $0 = $1;
    $4 = HEAP32[$3 + 4 >> 2];
    $1 = $4;
    $4 = HEAP32[$3 + 8 >> 2];
    $6 = $4;
    $4 = $0;
    $5 = __trunctfdf2($2, $1, $6, $4);
    global$0 = $3 + 16 | 0;
    return $5;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 8 >> 2] = $3;
  wasm2js_scratch_store_f64(+$5);
  $4 = wasm2js_scratch_load_i32(1) | 0;
  $0 = wasm2js_scratch_load_i32(0) | 0;
  HEAP32[$2 + 12 >> 2] = $0;
  HEAP32[$2 + 16 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
  return 0.0;
 }
 
 function __shlim($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  $3 = $0;
  HEAP32[$3 + 112 >> 2] = $1;
  HEAP32[$3 + 116 >> 2] = $2;
  $5 = HEAP32[$3 + 8 >> 2];
  $6 = HEAP32[$3 + 4 >> 2];
  $3 = $5 - $6 | 0;
  $4 = $3 >> 31;
  $7 = $3;
  $8 = $4;
  $3 = $0;
  HEAP32[$3 + 120 >> 2] = $7;
  HEAP32[$3 + 124 >> 2] = $4;
  $4 = $2;
  label$1 : {
   if (!($1 | $4)) {
    break label$1
   }
   $4 = $8;
   $3 = $2;
   if (($4 | 0) < ($3 | 0) ? 1 : ($4 | 0) <= ($3 | 0) ? ($7 >>> 0 > $1 >>> 0 ? 0 : 1) : 0) {
    break label$1
   }
   HEAP32[$0 + 104 >> 2] = $1 + $6;
   return;
  }
  HEAP32[$0 + 104 >> 2] = $5;
 }
 
 function __shgetc($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $8 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$8 >> 2];
   $6 = HEAP32[$8 + 4 >> 2];
   $3 = $8;
   $1 = HEAP32[$3 + 8 >> 2];
   $7 = $1;
   $2 = HEAP32[$3 + 12 >> 2];
   $4 = $2;
   $9 = HEAP32[$3 + 16 >> 2];
   $8 = HEAP32[$3 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $1 = HEAP32[$0 + 116 >> 2];
   $4 = $1;
   $2 = HEAP32[$0 + 112 >> 2];
   $7 = $2;
   $6 = !!($1 | $2);
  }
  label$2 : {
   label$5 : {
    label$6 : {
     if (!global$2) {
      if ($6) {
       $1 = HEAP32[$0 + 120 >> 2];
       $3 = $1;
       $2 = HEAP32[$0 + 124 >> 2];
       $1 = $4;
       if (($2 | 0) > ($1 | 0) ? 1 : ($2 | 0) >= ($1 | 0) ? ($3 >>> 0 < $7 >>> 0 ? 0 : 1) : 0) {
        break label$6
       }
      }
     }
     if (global$2 ? !$5 : 1) {
      $5 = __uflow($0);
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $9 = $5;
     }
     if (($9 | 0) > -1 ? !global$2 : 0) {
      break label$5
     }
    }
    if (!global$2) {
     HEAP32[$0 + 104 >> 2] = 0;
     return -1;
    }
   }
   if (!global$2) {
    $8 = HEAP32[$0 + 8 >> 2];
    $2 = HEAP32[$0 + 116 >> 2];
    $4 = $2;
    label$12 : {
     label$13 : {
      $3 = HEAP32[$0 + 112 >> 2];
      $7 = $3;
      if (!($2 | $3)) {
       break label$13
      }
      $2 = HEAP32[$0 + 120 >> 2];
      $6 = $2 ^ -1;
      $3 = HEAP32[$0 + 124 >> 2];
      $2 = $3 ^ -1;
      $5 = $2 + $4 | 0;
      $1 = $7;
      $3 = $6;
      $4 = $1 + $3 | 0;
      if ($4 >>> 0 < $1 >>> 0) {
       $5 = $5 + 1 | 0
      }
      $7 = $4;
      $4 = $5;
      $6 = HEAP32[$0 + 4 >> 2];
      $3 = $8 - $6 | 0;
      $5 = $3 >> 31;
      $2 = $7;
      $1 = $3;
      $3 = $5;
      if (($4 | 0) > ($3 | 0) ? 1 : ($4 | 0) >= ($3 | 0) ? ($2 >>> 0 < $1 >>> 0 ? 0 : 1) : 0) {
       break label$13
      }
      HEAP32[$0 + 104 >> 2] = $6 + $7;
      break label$12;
     }
     HEAP32[$0 + 104 >> 2] = $8;
    }
    label$14 : {
     if (!$8) {
      $6 = HEAP32[$0 + 4 >> 2];
      break label$14;
     }
     $7 = $0;
     $2 = HEAP32[$0 + 120 >> 2];
     $1 = $2;
     $5 = HEAP32[$0 + 124 >> 2];
     $4 = $5;
     $6 = HEAP32[$0 + 4 >> 2];
     $2 = ($8 - $6 | 0) + 1 | 0;
     $5 = $2 >> 31;
     $3 = $2;
     $2 = $5;
     $5 = $4;
     $4 = $2 + $5 | 0;
     $0 = $1 + $3 | 0;
     if ($0 >>> 0 < $3 >>> 0) {
      $4 = $4 + 1 | 0
     }
     $1 = $7;
     HEAP32[$1 + 120 >> 2] = $0;
     HEAP32[$1 + 124 >> 2] = $4;
    }
    $0 = $6 + -1 | 0;
    if (HEAPU8[$0 | 0] != ($9 | 0)) {
     HEAP8[$0 | 0] = $9
    }
    return $9;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $6;
  $1 = $5;
  HEAP32[$1 + 8 >> 2] = $7;
  HEAP32[$1 + 12 >> 2] = $4;
  HEAP32[$1 + 16 >> 2] = $9;
  HEAP32[$1 + 20 >> 2] = $8;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  return 0;
 }
 
 function __intscan($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -80;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $11 = HEAP32[$5 + 12 >> 2];
   $3 = $11;
   $7 = HEAP32[$5 + 16 >> 2];
   $4 = $7;
   $6 = HEAP32[$5 + 20 >> 2];
   $8 = HEAP32[$5 + 24 >> 2];
   $7 = HEAP32[$5 + 28 >> 2];
   $13 = $7;
   $11 = HEAP32[$5 + 32 >> 2];
   $12 = $11;
   $15 = HEAP32[$5 + 36 >> 2];
   $11 = HEAP32[$5 + 40 >> 2];
   $16 = $11;
   $7 = HEAP32[$5 + 44 >> 2];
   $20 = $7;
   $7 = HEAP32[$5 + 48 >> 2];
   $17 = $7;
   $11 = HEAP32[$5 + 52 >> 2];
   $19 = $11;
   $21 = HEAP32[$5 + 56 >> 2];
   $22 = HEAP32[$5 + 60 >> 2];
   $23 = HEAP32[$5 + 64 >> 2];
   $11 = HEAP32[$5 + 68 >> 2];
   $24 = $11;
   $7 = HEAP32[$5 + 72 >> 2];
   $25 = $7;
   $26 = HEAP32[$5 + 76 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $18 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $23 = global$0 - 16 | 0;
   global$0 = $23;
   $6 = $1 >>> 0 <= 36;
  }
  label$2 : {
   label$4 : {
    label$5 : {
     label$6 : {
      label$7 : {
       label$8 : {
        label$9 : {
         if ((global$2 | 0) == 2 | $6) {
          while (1) {
           if (!global$2) {
            $6 = HEAP32[$0 + 4 >> 2];
            $8 = $6 >>> 0 < HEAPU32[$0 + 104 >> 2];
           }
           label$15 : {
            if (!global$2) {
             if ($8) {
              $8 = $6 + 1 | 0;
              HEAP32[$0 + 4 >> 2] = $8;
              $5 = HEAPU8[$6 | 0];
              break label$15;
             }
            }
            if (global$2 ? !$18 : 1) {
             $5 = __shgetc($0);
             if ((global$2 | 0) == 1) {
              break label$2
             }
            } else {
             $5 = $6
            }
           }
           $6 = $5;
           if (!global$2) {
            $8 = isspace($6);
            if ($8) {
             continue
            }
           }
           break;
          };
          if (!global$2) {
           $21 = 0;
           $15 = $6 + -43 | 0;
           $8 = $15 >>> 0 > 2;
          }
          label$22 : {
           if (!global$2) {
            if ($8) {
             break label$22
            }
            $8 = !($15 - 1);
            if ($8) {
             break label$22
            }
            $21 = ($6 | 0) == 45 ? -1 : 0;
            $6 = HEAP32[$0 + 4 >> 2];
            $8 = $6 >>> 0 < HEAPU32[$0 + 104 >> 2];
            if ($8) {
             $8 = $6 + 1 | 0;
             HEAP32[$0 + 4 >> 2] = $8;
             $6 = HEAPU8[$6 | 0];
             break label$22;
            }
           }
           if (global$2 ? ($18 | 0) == 1 : 1) {
            $5 = __shgetc($0);
            $10 = 1;
            if ((global$2 | 0) == 1) {
             break label$2
            }
            $6 = $5;
           }
          }
          $8 = global$2 ? $8 : $1 & -17;
          label$26 : {
           label$27 : {
            if (!global$2) {
             if ($8) {
              break label$27
             }
             $8 = ($6 | 0) != 48;
             if ($8) {
              break label$27
             }
             $6 = HEAP32[$0 + 4 >> 2];
             $8 = $6 >>> 0 < HEAPU32[$0 + 104 >> 2];
            }
            label$29 : {
             if (!global$2) {
              if ($8) {
               $8 = $6 + 1 | 0;
               HEAP32[$0 + 4 >> 2] = $8;
               $5 = HEAPU8[$6 | 0];
               break label$29;
              }
             }
             if (global$2 ? ($18 | 0) == 2 : 1) {
              $5 = __shgetc($0);
              $10 = 2;
              if ((global$2 | 0) == 1) {
               break label$2
              }
             } else {
              $5 = $6
             }
            }
            $6 = $5;
            $8 = global$2 ? $8 : ($6 | 32) == 120;
            if ($8 | (global$2 | 0) == 2) {
             if (!global$2) {
              $6 = HEAP32[$0 + 4 >> 2];
              $1 = $6 >>> 0 < HEAPU32[$0 + 104 >> 2];
             }
             label$36 : {
              if (!global$2) {
               if ($1) {
                $1 = $6 + 1 | 0;
                HEAP32[$0 + 4 >> 2] = $1;
                $5 = HEAPU8[$6 | 0];
                break label$36;
               }
              }
              if (global$2 ? ($18 | 0) == 3 : 1) {
               $5 = __shgetc($0);
               $10 = 3;
               if ((global$2 | 0) == 1) {
                break label$2
               }
              } else {
               $5 = $6
              }
             }
             $6 = $5;
             if (!global$2) {
              $1 = 16;
              $8 = HEAPU8[$6 + 12913 | 0] < 16;
              if ($8) {
               break label$8
              }
              if (!HEAP32[$0 + 104 >> 2]) {
               $3 = 0;
               $4 = 0;
               if ($2) {
                break label$4
               }
               break label$5;
              }
              $6 = HEAP32[$0 + 4 >> 2];
              HEAP32[$0 + 4 >> 2] = $6 + -1;
              if (!$2) {
               break label$5
              }
              HEAP32[$0 + 4 >> 2] = $6 + -2;
              $3 = 0;
              $4 = 0;
              break label$4;
             }
            }
            if (!global$2) {
             if ($1) {
              break label$26
             }
             $1 = 8;
             break label$8;
            }
           }
           if (!global$2) {
            $1 = $1 ? $1 : 10;
            $2 = $1 >>> 0 > HEAPU8[$6 + 12913 | 0];
            if ($2) {
             break label$26
            }
            if (HEAP32[$0 + 104 >> 2]) {
             HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + -1
            }
            $3 = 0;
            $4 = 0;
            __shlim($0, 0, 0);
            HEAP32[__errno_location() >> 2] = 28;
            break label$4;
           }
          }
          if (!global$2) {
           $2 = ($1 | 0) != 10;
           if ($2) {
            break label$8
           }
           $13 = 0;
           $12 = 0;
           $2 = $6 + -48 | 0;
           $1 = $2 >>> 0 <= 9;
          }
          if ((global$2 | 0) == 2 | $1) {
           $1 = global$2 ? $1 : 0;
           while (1) {
            if (!global$2) {
             $6 = HEAP32[$0 + 4 >> 2];
             $8 = $6 >>> 0 < HEAPU32[$0 + 104 >> 2];
             $1 = Math_imul($1, 10);
            }
            label$51 : {
             if (!global$2) {
              if ($8) {
               $8 = $6 + 1 | 0;
               HEAP32[$0 + 4 >> 2] = $8;
               $5 = HEAPU8[$6 | 0];
               break label$51;
              }
             }
             if (global$2 ? ($18 | 0) == 4 : 1) {
              $5 = __shgetc($0);
              $10 = 4;
              if ((global$2 | 0) == 1) {
               break label$2
              }
             } else {
              $5 = $6
             }
            }
            $6 = $5;
            if (!global$2) {
             $1 = $1 + $2 | 0;
             $2 = $6 + -48 | 0;
             $15 = $1 >>> 0 < 429496729;
             $8 = $15 ? $2 >>> 0 <= 9 : 0;
             if ($8) {
              continue
             }
            }
            break;
           };
           $9 = global$2;
           $10 = $9 ? $13 : $1;
           $13 = $10;
           $7 = $12;
           $5 = $9 ? $7 : 0;
           $12 = $5;
          }
          if (!global$2) {
           $1 = $2 >>> 0 > 9;
           if ($1) {
            break label$9
           }
           $5 = $12;
           $10 = __wasm_i64_mul($13, $5, 10, 0);
           $16 = $10;
           $5 = i64toi32_i32$HIGH_BITS;
           $20 = $5;
           $17 = $2;
           $19 = 0;
          }
          while (1) {
           if (!global$2) {
            $6 = HEAP32[$0 + 4 >> 2];
            $1 = $6 >>> 0 < HEAPU32[$0 + 104 >> 2];
           }
           label$60 : {
            if (!global$2) {
             if ($1) {
              $1 = $6 + 1 | 0;
              HEAP32[$0 + 4 >> 2] = $1;
              $5 = HEAPU8[$6 | 0];
              break label$60;
             }
            }
            if (global$2 ? ($18 | 0) == 5 : 1) {
             $5 = __shgetc($0);
             $10 = 5;
             if ((global$2 | 0) == 1) {
              break label$2
             }
            } else {
             $5 = $6
            }
           }
           $6 = $5;
           if (!global$2) {
            $5 = $20;
            $10 = $19;
            $14 = $5 + $10 | 0;
            $7 = $17;
            $9 = $16;
            $11 = $7 + $9 | 0;
            if ($11 >>> 0 < $7 >>> 0) {
             $14 = $14 + 1 | 0
            }
            $13 = $11;
            $12 = $14;
            $2 = $6 + -48 | 0;
            $1 = $2 >>> 0 > 9;
            if ($1) {
             break label$9
            }
            $5 = $13;
            $1 = ($12 | 0) == 429496729 & $5 >>> 0 >= 2576980378 | $12 >>> 0 > 429496729;
            if ($1) {
             break label$9
            }
            $5 = $12;
            $14 = __wasm_i64_mul($13, $5, 10, 0);
            $16 = $14;
            $19 = 0;
            $17 = $2;
            $24 = $2 ^ -1;
            $25 = -1;
            $5 = i64toi32_i32$HIGH_BITS;
            $20 = $5;
            $14 = $5;
            $5 = $16;
            $9 = $24;
            $1 = ($14 | 0) == -1 & $5 >>> 0 <= $9 >>> 0 | $14 >>> 0 < 4294967295;
            if ($1) {
             continue
            }
           }
           break;
          };
          if (!global$2) {
           $1 = 10;
           break label$7;
          }
         }
         if (!global$2) {
          HEAP32[__errno_location() >> 2] = 28;
          $3 = 0;
          $4 = 0;
          break label$4;
         }
        }
        if (!global$2) {
         $1 = 10;
         $2 = $2 >>> 0 <= 9;
         if ($2) {
          break label$7
         }
         break label$6;
        }
       }
       $2 = global$2 ? $2 : $1 + -1 & $1;
       if ($2 | (global$2 | 0) == 2) {
        if (!global$2) {
         $13 = 0;
         $12 = 0;
         $2 = HEAPU8[$6 + 12913 | 0];
         $8 = $1 >>> 0 > $2 >>> 0;
        }
        if ((global$2 | 0) == 2 | $8) {
         $15 = global$2 ? $15 : 0;
         while (1) {
          if (!global$2) {
           $15 = Math_imul($1, $15) + $2 | 0;
           $22 = $15 >>> 0 <= 119304646;
           $8 = $1;
           $6 = HEAP32[$0 + 4 >> 2];
           $2 = $6 >>> 0 < HEAPU32[$0 + 104 >> 2];
          }
          label$75 : {
           if (!global$2) {
            if ($2) {
             $2 = $6 + 1 | 0;
             HEAP32[$0 + 4 >> 2] = $2;
             $5 = HEAPU8[$6 | 0];
             break label$75;
            }
           }
           if (global$2 ? ($18 | 0) == 6 : 1) {
            $5 = __shgetc($0);
            $10 = 6;
            if ((global$2 | 0) == 1) {
             break label$2
            }
           } else {
            $5 = $6
           }
          }
          $6 = $5;
          if (!global$2) {
           $2 = HEAPU8[$6 + 12913 | 0];
           $8 = $8 >>> 0 > $2 >>> 0 ? $22 : 0;
           if ($8) {
            continue
           }
          }
          break;
         };
         $10 = global$2;
         $7 = $10 ? $13 : $15;
         $13 = $7;
         $5 = $12;
         $9 = $10 ? $5 : 0;
         $12 = $9;
        }
        if (!global$2) {
         $8 = $1 >>> 0 <= $2 >>> 0;
         if ($8) {
          break label$7
         }
         $16 = $1;
         $20 = 0;
        }
        while (1) {
         if (!global$2) {
          $9 = $12;
          $7 = $20;
          $7 = __wasm_i64_mul($13, $9, $16, $7);
          $17 = $7;
          $9 = i64toi32_i32$HIGH_BITS;
          $19 = $9;
          $25 = 0;
          $24 = $2 & 255;
          $9 = $24;
          $5 = $9 ^ -1;
          $10 = $19;
          $2 = ($10 | 0) == -1 & $7 >>> 0 > $5 >>> 0 | $10 >>> 0 > 4294967295;
          if ($2) {
           break label$7
          }
          $6 = HEAP32[$0 + 4 >> 2];
          $2 = $6 >>> 0 < HEAPU32[$0 + 104 >> 2];
         }
         label$84 : {
          if (!global$2) {
           if ($2) {
            $2 = $6 + 1 | 0;
            HEAP32[$0 + 4 >> 2] = $2;
            $5 = HEAPU8[$6 | 0];
            break label$84;
           }
          }
          if (global$2 ? ($18 | 0) == 7 : 1) {
           $5 = __shgetc($0);
           $10 = 7;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          } else {
           $5 = $6
          }
         }
         $6 = $5;
         if (!global$2) {
          $7 = $19;
          $10 = $25;
          $11 = $7 + $10 | 0;
          $5 = $17;
          $9 = $24;
          $14 = $5 + $9 | 0;
          if ($14 >>> 0 < $9 >>> 0) {
           $11 = $11 + 1 | 0
          }
          $13 = $14;
          $12 = $11;
          $2 = HEAPU8[$6 + 12913 | 0];
          $8 = $1 >>> 0 <= $2 >>> 0;
          if ($8) {
           break label$7
          }
          $11 = $20;
          $7 = $12;
          __multi3($23, $16, $11, 0, 0, $13, $7, 0, 0);
          $5 = $23;
          $9 = HEAP32[$5 + 8 >> 2];
          $17 = $9;
          $7 = HEAP32[$5 + 12 >> 2];
          $19 = $7;
          $8 = !($7 | $9);
          if ($8) {
           continue
          }
         }
         break;
        };
        if (!global$2) {
         break label$7
        }
       }
       if (!global$2) {
        $22 = HEAP8[(Math_imul($1, 23) >>> 5 & 7) + 13169 | 0];
        $13 = 0;
        $12 = 0;
        $2 = HEAPU8[$6 + 12913 | 0];
        $8 = $1 >>> 0 > $2 >>> 0;
       }
       if ((global$2 | 0) == 2 | $8) {
        $15 = global$2 ? $15 : 0;
        while (1) {
         if (!global$2) {
          $15 = $15 << $22 | $2;
          $26 = $15 >>> 0 <= 134217727;
          $8 = $1;
          $6 = HEAP32[$0 + 4 >> 2];
          $2 = $6 >>> 0 < HEAPU32[$0 + 104 >> 2];
         }
         label$95 : {
          if (!global$2) {
           if ($2) {
            $2 = $6 + 1 | 0;
            HEAP32[$0 + 4 >> 2] = $2;
            $5 = HEAPU8[$6 | 0];
            break label$95;
           }
          }
          if (global$2 ? ($18 | 0) == 8 : 1) {
           $5 = __shgetc($0);
           $10 = 8;
           if ((global$2 | 0) == 1) {
            break label$2
           }
          } else {
           $5 = $6
          }
         }
         $6 = $5;
         if (!global$2) {
          $2 = HEAPU8[$6 + 12913 | 0];
          $8 = $8 >>> 0 > $2 >>> 0 ? $26 : 0;
          if ($8) {
           continue
          }
         }
         break;
        };
        $10 = global$2;
        $11 = $10 ? $13 : $15;
        $13 = $11;
        $7 = $12;
        $5 = $10 ? $7 : 0;
        $12 = $5;
       }
       if (!global$2) {
        $20 = 0;
        $11 = 0;
        $16 = $22;
        $7 = $16;
        $9 = $7 & 31;
        if (32 <= ($7 & 63) >>> 0) {
         $17 = -1 >>> $9 | 0
        } else {
         $11 = -1 >>> $9 | 0;
         $17 = (1 << $9) - 1 << 32 - $9 | -1 >>> $9;
        }
        $19 = $11;
        $10 = $12;
        $5 = $17;
        $7 = $13;
        $8 = ($11 | 0) == ($10 | 0) & $5 >>> 0 < $7 >>> 0 | $11 >>> 0 < $10 >>> 0;
        if ($8) {
         break label$7
        }
        $8 = $1 >>> 0 <= $2 >>> 0;
        if ($8) {
         break label$7
        }
       }
       while (1) {
        if (!global$2) {
         $2 = $2 & 255;
         $11 = $12;
         $5 = $13;
         $10 = $16;
         $9 = $10 & 31;
         if (32 <= ($10 & 63) >>> 0) {
          $7 = $5 << $9;
          $10 = 0;
         } else {
          $7 = (1 << $9) - 1 & $5 >>> 32 - $9 | $11 << $9;
          $10 = $5 << $9;
         }
         $11 = $2;
         $13 = $11 | $10;
         $5 = $7;
         $12 = $5;
         $6 = HEAP32[$0 + 4 >> 2];
         $2 = $6 >>> 0 < HEAPU32[$0 + 104 >> 2];
        }
        label$104 : {
         if (!global$2) {
          if ($2) {
           $2 = $6 + 1 | 0;
           HEAP32[$0 + 4 >> 2] = $2;
           $5 = HEAPU8[$6 | 0];
           break label$104;
          }
         }
         if (global$2 ? ($18 | 0) == 9 : 1) {
          $5 = __shgetc($0);
          $10 = 9;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         } else {
          $5 = $6
         }
        }
        $6 = $5;
        if (!global$2) {
         $11 = $19;
         $5 = $12;
         $7 = $13;
         $10 = $17;
         $2 = ($11 | 0) == ($5 | 0) & $7 >>> 0 > $10 >>> 0 | $5 >>> 0 > $11 >>> 0;
         if ($2) {
          break label$7
         }
         $2 = HEAPU8[$6 + 12913 | 0];
         $8 = $1 >>> 0 > $2 >>> 0;
         if ($8) {
          continue
         }
        }
        break;
       };
      }
      if (!global$2) {
       $2 = $1 >>> 0 <= HEAPU8[$6 + 12913 | 0];
       if ($2) {
        break label$6
       }
      }
      while (1) {
       if (!global$2) {
        $6 = HEAP32[$0 + 4 >> 2];
        $8 = $6 >>> 0 < HEAPU32[$0 + 104 >> 2];
        $2 = $1;
       }
       label$113 : {
        if (!global$2) {
         if ($8) {
          $8 = $6 + 1 | 0;
          HEAP32[$0 + 4 >> 2] = $8;
          $5 = HEAPU8[$6 | 0];
          break label$113;
         }
        }
        if (global$2 ? ($18 | 0) == 10 : 1) {
         $5 = __shgetc($0);
         $10 = 10;
         if ((global$2 | 0) == 1) {
          break label$2
         }
        } else {
         $5 = $6
        }
       }
       $6 = $5;
       if (!global$2) {
        $6 = HEAPU8[$6 + 12913 | 0];
        $2 = $2 >>> 0 > $6 >>> 0;
        if ($2) {
         continue
        }
       }
       break;
      };
      if (!global$2) {
       HEAP32[__errno_location() >> 2] = 68;
       $5 = 0;
       $10 = $3;
       $21 = !($5 | $10 & 1) ? $21 : 0;
       $13 = $10;
       $7 = $4;
       $5 = $7;
       $12 = $5;
      }
     }
     if (!global$2) {
      if (HEAP32[$0 + 104 >> 2]) {
       HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + -1
      }
      label$122 : {
       $5 = $12;
       $10 = $4;
       $7 = $13;
       $11 = $3;
       if (($5 | 0) == ($10 | 0) & $7 >>> 0 < $11 >>> 0 | $5 >>> 0 < $10 >>> 0) {
        break label$122
       }
       if (!($21 | $3 & 1)) {
        HEAP32[__errno_location() >> 2] = 68;
        $14 = $4 + -1 | 0;
        $9 = $3 + -1 | 0;
        if ($9 >>> 0 < 4294967295) {
         $14 = $14 + 1 | 0
        }
        $3 = $9;
        $4 = $14;
        break label$4;
       }
       $11 = $4;
       $7 = $13;
       $10 = $3;
       if (($11 | 0) == ($12 | 0) & $7 >>> 0 <= $10 >>> 0 | $12 >>> 0 < $11 >>> 0) {
        break label$122
       }
       HEAP32[__errno_location() >> 2] = 68;
       break label$4;
      }
      $14 = $21;
      $7 = $14 >> 31;
      $3 = $14;
      $4 = $7;
      $7 = $12;
      $14 = $4;
      $14 = $7 ^ $14;
      $11 = $3;
      $10 = $13;
      $7 = $11 ^ $10;
      $5 = $7 - $11 | 0;
      $3 = $5;
      $10 = $4;
      $9 = $10 + ($7 >>> 0 < $11 >>> 0) | 0;
      $9 = $14 - $9 | 0;
      $4 = $9;
      break label$4;
     }
    }
    if (!global$2) {
     __shlim($0, 0, 0);
     $4 = 0;
     $3 = 0;
    }
   }
   if (!global$2) {
    global$0 = $23 + 16 | 0;
    $9 = $4;
    i64toi32_i32$HIGH_BITS = $9;
    $7 = $3;
    return $7;
   }
   abort();
  }
  $5 = $10;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  $9 = $5;
  HEAP32[$9 + 12 >> 2] = $3;
  $7 = $4;
  HEAP32[$9 + 16 >> 2] = $7;
  HEAP32[$9 + 20 >> 2] = $6;
  HEAP32[$9 + 24 >> 2] = $8;
  HEAP32[$9 + 28 >> 2] = $13;
  $7 = $12;
  HEAP32[$9 + 32 >> 2] = $7;
  HEAP32[$9 + 36 >> 2] = $15;
  HEAP32[$9 + 40 >> 2] = $16;
  $7 = $20;
  HEAP32[$9 + 44 >> 2] = $7;
  HEAP32[$9 + 48 >> 2] = $17;
  $7 = $19;
  HEAP32[$9 + 52 >> 2] = $7;
  HEAP32[$9 + 56 >> 2] = $21;
  HEAP32[$9 + 60 >> 2] = $22;
  HEAP32[$9 + 64 >> 2] = $23;
  HEAP32[$9 + 68 >> 2] = $24;
  $7 = $25;
  HEAP32[$9 + 72 >> 2] = $7;
  HEAP32[$9 + 76 >> 2] = $26;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 80;
  i64toi32_i32$HIGH_BITS = 0;
  return 0;
 }
 
 function __syscall_ret($0) {
  if ($0 >>> 0 >= 4294963201) {
   HEAP32[__errno_location() >> 2] = 0 - $0;
   $0 = -1;
  }
  return $0;
 }
 
 function __floatscan($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -60;
   $5 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$5 >> 2];
   $2 = HEAP32[$5 + 8 >> 2];
   $3 = HEAP32[$5 + 12 >> 2];
   $4 = HEAP32[$5 + 16 >> 2];
   $6 = HEAP32[$5 + 20 >> 2];
   $7 = HEAP32[$5 + 24 >> 2];
   $9 = HEAP32[$5 + 28 >> 2];
   $8 = HEAP32[$5 + 32 >> 2];
   $15 = HEAP32[$5 + 36 >> 2];
   $13 = HEAP32[$5 + 40 >> 2];
   $10 = HEAP32[$5 + 44 >> 2];
   $11 = HEAP32[$5 + 48 >> 2];
   $16 = HEAP32[$5 + 52 >> 2];
   $17 = HEAP32[$5 + 56 >> 2];
   $1 = HEAP32[$5 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $12 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if (!global$2) {
    $9 = global$0 - 48 | 0;
    global$0 = $9;
    $15 = 0;
    $13 = 0;
    $4 = $2 >>> 0 <= 2;
   }
   label$4 : {
    if ((global$2 | 0) == 2 | $4) {
     if (!global$2) {
      $2 = $2 << 2;
      $4 = $2 + 13260 | 0;
      $16 = HEAP32[$4 >> 2];
      $2 = $2 + 13248 | 0;
      $17 = HEAP32[$2 >> 2];
      $7 = $1 + 4 | 0;
     }
     while (1) {
      if (!global$2) {
       $2 = HEAP32[$1 + 4 >> 2];
       $4 = $2 >>> 0 < HEAPU32[$1 + 104 >> 2];
      }
      label$11 : {
       if (!global$2) {
        if ($4) {
         $4 = $2 + 1 | 0;
         HEAP32[$7 >> 2] = $4;
         $2 = HEAPU8[$2 | 0];
         break label$11;
        }
       }
       if (global$2 ? !$12 : 1) {
        $5 = __shgetc($1);
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $2 = $5;
       }
      }
      if (!global$2) {
       $4 = isspace($2);
       if ($4) {
        continue
       }
      }
      break;
     };
     if (!global$2) {
      $4 = $2 + -43 | 0;
      $6 = $4 >>> 0 > 2;
     }
     label$18 : {
      if (!global$2) {
       if ($6) {
        $8 = 1;
        break label$18;
       }
       $8 = 1;
       $4 = !($4 - 1);
       if ($4) {
        break label$18
       }
       $8 = ($2 | 0) == 45 ? -1 : 1;
       $2 = HEAP32[$1 + 4 >> 2];
       $4 = $2 >>> 0 < HEAPU32[$1 + 104 >> 2];
       if ($4) {
        $4 = $2 + 1 | 0;
        HEAP32[$7 >> 2] = $4;
        $2 = HEAPU8[$2 | 0];
        break label$18;
       }
      }
      if (global$2 ? ($12 | 0) == 1 : 1) {
       $5 = __shgetc($1);
       $14 = 1;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $2 = $5;
      }
     }
     $4 = global$2 ? $4 : 0;
     label$23 : {
      label$24 : {
       while (1) {
        $6 = global$2 ? $6 : HEAP8[$4 + 13178 | 0] == ($2 | 32);
        if ($6 | (global$2 | 0) == 2) {
         $6 = global$2 ? $6 : $4 >>> 0 > 6;
         label$29 : {
          if (!global$2) {
           if ($6) {
            break label$29
           }
           $2 = HEAP32[$1 + 4 >> 2];
           $6 = $2 >>> 0 < HEAPU32[$1 + 104 >> 2];
           if ($6) {
            $6 = $2 + 1 | 0;
            HEAP32[$7 >> 2] = $6;
            $2 = HEAPU8[$2 | 0];
            break label$29;
           }
          }
          if (global$2 ? ($12 | 0) == 2 : 1) {
           $5 = __shgetc($1);
           $14 = 2;
           if ((global$2 | 0) == 1) {
            break label$2
           }
           $2 = $5;
          }
         }
         if (!global$2) {
          $4 = $4 + 1 | 0;
          $6 = ($4 | 0) != 8;
          if ($6) {
           continue
          }
          break label$24;
         }
        }
        break;
       };
       if (!global$2) {
        $6 = ($4 | 0) != 3;
        if ($6) {
         $6 = ($4 | 0) == 8;
         if ($6) {
          break label$24
         }
         $6 = !$3;
         if ($6) {
          break label$23
         }
         $6 = $4 >>> 0 < 4;
         if ($6) {
          break label$23
         }
         $2 = ($4 | 0) == 8;
         if ($2) {
          break label$24
         }
        }
        $1 = HEAP32[$1 + 104 >> 2];
        if ($1) {
         HEAP32[$7 >> 2] = HEAP32[$7 >> 2] + -1
        }
        $2 = !$3;
        if ($2) {
         break label$24
        }
        $2 = $4 >>> 0 < 4;
        if ($2) {
         break label$24
        }
        while (1) {
         if ($1) {
          HEAP32[$7 >> 2] = HEAP32[$7 >> 2] + -1
         }
         $4 = $4 + -1 | 0;
         $2 = $4 >>> 0 > 3;
         if ($2) {
          continue
         }
         break;
        };
       }
      }
      if (!global$2) {
       __extendsftf2($9, Math_fround(Math_fround($8 | 0) * Math_fround(infinity)));
       $1 = $9;
       $10 = HEAP32[$1 + 8 >> 2];
       $11 = HEAP32[$1 + 12 >> 2];
       $15 = HEAP32[$1 >> 2];
       $13 = HEAP32[$1 + 4 >> 2];
       break label$4;
      }
     }
     label$40 : {
      label$41 : {
       label$42 : {
        if (!global$2) {
         if ($4) {
          break label$42
         }
         $4 = 0;
        }
        while (1) {
         if (!global$2) {
          $6 = HEAP8[$4 + 13187 | 0] != ($2 | 32);
          if ($6) {
           break label$42
          }
          $6 = $4 >>> 0 > 1;
         }
         label$46 : {
          if (!global$2) {
           if ($6) {
            break label$46
           }
           $2 = HEAP32[$1 + 4 >> 2];
           $6 = $2 >>> 0 < HEAPU32[$1 + 104 >> 2];
           if ($6) {
            $6 = $2 + 1 | 0;
            HEAP32[$7 >> 2] = $6;
            $2 = HEAPU8[$2 | 0];
            break label$46;
           }
          }
          if (global$2 ? ($12 | 0) == 3 : 1) {
           $5 = __shgetc($1);
           $14 = 3;
           if ((global$2 | 0) == 1) {
            break label$2
           }
           $2 = $5;
          }
         }
         if (!global$2) {
          $4 = $4 + 1 | 0;
          $6 = ($4 | 0) != 3;
          if ($6) {
           continue
          }
         }
         break;
        };
        if (!global$2) {
         break label$41
        }
       }
       if (!global$2) {
        label$52 : {
         label$53 : {
          $6 = $4 >>> 0 > 3;
          if ($6) {
           break label$53
          }
          $4 = $4 - 1 | 0;
          switch ($4 | 0) {
          case 2:
           break label$41;
          case 0:
          case 1:
           break label$53;
          default:
           break label$52;
          };
         }
         if (HEAP32[$1 + 104 >> 2]) {
          HEAP32[$7 >> 2] = HEAP32[$7 >> 2] + -1
         }
         HEAP32[__errno_location() >> 2] = 28;
         break label$40;
        }
        $4 = ($2 | 0) != 48;
       }
       label$55 : {
        if (!global$2) {
         if ($4) {
          break label$55
         }
         $4 = HEAP32[$1 + 4 >> 2];
         $6 = $4 >>> 0 < HEAPU32[$1 + 104 >> 2];
        }
        label$57 : {
         if (!global$2) {
          if ($6) {
           $6 = $4 + 1 | 0;
           HEAP32[$7 >> 2] = $6;
           $5 = HEAPU8[$4 | 0];
           break label$57;
          }
         }
         if (global$2 ? ($12 | 0) == 4 : 1) {
          $5 = __shgetc($1);
          $14 = 4;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         } else {
          $5 = $4
         }
        }
        $4 = $5;
        $4 = global$2 ? $4 : ($4 | 32) == 120;
        if ($4 | (global$2 | 0) == 2) {
         $2 = global$2 ? $2 : $9 + 16 | 0;
         if (global$2 ? ($12 | 0) == 5 : 1) {
          hexfloat($2, $1, $17, $16, $8, $3);
          $14 = 5;
          if ((global$2 | 0) == 1) {
           break label$2
          }
         }
         if (!global$2) {
          $1 = $9;
          $10 = HEAP32[$1 + 24 >> 2];
          $11 = HEAP32[$1 + 28 >> 2];
          $15 = HEAP32[$1 + 16 >> 2];
          $13 = HEAP32[$1 + 20 >> 2];
          break label$4;
         }
        }
        if (!global$2) {
         $4 = !HEAP32[$1 + 104 >> 2];
         if ($4) {
          break label$55
         }
         $4 = HEAP32[$7 >> 2] + -1 | 0;
         HEAP32[$7 >> 2] = $4;
        }
       }
       $4 = global$2 ? $4 : $9 + 32 | 0;
       if (global$2 ? ($12 | 0) == 6 : 1) {
        decfloat($4, $1, $2, $17, $16, $8, $3);
        $14 = 6;
        if ((global$2 | 0) == 1) {
         break label$2
        }
       }
       if (!global$2) {
        $1 = $9;
        $10 = HEAP32[$1 + 40 >> 2];
        $11 = HEAP32[$1 + 44 >> 2];
        $15 = HEAP32[$1 + 32 >> 2];
        $13 = HEAP32[$1 + 36 >> 2];
        break label$4;
       }
      }
      if (!global$2) {
       $2 = HEAP32[$1 + 4 >> 2];
       $4 = $2 >>> 0 < HEAPU32[$1 + 104 >> 2];
      }
      label$69 : {
       if (!global$2) {
        if ($4) {
         $4 = $2 + 1 | 0;
         HEAP32[$7 >> 2] = $4;
         $2 = HEAPU8[$2 | 0];
         break label$69;
        }
       }
       if (global$2 ? ($12 | 0) == 7 : 1) {
        $5 = __shgetc($1);
        $14 = 7;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $2 = $5;
       }
      }
      if (!global$2) {
       label$75 : {
        $2 = ($2 | 0) == 40;
        if ($2) {
         $4 = 1;
         break label$75;
        }
        $10 = 0;
        $11 = 2147450880;
        if (!HEAP32[$1 + 104 >> 2]) {
         break label$4
        }
        HEAP32[$7 >> 2] = HEAP32[$7 >> 2] + -1;
        break label$4;
       }
      }
      while (1) {
       if (!global$2) {
        $2 = HEAP32[$1 + 4 >> 2];
        $6 = $2 >>> 0 < HEAPU32[$1 + 104 >> 2];
       }
       label$79 : {
        if (!global$2) {
         if ($6) {
          HEAP32[$7 >> 2] = $2 + 1;
          $2 = HEAPU8[$2 | 0];
          break label$79;
         }
        }
        if (global$2 ? ($12 | 0) == 8 : 1) {
         $5 = __shgetc($1);
         $14 = 8;
         if ((global$2 | 0) == 1) {
          break label$2
         }
         $2 = $5;
        }
       }
       if (!global$2) {
        $8 = $2 + -65 | 0;
        label$85 : {
         $6 = $2 + -48 >>> 0 < 10;
         label$86 : {
          if ($6) {
           break label$86
          }
          $6 = $8 >>> 0 < 26;
          if ($6) {
           break label$86
          }
          $8 = $2 + -97 | 0;
          $6 = ($2 | 0) == 95;
          if ($6) {
           break label$86
          }
          $6 = $8 >>> 0 >= 26;
          if ($6) {
           break label$85
          }
         }
         $4 = $4 + 1 | 0;
         continue;
        }
       }
       break;
      };
      if (!global$2) {
       $10 = 0;
       $11 = 2147450880;
       if (($2 | 0) == 41) {
        break label$4
       }
       $2 = HEAP32[$1 + 104 >> 2];
       if ($2) {
        HEAP32[$7 >> 2] = HEAP32[$7 >> 2] + -1
       }
       if ($3) {
        if (!$4) {
         break label$4
        }
        while (1) {
         $4 = $4 + -1 | 0;
         if ($2) {
          HEAP32[$7 >> 2] = HEAP32[$7 >> 2] + -1
         }
         if ($4) {
          continue
         }
         break;
        };
        break label$4;
       }
       HEAP32[__errno_location() >> 2] = 28;
      }
     }
     if (global$2) {
      $18 = $13
     } else {
      __shlim($1, 0, 0);
      $15 = 0;
     }
     $13 = $18;
    }
    $1 = global$2;
    $5 = $1 ? $10 : 0;
    $10 = $5;
    $1 = $1 ? $11 : 0;
    $11 = $1;
   }
   if (!global$2) {
    $5 = $0;
    HEAP32[$5 >> 2] = $15;
    $1 = $13;
    HEAP32[$5 + 4 >> 2] = $1;
    HEAP32[$5 + 8 >> 2] = $10;
    $1 = $11;
    HEAP32[$5 + 12 >> 2] = $1;
    global$0 = $9 + 48 | 0;
   }
   return;
  }
  $5 = $14;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $5;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[$5 + 20 >> 2] = $6;
  HEAP32[$5 + 24 >> 2] = $7;
  HEAP32[$5 + 28 >> 2] = $9;
  HEAP32[$5 + 32 >> 2] = $8;
  HEAP32[$5 + 36 >> 2] = $15;
  $1 = $13;
  HEAP32[$5 + 40 >> 2] = $1;
  HEAP32[$5 + 44 >> 2] = $10;
  $1 = $11;
  HEAP32[$5 + 48 >> 2] = $1;
  HEAP32[$5 + 52 >> 2] = $16;
  HEAP32[$5 + 56 >> 2] = $17;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 60;
 }
 
 function hexfloat($0, $1, $2, $3, $4, $5) {
  var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -112;
   $6 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$6 >> 2];
   $2 = HEAP32[$6 + 8 >> 2];
   $3 = HEAP32[$6 + 12 >> 2];
   $4 = HEAP32[$6 + 16 >> 2];
   $5 = HEAP32[$6 + 20 >> 2];
   $7 = HEAP32[$6 + 24 >> 2];
   $13 = HEAP32[$6 + 28 >> 2];
   $14 = HEAP32[$6 + 32 >> 2];
   $10 = $6;
   $6 = HEAP32[$10 + 36 >> 2];
   $15 = $6;
   $9 = HEAP32[$10 + 40 >> 2];
   $16 = $9;
   $9 = HEAP32[$10 + 44 >> 2];
   $17 = $9;
   $6 = HEAP32[$10 + 48 >> 2];
   $18 = $6;
   $6 = HEAP32[$10 + 52 >> 2];
   $20 = $6;
   $9 = HEAP32[$10 + 56 >> 2];
   $19 = $9;
   $9 = HEAP32[$10 + 60 >> 2];
   $21 = $9;
   $6 = HEAP32[$10 + 64 >> 2];
   $23 = $6;
   $6 = HEAP32[$10 + 68 >> 2];
   $24 = $6;
   $9 = HEAP32[$10 + 72 >> 2];
   $22 = $9;
   $29 = HEAP32[$10 + 76 >> 2];
   $9 = HEAP32[$10 + 80 >> 2];
   $25 = $9;
   $6 = HEAP32[$10 + 84 >> 2];
   $26 = $6;
   $28 = HEAP32[$10 + 88 >> 2];
   $27 = HEAP32[$10 + 92 >> 2];
   $6 = HEAP32[$10 + 96 >> 2];
   $31 = $6;
   $9 = HEAP32[$10 + 100 >> 2];
   $32 = $9;
   $34 = HEAP32[$10 + 104 >> 2];
   $35 = HEAP32[$10 + 108 >> 2];
   $1 = HEAP32[$10 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $30 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $7 = global$0 - 432 | 0;
   global$0 = $7;
   $13 = HEAP32[$1 + 4 >> 2];
   $14 = $13 >>> 0 < HEAPU32[$1 + 104 >> 2];
  }
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($14) {
      $14 = $13 + 1 | 0;
      HEAP32[$1 + 4 >> 2] = $14;
      $6 = HEAPU8[$13 | 0];
      break label$5;
     }
    }
    if (global$2 ? !$30 : 1) {
     $6 = __shgetc($1);
     if ((global$2 | 0) == 1) {
      break label$2
     }
    } else {
     $6 = $13
    }
   }
   $13 = $6;
   if (!global$2) {
    $28 = 0;
    $29 = 0;
    $24 = 0;
    $22 = 0;
   }
   label$11 : {
    label$12 : {
     while (1) {
      label$14 : {
       if (!global$2) {
        if (($13 | 0) != 48) {
         $14 = ($13 | 0) != 46;
         if ($14) {
          break label$11
         }
         $13 = HEAP32[$1 + 4 >> 2];
         $14 = $13 >>> 0 >= HEAPU32[$1 + 104 >> 2];
         if ($14) {
          break label$14
         }
         $14 = $13 + 1 | 0;
         HEAP32[$1 + 4 >> 2] = $14;
         $6 = HEAPU8[$13 | 0];
         break label$12;
        }
        $13 = HEAP32[$1 + 4 >> 2];
        $14 = $13 >>> 0 < HEAPU32[$1 + 104 >> 2];
        if ($14) {
         $29 = 1;
         $14 = $13 + 1 | 0;
         HEAP32[$1 + 4 >> 2] = $14;
         $13 = HEAPU8[$13 | 0];
         continue;
        }
        $29 = 1;
       }
       if (global$2 ? ($30 | 0) == 1 : 1) {
        $6 = __shgetc($1);
        $11 = 1;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $13 = $6;
       }
       if (!global$2) {
        continue
       }
      }
      break;
     };
     if (global$2 ? ($30 | 0) == 2 : 1) {
      $6 = __shgetc($1);
      $11 = 2;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     } else {
      $6 = $13
     }
    }
    $13 = $6;
    if (!global$2) {
     $28 = 1;
     $24 = 0;
     $22 = 0;
     $14 = ($13 | 0) != 48;
     if ($14) {
      break label$11
     }
    }
    while (1) {
     if (!global$2) {
      $13 = HEAP32[$1 + 4 >> 2];
      $14 = $13 >>> 0 < HEAPU32[$1 + 104 >> 2];
     }
     label$24 : {
      if (!global$2) {
       if ($14) {
        $14 = $13 + 1 | 0;
        HEAP32[$1 + 4 >> 2] = $14;
        $6 = HEAPU8[$13 | 0];
        break label$24;
       }
      }
      if (global$2 ? ($30 | 0) == 3 : 1) {
       $6 = __shgetc($1);
       $11 = 3;
       if ((global$2 | 0) == 1) {
        break label$2
       }
      } else {
       $6 = $13
      }
     }
     $13 = $6;
     if (!global$2) {
      $9 = $22;
      $8 = $9 + -1 | 0;
      $10 = $24;
      $12 = $10 + -1 | 0;
      if ($12 >>> 0 < 4294967295) {
       $8 = $8 + 1 | 0
      }
      $24 = $12;
      $22 = $8;
      $14 = ($13 | 0) == 48;
      if ($14) {
       continue
      }
     }
     break;
    };
    if (!global$2) {
     $29 = 1;
     $28 = 1;
    }
   }
   if (!global$2) {
    $20 = 0;
    $19 = 1073676288;
    $14 = 0;
    $15 = 0;
    $16 = 0;
    $21 = 0;
    $23 = 0;
    $25 = 0;
    $26 = 0;
    $34 = 0;
    $17 = 0;
    $18 = 0;
   }
   while (1) {
    label$33 : {
     if (!global$2) {
      $27 = $13 | 32;
      label$35 : {
       label$36 : {
        $35 = $13 + -48 | 0;
        if ($35 >>> 0 < 10) {
         break label$36
        }
        if ($27 + -97 >>> 0 > 5 ? ($13 | 0) != 46 : 0) {
         break label$33
        }
        if (($13 | 0) != 46) {
         break label$36
        }
        if ($28) {
         break label$33
        }
        $28 = 1;
        $24 = $17;
        $8 = $18;
        $22 = $8;
        break label$35;
       }
       $13 = ($13 | 0) > 57 ? $27 + -87 | 0 : $35;
       $9 = $17;
       $8 = $18;
       label$37 : {
        if (($8 | 0) < 0 ? 1 : ($8 | 0) <= 0 ? ($9 >>> 0 > 7 ? 0 : 1) : 0) {
         $14 = ($14 << 4) + $13 | 0;
         break label$37;
        }
        $11 = $17;
        $9 = $18;
        if (($9 | 0) < 0 ? 1 : ($9 | 0) <= 0 ? ($11 >>> 0 > 28 ? 0 : 1) : 0) {
         __floatsitf($7 + 48 | 0, $13);
         $11 = $26;
         $9 = $19;
         __multf3($7 + 32 | 0, $25, $11, $20, $9, 0, 0, 0, 1073414144);
         $8 = HEAP32[$7 + 32 >> 2];
         $25 = $8;
         $10 = HEAP32[$7 + 36 >> 2];
         $26 = $10;
         $10 = HEAP32[$7 + 40 >> 2];
         $20 = $10;
         $8 = HEAP32[$7 + 44 >> 2];
         $19 = $8;
         $8 = HEAP32[$7 + 48 >> 2];
         $12 = $8;
         $10 = HEAP32[$7 + 52 >> 2];
         $9 = $10;
         $10 = HEAP32[$7 + 56 >> 2];
         $6 = $10;
         $8 = HEAP32[$7 + 60 >> 2];
         $11 = $8;
         $8 = $26;
         $10 = $19;
         __multf3($7 + 16 | 0, $25, $8, $20, $10, $12, $9, $6, $11);
         $11 = HEAP32[$7 + 16 >> 2];
         $12 = $11;
         $9 = HEAP32[$7 + 20 >> 2];
         $10 = $9;
         $9 = HEAP32[$7 + 24 >> 2];
         $6 = $9;
         $11 = HEAP32[$7 + 28 >> 2];
         $8 = $11;
         $11 = $16;
         $9 = $23;
         __addtf3($7, $15, $11, $21, $9, $12, $10, $6, $8);
         $8 = HEAP32[$7 + 8 >> 2];
         $21 = $8;
         $10 = HEAP32[$7 + 12 >> 2];
         $23 = $10;
         $10 = HEAP32[$7 >> 2];
         $15 = $10;
         $8 = HEAP32[$7 + 4 >> 2];
         $16 = $8;
         break label$37;
        }
        if (!$13 | $34) {
         break label$37
        }
        $8 = $26;
        $10 = $19;
        __multf3($7 + 80 | 0, $25, $8, $20, $10, 0, 0, 0, 1073610752);
        $11 = HEAP32[$7 + 80 >> 2];
        $12 = $11;
        $9 = HEAP32[$7 + 84 >> 2];
        $10 = $9;
        $9 = HEAP32[$7 + 88 >> 2];
        $6 = $9;
        $11 = HEAP32[$7 + 92 >> 2];
        $8 = $11;
        $11 = $16;
        $9 = $23;
        __addtf3($7 - -64 | 0, $15, $11, $21, $9, $12, $10, $6, $8);
        $8 = HEAP32[$7 + 72 >> 2];
        $21 = $8;
        $10 = HEAP32[$7 + 76 >> 2];
        $23 = $10;
        $34 = 1;
        $10 = HEAP32[$7 + 64 >> 2];
        $15 = $10;
        $8 = HEAP32[$7 + 68 >> 2];
        $16 = $8;
       }
       $8 = $18;
       $12 = $8;
       $9 = $17;
       $6 = $9 + 1 | 0;
       if ($6 >>> 0 < 1) {
        $12 = $12 + 1 | 0
       }
       $17 = $6;
       $18 = $12;
       $29 = 1;
      }
      $13 = HEAP32[$1 + 4 >> 2];
      $27 = $13 >>> 0 < HEAPU32[$1 + 104 >> 2];
      if ($27) {
       $27 = $13 + 1 | 0;
       HEAP32[$1 + 4 >> 2] = $27;
       $13 = HEAPU8[$13 | 0];
       continue;
      }
     }
     if (global$2 ? ($30 | 0) == 4 : 1) {
      $6 = __shgetc($1);
      $11 = 4;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $13 = $6;
     }
     if (!global$2) {
      continue
     }
    }
    break;
   };
   $13 = global$2 ? $13 : !$29;
   label$42 : {
    label$43 : {
     label$44 : {
      if (global$2) {
       $8 = $13
      } else {
       if ($13) {
        if (!HEAP32[$1 + 104 >> 2]) {
         if ($5) {
          break label$43
         }
         break label$44;
        }
        $13 = HEAP32[$1 + 4 >> 2];
        HEAP32[$1 + 4 >> 2] = $13 + -1;
        if (!$5) {
         break label$44
        }
        HEAP32[$1 + 4 >> 2] = $13 + -2;
        if (!$28) {
         break label$43
        }
        HEAP32[$1 + 4 >> 2] = $13 + -3;
        break label$43;
       }
       $8 = $17;
       $12 = $18;
       if (($12 | 0) < 0 ? 1 : ($12 | 0) <= 0 ? ($8 >>> 0 > 7 ? 0 : 1) : 0) {
        $20 = $17;
        $8 = $18;
        $19 = $8;
        while (1) {
         $14 = $14 << 4;
         $8 = $19;
         $6 = $8;
         $11 = $20;
         $10 = $11 + 1 | 0;
         if ($10 >>> 0 < 1) {
          $6 = $6 + 1 | 0
         }
         $20 = $10;
         $19 = $6;
         $8 = $10;
         if (($8 | 0) != 8 | $6) {
          continue
         }
         break;
        };
       }
       $8 = ($27 | 0) == 112;
      }
      label$45 : {
       if ($8 | (global$2 | 0) == 2) {
        if (global$2 ? ($30 | 0) == 5 : 1) {
         $8 = scanexp($1, $5);
         $6 = i64toi32_i32$HIGH_BITS;
         $11 = 5;
         if ((global$2 | 0) == 1) {
          break label$2
         }
         $19 = $6;
         $20 = $8;
        }
        if (!global$2) {
         $9 = $20;
         $6 = $19;
         if ($9 | ($6 | 0) != -2147483648) {
          break label$45
         }
         if ($5) {
          $20 = 0;
          $19 = 0;
          if (!HEAP32[$1 + 104 >> 2]) {
           break label$45
          }
          HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + -1;
          break label$45;
         }
         $15 = 0;
         $16 = 0;
         __shlim($1, 0, 0);
         $8 = 0;
         break label$42;
        }
       }
       if (!global$2) {
        $20 = 0;
        $19 = 0;
        if (!HEAP32[$1 + 104 >> 2]) {
         break label$45
        }
        HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + -1;
       }
      }
      if (!global$2) {
       if (!$14) {
        __extenddftf2($7 + 112 | 0, +($4 | 0) * 0.0);
        $9 = HEAP32[$7 + 112 >> 2];
        $15 = $9;
        $6 = HEAP32[$7 + 116 >> 2];
        $16 = $6;
        $6 = HEAP32[$7 + 120 >> 2];
        $33 = $6;
        $9 = HEAP32[$7 + 124 >> 2];
        $8 = $9;
        break label$42;
       }
       $12 = $28;
       $8 = $12 ? $24 : $17;
       $9 = $22;
       $6 = $18;
       $11 = $12 ? $9 : $6;
       $12 = $8;
       $8 = $11 << 2 | $8 >>> 30;
       $11 = $12 << 2;
       $12 = $19;
       $10 = $8 + $12 | 0;
       $9 = $20;
       $6 = $9 + $11 | 0;
       if ($6 >>> 0 < $9 >>> 0) {
        $10 = $10 + 1 | 0
       }
       $8 = $6;
       $6 = $10 + -1 | 0;
       $12 = $8 + -32 | 0;
       if ($12 >>> 0 < 4294967264) {
        $6 = $6 + 1 | 0
       }
       $17 = $12;
       $18 = $6;
       $8 = 0 - $3 | 0;
       $6 = $8 >> 31;
       $1 = $6;
       $10 = $12;
       $9 = $8;
       $6 = $18;
       $8 = $1;
       if (($6 | 0) > ($8 | 0) ? 1 : ($6 | 0) >= ($8 | 0) ? ($10 >>> 0 <= $9 >>> 0 ? 0 : 1) : 0) {
        HEAP32[__errno_location() >> 2] = 68;
        __floatsitf($7 + 160 | 0, $4);
        $10 = HEAP32[$7 + 160 >> 2];
        $3 = $10;
        $10 = HEAP32[$7 + 172 >> 2];
        $1 = $10;
        $6 = HEAP32[$7 + 164 >> 2];
        $10 = $6;
        $6 = HEAP32[$7 + 168 >> 2];
        $2 = $6;
        $6 = $1;
        __multf3($7 + 144 | 0, $3, $10, $2, $6, -1, -1, -1, 2147418111);
        $8 = HEAP32[$7 + 144 >> 2];
        $3 = $8;
        $8 = HEAP32[$7 + 156 >> 2];
        $1 = $8;
        $9 = HEAP32[$7 + 148 >> 2];
        $8 = $9;
        $9 = HEAP32[$7 + 152 >> 2];
        $2 = $9;
        $9 = $1;
        __multf3($7 + 128 | 0, $3, $8, $2, $9, -1, -1, -1, 2147418111);
        $10 = HEAP32[$7 + 128 >> 2];
        $15 = $10;
        $6 = HEAP32[$7 + 132 >> 2];
        $16 = $6;
        $6 = HEAP32[$7 + 136 >> 2];
        $33 = $6;
        $10 = HEAP32[$7 + 140 >> 2];
        $8 = $10;
        break label$42;
       }
       $6 = $3 + -226 | 0;
       $10 = $6 >> 31;
       $1 = $10;
       $9 = $17;
       $8 = $6;
       $10 = $18;
       $6 = $1;
       if (($10 | 0) > ($6 | 0) ? 1 : ($10 | 0) >= ($6 | 0) ? ($9 >>> 0 < $8 >>> 0 ? 0 : 1) : 0) {
        if (($14 | 0) > -1) {
         while (1) {
          $9 = $16;
          $10 = $23;
          __addtf3($7 + 416 | 0, $15, $9, $21, $10, 0, 0, 0, -1073807360);
          $6 = $9;
          $8 = $10;
          $13 = __getf2($15, $6, $21, $8, 0, 0, 0, 1073610752);
          $10 = HEAP32[$7 + 420 >> 2];
          $5 = $10;
          $10 = $6;
          $9 = HEAP32[$7 + 416 >> 2];
          $1 = ($13 | 0) < 0;
          $11 = $1;
          $6 = $11 ? $15 : $9;
          $22 = $6;
          $9 = $5;
          $8 = $11 ? $10 : $9;
          $12 = $8;
          $6 = HEAP32[$7 + 428 >> 2];
          $5 = $6;
          $8 = HEAP32[$7 + 424 >> 2];
          $9 = $1;
          $10 = $9 ? $21 : $8;
          $19 = $10;
          $6 = $23;
          $8 = $5;
          $11 = $9 ? $6 : $8;
          $1 = $11;
          $11 = $16;
          $10 = $6;
          $9 = $12;
          $6 = $1;
          __addtf3($7 + 400 | 0, $15, $11, $21, $10, $22, $9, $19, $6);
          $6 = $18;
          $12 = $6 + -1 | 0;
          $10 = $17;
          $8 = $10 + -1 | 0;
          if ($8 >>> 0 < 4294967295) {
           $12 = $12 + 1 | 0
          }
          $17 = $8;
          $18 = $12;
          $12 = HEAP32[$7 + 408 >> 2];
          $21 = $12;
          $10 = HEAP32[$7 + 412 >> 2];
          $23 = $10;
          $10 = HEAP32[$7 + 400 >> 2];
          $15 = $10;
          $12 = HEAP32[$7 + 404 >> 2];
          $16 = $12;
          $14 = $14 << 1 | ($13 | 0) > -1;
          if (($14 | 0) > -1) {
           continue
          }
          break;
         }
        }
        $10 = $3;
        $12 = $10 >> 31;
        $1 = $12;
        $6 = $17;
        $11 = $10;
        $9 = $6 - $10 | 0;
        $12 = $18;
        $10 = $1;
        $8 = $10 + ($6 >>> 0 < $11 >>> 0) | 0;
        $8 = $12 - $8 | 0;
        $12 = $9;
        $9 = $8;
        $10 = $12 + 32 | 0;
        if ($10 >>> 0 < 32) {
         $9 = $9 + 1 | 0
        }
        $22 = $9;
        $1 = ($10 | 0) > 0;
        $12 = $2;
        $9 = $12 >> 31;
        $2 = $9;
        $8 = $10;
        $11 = $12;
        $9 = $22;
        $12 = $2;
        $13 = (($9 | 0) < ($12 | 0) ? 1 : ($9 | 0) <= ($12 | 0) ? ($8 >>> 0 >= $11 >>> 0 ? 0 : 1) : 0) ? ($1 ? $8 : 0) : $11;
        label$63 : {
         if (($13 | 0) >= 113) {
          __floatsitf($7 + 384 | 0, $4);
          $8 = HEAP32[$7 + 392 >> 2];
          $24 = $8;
          $9 = HEAP32[$7 + 396 >> 2];
          $22 = $9;
          $9 = HEAP32[$7 + 384 >> 2];
          $25 = $9;
          $8 = HEAP32[$7 + 388 >> 2];
          $26 = $8;
          $31 = 0;
          $32 = 0;
          $11 = 0;
          break label$63;
         }
         __extenddftf2($7 + 352 | 0, scalbn(1.0, 144 - $13 | 0));
         __floatsitf($7 + 336 | 0, $4);
         $8 = HEAP32[$7 + 352 >> 2];
         $4 = $8;
         $9 = HEAP32[$7 + 356 >> 2];
         $2 = $9;
         $9 = HEAP32[$7 + 360 >> 2];
         $3 = $9;
         $8 = HEAP32[$7 + 364 >> 2];
         $1 = $8;
         $8 = HEAP32[$7 + 336 >> 2];
         $25 = $8;
         $9 = HEAP32[$7 + 340 >> 2];
         $26 = $9;
         $9 = HEAP32[$7 + 344 >> 2];
         $24 = $9;
         $8 = HEAP32[$7 + 348 >> 2];
         $22 = $8;
         $8 = $2;
         $9 = $1;
         $11 = $26;
         $12 = $22;
         copysignl($7 + 368 | 0, $4, $8, $3, $9, $25, $11, $24, $12);
         $12 = HEAP32[$7 + 376 >> 2];
         $31 = $12;
         $11 = HEAP32[$7 + 380 >> 2];
         $32 = $11;
         $12 = HEAP32[$7 + 372 >> 2];
         $36 = $12;
         $11 = HEAP32[$7 + 368 >> 2];
        }
        $20 = $11;
        $12 = $36;
        $19 = $12;
        $1 = $7 + 320 | 0;
        $12 = $16;
        $11 = $23;
        $13 = !($14 & 1) & ((__letf2($15, $12, $21, $11, 0, 0, 0, 0) | 0) != 0 & ($13 | 0) < 32);
        __floatunsitf($1, $14 + $13 | 0);
        $8 = HEAP32[$7 + 320 >> 2];
        $2 = $8;
        $9 = HEAP32[$7 + 324 >> 2];
        $11 = $9;
        $9 = HEAP32[$7 + 328 >> 2];
        $1 = $9;
        $8 = HEAP32[$7 + 332 >> 2];
        $12 = $8;
        $8 = $26;
        $9 = $22;
        __multf3($7 + 304 | 0, $25, $8, $24, $9, $2, $11, $1, $12);
        $12 = HEAP32[$7 + 304 >> 2];
        $3 = $12;
        $12 = HEAP32[$7 + 316 >> 2];
        $1 = $12;
        $11 = HEAP32[$7 + 308 >> 2];
        $12 = $11;
        $11 = HEAP32[$7 + 312 >> 2];
        $2 = $11;
        $11 = $1;
        $9 = $19;
        $8 = $32;
        __addtf3($7 + 272 | 0, $3, $12, $2, $11, $20, $9, $31, $8);
        $6 = $13;
        $12 = $6 ? 0 : $15;
        $3 = $12;
        $9 = $16;
        $11 = $6 ? 0 : $9;
        $8 = $6 ? 0 : $21;
        $12 = $23;
        $6 = $6 ? 0 : $12;
        $1 = $6;
        $6 = $11;
        $2 = $8;
        $8 = $1;
        $9 = $26;
        $11 = $22;
        __multf3($7 + 288 | 0, $3, $6, $2, $8, $25, $9, $24, $11);
        $11 = HEAP32[$7 + 288 >> 2];
        $10 = $11;
        $9 = HEAP32[$7 + 292 >> 2];
        $2 = $9;
        $9 = HEAP32[$7 + 296 >> 2];
        $5 = $9;
        $11 = HEAP32[$7 + 300 >> 2];
        $1 = $11;
        $11 = HEAP32[$7 + 272 >> 2];
        $4 = $11;
        $9 = HEAP32[$7 + 276 >> 2];
        $8 = $9;
        $9 = HEAP32[$7 + 280 >> 2];
        $3 = $9;
        $11 = HEAP32[$7 + 284 >> 2];
        $6 = $11;
        $11 = $2;
        $9 = $1;
        __addtf3($7 + 256 | 0, $10, $11, $5, $9, $4, $8, $3, $6);
        $6 = HEAP32[$7 + 256 >> 2];
        $3 = $6;
        $6 = HEAP32[$7 + 268 >> 2];
        $1 = $6;
        $8 = HEAP32[$7 + 260 >> 2];
        $6 = $8;
        $8 = HEAP32[$7 + 264 >> 2];
        $2 = $8;
        $8 = $1;
        $9 = $19;
        $11 = $32;
        __subtf3($7 + 240 | 0, $3, $6, $2, $8, $20, $9, $31, $11);
        $11 = HEAP32[$7 + 240 >> 2];
        $15 = $11;
        $11 = HEAP32[$7 + 252 >> 2];
        $23 = $11;
        $9 = HEAP32[$7 + 244 >> 2];
        $16 = $9;
        $11 = $9;
        $9 = HEAP32[$7 + 248 >> 2];
        $21 = $9;
        $9 = $23;
        if (!__letf2($15, $11, $21, $9, 0, 0, 0, 0)) {
         HEAP32[__errno_location() >> 2] = 68
        }
        $6 = $16;
        $8 = $23;
        scalbnl($7 + 224 | 0, $15, $6, $21, $8, $17);
        $8 = HEAP32[$7 + 224 >> 2];
        $15 = $8;
        $6 = HEAP32[$7 + 228 >> 2];
        $16 = $6;
        $6 = HEAP32[$7 + 232 >> 2];
        $33 = $6;
        $8 = HEAP32[$7 + 236 >> 2];
        break label$42;
       }
       HEAP32[__errno_location() >> 2] = 68;
       __floatsitf($7 + 208 | 0, $4);
       $8 = HEAP32[$7 + 208 >> 2];
       $3 = $8;
       $8 = HEAP32[$7 + 220 >> 2];
       $1 = $8;
       $6 = HEAP32[$7 + 212 >> 2];
       $8 = $6;
       $6 = HEAP32[$7 + 216 >> 2];
       $2 = $6;
       $6 = $1;
       __multf3($7 + 192 | 0, $3, $8, $2, $6, 0, 0, 0, 65536);
       $11 = HEAP32[$7 + 192 >> 2];
       $3 = $11;
       $11 = HEAP32[$7 + 204 >> 2];
       $1 = $11;
       $9 = HEAP32[$7 + 196 >> 2];
       $11 = $9;
       $9 = HEAP32[$7 + 200 >> 2];
       $2 = $9;
       $9 = $1;
       __multf3($7 + 176 | 0, $3, $11, $2, $9, 0, 0, 0, 65536);
       $8 = HEAP32[$7 + 176 >> 2];
       $15 = $8;
       $6 = HEAP32[$7 + 180 >> 2];
       $16 = $6;
       $6 = HEAP32[$7 + 184 >> 2];
       $33 = $6;
       $8 = HEAP32[$7 + 188 >> 2];
       break label$42;
      }
     }
     if (!global$2) {
      __shlim($1, 0, 0)
     }
    }
    if (global$2) {
     $8 = $18;
     $6 = $17;
    } else {
     __extenddftf2($7 + 96 | 0, +($4 | 0) * 0.0);
     $8 = HEAP32[$7 + 96 >> 2];
     $15 = $8;
     $6 = HEAP32[$7 + 100 >> 2];
     $16 = $6;
     $8 = HEAP32[$7 + 108 >> 2];
     $6 = HEAP32[$7 + 104 >> 2];
    }
    $33 = $6;
   }
   $17 = $33;
   $18 = $8;
   if (!global$2) {
    $6 = $0;
    HEAP32[$6 >> 2] = $15;
    $8 = $16;
    HEAP32[$6 + 4 >> 2] = $8;
    HEAP32[$6 + 8 >> 2] = $17;
    $8 = $18;
    HEAP32[$6 + 12 >> 2] = $8;
    global$0 = $7 + 432 | 0;
   }
   return;
  }
  $6 = $11;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $4;
  HEAP32[$6 + 20 >> 2] = $5;
  HEAP32[$6 + 24 >> 2] = $7;
  HEAP32[$6 + 28 >> 2] = $13;
  HEAP32[$6 + 32 >> 2] = $14;
  HEAP32[$6 + 36 >> 2] = $15;
  $8 = $16;
  HEAP32[$6 + 40 >> 2] = $8;
  HEAP32[$6 + 44 >> 2] = $17;
  $8 = $18;
  HEAP32[$6 + 48 >> 2] = $8;
  HEAP32[$6 + 52 >> 2] = $20;
  $8 = $19;
  HEAP32[$6 + 56 >> 2] = $8;
  HEAP32[$6 + 60 >> 2] = $21;
  $8 = $23;
  HEAP32[$6 + 64 >> 2] = $8;
  HEAP32[$6 + 68 >> 2] = $24;
  $8 = $22;
  HEAP32[$6 + 72 >> 2] = $8;
  HEAP32[$6 + 76 >> 2] = $29;
  HEAP32[$6 + 80 >> 2] = $25;
  $8 = $26;
  HEAP32[$6 + 84 >> 2] = $8;
  HEAP32[$6 + 88 >> 2] = $28;
  HEAP32[$6 + 92 >> 2] = $27;
  HEAP32[$6 + 96 >> 2] = $31;
  $8 = $32;
  HEAP32[$6 + 100 >> 2] = $8;
  HEAP32[$6 + 104 >> 2] = $34;
  HEAP32[$6 + 108 >> 2] = $35;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 112;
 }
 
 function decfloat($0, $1, $2, $3, $4, $5, $6) {
  var $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0.0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -132;
   $11 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$11 >> 2];
   $2 = HEAP32[$11 + 8 >> 2];
   $3 = HEAP32[$11 + 12 >> 2];
   $4 = HEAP32[$11 + 16 >> 2];
   $5 = HEAP32[$11 + 20 >> 2];
   $6 = HEAP32[$11 + 24 >> 2];
   $7 = HEAP32[$11 + 28 >> 2];
   $14 = HEAP32[$11 + 32 >> 2];
   $16 = HEAP32[$11 + 36 >> 2];
   $8 = HEAP32[$11 + 40 >> 2];
   $15 = $8;
   $13 = HEAP32[$11 + 44 >> 2];
   $17 = $13;
   $13 = HEAP32[$11 + 48 >> 2];
   $18 = $13;
   $8 = HEAP32[$11 + 52 >> 2];
   $19 = $8;
   $20 = HEAP32[$11 + 56 >> 2];
   $21 = HEAP32[$11 + 60 >> 2];
   $22 = HEAP32[$11 + 64 >> 2];
   $23 = HEAP32[$11 + 68 >> 2];
   $8 = HEAP32[$11 + 72 >> 2];
   $24 = $8;
   $13 = HEAP32[$11 + 76 >> 2];
   $27 = $13;
   $13 = HEAP32[$11 + 80 >> 2];
   $25 = $13;
   $8 = HEAP32[$11 + 84 >> 2];
   $26 = $8;
   $28 = HEAP32[$11 + 88 >> 2];
   $13 = HEAP32[$11 + 96 >> 2];
   $8 = HEAP32[$11 + 92 >> 2];
   wasm2js_scratch_store_i32(0, $8 | 0);
   wasm2js_scratch_store_i32(1, $13 | 0);
   $30 = +wasm2js_scratch_load_f64();
   $31 = HEAP32[$11 + 100 >> 2];
   $13 = HEAP32[$11 + 104 >> 2];
   $32 = $13;
   $8 = HEAP32[$11 + 108 >> 2];
   $33 = $8;
   $8 = HEAP32[$11 + 112 >> 2];
   $34 = $8;
   $13 = HEAP32[$11 + 116 >> 2];
   $35 = $13;
   $37 = HEAP32[$11 + 120 >> 2];
   $38 = HEAP32[$11 + 124 >> 2];
   $39 = HEAP32[$11 + 128 >> 2];
   $1 = HEAP32[$11 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $36 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $14 = global$0;
   $7 = $14 - 8960 | 0;
   global$0 = $7;
   $20 = 0;
   $38 = $3 + $4 | 0;
   $39 = 0 - $38 | 0;
   $16 = 0;
   $15 = 0;
   $17 = 0;
  }
  label$2 : {
   label$5 : {
    label$6 : {
     while (1) {
      label$8 : {
       if (!global$2) {
        if (($2 | 0) != 48) {
         $14 = ($2 | 0) != 46;
         if ($14) {
          break label$5
         }
         $14 = HEAP32[$1 + 4 >> 2];
         $2 = $14 >>> 0 >= HEAPU32[$1 + 104 >> 2];
         if ($2) {
          break label$8
         }
         HEAP32[$1 + 4 >> 2] = $14 + 1;
         $2 = HEAPU8[$14 | 0];
         break label$6;
        }
        $14 = HEAP32[$1 + 4 >> 2];
        $2 = $14 >>> 0 < HEAPU32[$1 + 104 >> 2];
        if ($2) {
         $16 = 1;
         HEAP32[$1 + 4 >> 2] = $14 + 1;
         $2 = HEAPU8[$14 | 0];
         continue;
        }
        $16 = 1;
       }
       if (global$2 ? !$36 : 1) {
        $11 = __shgetc($1);
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $2 = $11;
       }
       if (!global$2) {
        continue
       }
      }
      break;
     };
     if (global$2 ? ($36 | 0) == 1 : 1) {
      $11 = __shgetc($1);
      $10 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $2 = $11;
     }
    }
    if (!global$2) {
     $20 = 1;
     $15 = 0;
     $17 = 0;
     $14 = ($2 | 0) != 48;
     if ($14) {
      break label$5
     }
    }
    while (1) {
     if (!global$2) {
      $14 = HEAP32[$1 + 4 >> 2];
      $2 = $14 >>> 0 < HEAPU32[$1 + 104 >> 2];
     }
     label$18 : {
      if (!global$2) {
       if ($2) {
        HEAP32[$1 + 4 >> 2] = $14 + 1;
        $2 = HEAPU8[$14 | 0];
        break label$18;
       }
      }
      if (global$2 ? ($36 | 0) == 2 : 1) {
       $11 = __shgetc($1);
       $10 = 2;
       if ((global$2 | 0) == 1) {
        break label$2
       }
       $2 = $11;
      }
     }
     if (!global$2) {
      $13 = $17;
      $9 = $13 + -1 | 0;
      $11 = $15;
      $10 = $11 + -1 | 0;
      if ($10 >>> 0 < 4294967295) {
       $9 = $9 + 1 | 0
      }
      $15 = $10;
      $17 = $9;
      $14 = ($2 | 0) == 48;
      if ($14) {
       continue
      }
     }
     break;
    };
    if (!global$2) {
     $20 = 1;
     $16 = 1;
    }
   }
   if (!global$2) {
    $28 = 0;
    HEAP32[$7 + 768 >> 2] = 0;
    $22 = $2 + -48 | 0;
    $21 = ($2 | 0) == 46;
   }
   label$26 : {
    label$27 : {
     label$28 : {
      label$29 : {
       label$30 : {
        label$31 : {
         if (!global$2) {
          label$33 : {
           if ($21) {
            break label$33
           }
           $18 = 0;
           $19 = 0;
           if ($22 >>> 0 <= 9) {
            break label$33
           }
           $14 = 0;
           $23 = 0;
           break label$31;
          }
          $18 = 0;
          $19 = 0;
          $23 = 0;
          $28 = 0;
          $14 = 0;
         }
         while (1) {
          if (!global$2) {
           label$36 : {
            if ($21 & 1) {
             if (!$20) {
              $15 = $18;
              $9 = $19;
              $17 = $9;
              $20 = 1;
              break label$36;
             }
             $16 = ($16 | 0) != 0;
             break label$30;
            }
            $9 = $19;
            $10 = $9;
            $13 = $18;
            $8 = $13 + 1 | 0;
            if ($8 >>> 0 < 1) {
             $10 = $10 + 1 | 0
            }
            $18 = $8;
            $19 = $10;
            if (($14 | 0) <= 2044) {
             $28 = ($2 | 0) != 48 ? $18 : $28;
             $16 = ($7 + 768 | 0) + ($14 << 2) | 0;
             HEAP32[$16 >> 2] = $23 ? (Math_imul(HEAP32[$16 >> 2], 10) + $2 | 0) + -48 | 0 : $22;
             $16 = 1;
             $2 = $23 + 1 | 0;
             $8 = $2;
             $2 = ($2 | 0) == 9;
             $23 = $2 ? 0 : $8;
             $14 = $2 + $14 | 0;
             break label$36;
            }
            if (($2 | 0) == 48) {
             break label$36
            }
            HEAP32[$7 + 8944 >> 2] = HEAP32[$7 + 8944 >> 2] | 1;
           }
           $2 = HEAP32[$1 + 4 >> 2];
           $21 = $2 >>> 0 < HEAPU32[$1 + 104 >> 2];
          }
          label$42 : {
           if (!global$2) {
            if ($21) {
             $21 = $2 + 1 | 0;
             HEAP32[$1 + 4 >> 2] = $21;
             $2 = HEAPU8[$2 | 0];
             break label$42;
            }
           }
           if (global$2 ? ($36 | 0) == 3 : 1) {
            $11 = __shgetc($1);
            $10 = 3;
            if ((global$2 | 0) == 1) {
             break label$2
            }
            $2 = $11;
           }
          }
          if (!global$2) {
           $21 = ($2 | 0) == 46;
           $22 = $2 + -48 | 0;
           if ($21 | $22 >>> 0 < 10) {
            continue
           }
          }
          break;
         };
        }
        if (!global$2) {
         $11 = $20;
         $12 = $11 ? $15 : $18;
         $15 = $12;
         $21 = !$16;
         $10 = $17;
         $13 = $19;
         $9 = $11 ? $10 : $13;
         $17 = $9;
        }
        if (!(($2 | 32) != 101 | $21 ? !global$2 : 0)) {
         if (global$2 ? ($36 | 0) == 4 : 1) {
          $9 = scanexp($1, $6);
          $12 = i64toi32_i32$HIGH_BITS;
          $10 = 4;
          if ((global$2 | 0) == 1) {
           break label$2
          }
          $27 = $12;
          $24 = $9;
         }
         if (!global$2) {
          $11 = $24;
          $12 = $27;
          label$53 : {
           if ($11 | ($12 | 0) != -2147483648) {
            break label$53
           }
           if (!$6) {
            break label$28
           }
           $24 = 0;
           $27 = 0;
           if (!HEAP32[$1 + 104 >> 2]) {
            break label$53
           }
           HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + -1;
          }
          $11 = $17;
          $12 = $27;
          $8 = $11 + $12 | 0;
          $10 = $15;
          $9 = $24;
          $13 = $10 + $9 | 0;
          if ($13 >>> 0 < $9 >>> 0) {
           $8 = $8 + 1 | 0
          }
          $15 = $13;
          $17 = $8;
          break label$27;
         }
        }
        if (!global$2) {
         $16 = ($16 | 0) != 0;
         if (($2 | 0) < 0) {
          break label$29
         }
        }
       }
       if (!global$2) {
        if (!HEAP32[$1 + 104 >> 2]) {
         break label$29
        }
        HEAP32[$1 + 4 >> 2] = HEAP32[$1 + 4 >> 2] + -1;
       }
      }
      if (!global$2) {
       if ($16) {
        break label$27
       }
       HEAP32[__errno_location() >> 2] = 28;
      }
     }
     if (!global$2) {
      $18 = 0;
      $19 = 0;
      __shlim($1, 0, 0);
      $8 = 0;
      break label$26;
     }
    }
    if (global$2) {
     $8 = $17;
     $12 = $8;
    } else {
     $1 = HEAP32[$7 + 768 >> 2];
     if (!$1) {
      __extenddftf2($7, +($5 | 0) * 0.0);
      $8 = HEAP32[$7 >> 2];
      $18 = $8;
      $10 = HEAP32[$7 + 4 >> 2];
      $19 = $10;
      $10 = HEAP32[$7 + 8 >> 2];
      $29 = $10;
      $8 = HEAP32[$7 + 12 >> 2];
      break label$26;
     }
     label$61 : {
      $11 = $18;
      $8 = $19;
      if (($8 | 0) > 0 ? 1 : ($8 | 0) >= 0 ? ($11 >>> 0 <= 9 ? 0 : 1) : 0) {
       break label$61
      }
      $10 = $18;
      $9 = $15;
      $11 = $17;
      if (($10 | 0) != ($9 | 0) | ($19 | 0) != ($11 | 0) | ($1 >>> $3 | 0 ? ($3 | 0) <= 30 : 0)) {
       break label$61
      }
      __floatsitf($7 + 48 | 0, $5);
      __floatunsitf($7 + 32 | 0, $1);
      $9 = HEAP32[$7 + 48 >> 2];
      $3 = $9;
      $11 = HEAP32[$7 + 52 >> 2];
      $1 = $11;
      $11 = HEAP32[$7 + 56 >> 2];
      $4 = $11;
      $9 = HEAP32[$7 + 60 >> 2];
      $2 = $9;
      $9 = HEAP32[$7 + 32 >> 2];
      $5 = $9;
      $11 = HEAP32[$7 + 36 >> 2];
      $10 = $11;
      $11 = HEAP32[$7 + 40 >> 2];
      $6 = $11;
      $9 = HEAP32[$7 + 44 >> 2];
      $8 = $9;
      $9 = $1;
      $11 = $2;
      __multf3($7 + 16 | 0, $3, $9, $4, $11, $5, $10, $6, $8);
      $8 = HEAP32[$7 + 16 >> 2];
      $18 = $8;
      $10 = HEAP32[$7 + 20 >> 2];
      $19 = $10;
      $10 = HEAP32[$7 + 24 >> 2];
      $29 = $10;
      $8 = HEAP32[$7 + 28 >> 2];
      break label$26;
     }
     $10 = ($4 | 0) / -2 | 0;
     $8 = $10 >> 31;
     $1 = $8;
     $11 = $15;
     $9 = $10;
     $8 = $17;
     $10 = $1;
     if (($8 | 0) > ($10 | 0) ? 1 : ($8 | 0) >= ($10 | 0) ? ($11 >>> 0 <= $9 >>> 0 ? 0 : 1) : 0) {
      HEAP32[__errno_location() >> 2] = 68;
      __floatsitf($7 + 96 | 0, $5);
      $11 = HEAP32[$7 + 96 >> 2];
      $2 = $11;
      $11 = HEAP32[$7 + 108 >> 2];
      $1 = $11;
      $8 = HEAP32[$7 + 100 >> 2];
      $11 = $8;
      $8 = HEAP32[$7 + 104 >> 2];
      $3 = $8;
      $8 = $1;
      __multf3($7 + 80 | 0, $2, $11, $3, $8, -1, -1, -1, 2147418111);
      $10 = HEAP32[$7 + 80 >> 2];
      $2 = $10;
      $10 = HEAP32[$7 + 92 >> 2];
      $1 = $10;
      $9 = HEAP32[$7 + 84 >> 2];
      $10 = $9;
      $9 = HEAP32[$7 + 88 >> 2];
      $3 = $9;
      $9 = $1;
      __multf3($7 - -64 | 0, $2, $10, $3, $9, -1, -1, -1, 2147418111);
      $11 = HEAP32[$7 + 64 >> 2];
      $18 = $11;
      $8 = HEAP32[$7 + 68 >> 2];
      $19 = $8;
      $8 = HEAP32[$7 + 72 >> 2];
      $29 = $8;
      $11 = HEAP32[$7 + 76 >> 2];
      $8 = $11;
      break label$26;
     }
     $8 = $4 + -226 | 0;
     $11 = $8 >> 31;
     $1 = $11;
     $9 = $15;
     $10 = $8;
     $11 = $17;
     $8 = $1;
     if (($11 | 0) < ($8 | 0) ? 1 : ($11 | 0) <= ($8 | 0) ? ($9 >>> 0 >= $10 >>> 0 ? 0 : 1) : 0) {
      HEAP32[__errno_location() >> 2] = 68;
      __floatsitf($7 + 144 | 0, $5);
      $9 = HEAP32[$7 + 144 >> 2];
      $2 = $9;
      $9 = HEAP32[$7 + 156 >> 2];
      $1 = $9;
      $11 = HEAP32[$7 + 148 >> 2];
      $9 = $11;
      $11 = HEAP32[$7 + 152 >> 2];
      $3 = $11;
      $11 = $1;
      __multf3($7 + 128 | 0, $2, $9, $3, $11, 0, 0, 0, 65536);
      $8 = HEAP32[$7 + 128 >> 2];
      $2 = $8;
      $8 = HEAP32[$7 + 140 >> 2];
      $1 = $8;
      $10 = HEAP32[$7 + 132 >> 2];
      $8 = $10;
      $10 = HEAP32[$7 + 136 >> 2];
      $3 = $10;
      $10 = $1;
      __multf3($7 + 112 | 0, $2, $8, $3, $10, 0, 0, 0, 65536);
      $9 = HEAP32[$7 + 112 >> 2];
      $18 = $9;
      $11 = HEAP32[$7 + 116 >> 2];
      $19 = $11;
      $11 = HEAP32[$7 + 120 >> 2];
      $29 = $11;
      $9 = HEAP32[$7 + 124 >> 2];
      $8 = $9;
      break label$26;
     }
     if ($23) {
      if (($23 | 0) <= 8) {
       $2 = ($7 + 768 | 0) + ($14 << 2) | 0;
       $1 = HEAP32[$2 >> 2];
       while (1) {
        $1 = Math_imul($1, 10);
        $23 = $23 + 1 | 0;
        if (($23 | 0) != 9) {
         continue
        }
        break;
       };
       HEAP32[$2 >> 2] = $1;
      }
      $14 = $14 + 1 | 0;
     }
     label$67 : {
      $20 = $15;
      if (($28 | 0) > 8 | ($28 | 0) > ($20 | 0) | ($20 | 0) > 17) {
       break label$67
      }
      if (($20 | 0) == 9) {
       __floatsitf($7 + 192 | 0, $5);
       __floatunsitf($7 + 176 | 0, HEAP32[$7 + 768 >> 2]);
       $9 = HEAP32[$7 + 192 >> 2];
       $3 = $9;
       $11 = HEAP32[$7 + 196 >> 2];
       $1 = $11;
       $11 = HEAP32[$7 + 200 >> 2];
       $4 = $11;
       $9 = HEAP32[$7 + 204 >> 2];
       $2 = $9;
       $9 = HEAP32[$7 + 176 >> 2];
       $5 = $9;
       $11 = HEAP32[$7 + 180 >> 2];
       $10 = $11;
       $11 = HEAP32[$7 + 184 >> 2];
       $6 = $11;
       $9 = HEAP32[$7 + 188 >> 2];
       $8 = $9;
       $9 = $1;
       $11 = $2;
       __multf3($7 + 160 | 0, $3, $9, $4, $11, $5, $10, $6, $8);
       $8 = HEAP32[$7 + 160 >> 2];
       $18 = $8;
       $10 = HEAP32[$7 + 164 >> 2];
       $19 = $10;
       $10 = HEAP32[$7 + 168 >> 2];
       $29 = $10;
       $8 = HEAP32[$7 + 172 >> 2];
       break label$26;
      }
      if (($20 | 0) <= 8) {
       __floatsitf($7 + 272 | 0, $5);
       __floatunsitf($7 + 256 | 0, HEAP32[$7 + 768 >> 2]);
       $8 = HEAP32[$7 + 272 >> 2];
       $3 = $8;
       $10 = HEAP32[$7 + 276 >> 2];
       $1 = $10;
       $10 = HEAP32[$7 + 280 >> 2];
       $4 = $10;
       $8 = HEAP32[$7 + 284 >> 2];
       $2 = $8;
       $8 = HEAP32[$7 + 256 >> 2];
       $5 = $8;
       $10 = HEAP32[$7 + 260 >> 2];
       $11 = $10;
       $10 = HEAP32[$7 + 264 >> 2];
       $6 = $10;
       $8 = HEAP32[$7 + 268 >> 2];
       $9 = $8;
       $8 = $1;
       $10 = $2;
       __multf3($7 + 240 | 0, $3, $8, $4, $10, $5, $11, $6, $9);
       __floatsitf($7 + 224 | 0, HEAP32[(0 - $20 << 2) + 13248 >> 2]);
       $9 = HEAP32[$7 + 240 >> 2];
       $3 = $9;
       $11 = HEAP32[$7 + 244 >> 2];
       $1 = $11;
       $11 = HEAP32[$7 + 248 >> 2];
       $4 = $11;
       $9 = HEAP32[$7 + 252 >> 2];
       $2 = $9;
       $9 = HEAP32[$7 + 224 >> 2];
       $5 = $9;
       $11 = HEAP32[$7 + 228 >> 2];
       $10 = $11;
       $11 = HEAP32[$7 + 232 >> 2];
       $6 = $11;
       $9 = HEAP32[$7 + 236 >> 2];
       $8 = $9;
       $9 = $1;
       $11 = $2;
       __divtf3($7 + 208 | 0, $3, $9, $4, $11, $5, $10, $6, $8);
       $8 = HEAP32[$7 + 208 >> 2];
       $18 = $8;
       $10 = HEAP32[$7 + 212 >> 2];
       $19 = $10;
       $10 = HEAP32[$7 + 216 >> 2];
       $29 = $10;
       $8 = HEAP32[$7 + 220 >> 2];
       break label$26;
      }
      $2 = (Math_imul($20, -3) + $3 | 0) + 27 | 0;
      $1 = HEAP32[$7 + 768 >> 2];
      if ($1 >>> $2 | 0 ? ($2 | 0) <= 30 : 0) {
       break label$67
      }
      __floatsitf($7 + 352 | 0, $5);
      __floatunsitf($7 + 336 | 0, $1);
      $8 = HEAP32[$7 + 352 >> 2];
      $3 = $8;
      $10 = HEAP32[$7 + 356 >> 2];
      $1 = $10;
      $10 = HEAP32[$7 + 360 >> 2];
      $4 = $10;
      $8 = HEAP32[$7 + 364 >> 2];
      $2 = $8;
      $8 = HEAP32[$7 + 336 >> 2];
      $5 = $8;
      $10 = HEAP32[$7 + 340 >> 2];
      $11 = $10;
      $10 = HEAP32[$7 + 344 >> 2];
      $6 = $10;
      $8 = HEAP32[$7 + 348 >> 2];
      $9 = $8;
      $8 = $1;
      $10 = $2;
      __multf3($7 + 320 | 0, $3, $8, $4, $10, $5, $11, $6, $9);
      __floatsitf($7 + 304 | 0, HEAP32[($20 << 2) + 13176 >> 2]);
      $9 = HEAP32[$7 + 320 >> 2];
      $3 = $9;
      $11 = HEAP32[$7 + 324 >> 2];
      $1 = $11;
      $11 = HEAP32[$7 + 328 >> 2];
      $4 = $11;
      $9 = HEAP32[$7 + 332 >> 2];
      $2 = $9;
      $9 = HEAP32[$7 + 304 >> 2];
      $5 = $9;
      $11 = HEAP32[$7 + 308 >> 2];
      $10 = $11;
      $11 = HEAP32[$7 + 312 >> 2];
      $6 = $11;
      $9 = HEAP32[$7 + 316 >> 2];
      $8 = $9;
      $9 = $1;
      $11 = $2;
      __multf3($7 + 288 | 0, $3, $9, $4, $11, $5, $10, $6, $8);
      $8 = HEAP32[$7 + 288 >> 2];
      $18 = $8;
      $10 = HEAP32[$7 + 292 >> 2];
      $19 = $10;
      $10 = HEAP32[$7 + 296 >> 2];
      $29 = $10;
      $8 = HEAP32[$7 + 300 >> 2];
      break label$26;
     }
     $23 = 0;
     $1 = ($20 | 0) % 9 | 0;
     label$70 : {
      if (!$1) {
       $2 = 0;
       break label$70;
      }
      $6 = ($20 | 0) > -1 ? $1 : $1 + 9 | 0;
      label$72 : {
       if (!$14) {
        $2 = 0;
        $14 = 0;
        break label$72;
       }
       $21 = HEAP32[(0 - $6 << 2) + 13248 >> 2];
       $31 = 1e9 / ($21 | 0) | 0;
       $16 = 0;
       $1 = 0;
       $2 = 0;
       while (1) {
        $22 = ($7 + 768 | 0) + ($1 << 2) | 0;
        $8 = $22;
        $22 = HEAP32[$22 >> 2];
        $28 = ($22 >>> 0) / ($21 >>> 0) | 0;
        $16 = $28 + $16 | 0;
        HEAP32[$8 >> 2] = $16;
        $16 = !$16 & ($1 | 0) == ($2 | 0);
        $2 = $16 ? $2 + 1 & 2047 : $2;
        $20 = $16 ? $20 + -9 | 0 : $20;
        $16 = Math_imul($22 - Math_imul($21, $28) | 0, $31);
        $1 = $1 + 1 | 0;
        if (($14 | 0) != ($1 | 0)) {
         continue
        }
        break;
       };
       if (!$16) {
        break label$72
       }
       HEAP32[($7 + 768 | 0) + ($14 << 2) >> 2] = $16;
       $14 = $14 + 1 | 0;
      }
      $20 = ($20 - $6 | 0) + 9 | 0;
     }
     while (1) {
      $28 = ($7 + 768 | 0) + ($2 << 2) | 0;
      label$76 : {
       while (1) {
        if (($20 | 0) != 36 | HEAPU32[$28 >> 2] >= 10384593 ? ($20 | 0) >= 36 : 0) {
         break label$76
        }
        $22 = $14 + 2047 | 0;
        $16 = 0;
        $21 = $14;
        while (1) {
         $14 = $21;
         $1 = $22 & 2047;
         $21 = ($7 + 768 | 0) + ($1 << 2) | 0;
         $11 = $21;
         $8 = HEAP32[$11 >> 2];
         $9 = $8 << 29;
         $8 = $8 >>> 3 | 0;
         $13 = $8;
         $10 = $16;
         $12 = $10 + $9 | 0;
         if ($12 >>> 0 < $9 >>> 0) {
          $13 = $13 + 1 | 0
         }
         $15 = $12;
         $16 = 0;
         $17 = $13;
         $8 = $12;
         $6 = !$13 & $8 >>> 0 < 1000000001 | $13 >>> 0 < 0;
         if (!$6) {
          $8 = $17;
          $13 = __wasm_i64_udiv($15, $8, 1e9, 0);
          $18 = $13;
          $8 = i64toi32_i32$HIGH_BITS;
          $19 = $8;
          $13 = __wasm_i64_mul($18, $8, 1e9, 0);
          $8 = i64toi32_i32$HIGH_BITS;
          $6 = $8;
          $9 = $15;
          $10 = $13;
          $11 = $9 - $10 | 0;
          $15 = $11;
          $8 = $17;
          $13 = $6;
          $12 = $13 + ($9 >>> 0 < $10 >>> 0) | 0;
          $12 = $8 - $12 | 0;
          $17 = $12;
          $16 = $18;
         }
         HEAP32[$21 >> 2] = $15;
         $21 = ($14 + -1 & 2047) != ($1 | 0) ? $14 : ($1 | 0) == ($2 | 0) ? $14 : $15 ? $14 : $1;
         $22 = $1 + -1 | 0;
         if (($1 | 0) != ($2 | 0)) {
          continue
         }
         break;
        };
        $23 = $23 + -29 | 0;
        if (!$16) {
         continue
        }
        break;
       };
       $2 = $2 + -1 & 2047;
       if (($21 | 0) == ($2 | 0)) {
        $1 = ($7 + 768 | 0) + (($21 + 2046 & 2047) << 2) | 0;
        $6 = HEAP32[$1 >> 2];
        $14 = $21 + -1 & 2047;
        HEAP32[$1 >> 2] = HEAP32[($7 + 768 | 0) + ($14 << 2) >> 2] | $6;
       }
       $20 = $20 + 9 | 0;
       HEAP32[($7 + 768 | 0) + ($2 << 2) >> 2] = $16;
       continue;
      }
      break;
     };
     label$82 : {
      label$83 : while (1) {
       $6 = $14 + 1 & 2047;
       $37 = ($7 + 768 | 0) + (($14 + -1 & 2047) << 2) | 0;
       while (1) {
        $22 = ($20 | 0) > 45 ? 9 : 1;
        label$85 : {
         while (1) {
          $21 = $2;
          $1 = 0;
          label$87 : {
           while (1) {
            label$89 : {
             $2 = $1 + $21 & 2047;
             if (($14 | 0) == ($2 | 0)) {
              break label$89
             }
             $2 = HEAP32[($7 + 768 | 0) + ($2 << 2) >> 2];
             $16 = HEAP32[($1 << 2) + 13200 >> 2];
             if ($2 >>> 0 < $16 >>> 0) {
              break label$89
             }
             if ($2 >>> 0 > $16 >>> 0) {
              break label$87
             }
             $1 = $1 + 1 | 0;
             if (($1 | 0) != 4) {
              continue
             }
            }
            break;
           };
           if (($20 | 0) != 36) {
            break label$87
           }
           $15 = 0;
           $17 = 0;
           $1 = 0;
           $18 = 0;
           $19 = 0;
           while (1) {
            $2 = $1 + $21 & 2047;
            if (($14 | 0) == ($2 | 0)) {
             $14 = $14 + 1 & 2047;
             HEAP32[(($14 << 2) + $7 | 0) + 764 >> 2] = 0;
            }
            $12 = $17;
            $9 = $19;
            __multf3($7 + 752 | 0, $15, $12, $18, $9, 0, 0, 1342177280, 1075633366);
            __floatunsitf($7 + 736 | 0, HEAP32[($7 + 768 | 0) + ($2 << 2) >> 2]);
            $10 = HEAP32[$7 + 752 >> 2];
            $11 = $10;
            $8 = HEAP32[$7 + 756 >> 2];
            $2 = $8;
            $8 = HEAP32[$7 + 760 >> 2];
            $17 = $8;
            $10 = HEAP32[$7 + 764 >> 2];
            $6 = $10;
            $10 = HEAP32[$7 + 736 >> 2];
            $19 = $10;
            $8 = HEAP32[$7 + 740 >> 2];
            $9 = $8;
            $8 = HEAP32[$7 + 744 >> 2];
            $15 = $8;
            $10 = HEAP32[$7 + 748 >> 2];
            $12 = $10;
            $10 = $2;
            $8 = $6;
            __addtf3($7 + 720 | 0, $11, $10, $17, $8, $19, $9, $15, $12);
            $12 = HEAP32[$7 + 728 >> 2];
            $18 = $12;
            $9 = HEAP32[$7 + 732 >> 2];
            $19 = $9;
            $9 = HEAP32[$7 + 720 >> 2];
            $15 = $9;
            $12 = HEAP32[$7 + 724 >> 2];
            $17 = $12;
            $1 = $1 + 1 | 0;
            if (($1 | 0) != 4) {
             continue
            }
            break;
           };
           __floatsitf($7 + 704 | 0, $5);
           $12 = HEAP32[$7 + 704 >> 2];
           $1 = $12;
           $9 = HEAP32[$7 + 708 >> 2];
           $8 = $9;
           $9 = HEAP32[$7 + 712 >> 2];
           $2 = $9;
           $12 = HEAP32[$7 + 716 >> 2];
           $10 = $12;
           $12 = $17;
           $9 = $19;
           __multf3($7 + 688 | 0, $15, $12, $18, $9, $1, $8, $2, $10);
           $10 = HEAP32[$7 + 696 >> 2];
           $18 = $10;
           $8 = HEAP32[$7 + 700 >> 2];
           $19 = $8;
           $15 = 0;
           $17 = 0;
           $8 = HEAP32[$7 + 688 >> 2];
           $24 = $8;
           $10 = HEAP32[$7 + 692 >> 2];
           $27 = $10;
           $16 = $23 + 113 | 0;
           $1 = $16 - $4 | 0;
           $2 = ($1 | 0) > 0;
           $22 = ($1 | 0) < ($3 | 0);
           $2 = $22 ? ($2 ? $1 : 0) : $3;
           if (($2 | 0) <= 112) {
            break label$85
           }
           $25 = 0;
           $26 = 0;
           $32 = 0;
           $33 = 0;
           $34 = 0;
           $35 = 0;
           break label$82;
          }
          $23 = $22 + $23 | 0;
          $2 = $14;
          if (($21 | 0) == ($2 | 0)) {
           continue
          }
          break;
         };
         $28 = 1e9 >>> $22 | 0;
         $31 = -1 << $22 ^ -1;
         $1 = 0;
         $2 = $21;
         while (1) {
          $16 = ($7 + 768 | 0) + ($21 << 2) | 0;
          $8 = $16;
          $16 = HEAP32[$16 >> 2];
          $1 = ($16 >>> $22 | 0) + $1 | 0;
          HEAP32[$8 >> 2] = $1;
          $1 = !$1 & ($2 | 0) == ($21 | 0);
          $2 = $1 ? $2 + 1 & 2047 : $2;
          $20 = $1 ? $20 + -9 | 0 : $20;
          $1 = Math_imul($16 & $31, $28);
          $21 = $21 + 1 & 2047;
          if (($21 | 0) != ($14 | 0)) {
           continue
          }
          break;
         };
         if (!$1) {
          continue
         }
         if (($2 | 0) != ($6 | 0)) {
          HEAP32[($7 + 768 | 0) + ($14 << 2) >> 2] = $1;
          $14 = $6;
          continue label$83;
         }
         HEAP32[$37 >> 2] = HEAP32[$37 >> 2] | 1;
         $2 = $6;
         continue;
        }
        break;
       };
       break;
      };
      __extenddftf2($7 + 640 | 0, scalbn(1.0, 225 - $2 | 0));
      $10 = HEAP32[$7 + 640 >> 2];
      $4 = $10;
      $10 = HEAP32[$7 + 652 >> 2];
      $3 = $10;
      $8 = HEAP32[$7 + 644 >> 2];
      $10 = $8;
      $8 = HEAP32[$7 + 648 >> 2];
      $6 = $8;
      $8 = $3;
      $9 = $27;
      $12 = $19;
      copysignl($7 + 672 | 0, $4, $10, $6, $8, $24, $9, $18, $12);
      $12 = HEAP32[$7 + 680 >> 2];
      $34 = $12;
      $9 = HEAP32[$7 + 684 >> 2];
      $35 = $9;
      $9 = HEAP32[$7 + 672 >> 2];
      $32 = $9;
      $12 = HEAP32[$7 + 676 >> 2];
      $33 = $12;
      __extenddftf2($7 + 624 | 0, scalbn(1.0, 113 - $2 | 0));
      $12 = HEAP32[$7 + 624 >> 2];
      $3 = $12;
      $9 = HEAP32[$7 + 628 >> 2];
      $8 = $9;
      $9 = HEAP32[$7 + 632 >> 2];
      $4 = $9;
      $12 = HEAP32[$7 + 636 >> 2];
      $10 = $12;
      $12 = $27;
      $9 = $19;
      fmodl($7 + 656 | 0, $24, $12, $18, $9, $3, $8, $4, $10);
      $10 = HEAP32[$7 + 656 >> 2];
      $15 = $10;
      $8 = HEAP32[$7 + 660 >> 2];
      $17 = $8;
      $8 = HEAP32[$7 + 664 >> 2];
      $25 = $8;
      $10 = HEAP32[$7 + 668 >> 2];
      $26 = $10;
      $10 = $12;
      $8 = $9;
      $9 = $17;
      $12 = $26;
      __subtf3($7 + 608 | 0, $24, $10, $18, $8, $15, $9, $25, $12);
      $12 = HEAP32[$7 + 608 >> 2];
      $3 = $12;
      $9 = HEAP32[$7 + 612 >> 2];
      $8 = $9;
      $9 = HEAP32[$7 + 616 >> 2];
      $4 = $9;
      $12 = HEAP32[$7 + 620 >> 2];
      $10 = $12;
      $12 = $33;
      $9 = $35;
      __addtf3($7 + 592 | 0, $32, $12, $34, $9, $3, $8, $4, $10);
      $10 = HEAP32[$7 + 600 >> 2];
      $18 = $10;
      $8 = HEAP32[$7 + 604 >> 2];
      $19 = $8;
      $8 = HEAP32[$7 + 592 >> 2];
      $24 = $8;
      $10 = HEAP32[$7 + 596 >> 2];
      $27 = $10;
     }
     $20 = $21 + 4 & 2047;
     label$94 : {
      if (($20 | 0) == ($14 | 0)) {
       break label$94
      }
      $20 = HEAP32[($7 + 768 | 0) + ($20 << 2) >> 2];
      label$95 : {
       if ($20 >>> 0 <= 499999999) {
        if (($21 + 5 & 2047) == ($14 | 0) ? !$20 : 0) {
         break label$95
        }
        __extenddftf2($7 + 480 | 0, +($5 | 0) * .25);
        $10 = HEAP32[$7 + 480 >> 2];
        $3 = $10;
        $8 = HEAP32[$7 + 484 >> 2];
        $9 = $8;
        $8 = HEAP32[$7 + 488 >> 2];
        $4 = $8;
        $10 = HEAP32[$7 + 492 >> 2];
        $12 = $10;
        $10 = $17;
        $8 = $26;
        __addtf3($7 + 464 | 0, $15, $10, $25, $8, $3, $9, $4, $12);
        $12 = HEAP32[$7 + 472 >> 2];
        $25 = $12;
        $9 = HEAP32[$7 + 476 >> 2];
        $26 = $9;
        $9 = HEAP32[$7 + 464 >> 2];
        $15 = $9;
        $12 = HEAP32[$7 + 468 >> 2];
        $17 = $12;
        break label$95;
       }
       if (($20 | 0) != 5e8) {
        __extenddftf2($7 + 576 | 0, +($5 | 0) * .75);
        $12 = HEAP32[$7 + 576 >> 2];
        $3 = $12;
        $9 = HEAP32[$7 + 580 >> 2];
        $8 = $9;
        $9 = HEAP32[$7 + 584 >> 2];
        $4 = $9;
        $12 = HEAP32[$7 + 588 >> 2];
        $10 = $12;
        $12 = $17;
        $9 = $26;
        __addtf3($7 + 560 | 0, $15, $12, $25, $9, $3, $8, $4, $10);
        $10 = HEAP32[$7 + 568 >> 2];
        $25 = $10;
        $8 = HEAP32[$7 + 572 >> 2];
        $26 = $8;
        $8 = HEAP32[$7 + 560 >> 2];
        $15 = $8;
        $10 = HEAP32[$7 + 564 >> 2];
        $17 = $10;
        break label$95;
       }
       $30 = +($5 | 0);
       if (($21 + 5 & 2047) == ($14 | 0)) {
        __extenddftf2($7 + 512 | 0, $30 * .5);
        $10 = HEAP32[$7 + 512 >> 2];
        $3 = $10;
        $8 = HEAP32[$7 + 516 >> 2];
        $9 = $8;
        $8 = HEAP32[$7 + 520 >> 2];
        $4 = $8;
        $10 = HEAP32[$7 + 524 >> 2];
        $12 = $10;
        $10 = $17;
        $8 = $26;
        __addtf3($7 + 496 | 0, $15, $10, $25, $8, $3, $9, $4, $12);
        $12 = HEAP32[$7 + 504 >> 2];
        $25 = $12;
        $9 = HEAP32[$7 + 508 >> 2];
        $26 = $9;
        $9 = HEAP32[$7 + 496 >> 2];
        $15 = $9;
        $12 = HEAP32[$7 + 500 >> 2];
        $17 = $12;
        break label$95;
       }
       __extenddftf2($7 + 544 | 0, $30 * .75);
       $12 = HEAP32[$7 + 544 >> 2];
       $3 = $12;
       $9 = HEAP32[$7 + 548 >> 2];
       $8 = $9;
       $9 = HEAP32[$7 + 552 >> 2];
       $4 = $9;
       $12 = HEAP32[$7 + 556 >> 2];
       $10 = $12;
       $12 = $17;
       $9 = $26;
       __addtf3($7 + 528 | 0, $15, $12, $25, $9, $3, $8, $4, $10);
       $10 = HEAP32[$7 + 536 >> 2];
       $25 = $10;
       $8 = HEAP32[$7 + 540 >> 2];
       $26 = $8;
       $8 = HEAP32[$7 + 528 >> 2];
       $15 = $8;
       $10 = HEAP32[$7 + 532 >> 2];
       $17 = $10;
      }
      if (($2 | 0) > 111) {
       break label$94
      }
      $10 = $17;
      $8 = $26;
      fmodl($7 + 448 | 0, $15, $10, $25, $8, 0, 0, 0, 1073676288);
      $12 = HEAP32[$7 + 448 >> 2];
      $4 = $12;
      $12 = HEAP32[$7 + 460 >> 2];
      $3 = $12;
      $9 = HEAP32[$7 + 452 >> 2];
      $12 = $9;
      $9 = HEAP32[$7 + 456 >> 2];
      $5 = $9;
      $9 = $3;
      if (__letf2($4, $12, $5, $9, 0, 0, 0, 0)) {
       break label$94
      }
      $10 = $17;
      $8 = $26;
      __addtf3($7 + 432 | 0, $15, $10, $25, $8, 0, 0, 0, 1073676288);
      $12 = HEAP32[$7 + 440 >> 2];
      $25 = $12;
      $9 = HEAP32[$7 + 444 >> 2];
      $26 = $9;
      $9 = HEAP32[$7 + 432 >> 2];
      $15 = $9;
      $12 = HEAP32[$7 + 436 >> 2];
      $17 = $12;
     }
     $12 = $27;
     $9 = $19;
     $8 = $17;
     $10 = $26;
     __addtf3($7 + 416 | 0, $24, $12, $18, $9, $15, $8, $25, $10);
     $10 = HEAP32[$7 + 416 >> 2];
     $4 = $10;
     $10 = HEAP32[$7 + 428 >> 2];
     $3 = $10;
     $8 = HEAP32[$7 + 420 >> 2];
     $10 = $8;
     $8 = HEAP32[$7 + 424 >> 2];
     $5 = $8;
     $8 = $3;
     $9 = $33;
     $12 = $35;
     __subtf3($7 + 400 | 0, $4, $10, $5, $8, $32, $9, $34, $12);
     $12 = HEAP32[$7 + 408 >> 2];
     $18 = $12;
     $9 = HEAP32[$7 + 412 >> 2];
     $19 = $9;
     $9 = HEAP32[$7 + 400 >> 2];
     $24 = $9;
     $12 = HEAP32[$7 + 404 >> 2];
     $27 = $12;
     label$99 : {
      if (($16 & 2147483647) <= (-2 - $38 | 0)) {
       break label$99
      }
      $12 = $27;
      $9 = $19;
      __multf3($7 + 384 | 0, $24, $12, $18, $9, 0, 0, 0, 1073610752);
      $10 = $17;
      $8 = $26;
      $16 = __letf2($15, $10, $25, $8, 0, 0, 0, 0);
      $12 = $27;
      $9 = $19;
      $30 = fabs(__trunctfdf2($24, $12, $18, $9));
      $9 = HEAP32[$7 + 392 >> 2];
      $14 = $30 >= 1038459371706965525706099.0e10;
      $13 = $14;
      $10 = $13 ? $9 : $18;
      $18 = $10;
      $12 = HEAP32[$7 + 396 >> 2];
      $9 = $19;
      $8 = $13 ? $12 : $9;
      $19 = $8;
      $8 = HEAP32[$7 + 384 >> 2];
      $9 = $13;
      $12 = $9 ? $8 : $24;
      $24 = $12;
      $10 = HEAP32[$7 + 388 >> 2];
      $8 = $27;
      $13 = $9 ? $10 : $8;
      $27 = $13;
      $23 = $9 + $23 | 0;
      if (($23 + 110 | 0) <= ($39 | 0) ? !(($9 ^ 1 | ($1 | 0) != ($2 | 0)) & $22 & ($16 | 0) != 0) : 0) {
       break label$99
      }
      HEAP32[__errno_location() >> 2] = 68;
     }
     $13 = $27;
     $12 = $19;
     scalbnl($7 + 368 | 0, $24, $13, $18, $12, $23);
     $12 = HEAP32[$7 + 368 >> 2];
     $18 = $12;
     $13 = HEAP32[$7 + 372 >> 2];
     $19 = $13;
     $12 = HEAP32[$7 + 380 >> 2];
     $13 = HEAP32[$7 + 376 >> 2];
     $15 = $13;
    }
    $29 = $15;
    $8 = $12;
   }
   $15 = $29;
   $12 = $8;
   $17 = $12;
   if (!global$2) {
    $13 = $0;
    HEAP32[$13 >> 2] = $18;
    $12 = $19;
    HEAP32[$13 + 4 >> 2] = $12;
    HEAP32[$13 + 8 >> 2] = $15;
    $12 = $17;
    HEAP32[$13 + 12 >> 2] = $12;
    global$0 = $7 + 8960 | 0;
   }
   return;
  }
  $11 = $10;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $11;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $11 = HEAP32[global$3 >> 2];
  HEAP32[$11 >> 2] = $0;
  HEAP32[$11 + 4 >> 2] = $1;
  HEAP32[$11 + 8 >> 2] = $2;
  HEAP32[$11 + 12 >> 2] = $3;
  HEAP32[$11 + 16 >> 2] = $4;
  HEAP32[$11 + 20 >> 2] = $5;
  HEAP32[$11 + 24 >> 2] = $6;
  HEAP32[$11 + 28 >> 2] = $7;
  HEAP32[$11 + 32 >> 2] = $14;
  HEAP32[$11 + 36 >> 2] = $16;
  $13 = $11;
  HEAP32[$13 + 40 >> 2] = $15;
  $12 = $17;
  HEAP32[$13 + 44 >> 2] = $12;
  HEAP32[$13 + 48 >> 2] = $18;
  $12 = $19;
  HEAP32[$13 + 52 >> 2] = $12;
  HEAP32[$13 + 56 >> 2] = $20;
  HEAP32[$13 + 60 >> 2] = $21;
  HEAP32[$13 + 64 >> 2] = $22;
  HEAP32[$13 + 68 >> 2] = $23;
  HEAP32[$13 + 72 >> 2] = $24;
  $12 = $27;
  HEAP32[$13 + 76 >> 2] = $12;
  HEAP32[$13 + 80 >> 2] = $25;
  $12 = $26;
  HEAP32[$13 + 84 >> 2] = $12;
  HEAP32[$13 + 88 >> 2] = $28;
  wasm2js_scratch_store_f64(+$30);
  $12 = wasm2js_scratch_load_i32(1) | 0;
  HEAP32[$13 + 92 >> 2] = wasm2js_scratch_load_i32(0);
  HEAP32[$13 + 96 >> 2] = $12;
  HEAP32[$13 + 100 >> 2] = $31;
  HEAP32[$13 + 104 >> 2] = $32;
  $12 = $33;
  HEAP32[$13 + 108 >> 2] = $12;
  HEAP32[$13 + 112 >> 2] = $34;
  $12 = $35;
  HEAP32[$13 + 116 >> 2] = $12;
  HEAP32[$13 + 120 >> 2] = $37;
  HEAP32[$13 + 124 >> 2] = $38;
  HEAP32[$13 + 128 >> 2] = $39;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 132;
 }
 
 function scanexp($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -32;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $3 = HEAP32[$2 + 8 >> 2];
   $5 = HEAP32[$2 + 12 >> 2];
   $4 = HEAP32[$2 + 16 >> 2];
   $1 = HEAP32[$2 + 20 >> 2];
   $7 = $1;
   $6 = HEAP32[$2 + 24 >> 2];
   $9 = HEAP32[$2 + 28 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $3 = HEAP32[$0 + 4 >> 2];
   $5 = $3 >>> 0 < HEAPU32[$0 + 104 >> 2];
  }
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($5) {
      $5 = $3 + 1 | 0;
      HEAP32[$0 + 4 >> 2] = $5;
      $3 = HEAPU8[$3 | 0];
      break label$5;
     }
    }
    if (global$2 ? !$8 : 1) {
     $2 = __shgetc($0);
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $3 = $2;
    }
   }
   if (!global$2) {
    $4 = $3 + -43 | 0;
    $2 = $4 >>> 0 <= 2;
    $4 = $4 - 1 | 0;
    $5 = !($4 ? $2 : 0);
   }
   label$11 : {
    if (!global$2) {
     if ($5) {
      $4 = $3 + -48 | 0;
      $9 = 0;
      break label$11;
     }
     $4 = HEAP32[$0 + 4 >> 2];
     $5 = $4 >>> 0 < HEAPU32[$0 + 104 >> 2];
    }
    label$14 : {
     if (!global$2) {
      if ($5) {
       HEAP32[$0 + 4 >> 2] = $4 + 1;
       $2 = HEAPU8[$4 | 0];
       break label$14;
      }
     }
     if (global$2 ? ($8 | 0) == 1 : 1) {
      $2 = __shgetc($0);
      $10 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
     } else {
      $2 = $5
     }
    }
    $5 = $2;
    if (!global$2) {
     $9 = ($3 | 0) == 45;
     $4 = $5 + -48 | 0;
     $1 = !$1;
     label$20 : {
      if ($1) {
       break label$20
      }
      $1 = $4 >>> 0 < 10;
      if ($1) {
       break label$20
      }
      $1 = !HEAP32[$0 + 104 >> 2];
      if ($1) {
       break label$20
      }
      $1 = HEAP32[$0 + 4 >> 2] + -1 | 0;
      HEAP32[$0 + 4 >> 2] = $1;
     }
     $3 = $5;
    }
   }
   $1 = global$2 ? $1 : $4 >>> 0 < 10;
   label$21 : {
    if ($1 | (global$2 | 0) == 2) {
     $4 = global$2 ? $4 : 0;
     while (1) {
      if (!global$2) {
       $4 = Math_imul($4, 10) + $3 | 0;
       $3 = HEAP32[$0 + 4 >> 2];
       $1 = $3 >>> 0 < HEAPU32[$0 + 104 >> 2];
      }
      label$25 : {
       if (!global$2) {
        if ($1) {
         $1 = $3 + 1 | 0;
         HEAP32[$0 + 4 >> 2] = $1;
         $3 = HEAPU8[$3 | 0];
         break label$25;
        }
       }
       if (global$2 ? ($8 | 0) == 2 : 1) {
        $2 = __shgetc($0);
        $10 = 2;
        if ((global$2 | 0) == 1) {
         break label$2
        }
        $3 = $2;
       }
      }
      if (!global$2) {
       $5 = $3 + -48 | 0;
       $4 = $4 + -48 | 0;
       $1 = ($4 | 0) < 214748364 ? $5 >>> 0 <= 9 : 0;
       if ($1) {
        continue
       }
      }
      break;
     };
     $2 = !global$2;
     if (!global$2) {
      $7 = $4;
      $6 = $4 >> 31;
      $1 = $5 >>> 0 >= 10;
     }
     label$31 : {
      if ($1 ? $2 : 0) {
       break label$31
      }
      while (1) {
       if (!global$2) {
        $1 = __wasm_i64_mul($7, $6, 10, 0);
        $6 = $1;
        $1 = i64toi32_i32$HIGH_BITS;
        $2 = $3 + $6 | 0;
        if ($2 >>> 0 < $6 >>> 0) {
         $1 = $1 + 1 | 0
        }
        $7 = $2;
        $6 = $1;
        $3 = HEAP32[$0 + 4 >> 2];
        $1 = $3 >>> 0 < HEAPU32[$0 + 104 >> 2];
       }
       label$36 : {
        if (!global$2) {
         if ($1) {
          $1 = $3 + 1 | 0;
          HEAP32[$0 + 4 >> 2] = $1;
          $3 = HEAPU8[$3 | 0];
          break label$36;
         }
        }
        if (global$2 ? ($8 | 0) == 3 : 1) {
         $2 = __shgetc($0);
         $10 = 3;
         if ((global$2 | 0) == 1) {
          break label$2
         }
         $3 = $2;
        }
       }
       if (!global$2) {
        $2 = $6 + -1 | 0;
        $1 = $7 + -48 | 0;
        if ($1 >>> 0 < 4294967248) {
         $2 = $2 + 1 | 0
        }
        $7 = $1;
        $6 = $2;
        $5 = $3 + -48 | 0;
        $1 = $5 >>> 0 > 9;
        if ($1) {
         break label$31
        }
        $1 = ($6 | 0) < 21474836 ? 1 : ($6 | 0) <= 21474836 ? ($7 >>> 0 >= 2061584302 ? 0 : 1) : 0;
        if ($1) {
         continue
        }
       }
       break;
      };
     }
     $1 = global$2 ? $1 : $5 >>> 0 < 10;
     if ($1 | (global$2 | 0) == 2) {
      while (1) {
       if (!global$2) {
        $3 = HEAP32[$0 + 4 >> 2];
        $1 = $3 >>> 0 < HEAPU32[$0 + 104 >> 2];
       }
       label$45 : {
        if (!global$2) {
         if ($1) {
          HEAP32[$0 + 4 >> 2] = $3 + 1;
          $3 = HEAPU8[$3 | 0];
          break label$45;
         }
        }
        if (global$2 ? ($8 | 0) == 4 : 1) {
         $2 = __shgetc($0);
         $10 = 4;
         if ((global$2 | 0) == 1) {
          break label$2
         }
         $3 = $2;
        }
       }
       if (!global$2) {
        $1 = $3 + -48 >>> 0 < 10;
        if ($1) {
         continue
        }
       }
       break;
      }
     }
     if (!global$2) {
      if (HEAP32[$0 + 104 >> 2]) {
       HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + -1
      }
      $1 = $6 + (0 < $7 >>> 0) | 0;
      $1 = 0 - $1 | 0;
      $2 = $9;
      $7 = $2 ? 0 - $7 | 0 : $7;
      $1 = $2 ? $1 : $6;
      $6 = $1;
      break label$21;
     }
    }
    if (!global$2) {
     $7 = 0;
     $6 = -2147483648;
     if (!HEAP32[$0 + 104 >> 2]) {
      break label$21
     }
     HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + -1;
     i64toi32_i32$HIGH_BITS = -2147483648;
     return 0;
    }
   }
   if (!global$2) {
    i64toi32_i32$HIGH_BITS = $6;
    return $7;
   }
   abort();
  }
  $2 = $10;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 + 8 >> 2] = $3;
  HEAP32[$2 + 12 >> 2] = $5;
  HEAP32[$2 + 16 >> 2] = $4;
  HEAP32[$2 + 20 >> 2] = $7;
  HEAP32[$2 + 24 >> 2] = $6;
  HEAP32[$2 + 28 >> 2] = $9;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 32;
  i64toi32_i32$HIGH_BITS = 0;
  return 0;
 }
 
 function __strerror_l($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  label$1 : {
   label$2 : {
    while (1) {
     if (HEAPU8[$2 + 13280 | 0] != ($0 | 0)) {
      $3 = 87;
      $2 = $2 + 1 | 0;
      if (($2 | 0) != 87) {
       continue
      }
      break label$2;
     }
     break;
    };
    $3 = $2;
    if ($2) {
     break label$2
    }
    $4 = 13376;
    break label$1;
   }
   $2 = 13376;
   while (1) {
    $0 = HEAPU8[$2 | 0];
    $4 = $2 + 1 | 0;
    $2 = $4;
    if ($0) {
     continue
    }
    $2 = $4;
    $3 = $3 + -1 | 0;
    if ($3) {
     continue
    }
    break;
   };
  }
  return __lctrans($4, HEAP32[$1 + 20 >> 2]);
 }
 
 function strerror($0) {
  return __strerror_l($0, HEAP32[__pthread_self() + 176 >> 2]);
 }
 
 function __pthread_self() {
  return pthread_self();
 }
 
 function __errno_location() {
  return 23956;
 }
 
 function dummy_1($0, $1) {
  return $0;
 }
 
 function __lctrans($0, $1) {
  return dummy_1($0, $1);
 }
 
 function __strxfrm_l($0, $1, $2, $3) {
  $3 = strlen($1);
  if ($3 >>> 0 < $2 >>> 0) {
   strcpy($0, $1)
  }
  return $3;
 }
 
 function strxfrm($0, $1, $2) {
  __pthread_self_1();
  return __strxfrm_l($0, $1, $2, $0);
 }
 
 function __pthread_self_1() {
  return pthread_self();
 }
 
 function __strcoll_l($0, $1, $2) {
  return strcmp($0, $1);
 }
 
 function strcoll($0, $1) {
  __pthread_self_2();
  return __strcoll_l($0, $1, $0);
 }
 
 function __pthread_self_2() {
  return pthread_self();
 }
 
 function islower($0) {
  return $0 + -97 >>> 0 < 26;
 }
 
 function isxdigit($0) {
  return (isdigit($0) | 0) != 0 | ($0 | 32) + -97 >>> 0 < 6;
 }
 
 function isalpha($0) {
  return ($0 | 32) + -97 >>> 0 < 26;
 }
 
 function isgraph($0) {
  return $0 + -33 >>> 0 < 94;
 }
 
 function tolower($0) {
  return isupper($0) ? $0 | 32 : $0;
 }
 
 function isupper($0) {
  return $0 + -65 >>> 0 < 26;
 }
 
 function iscntrl($0) {
  return ($0 | 0) == 127 | $0 >>> 0 < 32;
 }
 
 function toupper($0) {
  return islower($0) ? $0 & 95 : $0;
 }
 
 function isdigit($0) {
  return $0 + -48 >>> 0 < 10;
 }
 
 function ispunct($0) {
  if (!isgraph($0)) {
   return 0
  }
  return !isalnum($0);
 }
 
 function isprint($0) {
  return $0 + -32 >>> 0 < 95;
 }
 
 function isalnum($0) {
  if (isalpha($0)) {
   $0 = 1
  } else {
   $0 = (isdigit($0) | 0) != 0
  }
  return $0;
 }
 
 function isspace($0) {
  return ($0 | 0) == 32 | $0 + -9 >>> 0 < 5;
 }
 
 function mbrtowc($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  $7 = global$0 - 16 | 0;
  global$0 = $7;
  $5 = $3 ? $3 : 23960;
  $3 = HEAP32[$5 >> 2];
  label$1 : {
   label$2 : {
    label$3 : {
     if (!$1) {
      if ($3) {
       break label$3
      }
      break label$1;
     }
     $4 = -2;
     if (!$2) {
      break label$1
     }
     $8 = $0 ? $0 : $7 + 12 | 0;
     label$5 : {
      if ($3) {
       $0 = $2;
       break label$5;
      }
      $3 = HEAPU8[$1 | 0];
      $0 = $3 << 24 >> 24;
      if (($0 | 0) >= 0) {
       HEAP32[$8 >> 2] = $3;
       $4 = ($0 | 0) != 0;
       break label$1;
      }
      $3 = HEAP32[HEAP32[__pthread_self_3() + 176 >> 2] >> 2];
      $0 = HEAP8[$1 | 0];
      if (!$3) {
       HEAP32[$8 >> 2] = $0 & 57343;
       $4 = 1;
       break label$1;
      }
      $3 = ($0 & 255) + -194 | 0;
      if ($3 >>> 0 > 50) {
       break label$3
      }
      $3 = HEAP32[($3 << 2) + 15184 >> 2];
      $0 = $2 + -1 | 0;
      if (!$0) {
       break label$2
      }
      $1 = $1 + 1 | 0;
     }
     $6 = HEAPU8[$1 | 0];
     $9 = $6 >>> 3 | 0;
     if (($9 + -16 | ($3 >> 26) + $9) >>> 0 > 7) {
      break label$3
     }
     while (1) {
      $0 = $0 + -1 | 0;
      $3 = $6 + -128 | $3 << 6;
      if (($3 | 0) >= 0) {
       HEAP32[$5 >> 2] = 0;
       HEAP32[$8 >> 2] = $3;
       $4 = $2 - $0 | 0;
       break label$1;
      }
      if (!$0) {
       break label$2
      }
      $1 = $1 + 1 | 0;
      $6 = HEAPU8[$1 | 0];
      if (($6 & 192) == 128) {
       continue
      }
      break;
     };
    }
    HEAP32[$5 >> 2] = 0;
    HEAP32[__errno_location() >> 2] = 25;
    $4 = -1;
    break label$1;
   }
   HEAP32[$5 >> 2] = $3;
  }
  global$0 = $7 + 16 | 0;
  return $4;
 }
 
 function __pthread_self_3() {
  return pthread_self();
 }
 
 function wctomb($0, $1) {
  if (!$0) {
   return 0
  }
  return wcrtomb($0, $1, 0);
 }
 
 function mbsinit($0) {
  if (!$0) {
   return 1
  }
  return !HEAP32[$0 >> 2];
 }
 
 function wcrtomb($0, $1, $2) {
  label$1 : {
   if ($0) {
    if ($1 >>> 0 <= 127) {
     break label$1
    }
    label$3 : {
     if (!HEAP32[HEAP32[__pthread_self_4() + 176 >> 2] >> 2]) {
      if (($1 & -128) == 57216) {
       break label$1
      }
      break label$3;
     }
     if ($1 >>> 0 <= 2047) {
      HEAP8[$0 + 1 | 0] = $1 & 63 | 128;
      HEAP8[$0 | 0] = $1 >>> 6 | 192;
      return 2;
     }
     if (!(($1 & -8192) != 57344 ? $1 >>> 0 >= 55296 : 0)) {
      HEAP8[$0 + 2 | 0] = $1 & 63 | 128;
      HEAP8[$0 | 0] = $1 >>> 12 | 224;
      HEAP8[$0 + 1 | 0] = $1 >>> 6 & 63 | 128;
      return 3;
     }
     if ($1 + -65536 >>> 0 <= 1048575) {
      HEAP8[$0 + 3 | 0] = $1 & 63 | 128;
      HEAP8[$0 | 0] = $1 >>> 18 | 240;
      HEAP8[$0 + 2 | 0] = $1 >>> 6 & 63 | 128;
      HEAP8[$0 + 1 | 0] = $1 >>> 12 & 63 | 128;
      return 4;
     }
    }
    HEAP32[__errno_location() >> 2] = 25;
    $0 = -1;
   } else {
    $0 = 1
   }
   return $0;
  }
  HEAP8[$0 | 0] = $1;
  return 1;
 }
 
 function __pthread_self_4() {
  return pthread_self();
 }
 
 function frexp($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  wasm2js_scratch_store_f64(+$0);
  $2 = wasm2js_scratch_load_i32(1) | 0;
  $3 = wasm2js_scratch_load_i32(0) | 0;
  $4 = $2;
  $2 = $2 >>> 20 & 2047;
  if (($2 | 0) != 2047) {
   if (!$2) {
    $2 = $1;
    if ($0 == 0.0) {
     $1 = 0
    } else {
     $0 = frexp($0 * 18446744073709551615.0, $1);
     $1 = HEAP32[$1 >> 2] + -64 | 0;
    }
    HEAP32[$2 >> 2] = $1;
    return $0;
   }
   HEAP32[$1 >> 2] = $2 + -1022;
   $2 = $4 & -2146435073 | 1071644672;
   wasm2js_scratch_store_i32(0, $3 | 0);
   wasm2js_scratch_store_i32(1, $2 | 0);
   $0 = +wasm2js_scratch_load_f64();
  }
  return $0;
 }
 
 function tanh($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  wasm2js_scratch_store_f64(+$0);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  $2 = wasm2js_scratch_load_i32(0) | 0;
  $3 = $1;
  $1 = $3 & 2147483647;
  wasm2js_scratch_store_i32(0, $2 | 0);
  wasm2js_scratch_store_i32(1, $1 | 0);
  $0 = +wasm2js_scratch_load_f64();
  label$1 : {
   if ($1 >>> 0 >= 1071748075) {
    if ($1 >>> 0 >= 1077149697) {
     $0 = -0.0 / $0 + 1.0;
     break label$1;
    }
    $0 = 1.0 - 2.0 / (expm1($0 + $0) + 2.0);
    break label$1;
   }
   if ($1 >>> 0 >= 1070618799) {
    $0 = expm1($0 + $0);
    $0 = $0 / ($0 + 2.0);
    break label$1;
   }
   if ($1 >>> 0 < 1048576) {
    break label$1
   }
   $0 = expm1($0 * -2.0);
   $0 = -$0 / ($0 + 2.0);
  }
  return (($3 | 0) < 0 ? 1 : ($3 | 0) <= 0 ? ($2 >>> 0 >= 0 ? 0 : 1) : 0) ? -$0 : $0;
 }
 
 function copysignl($0, $1, $2, $3, $4, $5, $6, $7, $8) {
  HEAP32[$0 >> 2] = $1;
  HEAP32[$0 + 4 >> 2] = $2;
  HEAP32[$0 + 8 >> 2] = $3;
  HEAP32[$0 + 12 >> 2] = $4 & 65535 | ($8 >>> 16 & 32768 | $4 >>> 16 & 32767) << 16;
 }
 
 function ldexp($0, $1) {
  return scalbn($0, $1);
 }
 
 function sinh($0) {
  var $1 = 0, $2 = 0.0, $3 = 0, $4 = 0, $5 = 0.0, $6 = 0, $7 = 0, $8 = 0;
  wasm2js_scratch_store_f64(.5);
  $4 = wasm2js_scratch_load_i32(1) | 0;
  $1 = wasm2js_scratch_load_i32(0) | 0;
  $6 = $1;
  $3 = $4 & 2147483647;
  $7 = $3;
  wasm2js_scratch_store_f64(+$0);
  $3 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  $1 = $3 & -2147483648;
  $4 = $1;
  $1 = $7;
  $4 = $4 | $1;
  $3 = $6;
  wasm2js_scratch_store_i32(0, $8 | $3);
  wasm2js_scratch_store_i32(1, $4 | 0);
  $5 = +wasm2js_scratch_load_f64();
  wasm2js_scratch_store_f64(+$0);
  $4 = wasm2js_scratch_load_i32(1) | 0;
  $1 = wasm2js_scratch_load_i32(0) | 0;
  $3 = $4 & 2147483647;
  wasm2js_scratch_store_i32(0, $1 | 0);
  wasm2js_scratch_store_i32(1, $3 | 0);
  $2 = +wasm2js_scratch_load_f64();
  $1 = $3;
  label$1 : {
   if ($3 >>> 0 <= 1082535489) {
    $2 = expm1($2);
    if ($1 >>> 0 <= 1072693247) {
     if ($1 >>> 0 < 1045430272) {
      break label$1
     }
     return $5 * ($2 + $2 - $2 * $2 / ($2 + 1.0));
    }
    return $5 * ($2 + $2 / ($2 + 1.0));
   }
   $0 = ($5 + $5) * __expo2($2);
  }
  return $0;
 }
 
 function cosh($0) {
  var $1 = 0, $2 = 0.0, $3 = 0;
  wasm2js_scratch_store_f64(+$0);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  $3 = wasm2js_scratch_load_i32(0) | 0;
  $1 = $1 & 2147483647;
  wasm2js_scratch_store_i32(0, $3 | 0);
  wasm2js_scratch_store_i32(1, $1 | 0);
  $0 = +wasm2js_scratch_load_f64();
  label$1 : {
   if ($1 >>> 0 <= 1072049729) {
    $2 = 1.0;
    if ($1 >>> 0 < 1045430272) {
     break label$1
    }
    $0 = expm1($0);
    $2 = $0 * $0;
    $0 = $0 + 1.0;
    return $2 / ($0 + $0) + 1.0;
   }
   if ($1 >>> 0 <= 1082535489) {
    $0 = exp($0);
    return ($0 + 1.0 / $0) * .5;
   }
   $2 = __expo2($0);
  }
  return $2;
 }
 
 function scalbnl($0, $1, $2, $3, $4, $5) {
  var $6 = 0, $7 = 0;
  $6 = global$0 - 80 | 0;
  global$0 = $6;
  label$1 : {
   if (($5 | 0) >= 16384) {
    __multf3($6 + 32 | 0, $1, $2, $3, $4, 0, 0, 0, 2147352576);
    $7 = HEAP32[$6 + 40 >> 2];
    $3 = $7;
    $4 = HEAP32[$6 + 44 >> 2];
    $1 = HEAP32[$6 + 32 >> 2];
    $7 = HEAP32[$6 + 36 >> 2];
    $2 = $7;
    if (($5 | 0) < 32767) {
     $5 = $5 + -16383 | 0;
     break label$1;
    }
    $7 = $2;
    __multf3($6 + 16 | 0, $1, $7, $3, $4, 0, 0, 0, 2147352576);
    $5 = (($5 | 0) < 49149 ? $5 : 49149) + -32766 | 0;
    $2 = HEAP32[$6 + 24 >> 2];
    $3 = $2;
    $4 = HEAP32[$6 + 28 >> 2];
    $1 = HEAP32[$6 + 16 >> 2];
    $2 = HEAP32[$6 + 20 >> 2];
    break label$1;
   }
   if (($5 | 0) > -16383) {
    break label$1
   }
   __multf3($6 - -64 | 0, $1, $2, $3, $4, 0, 0, 0, 65536);
   $7 = HEAP32[$6 + 72 >> 2];
   $3 = $7;
   $4 = HEAP32[$6 + 76 >> 2];
   $1 = HEAP32[$6 + 64 >> 2];
   $7 = HEAP32[$6 + 68 >> 2];
   $2 = $7;
   if (($5 | 0) > -32765) {
    $5 = $5 + 16382 | 0;
    break label$1;
   }
   $7 = $2;
   __multf3($6 + 48 | 0, $1, $7, $3, $4, 0, 0, 0, 65536);
   $5 = (($5 | 0) > -49146 ? $5 : -49146) + 32764 | 0;
   $2 = HEAP32[$6 + 56 >> 2];
   $3 = $2;
   $4 = HEAP32[$6 + 60 >> 2];
   $1 = HEAP32[$6 + 48 >> 2];
   $2 = HEAP32[$6 + 52 >> 2];
  }
  $7 = $5 + 16383 << 16;
  __multf3($6, $1, $2, $3, $4, 0, 0, 0, $7);
  $2 = HEAP32[$6 + 12 >> 2];
  $7 = HEAP32[$6 + 8 >> 2];
  $1 = $7;
  $7 = $0;
  HEAP32[$7 + 8 >> 2] = $1;
  HEAP32[$7 + 12 >> 2] = $2;
  $7 = HEAP32[$6 + 4 >> 2];
  $2 = HEAP32[$6 >> 2];
  $1 = $2;
  $2 = $0;
  HEAP32[$2 >> 2] = $1;
  HEAP32[$2 + 4 >> 2] = $7;
  global$0 = $6 + 80 | 0;
 }
 
 function expm1($0) {
  var $1 = 0.0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0.0, $7 = 0.0, $8 = 0, $9 = 0.0, $10 = 0;
  label$1 : {
   label$2 : {
    label$3 : {
     label$4 : {
      label$5 : {
       wasm2js_scratch_store_f64(+$0);
       $5 = wasm2js_scratch_load_i32(1) | 0;
       $8 = wasm2js_scratch_load_i32(0) | 0;
       $4 = $5;
       $3 = $4 & 2147483647;
       if ($3 >>> 0 >= 1078159482) {
        $2 = __DOUBLE_BITS_1($0);
        $5 = $2;
        $3 = i64toi32_i32$HIGH_BITS;
        $2 = $3 & 2147483647;
        $3 = $5;
        if (($2 | 0) == 2146435072 & $3 >>> 0 > 0 | $2 >>> 0 > 2146435072) {
         break label$1
        }
        $2 = $8;
        if (($4 | 0) < 0 ? 1 : ($4 | 0) <= 0 ? ($2 >>> 0 >= 0 ? 0 : 1) : 0) {
         return -1.0
        }
        if (!($0 > 709.782712893384)) {
         break label$5
        }
        return $0 * 8988465674311579538646525.0e283;
       }
       if ($3 >>> 0 < 1071001155) {
        break label$3
       }
       if ($3 >>> 0 > 1072734897) {
        break label$5
       }
       $5 = $8;
       if (($4 | 0) > 0 ? 1 : ($4 | 0) >= 0 ? ($5 >>> 0 < 0 ? 0 : 1) : 0) {
        $3 = 1;
        $6 = 1.9082149292705877e-10;
        $1 = $0 + -.6931471803691238;
        break label$4;
       }
       $3 = -1;
       $6 = -1.9082149292705877e-10;
       $1 = $0 + .6931471803691238;
       break label$4;
      }
      $1 = $0 * 1.4426950408889634;
      wasm2js_scratch_store_f64(.5);
      $5 = wasm2js_scratch_load_i32(1) | 0;
      $2 = wasm2js_scratch_load_i32(0) | 0;
      $4 = $2;
      $2 = $5 & 2147483647;
      $3 = $2;
      wasm2js_scratch_store_f64(+$0);
      $2 = wasm2js_scratch_load_i32(1) | 0;
      wasm2js_scratch_load_i32(0) | 0;
      $2 = $2 & -2147483648;
      $5 = $2;
      $2 = $3;
      $5 = $5 | $2;
      $3 = $10;
      $2 = $4;
      wasm2js_scratch_store_i32(0, $3 | $2);
      wasm2js_scratch_store_i32(1, $5 | 0);
      $1 = $1 + +wasm2js_scratch_load_f64();
      label$9 : {
       if (Math_abs($1) < 2147483648.0) {
        $3 = ~~$1;
        break label$9;
       }
       $3 = -2147483648;
      }
      $1 = +($3 | 0);
      $6 = $1 * 1.9082149292705877e-10;
      $1 = $0 + $1 * -.6931471803691238;
     }
     $0 = $1 - $6;
     $6 = $1 - $0 - $6;
     break label$2;
    }
    if ($3 >>> 0 < 1016070144) {
     break label$1
    }
    $3 = 0;
   }
   $7 = $0 * .5;
   $1 = $0 * $7;
   $9 = $1 * -2.0109921818362437e-07 + 4.008217827329362e-06;
   $9 = $1 * ($1 * ($1 * ($1 * $9 + -7.93650757867488e-05) + 1.5873015872548146e-03) + -.03333333333333313) + 1.0;
   $7 = 3.0 - $7 * $9;
   $7 = $1 * (($9 - $7) / (6.0 - $0 * $7));
   if (!$3) {
    return $0 - ($0 * $7 - $1)
   }
   $1 = $0 * ($7 - $6) - $6 - $1;
   label$12 : {
    $2 = $3 + 1 | 0;
    if ($2 >>> 0 > 2) {
     break label$12
    }
    label$13 : {
     switch ($2 - 1 | 0) {
     default:
      return ($0 - $1) * .5 + -.5;
     case 0:
      break label$12;
     case 1:
      break label$13;
     };
    }
    if (!!($0 < -.25)) {
     return ($1 - ($0 + .5)) * -2.0
    }
    $0 = $0 - $1;
    return $0 + $0 + 1.0;
   }
   $2 = $3 + 1023 | 0;
   $2 = $2 << 20;
   wasm2js_scratch_store_i32(0, 0);
   wasm2js_scratch_store_i32(1, $2 | 0);
   $6 = +wasm2js_scratch_load_f64();
   if ($3 >>> 0 >= 57) {
    $0 = $0 - $1 + 1.0;
    return (($3 | 0) == 1024 ? ($0 + $0) * 8988465674311579538646525.0e283 : $0 * $6) + -1.0;
   }
   $8 = 0;
   $5 = 1023 - $3 | 0;
   $2 = $5 << 20;
   $4 = $2;
   label$17 : {
    if (($3 | 0) <= 19) {
     $0 = $0 - $1;
     wasm2js_scratch_store_i32(0, $8 | 0);
     wasm2js_scratch_store_i32(1, $4 | 0);
     $1 = 1.0 - +wasm2js_scratch_load_f64();
     break label$17;
    }
    wasm2js_scratch_store_i32(0, $8 | 0);
    wasm2js_scratch_store_i32(1, $4 | 0);
    $1 = $0 - ($1 + +wasm2js_scratch_load_f64());
    $0 = 1.0;
   }
   $0 = ($1 + $0) * $6;
  }
  return $0;
 }
 
 function __DOUBLE_BITS_1($0) {
  var $1 = 0, $2 = 0;
  wasm2js_scratch_store_f64(+$0);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  $2 = wasm2js_scratch_load_i32(0) | 0;
  i64toi32_i32$HIGH_BITS = $1;
  return $2;
 }
 
 function __expo2($0) {
  return exp($0 + -1416.0996898839683) * 2247116418577894884661631.0e283 * 2247116418577894884661631.0e283;
 }
 
 function fabs($0) {
  return Math_abs($0);
 }
 
 function modf($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  wasm2js_scratch_store_f64(+$0);
  $2 = wasm2js_scratch_load_i32(1) | 0;
  $6 = wasm2js_scratch_load_i32(0) | 0;
  $7 = $2;
  $2 = $2 >>> 20 & 2047;
  $4 = $2 + -1023 | 0;
  label$1 : {
   if ($2 >>> 0 >= 1075) {
    HEAPF64[$1 >> 3] = $0;
    $2 = $6;
    $3 = $7;
    $5 = $3 & 1048575;
    if (($4 | 0) == 1024 ? $2 | $5 : 0) {
     break label$1
    }
    $2 = $7 & -2147483648;
    wasm2js_scratch_store_i32(0, 0);
    wasm2js_scratch_store_i32(1, $2 | 0);
    return +wasm2js_scratch_load_f64();
   }
   if ($2 >>> 0 <= 1022) {
    HEAP32[$1 >> 2] = 0;
    $3 = $7 & -2147483648;
    HEAP32[$1 + 4 >> 2] = $3;
    return $0;
   }
   $3 = $7;
   $2 = $6;
   $8 = $4;
   $5 = $4;
   $4 = $5 & 31;
   if (32 <= ($5 & 63) >>> 0) {
    $5 = $2 << $4;
    $3 = 0;
   } else {
    $5 = (1 << $4) - 1 & $2 >>> 32 - $4 | $3 << $4;
    $3 = $2 << $4;
   }
   $2 = $5 & 1048575;
   if (!($2 | $3)) {
    HEAPF64[$1 >> 3] = $0;
    $2 = $7;
    $3 = $2 & -2147483648;
    wasm2js_scratch_store_i32(0, 0);
    wasm2js_scratch_store_i32(1, $3 | 0);
    return +wasm2js_scratch_load_f64();
   }
   $5 = $8;
   $4 = $5 & 31;
   if (32 <= ($5 & 63) >>> 0) {
    $5 = -1;
    $3 = -1048576 >> $4;
   } else {
    $5 = -1048576 >> $4;
    $3 = ((1 << $4) - 1 & -1048576) << 32 - $4;
   }
   $6 = $3 & $6;
   $2 = $7;
   $2 = $5 & $2;
   $3 = $1;
   HEAP32[$3 >> 2] = $6;
   HEAP32[$3 + 4 >> 2] = $2;
   wasm2js_scratch_store_i32(0, $6 | 0);
   wasm2js_scratch_store_i32(1, $2 | 0);
   $0 = $0 - +wasm2js_scratch_load_f64();
  }
  return $0;
 }
 
 function lockf($0, $1, $2, $3) {
  var $4 = 0;
  $4 = global$0 - 80 | 0;
  global$0 = $4;
  HEAP32[$4 + 72 >> 2] = 0;
  HEAP32[$4 + 64 >> 2] = $2;
  HEAP32[$4 + 68 >> 2] = $3;
  HEAP32[$4 + 56 >> 2] = 0;
  HEAP32[$4 + 60 >> 2] = 0;
  HEAP32[$4 + 48 >> 2] = 65537;
  label$1 : {
   label$2 : {
    if ($1 >>> 0 <= 3) {
     label$4 : {
      switch ($1 - 1 | 0) {
      case 2:
       HEAP32[$4 >> 2] = $4 + 48;
       $1 = 0;
       HEAP16[$4 + 48 >> 1] = 0;
       if ((fcntl($0, 12, $4) | 0) < 0) {
        break label$2
       }
       if (HEAPU16[$4 + 48 >> 1] == 2) {
        break label$1
       }
       if (HEAP32[$4 + 72 >> 2] == (getpid() | 0)) {
        break label$1
       }
       HEAP32[__errno_location() >> 2] = 2;
       break label$2;
      default:
       HEAP16[$4 + 48 >> 1] = 2;
      case 1:
       HEAP32[$4 + 16 >> 2] = $4 + 48;
       $1 = fcntl($0, 13, $4 + 16 | 0);
       break label$1;
      case 0:
       break label$4;
      };
     }
     HEAP32[$4 + 32 >> 2] = $4 + 48;
     $1 = fcntl($0, 14, $4 + 32 | 0);
     break label$1;
    }
    HEAP32[__errno_location() >> 2] = 28;
   }
   $1 = -1;
  }
  global$0 = $4 + 80 | 0;
  return $1;
 }
 
 function __pthread_self_5() {
  return pthread_self();
 }
 
 function __unlist_locked_file($0) {
  var $1 = 0;
  if (HEAP32[$0 + 68 >> 2]) {
   $1 = HEAP32[$0 + 132 >> 2];
   if ($1) {
    HEAP32[$1 + 128 >> 2] = HEAP32[$0 + 128 >> 2]
   }
   $0 = HEAP32[$0 + 128 >> 2];
   label$3 : {
    if ($0) {
     $0 = $0 + 132 | 0;
     break label$3;
    }
    $0 = __pthread_self_5() + 220 | 0;
   }
   HEAP32[$0 >> 2] = $1;
  }
 }
 
 function gethostid() {
  return 0;
 }
 
 function pthread_self() {
  return 21492;
 }
 
 function __procfdname($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  while (1) {
   $4 = $0 + $2 | 0;
   HEAP8[$4 | 0] = HEAPU8[$2 + 15388 | 0];
   $3 = ($2 | 0) != 14;
   $2 = $2 + 1 | 0;
   if ($3) {
    continue
   }
   break;
  };
  if ($1) {
   $2 = 14;
   $3 = $1;
   while (1) {
    $2 = $2 + 1 | 0;
    $4 = $3 >>> 0 > 9;
    $3 = ($3 >>> 0) / 10 | 0;
    if ($4) {
     continue
    }
    break;
   };
   HEAP8[$0 + $2 | 0] = 0;
   while (1) {
    $2 = $2 + -1 | 0;
    $3 = ($1 >>> 0) / 10 | 0;
    HEAP8[$2 + $0 | 0] = $1 - Math_imul($3, 10) | 48;
    $4 = $1 >>> 0 > 9;
    $1 = $3;
    if ($4) {
     continue
    }
    break;
   };
   return;
  }
  HEAP8[$4 | 0] = 48;
  HEAP8[$0 + 15 | 0] = 0;
 }
 
 function ttyname_r($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0;
  $4 = global$0 - 32 | 0;
  global$0 = $4;
  $5 = !isatty($0);
  $3 = 59;
  label$1 : {
   if ($5) {
    break label$1
   }
   __procfdname($4, $0);
   $0 = readlink($4, $1, $2);
   if (($0 | 0) <= -1) {
    $3 = HEAP32[__errno_location() >> 2];
    break label$1;
   }
   $3 = 68;
   if (($0 | 0) == ($2 | 0)) {
    break label$1
   }
   HEAP8[$0 + $1 | 0] = 0;
   $3 = 0;
  }
  global$0 = $4 + 32 | 0;
  $0 = $3;
  return $0;
 }
 
 function read($0, $1, $2) {
  return __syscall_ret(__syscall3($0 | 0, $1 | 0, $2 | 0) | 0);
 }
 
 function getpgrp() {
  return __syscall132(0) | 0;
 }
 
 function nice($0) {
  return __syscall_ret(__syscall34($0 | 0) | 0);
 }
 
 function getlogin_r($0, $1) {
  var $2 = 0;
  $2 = getlogin();
  if (!$2) {
   return 60
  }
  if (strlen($2) >>> 0 < $1 >>> 0) {
   strcpy($0, $2);
   $0 = 0;
  } else {
   $0 = 68
  }
  return $0;
 }
 
 function chown($0, $1, $2) {
  return __syscall_ret(__syscall212($0 | 0, $1 | 0, $2 | 0) | 0);
 }
 
 function ioctl($0, $1, $2) {
  var $3 = 0;
  $3 = global$0 - 16 | 0;
  global$0 = $3;
  HEAP32[$3 + 12 >> 2] = $2 + 4;
  HEAP32[$3 >> 2] = HEAP32[$2 >> 2];
  $2 = __syscall_ret(__syscall54($0 | 0, $1 | 0, $3 | 0) | 0);
  global$0 = $3 + 16 | 0;
  return $2;
 }
 
 function tcgetpgrp($0) {
  var $1 = 0;
  $1 = global$0 - 16 | 0;
  global$0 = $1;
  HEAP32[$1 >> 2] = $1 + 12;
  $0 = ioctl($0, 21519, $1);
  global$0 = $1 + 16 | 0;
  return ($0 | 0) > -1 ? HEAP32[$1 + 12 >> 2] : -1;
 }
 
 function chdir($0) {
  return __syscall_ret(__syscall12($0 | 0) | 0);
 }
 
 function rmdir($0) {
  return __syscall_ret(__syscall40($0 | 0) | 0);
 }
 
 function tcsetpgrp($0, $1) {
  var $2 = 0;
  $2 = global$0 - 16 | 0;
  global$0 = $2;
  HEAP32[$2 + 12 >> 2] = $1;
  HEAP32[$2 >> 2] = $2 + 12;
  $0 = ioctl($0, 21520, $2);
  global$0 = $2 + 16 | 0;
  return $0;
 }
 
 function getcwd($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = global$0 - 4096 | 0;
  global$0 = $2;
  label$1 : {
   label$2 : {
    if (!$0) {
     $1 = 4096;
     $0 = $2;
     break label$2;
    }
    if ($1) {
     break label$2
    }
    HEAP32[__errno_location() >> 2] = 28;
    $1 = 0;
    break label$1;
   }
   $3 = (__syscall_ret(__syscall183($0 | 0, $1 | 0) | 0) | 0) < 0;
   $1 = 0;
   if ($3) {
    break label$1
   }
   $1 = $0;
   if (($0 | 0) != ($2 | 0)) {
    break label$1
   }
   $1 = __strdup($2);
  }
  global$0 = $2 + 4096 | 0;
  $0 = $1;
  return $0;
 }
 
 function lseek($0, $1, $2, $3) {
  var $4 = 0;
  $4 = global$0 - 16 | 0;
  global$0 = $4;
  $0 = __wasi_syscall_ret(legalfunc$__wasi_fd_seek($0, $1, $2, $3 & 255, $4 + 8 | 0));
  global$0 = $4 + 16 | 0;
  $2 = HEAP32[$4 + 12 >> 2];
  i64toi32_i32$HIGH_BITS = $0 ? -1 : $2;
  $1 = HEAP32[$4 + 8 >> 2];
  return $0 ? -1 : $1;
 }
 
 function __dup3($0, $1, $2) {
  var $3 = 0;
  $3 = -28;
  label$1 : {
   if (($0 | 0) == ($1 | 0)) {
    break label$1
   }
   if ($2 & 524288) {
    while (1) {
     $3 = __syscall330($0 | 0, $1 | 0, $2 | 0) | 0;
     if (($3 | 0) == -10) {
      continue
     }
     break;
    };
    if (($3 | 0) != -52) {
     break label$1
    }
   }
   while (1) {
    $3 = __syscall63($0 | 0, $1 | 0) | 0;
    if (($3 | 0) == -10) {
     continue
    }
    break;
   };
  }
  return __syscall_ret($3);
 }
 
 function setpgid($0, $1) {
  return __syscall_ret(__syscall57($0 | 0, $1 | 0) | 0);
 }
 
 function dup($0) {
  return __syscall_ret(__syscall41($0 | 0) | 0);
 }
 
 function ftruncate($0, $1, $2) {
  return __syscall_ret(__syscall194($0 | 0, 0, $1 | 0, $2 | 0) | 0);
 }
 
 function dup2($0, $1) {
  var $2 = 0;
  while (1) {
   $2 = __syscall63($0 | 0, $1 | 0) | 0;
   if (($2 | 0) == -10) {
    continue
   }
   break;
  };
  return __syscall_ret($2);
 }
 
 function pause() {
  return __syscall_ret(__syscall29() | 0);
 }
 
 function setsid() {
  return __syscall_ret(__syscall66() | 0);
 }
 
 function fchown($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $3 = global$0 - 32 | 0;
  global$0 = $3;
  label$1 : {
   label$2 : {
    $4 = __syscall207($0 | 0, $1 | 0, $2 | 0) | 0;
    if (($4 | 0) == -8) {
     if (__wasi_fd_is_valid($0)) {
      break label$2
     }
    }
    $0 = __syscall_ret($4);
    break label$1;
   }
   __procfdname($3, $0);
   $0 = __syscall_ret(__syscall212($3 | 0, $1 | 0, $2 | 0) | 0);
  }
  global$0 = $3 + 32 | 0;
  return $0;
 }
 
 function close($0) {
  $0 = __wasi_fd_close(dummy($0) | 0) | 0;
  return __wasi_syscall_ret(($0 | 0) == 27 ? 0 : $0);
 }
 
 function fchdir($0) {
  var $1 = 0, $2 = 0;
  $1 = global$0 - 32 | 0;
  global$0 = $1;
  label$1 : {
   label$2 : {
    $2 = __syscall133($0 | 0) | 0;
    if (($2 | 0) == -8) {
     if (__wasi_fd_is_valid($0)) {
      break label$2
     }
    }
    $0 = __syscall_ret($2);
    break label$1;
   }
   __procfdname($1, $0);
   $0 = __syscall_ret(__syscall12($1 | 0) | 0);
  }
  global$0 = $1 + 32 | 0;
  return $0;
 }
 
 function lchown($0, $1, $2) {
  return __syscall_ret(__syscall198($0 | 0, $1 | 0, $2 | 0) | 0);
 }
 
 function symlink($0, $1) {
  return __syscall_ret(__syscall83($0 | 0, $1 | 0) | 0);
 }
 
 function getppid() {
  return __syscall64() | 0;
 }
 
 function getgid() {
  return __syscall200() | 0;
 }
 
 function readlink($0, $1, $2) {
  return __syscall_ret(__syscall85($0 | 0, $1 | 0, $2 | 0) | 0);
 }
 
 function geteuid() {
  return __syscall201() | 0;
 }
 
 function setreuid($0, $1) {
  var $2 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $2 = 0
  }
  label$2 : {
   if (global$2 ? !$2 : 1) {
    $2 = __setxid(203, $0, $1, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $2;
   }
   if (!global$2) {
    return $0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
  return 0;
 }
 
 function setgid($0) {
  var $1 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $0 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $1 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $1 = 0
  }
  label$2 : {
   if (global$2 ? !$1 : 1) {
    $1 = __setxid(214, $0, 0, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $1;
   }
   if (!global$2) {
    return $0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  return 0;
 }
 
 function link($0, $1) {
  return __syscall_ret(__syscall9($0 | 0, $1 | 0) | 0);
 }
 
 function write($0, $1, $2) {
  var $3 = 0;
  $3 = global$0 - 16 | 0;
  global$0 = $3;
  HEAP32[$3 + 12 >> 2] = $2;
  HEAP32[$3 + 8 >> 2] = $1;
  $0 = __wasi_fd_write($0 | 0, $3 + 8 | 0, 1, $3 + 4 | 0) | 0;
  label$1 : {
   if ($0) {
    $0 = __wasi_syscall_ret($0);
    break label$1;
   }
   $0 = HEAP32[$3 + 4 >> 2];
  }
  global$0 = $3 + 16 | 0;
  return $0;
 }
 
 function access($0, $1) {
  return __syscall_ret(__syscall33($0 | 0, $1 | 0) | 0);
 }
 
 function setregid($0, $1) {
  var $2 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $2 = 0
  }
  label$2 : {
   if (global$2 ? !$2 : 1) {
    $2 = __setxid(204, $0, $1, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $2;
   }
   if (!global$2) {
    return $0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
  return 0;
 }
 
 function getegid() {
  return __syscall202() | 0;
 }
 
 function setuid($0) {
  var $1 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $0 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $1 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $1 = 0
  }
  label$2 : {
   if (global$2 ? !$1 : 1) {
    $1 = __setxid(213, $0, 0, 0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $1;
   }
   if (!global$2) {
    return $0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  return 0;
 }
 
 function isatty($0) {
  var $1 = 0, $2 = 0;
  $1 = global$0 - 32 | 0;
  global$0 = $1;
  $0 = __wasi_fd_fdstat_get($0 | 0, $1 + 8 | 0) | 0;
  label$1 : {
   if (!$0) {
    $0 = 59;
    $2 = 1;
    if (HEAPU8[$1 + 8 | 0] == 2) {
     break label$1
    }
   }
   HEAP32[__errno_location() >> 2] = $0;
   $2 = 0;
  }
  global$0 = $1 + 32 | 0;
  $0 = $2;
  return $0;
 }
 
 function ttyname($0) {
  $0 = ttyname_r($0, 23984, 32);
  if ($0) {
   HEAP32[__errno_location() >> 2] = $0;
   $0 = 0;
  } else {
   $0 = 23984
  }
  return $0;
 }
 
 function sync() {
  __syscall36() | 0;
 }
 
 function getlogin() {
  return getenv(15403);
 }
 
 function __synccall($0, $1) {
  var $2 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   } else {
    $2 = 0
   }
   if (global$2 ? !$2 : 1) {
    FUNCTION_TABLE[$0]($1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function __setxid($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $4 = HEAP32[$4 + 20 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $6 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = global$0 - 32 | 0;
   global$0 = $5;
   $4 = -1;
   HEAP32[$5 + 24 >> 2] = -1;
   HEAP32[$5 + 20 >> 2] = $0;
   HEAP32[$5 + 16 >> 2] = $3;
   HEAP32[$5 + 12 >> 2] = $2;
   HEAP32[$5 + 8 >> 2] = $1;
   $0 = $5 + 8 | 0;
  }
  label$2 : {
   if (global$2 ? !$6 : 1) {
    __synccall(250, $0);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   if (!global$2) {
    $1 = HEAP32[$5 + 24 >> 2];
    label$7 : {
     if (!$1) {
      $4 = 0;
      break label$7;
     }
     if (($1 | 0) < 1) {
      break label$7
     }
     HEAP32[__errno_location() >> 2] = $1;
    }
    global$0 = $5 + 32 | 0;
    return $4;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $6 = HEAP32[global$3 >> 2];
  HEAP32[$6 >> 2] = $0;
  HEAP32[$6 + 4 >> 2] = $1;
  HEAP32[$6 + 8 >> 2] = $2;
  HEAP32[$6 + 12 >> 2] = $3;
  HEAP32[$6 + 16 >> 2] = $5;
  HEAP32[$6 + 20 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  return 0;
 }
 
 function do_setxid($0) {
  $0 = $0 | 0;
  if (HEAP32[$0 + 16 >> 2] <= 0) {
   HEAP32[$0 + 16 >> 2] = 63
  }
 }
 
 function ctermid($0) {
  if (!$0) {
   return 15411
  }
  return strcpy($0, 15411);
 }
 
 function sleep($0) {
  var $1 = 0;
  $1 = global$0 - 16 | 0;
  global$0 = $1;
  HEAP32[$1 + 8 >> 2] = $0;
  HEAP32[$1 + 12 >> 2] = 0;
  $0 = nanosleep($1 + 8 | 0, $1 + 8 | 0) | 0;
  global$0 = $1 + 16 | 0;
  return $0 ? HEAP32[$1 + 8 >> 2] : 0;
 }
 
 function truncate($0, $1, $2) {
  return __syscall_ret(__syscall193($0 | 0, 0, $1 | 0, $2 | 0) | 0);
 }
 
 function unlink($0) {
  return __syscall_ret(__syscall10($0 | 0) | 0);
 }
 
 function fsync($0) {
  var $1 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $0 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $1 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $1 = 0
  }
  label$2 : {
   if (global$2 ? !$1 : 1) {
    $1 = __wasi_fd_sync($0 | 0) | 0;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $1;
   }
   if (!global$2) {
    return __wasi_syscall_ret($0)
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  return 0;
 }
 
 function getpid() {
  return __syscall20() | 0;
 }
 
 function setpgrp() {
  return setpgid(0, 0);
 }
 
 function fdatasync($0) {
  return __syscall_ret(__syscall148($0 | 0) | 0);
 }
 
 function getuid() {
  return __syscall199() | 0;
 }
 
 function ualarm($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = global$0 - 16 | 0;
  global$0 = $2;
  $3 = $2 + 12 | 0;
  HEAP32[$3 >> 2] = $0;
  HEAP32[$2 + 8 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[$2 >> 2] = 0;
  setitimer(0, $2 | 0, $2 | 0) | 0;
  global$0 = $2 + 16 | 0;
  $0 = HEAP32[$3 >> 2];
  $1 = HEAP32[$2 + 8 >> 2];
  return $0 + Math_imul($1, 1e6) | 0;
 }
 
 function fcntl($0, $1, $2) {
  var $3 = 0;
  $3 = global$0 - 144 | 0;
  global$0 = $3;
  HEAP32[$3 + 140 >> 2] = $2 + 4;
  $2 = HEAP32[$2 >> 2];
  $2 = ($1 | 0) == 4 ? $2 | 32768 : $2;
  label$1 : {
   label$2 : {
    if ($1 >>> 0 > 16) {
     break label$2
    }
    if (!(1 << $1 & 110592)) {
     if (($1 | 0) != 9) {
      if (($1 | 0) != 14) {
       break label$2
      }
      HEAP32[$3 + 16 >> 2] = $2;
      $1 = __syscall_ret(__syscall221($0 | 0, 14, $3 + 16 | 0) | 0);
      break label$1;
     }
     HEAP32[$3 + 48 >> 2] = $3 + 128;
     $1 = __syscall221($0 | 0, 16, $3 + 48 | 0) | 0;
     if ($1) {
      if (($1 | 0) == -28) {
       HEAP32[$3 + 32 >> 2] = $2;
       $1 = __syscall221($0 | 0, 9, $3 + 32 | 0) | 0;
       break label$1;
      }
      $1 = __syscall_ret($1);
      break label$1;
     }
     $1 = HEAP32[$3 + 132 >> 2];
     $1 = HEAP32[$3 + 128 >> 2] == 2 ? 0 - $1 | 0 : $1;
     break label$1;
    }
    HEAP32[$3 + 112 >> 2] = $2;
    $1 = __syscall_ret(__syscall221($0 | 0, $1 | 0, $3 + 112 | 0) | 0);
    break label$1;
   }
   if (($1 | 0) != 1030) {
    HEAP32[$3 >> 2] = $2;
    $1 = __syscall_ret(__syscall221($0 | 0, $1 | 0, $3 | 0) | 0);
    break label$1;
   }
   HEAP32[$3 + 96 >> 2] = $2;
   $1 = __syscall221($0 | 0, 1030, $3 + 96 | 0) | 0;
   if (($1 | 0) != -28) {
    $1 = __syscall_ret($1);
    break label$1;
   }
   HEAP32[$3 + 80 >> 2] = 0;
   $1 = __syscall221($0 | 0, 1030, $3 + 80 | 0) | 0;
   if (($1 | 0) != -28) {
    if (($1 | 0) >= 0) {
     __wasi_fd_close($1 | 0) | 0
    }
    $1 = __syscall_ret(-28);
    break label$1;
   }
   HEAP32[$3 + 64 >> 2] = $2;
   $1 = __syscall_ret(__syscall221($0 | 0, 0, $3 - -64 | 0) | 0);
  }
  global$0 = $3 + 144 | 0;
  return $1;
 }
 
 function strcmp($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0;
  $2 = HEAPU8[$0 | 0];
  $3 = HEAPU8[$1 | 0];
  label$1 : {
   if (!$2 | ($2 | 0) != ($3 | 0)) {
    break label$1
   }
   while (1) {
    $3 = HEAPU8[$1 + 1 | 0];
    $2 = HEAPU8[$0 + 1 | 0];
    if (!$2) {
     break label$1
    }
    $1 = $1 + 1 | 0;
    $0 = $0 + 1 | 0;
    if (($2 | 0) == ($3 | 0)) {
     continue
    }
    break;
   };
  }
  return $2 - $3 | 0;
 }
 
 function strchr($0, $1) {
  $0 = __strchrnul($0, $1);
  return HEAPU8[$0 | 0] == ($1 & 255) ? $0 : 0;
 }
 
 function memcmp($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0;
  label$1 : {
   if (!$2) {
    break label$1
   }
   while (1) {
    $3 = HEAPU8[$0 | 0];
    $4 = HEAPU8[$1 | 0];
    if (($3 | 0) == ($4 | 0)) {
     $1 = $1 + 1 | 0;
     $0 = $0 + 1 | 0;
     $2 = $2 + -1 | 0;
     if ($2) {
      continue
     }
     break label$1;
    }
    break;
   };
   $5 = $3 - $4 | 0;
  }
  return $5;
 }
 
 function strspn($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $4 = global$0 - 32 | 0;
  $2 = $4;
  HEAP32[$2 + 24 >> 2] = 0;
  HEAP32[$2 + 28 >> 2] = 0;
  HEAP32[$2 + 16 >> 2] = 0;
  HEAP32[$2 + 20 >> 2] = 0;
  HEAP32[$2 + 8 >> 2] = 0;
  HEAP32[$2 + 12 >> 2] = 0;
  HEAP32[$2 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 0;
  $3 = HEAPU8[$1 | 0];
  if (!$3) {
   return 0
  }
  if (!HEAPU8[$1 + 1 | 0]) {
   $1 = $0;
   while (1) {
    $2 = $1;
    $1 = $1 + 1 | 0;
    if (HEAPU8[$2 | 0] == ($3 | 0)) {
     continue
    }
    break;
   };
   return $2 - $0 | 0;
  }
  while (1) {
   $2 = ($3 >>> 3 & 28) + $4 | 0;
   HEAP32[$2 >> 2] = HEAP32[$2 >> 2] | 1 << ($3 & 31);
   $3 = HEAPU8[$1 + 1 | 0];
   $1 = $1 + 1 | 0;
   if ($3) {
    continue
   }
   break;
  };
  $2 = $0;
  $3 = HEAPU8[$2 | 0];
  label$5 : {
   if (!$3) {
    break label$5
   }
   $1 = $0;
   while (1) {
    if (!(HEAP32[($3 >>> 3 & 28) + $4 >> 2] >>> ($3 & 31) & 1)) {
     $2 = $1;
     break label$5;
    }
    $3 = HEAPU8[$1 + 1 | 0];
    $2 = $1 + 1 | 0;
    $1 = $2;
    if ($3) {
     continue
    }
    break;
   };
  }
  return $2 - $0 | 0;
 }
 
 function strtok($0, $1) {
  var $2 = 0;
  label$1 : {
   if (!$0) {
    $0 = HEAP32[6004];
    if (!$0) {
     break label$1
    }
   }
   $2 = strspn($0, $1) + $0 | 0;
   if (!HEAPU8[$2 | 0]) {
    HEAP32[6004] = 0;
    return 0;
   }
   $0 = strcspn($2, $1) + $2 | 0;
   HEAP32[6004] = $0;
   if (HEAPU8[$0 | 0]) {
    HEAP32[6004] = $0 + 1;
    HEAP8[$0 | 0] = 0;
    return $2;
   }
   HEAP32[6004] = 0;
  }
  return $2;
 }
 
 function index($0, $1) {
  return strchr($0, $1);
 }
 
 function strncat($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $3 = strlen($0) + $0 | 0;
  label$1 : {
   if (!$2) {
    break label$1
   }
   while (1) {
    $4 = HEAPU8[$1 | 0];
    if (!$4) {
     break label$1
    }
    HEAP8[$3 | 0] = $4;
    $3 = $3 + 1 | 0;
    $1 = $1 + 1 | 0;
    $2 = $2 + -1 | 0;
    if ($2) {
     continue
    }
    break;
   };
  }
  HEAP8[$3 | 0] = 0;
  return $0;
 }
 
 function strcspn($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $4 = global$0 - 32 | 0;
  global$0 = $4;
  $2 = HEAP8[$1 | 0];
  label$1 : {
   if (!(HEAPU8[$1 + 1 | 0] ? $2 : 0)) {
    $3 = __strchrnul($0, $2);
    break label$1;
   }
   memset($4, 0, 32);
   $2 = HEAPU8[$1 | 0];
   if ($2) {
    while (1) {
     $3 = ($2 >>> 3 & 28) + $4 | 0;
     HEAP32[$3 >> 2] = HEAP32[$3 >> 2] | 1 << ($2 & 31);
     $2 = HEAPU8[$1 + 1 | 0];
     $1 = $1 + 1 | 0;
     if ($2) {
      continue
     }
     break;
    }
   }
   $3 = $0;
   $2 = HEAPU8[$3 | 0];
   if (!$2) {
    break label$1
   }
   $1 = $0;
   while (1) {
    if (HEAP32[($2 >>> 3 & 28) + $4 >> 2] >>> ($2 & 31) & 1) {
     $3 = $1;
     break label$1;
    }
    $2 = HEAPU8[$1 + 1 | 0];
    $3 = $1 + 1 | 0;
    $1 = $3;
    if ($2) {
     continue
    }
    break;
   };
  }
  global$0 = $4 + 32 | 0;
  return $3 - $0 | 0;
 }
 
 function strtok_r($0, $1, $2) {
  label$1 : {
   if ($0) {
    break label$1
   }
   $0 = HEAP32[$2 >> 2];
   if ($0) {
    break label$1
   }
   return 0;
  }
  $0 = strspn($0, $1) + $0 | 0;
  if (!HEAPU8[$0 | 0]) {
   HEAP32[$2 >> 2] = 0;
   return 0;
  }
  $1 = strcspn($0, $1) + $0 | 0;
  HEAP32[$2 >> 2] = $1;
  if (HEAPU8[$1 | 0]) {
   HEAP32[$2 >> 2] = $1 + 1;
   HEAP8[$1 | 0] = 0;
   return $0;
  }
  HEAP32[$2 >> 2] = 0;
  return $0;
 }
 
 function __stpncpy($0, $1, $2) {
  var $3 = 0;
  label$1 : {
   label$2 : {
    label$3 : {
     if (($0 ^ $1) & 3) {
      break label$3
     }
     $3 = ($2 | 0) != 0;
     label$4 : {
      if (!$2 | !($1 & 3)) {
       break label$4
      }
      while (1) {
       $3 = HEAPU8[$1 | 0];
       HEAP8[$0 | 0] = $3;
       if (!$3) {
        break label$1
       }
       $0 = $0 + 1 | 0;
       $1 = $1 + 1 | 0;
       $2 = $2 + -1 | 0;
       $3 = ($2 | 0) != 0;
       if (!$2) {
        break label$4
       }
       if ($1 & 3) {
        continue
       }
       break;
      };
     }
     if (!$3) {
      break label$2
     }
     if (!HEAPU8[$1 | 0]) {
      break label$1
     }
     if ($2 >>> 0 < 4) {
      break label$3
     }
     while (1) {
      $3 = HEAP32[$1 >> 2];
      if (($3 ^ -1) & $3 + -16843009 & -2139062144) {
       break label$3
      }
      HEAP32[$0 >> 2] = $3;
      $0 = $0 + 4 | 0;
      $1 = $1 + 4 | 0;
      $2 = $2 + -4 | 0;
      if ($2 >>> 0 > 3) {
       continue
      }
      break;
     };
    }
    if (!$2) {
     break label$2
    }
    while (1) {
     $3 = HEAPU8[$1 | 0];
     HEAP8[$0 | 0] = $3;
     if (!$3) {
      break label$1
     }
     $0 = $0 + 1 | 0;
     $1 = $1 + 1 | 0;
     $2 = $2 + -1 | 0;
     if ($2) {
      continue
     }
     break;
    };
   }
   $2 = 0;
  }
  memset($0, 0, $2);
  return $0;
 }
 
 function strncpy($0, $1, $2) {
  __stpncpy($0, $1, $2);
  return $0;
 }
 
 function strstr($0, $1) {
  var $2 = 0, $3 = 0;
  $2 = HEAP8[$1 | 0];
  if (!$2) {
   return $0
  }
  $0 = strchr($0, $2);
  label$2 : {
   if (!$0) {
    break label$2
   }
   if (!HEAPU8[$1 + 1 | 0]) {
    return $0
   }
   if (!HEAPU8[$0 + 1 | 0]) {
    break label$2
   }
   if (!HEAPU8[$1 + 2 | 0]) {
    return twobyte_strstr($0, $1)
   }
   if (!HEAPU8[$0 + 2 | 0]) {
    break label$2
   }
   if (!HEAPU8[$1 + 3 | 0]) {
    return threebyte_strstr($0, $1)
   }
   if (!HEAPU8[$0 + 3 | 0]) {
    break label$2
   }
   if (!HEAPU8[$1 + 4 | 0]) {
    return fourbyte_strstr($0, $1)
   }
   $3 = twoway_strstr($0, $1);
  }
  return $3;
 }
 
 function twobyte_strstr($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $2 = HEAPU8[$0 + 1 | 0];
  $4 = ($2 | 0) != 0;
  label$1 : {
   if (!$2) {
    break label$1
   }
   $3 = HEAPU8[$0 | 0] << 8 | $2;
   $5 = HEAPU8[$1 + 1 | 0] | HEAPU8[$1 | 0] << 8;
   if (($3 | 0) == ($5 | 0)) {
    break label$1
   }
   $1 = $0 + 1 | 0;
   while (1) {
    $0 = $1;
    $2 = HEAPU8[$0 + 1 | 0];
    $4 = ($2 | 0) != 0;
    if (!$2) {
     break label$1
    }
    $1 = $0 + 1 | 0;
    $3 = $3 << 8 & 65280 | $2;
    if (($5 | 0) != ($3 | 0)) {
     continue
    }
    break;
   };
  }
  return $4 ? $0 : 0;
 }
 
 function threebyte_strstr($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  $2 = $0 + 2 | 0;
  $4 = HEAPU8[$0 + 2 | 0];
  $5 = ($4 | 0) != 0;
  $3 = HEAPU8[$0 | 0] << 24 | HEAPU8[$0 + 1 | 0] << 16 | $4 << 8;
  $6 = HEAPU8[$1 + 1 | 0] << 16 | HEAPU8[$1 | 0] << 24 | HEAPU8[$1 + 2 | 0] << 8;
  label$1 : {
   if (!(!$4 | ($3 | 0) == ($6 | 0))) {
    while (1) {
     $1 = $2 + 1 | 0;
     $0 = HEAPU8[$2 + 1 | 0];
     $5 = ($0 | 0) != 0;
     $3 = ($0 | $3) << 8;
     if (($6 | 0) == ($3 | 0)) {
      break label$1
     }
     $2 = $1;
     if ($0) {
      continue
     }
     break;
    };
    break label$1;
   }
   $1 = $2;
  }
  return $5 ? $1 + -2 | 0 : 0;
 }
 
 function fourbyte_strstr($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $3 = $0 + 3 | 0;
  $2 = HEAPU8[$0 + 3 | 0];
  $5 = ($2 | 0) != 0;
  $4 = HEAPU8[$0 | 0] << 24 | HEAPU8[$0 + 1 | 0] << 16 | HEAPU8[$0 + 2 | 0] << 8 | $2;
  $0 = HEAPU8[$1 | 0] | HEAPU8[$1 + 1 | 0] << 8 | (HEAPU8[$1 + 2 | 0] << 16 | HEAPU8[$1 + 3 | 0] << 24);
  $1 = $0 << 24;
  $1 = $0 >>> 8 & 65280 | $0 >>> 24 | ($0 << 8 & 16711680 | $1);
  label$1 : {
   if (!(!$2 | ($4 | 0) == ($1 | 0))) {
    while (1) {
     $2 = $3 + 1 | 0;
     $0 = HEAPU8[$3 + 1 | 0];
     $5 = ($0 | 0) != 0;
     $4 = $4 << 8 | $0;
     if (($4 | 0) == ($1 | 0)) {
      break label$1
     }
     $3 = $2;
     if ($0) {
      continue
     }
     break;
    };
    break label$1;
   }
   $2 = $3;
  }
  return $5 ? $2 + -3 | 0 : 0;
 }
 
 function twoway_strstr($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
  $7 = global$0 - 1056 | 0;
  global$0 = $7;
  $2 = $7 + 1048 | 0;
  HEAP32[$2 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 0;
  $2 = $7 + 1040 | 0;
  HEAP32[$2 >> 2] = 0;
  HEAP32[$2 + 4 >> 2] = 0;
  HEAP32[$7 + 1032 >> 2] = 0;
  HEAP32[$7 + 1036 >> 2] = 0;
  HEAP32[$7 + 1024 >> 2] = 0;
  HEAP32[$7 + 1028 >> 2] = 0;
  label$1 : {
   label$2 : {
    label$3 : {
     label$4 : {
      $2 = HEAPU8[$1 | 0];
      label$5 : {
       if (!$2) {
        $8 = -1;
        $4 = 1;
        break label$5;
       }
       while (1) {
        if (!HEAPU8[$0 + $5 | 0]) {
         break label$2
        }
        $4 = $2 & 255;
        $5 = $5 + 1 | 0;
        HEAP32[($4 << 2) + $7 >> 2] = $5;
        $4 = ($7 + 1024 | 0) + ($4 >>> 3 & 28) | 0;
        $2 = HEAP32[$4 >> 2] | 1 << ($2 & 31);
        HEAP32[$4 >> 2] = $2;
        $2 = HEAPU8[$1 + $5 | 0];
        if ($2) {
         continue
        }
        break;
       };
       $4 = 1;
       $8 = -1;
       if ($5 >>> 0 > 1) {
        break label$4
       }
      }
      $6 = -1;
      $10 = 1;
      break label$3;
     }
     $9 = 1;
     $2 = 1;
     while (1) {
      $6 = HEAPU8[($2 + $8 | 0) + $1 | 0];
      $10 = HEAPU8[$1 + $4 | 0];
      label$9 : {
       if (($6 | 0) == ($10 | 0)) {
        if (($2 | 0) == ($9 | 0)) {
         $3 = $3 + $9 | 0;
         $2 = 1;
         break label$9;
        }
        $2 = $2 + 1 | 0;
        break label$9;
       }
       if ($6 >>> 0 > $10 >>> 0) {
        $9 = $4 - $8 | 0;
        $3 = $4;
        $2 = 1;
        break label$9;
       }
       $8 = $3;
       $3 = $3 + 1 | 0;
       $9 = 1;
       $2 = 1;
      }
      $4 = $2 + $3 | 0;
      if ($4 >>> 0 < $5 >>> 0) {
       continue
      }
      break;
     };
     $6 = -1;
     $3 = 0;
     $4 = 1;
     $10 = 1;
     $2 = 1;
     while (1) {
      $11 = HEAPU8[($2 + $6 | 0) + $1 | 0];
      $12 = HEAPU8[$1 + $4 | 0];
      label$14 : {
       if (($11 | 0) == ($12 | 0)) {
        if (($2 | 0) == ($10 | 0)) {
         $3 = $3 + $10 | 0;
         $2 = 1;
         break label$14;
        }
        $2 = $2 + 1 | 0;
        break label$14;
       }
       if ($11 >>> 0 < $12 >>> 0) {
        $10 = $4 - $6 | 0;
        $3 = $4;
        $2 = 1;
        break label$14;
       }
       $6 = $3;
       $3 = $3 + 1 | 0;
       $10 = 1;
       $2 = 1;
      }
      $4 = $2 + $3 | 0;
      if ($4 >>> 0 < $5 >>> 0) {
       continue
      }
      break;
     };
     $4 = $9;
    }
    $2 = $6 + 1 >>> 0 > $8 + 1 >>> 0;
    $9 = $2 ? $10 : $4;
    $13 = $2 ? $6 : $8;
    $11 = $13 + 1 | 0;
    label$18 : {
     if (memcmp($1, $9 + $1 | 0, $11)) {
      $2 = ($13 ^ -1) + $5 | 0;
      $3 = $13 >>> 0 > $2 >>> 0;
      $9 = ($3 ? $13 : $2) + 1 | 0;
      $14 = $5 - $9 | 0;
      $15 = 0;
      break label$18;
     }
     $14 = $5 - $9 | 0;
     $15 = $14;
    }
    $10 = $5 + -1 | 0;
    $12 = $5 | 63;
    $6 = 0;
    $4 = $0;
    while (1) {
     label$21 : {
      if ($0 - $4 >>> 0 >= $5 >>> 0) {
       break label$21
      }
      $2 = memchr($0, 0, $12);
      if ($2) {
       $0 = $2;
       if ($2 - $4 >>> 0 < $5 >>> 0) {
        break label$2
       }
       break label$21;
      }
      $0 = $0 + $12 | 0;
     }
     $2 = HEAPU8[$4 + $10 | 0];
     $3 = $5;
     label$23 : {
      label$24 : {
       if (!(HEAP32[($7 + 1024 | 0) + ($2 >>> 3 & 28) >> 2] >>> ($2 & 31) & 1)) {
        break label$24
       }
       $2 = $5 - HEAP32[($2 << 2) + $7 >> 2] | 0;
       if ($2) {
        $3 = $15 ? ($6 ? ($2 >>> 0 < $9 >>> 0 ? $14 : $2) : $2) : $2;
        break label$24;
       }
       $2 = $11;
       $3 = $2 >>> 0 > $6 >>> 0;
       label$26 : {
        $3 = $3 ? $2 : $6;
        $8 = HEAPU8[$3 + $1 | 0];
        if ($8) {
         while (1) {
          if (HEAPU8[$4 + $3 | 0] != ($8 & 255)) {
           break label$26
          }
          $3 = $3 + 1 | 0;
          $8 = HEAPU8[$3 + $1 | 0];
          if ($8) {
           continue
          }
          break;
         }
        }
        while (1) {
         if ($2 >>> 0 <= $6 >>> 0) {
          break label$1
         }
         $2 = $2 + -1 | 0;
         $8 = HEAPU8[$2 + $1 | 0];
         if (($8 | 0) == HEAPU8[$2 + $4 | 0]) {
          continue
         }
         break;
        };
        $2 = $9;
        $3 = $15;
        break label$23;
       }
       $3 = $3 - $13 | 0;
      }
      $2 = $3;
      $3 = 0;
     }
     $6 = $3;
     $4 = $2 + $4 | 0;
     continue;
    };
   }
   $4 = 0;
  }
  global$0 = $7 + 1056 | 0;
  return $4;
 }
 
 function strncmp($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0;
  if (!$2) {
   return 0
  }
  $3 = HEAPU8[$0 | 0];
  label$2 : {
   if (!$3) {
    break label$2
   }
   while (1) {
    label$4 : {
     $4 = HEAPU8[$1 | 0];
     if (($4 | 0) != ($3 | 0)) {
      break label$4
     }
     $2 = $2 + -1 | 0;
     if (!$2 | !$4) {
      break label$4
     }
     $1 = $1 + 1 | 0;
     $3 = HEAPU8[$0 + 1 | 0];
     $0 = $0 + 1 | 0;
     if ($3) {
      continue
     }
     break label$2;
    }
    break;
   };
   $5 = $3;
  }
  return ($5 & 255) - HEAPU8[$1 | 0] | 0;
 }
 
 function __strdup($0) {
  var $1 = 0, $2 = 0;
  $1 = strlen($0) + 1 | 0;
  $2 = dlmalloc($1);
  if (!$2) {
   return 0
  }
  return memcpy($2, $0, $1);
 }
 
 function __strchrnul($0, $1) {
  var $2 = 0, $3 = 0;
  label$1 : {
   $3 = $1 & 255;
   if ($3) {
    if ($0 & 3) {
     while (1) {
      $2 = HEAPU8[$0 | 0];
      if (!$2 | ($1 & 255) == ($2 | 0)) {
       break label$1
      }
      $0 = $0 + 1 | 0;
      if ($0 & 3) {
       continue
      }
      break;
     }
    }
    $2 = HEAP32[$0 >> 2];
    label$5 : {
     if (($2 ^ -1) & $2 + -16843009 & -2139062144) {
      break label$5
     }
     $3 = Math_imul($3, 16843009);
     while (1) {
      $2 = $2 ^ $3;
      if (($2 ^ -1) & $2 + -16843009 & -2139062144) {
       break label$5
      }
      $2 = HEAP32[$0 + 4 >> 2];
      $0 = $0 + 4 | 0;
      if (!($2 + -16843009 & ($2 ^ -1) & -2139062144)) {
       continue
      }
      break;
     };
    }
    while (1) {
     $2 = $0;
     $3 = HEAPU8[$2 | 0];
     if ($3) {
      $0 = $2 + 1 | 0;
      if (($1 & 255) != ($3 | 0)) {
       continue
      }
     }
     break;
    };
    return $2;
   }
   return strlen($0) + $0 | 0;
  }
  return $0;
 }
 
 function strcat($0, $1) {
  strcpy(strlen($0) + $0 | 0, $1);
  return $0;
 }
 
 function rindex($0, $1) {
  return strrchr($0, $1);
 }
 
 function __stpcpy($0, $1) {
  var $2 = 0;
  label$1 : {
   label$2 : {
    if (($0 ^ $1) & 3) {
     break label$2
    }
    if ($1 & 3) {
     while (1) {
      $2 = HEAPU8[$1 | 0];
      HEAP8[$0 | 0] = $2;
      if (!$2) {
       break label$1
      }
      $0 = $0 + 1 | 0;
      $1 = $1 + 1 | 0;
      if ($1 & 3) {
       continue
      }
      break;
     }
    }
    $2 = HEAP32[$1 >> 2];
    if (($2 ^ -1) & $2 + -16843009 & -2139062144) {
     break label$2
    }
    while (1) {
     HEAP32[$0 >> 2] = $2;
     $2 = HEAP32[$1 + 4 >> 2];
     $0 = $0 + 4 | 0;
     $1 = $1 + 4 | 0;
     if (!($2 + -16843009 & ($2 ^ -1) & -2139062144)) {
      continue
     }
     break;
    };
   }
   $2 = HEAPU8[$1 | 0];
   HEAP8[$0 | 0] = $2;
   if (!$2) {
    break label$1
   }
   while (1) {
    $2 = HEAPU8[$1 + 1 | 0];
    HEAP8[$0 + 1 | 0] = $2;
    $0 = $0 + 1 | 0;
    $1 = $1 + 1 | 0;
    if ($2) {
     continue
    }
    break;
   };
  }
  return $0;
 }
 
 function strcpy($0, $1) {
  __stpcpy($0, $1);
  return $0;
 }
 
 function strpbrk($0, $1) {
  $0 = strcspn($0, $1) + $0 | 0;
  $1 = HEAPU8[$0 | 0];
  return $1 ? $0 : 0;
 }
 
 function memchr($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $3 = ($2 | 0) != 0;
  label$1 : {
   label$2 : {
    label$3 : {
     label$4 : {
      if (!$2 | !($0 & 3)) {
       break label$4
      }
      $4 = $1 & 255;
      while (1) {
       if (HEAPU8[$0 | 0] == ($4 | 0)) {
        break label$3
       }
       $0 = $0 + 1 | 0;
       $2 = $2 + -1 | 0;
       $3 = ($2 | 0) != 0;
       if (!$2) {
        break label$4
       }
       if ($0 & 3) {
        continue
       }
       break;
      };
     }
     if (!$3) {
      break label$2
     }
    }
    if (HEAPU8[$0 | 0] == ($1 & 255)) {
     break label$1
    }
    label$6 : {
     if ($2 >>> 0 >= 4) {
      $4 = Math_imul($1 & 255, 16843009);
      while (1) {
       $3 = HEAP32[$0 >> 2] ^ $4;
       if (($3 ^ -1) & $3 + -16843009 & -2139062144) {
        break label$6
       }
       $0 = $0 + 4 | 0;
       $2 = $2 + -4 | 0;
       if ($2 >>> 0 > 3) {
        continue
       }
       break;
      };
     }
     if (!$2) {
      break label$2
     }
    }
    $3 = $1 & 255;
    while (1) {
     if (HEAPU8[$0 | 0] == ($3 | 0)) {
      break label$1
     }
     $0 = $0 + 1 | 0;
     $2 = $2 + -1 | 0;
     if ($2) {
      continue
     }
     break;
    };
   }
   return 0;
  }
  return $0;
 }
 
 function __memrchr($0, $1, $2) {
  var $3 = 0;
  $1 = $1 & 255;
  while (1) {
   if (!$2) {
    return 0
   }
   $2 = $2 + -1 | 0;
   $3 = $2 + $0 | 0;
   if (HEAPU8[$3 | 0] != ($1 | 0)) {
    continue
   }
   break;
  };
  return $3;
 }
 
 function strrchr($0, $1) {
  return __memrchr($0, $1, strlen($0) + 1 | 0);
 }
 
 function __randname($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  $1 = global$0 - 16 | 0;
  global$0 = $1;
  __clock_gettime(0, $1 + 8 | 0) | 0;
  $2 = ($1 + 8 >>> 4 | 0) + $0 ^ Math_imul(HEAP32[$1 + 12 >> 2], 65537);
  while (1) {
   HEAP8[$0 + $3 | 0] = ($2 & 15 | $2 << 1 & 32) + 65;
   $2 = $2 >>> 5 | 0;
   $3 = $3 + 1 | 0;
   if (($3 | 0) != 6) {
    continue
   }
   break;
  };
  global$0 = $1 + 16 | 0;
  return $0;
 }
 
 function stat($0, $1) {
  return __syscall_ret(__syscall195($0 | 0, $1 | 0) | 0);
 }
 
 function srand($0) {
  HEAP32[6006] = $0 + -1;
  HEAP32[6007] = 0;
 }
 
 function rand() {
  var $0 = 0, $1 = 0;
  $0 = __wasm_i64_mul(HEAP32[6006], HEAP32[6007], 1284865837, 1481765933);
  $1 = i64toi32_i32$HIGH_BITS;
  $0 = $0 + 1 | 0;
  if ($0 >>> 0 < 1) {
   $1 = $1 + 1 | 0
  }
  HEAP32[6006] = $0;
  HEAP32[6007] = $1;
  return $1 >>> 1 | 0;
 }
 
 function getpagesize() {
  return 16384;
 }
 
 function __emscripten_environ_constructor() {
  var $0 = 0, $1 = 0, $2 = 0;
  $0 = global$0 - 16 | 0;
  global$0 = $0;
  label$1 : {
   if (__wasi_environ_sizes_get($0 + 12 | 0, $0 + 8 | 0)) {
    break label$1
   }
   $1 = dlmalloc((HEAP32[$0 + 12 >> 2] << 2) + 4 | 0);
   HEAP32[6008] = $1;
   if (!$1) {
    break label$1
   }
   label$2 : {
    $1 = dlmalloc(HEAP32[$0 + 8 >> 2]);
    if ($1) {
     $2 = HEAP32[6008];
     if ($2) {
      break label$2
     }
    }
    HEAP32[6008] = 0;
    break label$1;
   }
   HEAP32[(HEAP32[$0 + 12 >> 2] << 2) + $2 >> 2] = 0;
   if (!__wasi_environ_get(HEAP32[6008], $1 | 0)) {
    break label$1
   }
   HEAP32[6008] = 0;
  }
  global$0 = $0 + 16 | 0;
 }
 
 function getenv($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $4 = strlen($0);
  label$1 : {
   label$2 : {
    if (!HEAP32[6008] | !HEAPU8[$0 | 0]) {
     break label$2
    }
    if (strchr($0, 61)) {
     break label$2
    }
    $1 = HEAP32[HEAP32[6008] >> 2];
    if (!$1) {
     break label$2
    }
    while (1) {
     $2 = strncmp($0, $1, $4);
     $1 = HEAP32[6008];
     if (!$2) {
      $2 = HEAP32[($3 << 2) + $1 >> 2];
      $5 = $4 + $2 | 0;
      if (HEAPU8[$5 | 0] == 61) {
       break label$1
      }
     }
     $3 = $3 + 1 | 0;
     $1 = HEAP32[($3 << 2) + $1 >> 2];
     if ($1) {
      continue
     }
     break;
    };
   }
   return 0;
  }
  return ($2 ? $5 + 1 | 0 : 0) | 0;
 }
 
 function _get_tzname() {
  return 24036;
 }
 
 function _get_daylight() {
  return 24044;
 }
 
 function _get_timezone() {
  return 24048;
 }
 
 function __lock($0) {
  
 }
 
 function __unlock($0) {
  
 }
 
 function __wasi_syscall_ret($0) {
  if (!$0) {
   return 0
  }
  HEAP32[__errno_location() >> 2] = $0;
  return -1;
 }
 
 function __wasi_fd_is_valid($0) {
  var $1 = 0;
  $1 = global$0 - 32 | 0;
  global$0 = $1;
  $0 = __wasi_fd_fdstat_get($0 | 0, $1 + 8 | 0) | 0;
  if ($0) {
   HEAP32[__errno_location() >> 2] = $0;
   $0 = 0;
  } else {
   $0 = 1
  }
  global$0 = $1 + 32 | 0;
  return $0;
 }
 
 function __addtf3($0, $1, $2, $3, $4, $5, $6, $7, $8) {
  var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0;
  $17 = global$0 - 112 | 0;
  global$0 = $17;
  $13 = $7;
  $18 = $13;
  $14 = $8;
  $11 = $14 & 2147483647;
  $19 = $11;
  $11 = $2;
  $9 = $11 + -1 | 0;
  $14 = $1;
  $10 = $14 + -1 | 0;
  if ($10 >>> 0 < 4294967295) {
   $9 = $9 + 1 | 0
  }
  $20 = $9;
  $22 = ($10 | 0) == -1 & ($9 | 0) == -1;
  $12 = $3;
  $21 = $12;
  $11 = $4;
  $9 = $11 & 2147483647;
  $23 = $9;
  $12 = $2;
  $9 = $20;
  $12 = ($12 | 0) == ($9 | 0) & $10 >>> 0 < $1 >>> 0 | $9 >>> 0 < $12 >>> 0;
  $11 = $23;
  $10 = $11;
  $14 = $3;
  $13 = $14 + $12 | 0;
  if ($13 >>> 0 < $12 >>> 0) {
   $10 = $10 + 1 | 0
  }
  $11 = $13;
  $13 = $10 + -1 | 0;
  $9 = $11 + -1 | 0;
  if ($9 >>> 0 < 4294967295) {
   $13 = $13 + 1 | 0
  }
  label$1 : {
   label$2 : {
    $11 = ($13 | 0) == 2147418111 & $9 >>> 0 > 4294967295 | $13 >>> 0 > 2147418111;
    $10 = $13;
    if (!(($9 | 0) == -1 & ($10 | 0) == 2147418111 ? $22 : $11)) {
     $12 = $6;
     $9 = $12 + -1 | 0;
     $11 = $5;
     $14 = $11 + -1 | 0;
     if ($14 >>> 0 < 4294967295) {
      $9 = $9 + 1 | 0
     }
     $12 = $14;
     $20 = ($12 | 0) != -1 | ($9 | 0) != -1;
     $12 = $9;
     $9 = $6;
     $13 = $14;
     $9 = ($12 | 0) == ($9 | 0) & $13 >>> 0 < $5 >>> 0 | $12 >>> 0 < $9 >>> 0;
     $13 = $19;
     $14 = $13;
     $11 = $18;
     $10 = $11 + $9 | 0;
     if ($10 >>> 0 < $9 >>> 0) {
      $14 = $14 + 1 | 0
     }
     $13 = $10;
     $10 = $14 + -1 | 0;
     $12 = $13 + -1 | 0;
     if ($12 >>> 0 < 4294967295) {
      $10 = $10 + 1 | 0
     }
     $11 = ($10 | 0) == 2147418111 & $12 >>> 0 < 4294967295 | $10 >>> 0 < 2147418111;
     $14 = $10;
     $9 = $12;
     if (($9 | 0) == -1 & ($14 | 0) == 2147418111 ? $20 : $11) {
      break label$2
     }
    }
    $9 = $2;
    $11 = !($9 | $1);
    $9 = $23;
    $13 = $21;
    $12 = ($9 | 0) == 2147418112 & $13 >>> 0 < 0 | $9 >>> 0 < 2147418112;
    $13 = $9;
    $10 = $21;
    if (!(!$10 & ($13 | 0) == 2147418112 ? $11 : $12)) {
     $14 = $3;
     $7 = $14;
     $10 = $4;
     $13 = $10 | 32768;
     $8 = $13;
     $5 = $1;
     $13 = $2;
     $6 = $13;
     break label$1;
    }
    $13 = $6;
    $11 = !($13 | $5);
    $13 = $19;
    $10 = $18;
    $12 = ($13 | 0) == 2147418112 & $10 >>> 0 < 0 | $13 >>> 0 < 2147418112;
    $10 = $13;
    $9 = $18;
    if (!(!$9 & ($10 | 0) == 2147418112 ? $11 : $12)) {
     $14 = $7;
     $7 = $14;
     $9 = $8;
     $10 = $9 | 32768;
     $8 = $10;
     break label$1;
    }
    $10 = $23;
    $14 = $10 ^ 2147418112;
    $13 = $1;
    $9 = $21;
    $10 = $9;
    $9 = $2;
    $9 = $14 | $9;
    if (!($13 | $10 | $9)) {
     $10 = $8;
     $9 = $4;
     $10 = $10 ^ $9;
     $14 = $3;
     $13 = $7;
     $9 = $14 ^ $13;
     $7 = $9;
     $14 = $10 ^ -2147483648;
     $8 = $14;
     $14 = $2;
     $9 = $6;
     $9 = $14 ^ $9;
     $14 = $7;
     $13 = $5;
     $10 = $1;
     $13 = $13 ^ $10;
     $10 = $9;
     $9 = $8;
     $10 = $10 | $9;
     $16 = !($14 | $13 | $10);
     $11 = $16;
     $13 = $11 ? 0 : $3;
     $7 = $13;
     $14 = $4;
     $9 = $11 ? 2147450880 : $14;
     $8 = $9;
     $10 = $11 ? 0 : $1;
     $5 = $10;
     $13 = $2;
     $11 = $11 ? 0 : $13;
     $6 = $11;
     break label$1;
    }
    $11 = $19;
    $10 = $11 ^ 2147418112;
    $14 = $18;
    $11 = $14;
    $9 = $5;
    $14 = $6;
    $14 = $14 | $10;
    if (!($11 | $9 | $14)) {
     break label$1
    }
    $14 = $2;
    $11 = $23;
    $11 = $14 | $11;
    $10 = $1;
    $9 = $21;
    if (!($11 | ($10 | $9))) {
     $11 = $6;
     $10 = $19;
     $10 = $11 | $10;
     $14 = $5;
     $9 = $18;
     $11 = $14 | $9;
     if ($11 | $10) {
      break label$1
     }
     $14 = $5;
     $9 = $1;
     $5 = $14 & $9;
     $11 = $2;
     $10 = $6;
     $10 = $11 & $10;
     $6 = $10;
     $14 = $7;
     $11 = $3;
     $7 = $14 & $11;
     $10 = $4;
     $9 = $8;
     $9 = $10 & $9;
     $8 = $9;
     break label$1;
    }
    $11 = $19;
    $9 = $6;
    $11 = $11 | $9;
    $14 = $18;
    $10 = $5;
    if ($11 | ($14 | $10)) {
     break label$2
    }
    $5 = $1;
    $11 = $2;
    $6 = $11;
    $7 = $3;
    $11 = $4;
    $8 = $11;
    break label$1;
   }
   $11 = $6;
   $10 = $2;
   $9 = $5;
   $14 = $1;
   $12 = ($11 | 0) == ($10 | 0) & $9 >>> 0 > $14 >>> 0 | $11 >>> 0 > $10 >>> 0;
   $11 = $23;
   $9 = $19;
   $14 = $18;
   $10 = $21;
   $13 = ($11 | 0) == ($9 | 0) & $14 >>> 0 > $10 >>> 0 | $9 >>> 0 > $11 >>> 0;
   $14 = $9;
   $10 = $18;
   $9 = $11;
   $11 = $21;
   $15 = ($10 | 0) == ($11 | 0) & ($9 | 0) == ($14 | 0) ? $12 : $13;
   $13 = $15;
   $9 = $13 ? $5 : $1;
   $18 = $9;
   $10 = $6;
   $14 = $2;
   $11 = $13 ? $10 : $14;
   $19 = $11;
   $10 = $13 ? $7 : $3;
   $21 = $10;
   $11 = $8;
   $9 = $4;
   $13 = $13 ? $11 : $9;
   $23 = $13;
   $22 = $10;
   $10 = $13 & 65535;
   $20 = $10;
   $9 = $15;
   $11 = $9 ? $3 : $7;
   $3 = $11;
   $10 = $4;
   $14 = $8;
   $13 = $9 ? $10 : $14;
   $4 = $13;
   $25 = $13 >>> 16 & 32767;
   $11 = $23;
   $16 = $11 >>> 16 & 32767;
   if (!$16) {
    $9 = $20;
    $16 = !($9 | $22);
    $14 = $16;
    $10 = $14 ? $18 : $22;
    $9 = $19;
    $13 = $20;
    $11 = $14 ? $9 : $13;
    $9 = Math_clz32($11);
    $24 = ($9 | 0) == 32 ? Math_clz32($10) + 32 | 0 : $9;
    $8 = $17 + 96 | 0;
    $14 = $19;
    $12 = $14;
    $7 = $13;
    $10 = $24;
    $9 = $16 << 6;
    $13 = $10 + $9 | 0;
    $13 >>> 0 < $9 >>> 0;
    $10 = $7;
    __ashlti3($8, $18, $12, $22, $10, $13 + -15 | 0);
    $14 = $17;
    $10 = HEAP32[$14 + 104 >> 2];
    $22 = $10;
    $12 = HEAP32[$14 + 108 >> 2];
    $20 = $12;
    $12 = HEAP32[$14 + 96 >> 2];
    $18 = $12;
    $10 = HEAP32[$14 + 100 >> 2];
    $19 = $10;
    $16 = 16 - $13 | 0;
   }
   $11 = $15;
   $9 = $11 ? $1 : $5;
   $5 = $9;
   $10 = $2;
   $12 = $6;
   $14 = $11 ? $10 : $12;
   $6 = $14;
   $11 = $3;
   $1 = $11;
   $14 = $4;
   $9 = $14 & 65535;
   $2 = $9;
   if ($25) {
    $9 = $2;
    $10 = $9;
   } else {
    $9 = $2;
    $15 = !($9 | $1);
    $12 = $15;
    $10 = $12 ? $5 : $1;
    $9 = $6;
    $11 = $2;
    $14 = $12 ? $9 : $11;
    $9 = Math_clz32($14);
    $24 = ($9 | 0) == 32 ? Math_clz32($10) + 32 | 0 : $9;
    $7 = $17 + 80 | 0;
    $12 = $6;
    $2 = $1;
    $1 = $11;
    $10 = $24;
    $9 = $15 << 6;
    $11 = $10 + $9 | 0;
    $11 >>> 0 < $9 >>> 0;
    $13 = $12;
    $10 = $1;
    __ashlti3($7, $5, $13, $2, $10, $11 + -15 | 0);
    $25 = 16 - $11 | 0;
    $12 = $17;
    $10 = HEAP32[$12 + 80 >> 2];
    $5 = $10;
    $13 = HEAP32[$12 + 84 >> 2];
    $6 = $13;
    $10 = HEAP32[$12 + 92 >> 2];
    $13 = HEAP32[$12 + 88 >> 2];
    $1 = $13;
   }
   $12 = $1;
   $2 = $12 << 3;
   $13 = $10 << 3 | $12 >>> 29;
   $1 = $13;
   $13 = $6;
   $9 = $13 >>> 29 | 0;
   $12 = 0;
   $10 = $12;
   $12 = $1;
   $10 = $12 | $10;
   $13 = $2;
   $12 = $13 | $9;
   $7 = $12;
   $13 = $10 | 524288;
   $8 = $13;
   $10 = $22;
   $13 = $20;
   $12 = $13 << 3 | $10 >>> 29;
   $2 = $12;
   $12 = $19;
   $9 = $12 >>> 29 | 0;
   $12 = $10 << 3;
   $1 = $12 | $9;
   $10 = 0;
   $13 = $10;
   $10 = $2;
   $13 = $13 | $10;
   $2 = $13;
   $10 = $3;
   $9 = $21;
   $22 = $10 ^ $9;
   $13 = $4;
   $12 = $23;
   $12 = $13 ^ $12;
   $20 = $12;
   $13 = $5;
   $5 = $13 << 3;
   $4 = $5;
   $12 = $6;
   $10 = $12 << 3 | $13 >>> 29;
   $6 = $10;
   $3 = $10;
   $15 = $16 - $25 | 0;
   label$11 : {
    if (!$15) {
     break label$11
    }
    if ($15 >>> 0 > 127) {
     $7 = 0;
     $8 = 0;
     $4 = 1;
     $10 = 0;
     break label$11;
    }
    $10 = $6;
    $13 = $8;
    __ashlti3($17 - -64 | 0, $5, $10, $7, $13, 128 - $15 | 0);
    $13 = $10;
    $10 = $8;
    __lshrti3($17 + 48 | 0, $5, $13, $7, $10, $15);
    $12 = $17;
    $10 = HEAP32[$12 + 56 >> 2];
    $7 = $10;
    $13 = HEAP32[$12 + 60 >> 2];
    $8 = $13;
    $13 = HEAP32[$12 + 48 >> 2];
    $3 = $13;
    $10 = HEAP32[$12 + 52 >> 2];
    $5 = $10;
    $10 = HEAP32[$12 + 72 >> 2];
    $4 = $10;
    $13 = HEAP32[$12 + 76 >> 2];
    $6 = $13;
    $13 = HEAP32[$12 + 64 >> 2];
    $9 = $13;
    $10 = HEAP32[$12 + 68 >> 2];
    $13 = $10;
    $10 = $6;
    $13 = $13 | $10;
    $12 = $4;
    $10 = $12 | $9;
    $12 = ($10 | 0) != 0 | ($13 | 0) != 0;
    $9 = $3;
    $4 = $12 | $9;
    $10 = $5;
   }
   $5 = $4;
   $13 = $10;
   $6 = $13;
   $10 = $1;
   $24 = $10;
   $13 = $2;
   $9 = $13 | 524288;
   $15 = $9;
   $13 = $18;
   $3 = $13 << 3;
   $9 = $19;
   $10 = $9 << 3 | $13 >>> 29;
   $4 = $10;
   $9 = $22;
   $10 = $20;
   label$13 : {
    if (($10 | 0) < -1 ? 1 : ($10 | 0) <= -1 ? ($9 >>> 0 > 4294967295 ? 0 : 1) : 0) {
     $12 = $3;
     $13 = $5;
     $14 = $12 - $13 | 0;
     $1 = $14;
     $9 = $4;
     $10 = $6;
     $11 = $10 + ($12 >>> 0 < $13 >>> 0) | 0;
     $11 = $9 - $11 | 0;
     $2 = $11;
     $9 = $24;
     $13 = $7;
     $10 = $9 - $13 | 0;
     $11 = $15;
     $12 = $8;
     $14 = $12 + ($9 >>> 0 < $13 >>> 0) | 0;
     $14 = $11 - $14 | 0;
     $7 = $14;
     $14 = $4;
     $9 = $6;
     $11 = $3;
     $13 = $5;
     $9 = ($14 | 0) == ($9 | 0) & $11 >>> 0 < $13 >>> 0 | $14 >>> 0 < $9 >>> 0;
     $12 = $10 - $9 | 0;
     $5 = $12;
     $11 = $7;
     $10 = $10 >>> 0 < $9 >>> 0;
     $10 = $11 - $10 | 0;
     $6 = $10;
     $13 = $10;
     $10 = $2;
     $13 = $13 | $10;
     $11 = $1;
     $9 = $12;
     if (!($13 | ($11 | $9))) {
      $5 = 0;
      $6 = 0;
      $7 = 0;
      $8 = 0;
      break label$1;
     }
     $13 = $6;
     $10 = $5;
     if (($13 | 0) == 524287 & $10 >>> 0 > 4294967295 | $13 >>> 0 > 524287) {
      break label$13
     }
     $10 = $6;
     $15 = !($10 | $5);
     $14 = $15;
     $11 = $14 ? $1 : $5;
     $10 = $2;
     $9 = $14 ? $10 : $6;
     $10 = Math_clz32($9);
     $7 = ($10 | 0) == 32 ? Math_clz32($11) + 32 | 0 : $10;
     $3 = $17 + 32 | 0;
     $14 = $2;
     $12 = $14;
     $14 = $6;
     $11 = $7;
     $10 = $15 << 6;
     $13 = $11 + $10 | 0;
     $13 >>> 0 < $10 >>> 0;
     $15 = $13 + -12 | 0;
     $11 = $14;
     __ashlti3($3, $1, $12, $5, $11, $15);
     $16 = $16 - $15 | 0;
     $14 = $17;
     $11 = HEAP32[$14 + 40 >> 2];
     $5 = $11;
     $12 = HEAP32[$14 + 44 >> 2];
     $6 = $12;
     $12 = HEAP32[$14 + 32 >> 2];
     $1 = $12;
     $11 = HEAP32[$14 + 36 >> 2];
     $2 = $11;
     break label$13;
    }
    $11 = $4;
    $12 = $6;
    $13 = $11 + $12 | 0;
    $14 = $3;
    $10 = $5;
    $9 = $14 + $10 | 0;
    if ($9 >>> 0 < $10 >>> 0) {
     $13 = $13 + 1 | 0
    }
    $1 = $9;
    $14 = $6;
    $2 = $13;
    $3 = ($14 | 0) == ($13 | 0) & $9 >>> 0 < $5 >>> 0 | $13 >>> 0 < $14 >>> 0;
    $11 = $8;
    $13 = $15;
    $9 = $11 + $13 | 0;
    $14 = $24;
    $10 = $7;
    $12 = $14 + $10 | 0;
    if ($12 >>> 0 < $14 >>> 0) {
     $9 = $9 + 1 | 0
    }
    $14 = $12;
    $12 = $9;
    $11 = $3;
    $13 = $14 + $11 | 0;
    if ($13 >>> 0 < $14 >>> 0) {
     $12 = $12 + 1 | 0
    }
    $5 = $13;
    $6 = $12;
    $11 = $12 & 1048576;
    if (!$11) {
     break label$13
    }
    $12 = $1;
    $7 = $12 & 1;
    $9 = 0;
    $3 = $9;
    $11 = $5;
    $12 = $11 << 31;
    $4 = $12;
    $12 = $2;
    $11 = $12 >>> 1 | 0;
    $9 = $1;
    $14 = ($12 & 1) << 31 | $9 >>> 1;
    $9 = $11;
    $11 = $4;
    $9 = $11 | $9;
    $12 = 0;
    $14 = $14 | $12;
    $11 = $7;
    $1 = $14 | $11;
    $12 = $9;
    $9 = $3;
    $12 = $12 | $9;
    $2 = $12;
    $16 = $16 + 1 | 0;
    $9 = $5;
    $5 = ($6 & 1) << 31 | $9 >>> 1;
    $12 = $6;
    $11 = $12 >>> 1 | 0;
    $6 = $11;
   }
   $7 = 0;
   $11 = $23;
   $9 = $11 & -2147483648;
   $8 = $9;
   if (($16 | 0) >= 32767) {
    $11 = $7;
    $7 = $11;
    $9 = $8;
    $12 = $9 | 2147418112;
    $8 = $12;
    $5 = 0;
    $6 = 0;
    break label$1;
   }
   $15 = 0;
   label$17 : {
    if (($16 | 0) > 0) {
     $15 = $16;
     break label$17;
    }
    $12 = $2;
    $11 = $6;
    __ashlti3($17 + 16 | 0, $1, $12, $5, $11, $16 + 127 | 0);
    $11 = $12;
    $12 = $6;
    __lshrti3($17, $1, $11, $5, $12, 1 - $16 | 0);
    $9 = $17;
    $12 = HEAP32[$9 >> 2];
    $1 = $12;
    $11 = HEAP32[$9 + 4 >> 2];
    $2 = $11;
    $11 = HEAP32[$9 + 24 >> 2];
    $3 = $11;
    $12 = HEAP32[$9 + 28 >> 2];
    $4 = $12;
    $12 = HEAP32[$9 + 16 >> 2];
    $14 = $12;
    $11 = HEAP32[$9 + 20 >> 2];
    $12 = $11;
    $11 = $4;
    $12 = $11 | $12;
    $9 = $3;
    $11 = $14 | $9;
    $14 = $1;
    $9 = ($11 | 0) != 0 | ($12 | 0) != 0;
    $1 = $14 | $9;
    $11 = $2;
    $2 = $11;
    $11 = $17;
    $12 = HEAP32[$11 + 8 >> 2];
    $5 = $12;
    $14 = HEAP32[$11 + 12 >> 2];
    $6 = $14;
   }
   $14 = $6;
   $12 = $14 >>> 3 | 0;
   $11 = $5;
   $14 = ($14 & 7) << 29 | $11 >>> 3;
   $11 = $12 & 65535;
   $12 = $7;
   $9 = $14;
   $3 = $12 | $9;
   $14 = $11;
   $11 = $8;
   $14 = $14 | $11;
   $11 = $15;
   $12 = $11 << 16;
   $11 = $12;
   $12 = $14;
   $11 = $11 | $12;
   $14 = $3;
   $9 = 0;
   $24 = $14 | $9;
   $3 = $11;
   $12 = $5;
   $14 = $12 << 29;
   $4 = $14;
   $11 = $1;
   $9 = ($2 & 7) << 29 | $11 >>> 3;
   $14 = $2;
   $12 = $14 >>> 3 | 0;
   $11 = $12;
   $12 = $4;
   $11 = $11 | $12;
   $8 = $11;
   $13 = $11;
   $14 = 0;
   $7 = $14 | $9;
   $12 = $7;
   $16 = $1 & 7;
   $9 = $16 >>> 0 > 4;
   $10 = $12 + $9 | 0;
   if ($10 >>> 0 < $9 >>> 0) {
    $13 = $13 + 1 | 0
   }
   $5 = $10;
   $6 = $13;
   $12 = $8;
   $9 = $7;
   $12 = ($13 | 0) == ($12 | 0) & $10 >>> 0 < $9 >>> 0 | $13 >>> 0 < $12 >>> 0;
   $11 = $3;
   $10 = $11;
   $9 = $24;
   $14 = $12 + $9 | 0;
   if ($14 >>> 0 < $12 >>> 0) {
    $10 = $10 + 1 | 0
   }
   $3 = $14;
   $4 = $10;
   $11 = $5;
   $13 = ($16 | 0) == 4;
   $12 = $13 ? $11 & 1 : 0;
   $1 = $12;
   $9 = 0;
   $10 = $13 ? $9 : 0;
   $2 = $10;
   $12 = $10;
   $10 = $6;
   $14 = $12 + $10 | 0;
   $9 = $1;
   $11 = $11 + $9 | 0;
   if ($11 >>> 0 < $9 >>> 0) {
    $14 = $14 + 1 | 0
   }
   $5 = $11;
   $6 = $14;
   $13 = $2;
   $10 = $11;
   $13 = ($14 | 0) == ($13 | 0) & $10 >>> 0 < $1 >>> 0 | $14 >>> 0 < $13 >>> 0;
   $10 = $4;
   $11 = $10;
   $9 = $3;
   $12 = $13 + $9 | 0;
   if ($12 >>> 0 < $13 >>> 0) {
    $11 = $11 + 1 | 0
   }
   $7 = $12;
   $8 = $11;
  }
  $9 = $0;
  HEAP32[$9 >> 2] = $5;
  $11 = $6;
  HEAP32[$9 + 4 >> 2] = $11;
  HEAP32[$9 + 8 >> 2] = $7;
  $11 = $8;
  HEAP32[$9 + 12 >> 2] = $11;
  global$0 = $17 + 112 | 0;
 }
 
 function __ashlti3($0, $1, $2, $3, $4, $5) {
  var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0;
  label$1 : {
   if ($5 & 64) {
    $7 = $2;
    $8 = $1;
    $9 = $5 + -64 | 0;
    $6 = $9 & 31;
    if (32 <= ($9 & 63) >>> 0) {
     $10 = $8 << $6;
     $3 = 0;
    } else {
     $10 = (1 << $6) - 1 & $8 >>> 32 - $6 | $7 << $6;
     $3 = $8 << $6;
    }
    $4 = $10;
    $1 = 0;
    $2 = 0;
    break label$1;
   }
   if (!$5) {
    break label$1
   }
   $10 = $4;
   $7 = $3;
   $11 = $5;
   $9 = $5;
   $6 = $9 & 31;
   if (32 <= ($9 & 63) >>> 0) {
    $8 = $7 << $6;
    $3 = 0;
   } else {
    $8 = (1 << $6) - 1 & $7 >>> 32 - $6 | $10 << $6;
    $3 = $7 << $6;
   }
   $4 = $8;
   $8 = $2;
   $10 = $1;
   $7 = 0;
   $9 = 64 - $5 | 0;
   $6 = $9 & 31;
   if (32 <= ($9 & 63) >>> 0) {
    $9 = $8 >>> $6 | 0
   } else {
    $7 = $8 >>> $6 | 0;
    $9 = ((1 << $6) - 1 & $8) << 32 - $6 | $10 >>> $6;
   }
   $10 = $7;
   $8 = $3;
   $3 = $8 | $9;
   $7 = $4;
   $10 = $7 | $10;
   $4 = $10;
   $10 = $2;
   $7 = $1;
   $9 = $11;
   $6 = $9 & 31;
   if (32 <= ($9 & 63) >>> 0) {
    $8 = $7 << $6;
    $1 = 0;
   } else {
    $8 = (1 << $6) - 1 & $7 >>> 32 - $6 | $10 << $6;
    $1 = $7 << $6;
   }
   $2 = $8;
  }
  $7 = $0;
  HEAP32[$7 >> 2] = $1;
  $8 = $2;
  HEAP32[$7 + 4 >> 2] = $8;
  HEAP32[$7 + 8 >> 2] = $3;
  $8 = $4;
  HEAP32[$7 + 12 >> 2] = $8;
 }
 
 function __letf2($0, $1, $2, $3, $4, $5, $6, $7) {
  var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
  $15 = 1;
  $9 = $0;
  $10 = $1;
  $16 = ($9 | 0) != 0 | ($10 | 0) != 0;
  $9 = $3;
  $10 = $9 & 2147483647;
  $12 = $10;
  $8 = $2;
  $13 = $8;
  $14 = ($10 | 0) == 2147418112 & $8 >>> 0 > 0 | $10 >>> 0 > 2147418112;
  $9 = $10;
  $11 = $8;
  label$1 : {
   if (!$11 & ($9 | 0) == 2147418112 ? $16 : $14) {
    break label$1
   }
   $8 = $4;
   $11 = $5;
   $17 = ($8 | 0) != 0 | ($11 | 0) != 0;
   $8 = $7;
   $11 = $8 & 2147483647;
   $16 = $11;
   $10 = $6;
   $14 = $10;
   $8 = $10;
   $18 = ($11 | 0) == 2147418112 & $8 >>> 0 > 0 | $11 >>> 0 > 2147418112;
   $8 = $11;
   $9 = $10;
   if (!$9 & ($8 | 0) == 2147418112 ? $17 : $18) {
    break label$1
   }
   $10 = $13;
   $11 = $14;
   $14 = $10 | $11;
   $9 = $12;
   $8 = $16;
   $8 = $9 | $8;
   $12 = $8;
   $10 = $5;
   $8 = $1;
   $10 = $10 | $8;
   $13 = $10;
   $11 = $4;
   $9 = $0;
   $11 = $11 | $9;
   $8 = $14;
   $10 = $12;
   $9 = $13;
   $9 = $10 | $9;
   if (!($11 | $8 | $9)) {
    return 0
   }
   $9 = $3;
   $8 = $7;
   $8 = $9 & $8;
   $10 = $2;
   $11 = $6;
   $9 = $10 & $11;
   if (($8 | 0) > 0 ? 1 : ($8 | 0) >= 0 ? ($9 >>> 0 < 0 ? 0 : 1) : 0) {
    $15 = -1;
    $9 = $1;
    $8 = $5;
    $11 = $0;
    $10 = $4;
    $12 = ($9 | 0) == ($8 | 0) & $11 >>> 0 < $10 >>> 0 | $9 >>> 0 < $8 >>> 0;
    $10 = $2;
    $8 = $6;
    $11 = $3;
    $9 = $7;
    $13 = ($11 | 0) < ($9 | 0) ? 1 : ($11 | 0) <= ($9 | 0) ? ($10 >>> 0 >= $8 >>> 0 ? 0 : 1) : 0;
    $9 = $8;
    $8 = $10;
    $10 = $11;
    $11 = $7;
    if (($9 | 0) == ($8 | 0) & ($10 | 0) == ($11 | 0) ? $12 : $13) {
     break label$1
    }
    $11 = $4;
    $9 = $0;
    $4 = $11 ^ $9;
    $10 = $5;
    $8 = $1;
    $10 = $10 ^ $8;
    $0 = $10;
    $10 = $3;
    $9 = $7;
    $9 = $10 ^ $9;
    $1 = $9;
    $11 = $6;
    $8 = $2;
    $11 = $11 ^ $8;
    $9 = $0;
    $8 = $1;
    $8 = $9 | $8;
    $10 = $4;
    $9 = $11 | $10;
    return ($9 | 0) != 0 | ($8 | 0) != 0;
   }
   $15 = -1;
   $9 = $1;
   $8 = $5;
   $11 = $0;
   $10 = $4;
   $12 = ($9 | 0) == ($8 | 0) & $11 >>> 0 > $10 >>> 0 | $9 >>> 0 > $8 >>> 0;
   $10 = $2;
   $8 = $6;
   $11 = $3;
   $9 = $7;
   $13 = ($11 | 0) > ($9 | 0) ? 1 : ($11 | 0) >= ($9 | 0) ? ($10 >>> 0 <= $8 >>> 0 ? 0 : 1) : 0;
   $9 = $8;
   $8 = $10;
   $10 = $11;
   $11 = $7;
   if (($9 | 0) == ($8 | 0) & ($10 | 0) == ($11 | 0) ? $12 : $13) {
    break label$1
   }
   $11 = $4;
   $9 = $0;
   $4 = $11 ^ $9;
   $10 = $5;
   $8 = $1;
   $10 = $10 ^ $8;
   $0 = $10;
   $10 = $3;
   $9 = $7;
   $9 = $10 ^ $9;
   $1 = $9;
   $11 = $6;
   $8 = $2;
   $11 = $11 ^ $8;
   $9 = $0;
   $8 = $1;
   $8 = $9 | $8;
   $10 = $4;
   $9 = $11 | $10;
   $15 = ($9 | 0) != 0 | ($8 | 0) != 0;
  }
  return $15;
 }
 
 function __getf2($0, $1, $2, $3, $4, $5, $6, $7) {
  var $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
  $16 = -1;
  $9 = $0;
  $10 = $1;
  $15 = ($9 | 0) != 0 | ($10 | 0) != 0;
  $9 = $3;
  $10 = $9 & 2147483647;
  $12 = $10;
  $8 = $2;
  $13 = $8;
  $14 = ($10 | 0) == 2147418112 & $8 >>> 0 > 0 | $10 >>> 0 > 2147418112;
  $9 = $10;
  $11 = $8;
  label$1 : {
   if (!$11 & ($9 | 0) == 2147418112 ? $15 : $14) {
    break label$1
   }
   $8 = $4;
   $11 = $5;
   $17 = ($8 | 0) != 0 | ($11 | 0) != 0;
   $8 = $7;
   $11 = $8 & 2147483647;
   $15 = $11;
   $10 = $6;
   $14 = $10;
   $8 = $10;
   $18 = ($11 | 0) == 2147418112 & $8 >>> 0 > 0 | $11 >>> 0 > 2147418112;
   $8 = $11;
   $9 = $10;
   if (!$9 & ($8 | 0) == 2147418112 ? $17 : $18) {
    break label$1
   }
   $10 = $13;
   $11 = $14;
   $14 = $10 | $11;
   $9 = $12;
   $8 = $15;
   $8 = $9 | $8;
   $12 = $8;
   $10 = $5;
   $8 = $1;
   $10 = $10 | $8;
   $13 = $10;
   $11 = $4;
   $9 = $0;
   $11 = $11 | $9;
   $8 = $14;
   $10 = $12;
   $9 = $13;
   $9 = $10 | $9;
   if (!($11 | $8 | $9)) {
    return 0
   }
   $9 = $3;
   $8 = $7;
   $8 = $9 & $8;
   $10 = $2;
   $11 = $6;
   $9 = $10 & $11;
   if (($8 | 0) > 0 ? 1 : ($8 | 0) >= 0 ? ($9 >>> 0 < 0 ? 0 : 1) : 0) {
    $9 = $1;
    $8 = $5;
    $11 = $0;
    $10 = $4;
    $12 = ($9 | 0) == ($8 | 0) & $11 >>> 0 < $10 >>> 0 | $9 >>> 0 < $8 >>> 0;
    $10 = $2;
    $8 = $6;
    $11 = $3;
    $9 = $7;
    $13 = ($11 | 0) < ($9 | 0) ? 1 : ($11 | 0) <= ($9 | 0) ? ($10 >>> 0 >= $8 >>> 0 ? 0 : 1) : 0;
    $9 = $8;
    $8 = $10;
    $10 = $11;
    $11 = $7;
    if (($9 | 0) == ($8 | 0) & ($10 | 0) == ($11 | 0) ? $12 : $13) {
     break label$1
    }
    $11 = $4;
    $9 = $0;
    $4 = $11 ^ $9;
    $10 = $5;
    $8 = $1;
    $10 = $10 ^ $8;
    $0 = $10;
    $10 = $3;
    $9 = $7;
    $9 = $10 ^ $9;
    $1 = $9;
    $11 = $6;
    $8 = $2;
    $11 = $11 ^ $8;
    $9 = $0;
    $8 = $1;
    $8 = $9 | $8;
    $10 = $4;
    $9 = $11 | $10;
    return ($9 | 0) != 0 | ($8 | 0) != 0;
   }
   $9 = $1;
   $8 = $5;
   $11 = $0;
   $10 = $4;
   $12 = ($9 | 0) == ($8 | 0) & $11 >>> 0 > $10 >>> 0 | $9 >>> 0 > $8 >>> 0;
   $10 = $2;
   $8 = $6;
   $11 = $3;
   $9 = $7;
   $13 = ($11 | 0) > ($9 | 0) ? 1 : ($11 | 0) >= ($9 | 0) ? ($10 >>> 0 <= $8 >>> 0 ? 0 : 1) : 0;
   $9 = $8;
   $8 = $10;
   $10 = $11;
   $11 = $7;
   if (($9 | 0) == ($8 | 0) & ($10 | 0) == ($11 | 0) ? $12 : $13) {
    break label$1
   }
   $11 = $4;
   $9 = $0;
   $4 = $11 ^ $9;
   $10 = $5;
   $8 = $1;
   $10 = $10 ^ $8;
   $0 = $10;
   $10 = $3;
   $9 = $7;
   $9 = $10 ^ $9;
   $1 = $9;
   $11 = $6;
   $8 = $2;
   $11 = $11 ^ $8;
   $9 = $0;
   $8 = $1;
   $8 = $9 | $8;
   $10 = $4;
   $9 = $11 | $10;
   $16 = ($9 | 0) != 0 | ($8 | 0) != 0;
  }
  return $16;
 }
 
 function __divtf3($0, $1, $2, $3, $4, $5, $6, $7, $8) {
  var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0;
  $19 = global$0 - 192 | 0;
  global$0 = $19;
  $12 = $7;
  $36 = $12;
  $13 = $8;
  $9 = $13 & 65535;
  $37 = $9;
  $13 = $3;
  $25 = $13;
  $9 = $4;
  $12 = $9 & 65535;
  $26 = $12;
  $12 = $9;
  $9 = $13;
  $13 = $8;
  $13 = $12 ^ $13;
  $10 = $7;
  $9 = $13 & -2147483648;
  $33 = $9;
  $9 = $8;
  $38 = $9 >>> 16 & 32767;
  label$1 : {
   $12 = $4;
   $16 = $12 >>> 16 & 32767;
   label$2 : {
    label$3 : {
     if ($16 + -1 >>> 0 <= 32765) {
      if ($38 + -1 >>> 0 < 32766) {
       break label$3
      }
     }
     $13 = $2;
     $11 = !($13 | $1);
     $13 = $4;
     $9 = $13 & 2147483647;
     $17 = $9;
     $12 = $3;
     $18 = $12;
     $14 = ($9 | 0) == 2147418112 & $12 >>> 0 < 0 | $9 >>> 0 < 2147418112;
     $13 = $9;
     $10 = $12;
     if (!(!$10 & ($13 | 0) == 2147418112 ? $11 : $14)) {
      $12 = $3;
      $35 = $12;
      $10 = $4;
      $13 = $10 | 32768;
      $33 = $13;
      break label$2;
     }
     $13 = $6;
     $11 = !($13 | $5);
     $13 = $8;
     $12 = $13 & 2147483647;
     $4 = $12;
     $10 = $7;
     $3 = $10;
     $14 = ($12 | 0) == 2147418112 & $10 >>> 0 < 0 | $12 >>> 0 < 2147418112;
     $13 = $12;
     $9 = $10;
     if (!(!$9 & ($13 | 0) == 2147418112 ? $11 : $14)) {
      $10 = $7;
      $35 = $10;
      $9 = $8;
      $13 = $9 | 32768;
      $33 = $13;
      $1 = $5;
      $13 = $6;
      $2 = $13;
      break label$2;
     }
     $13 = $17;
     $10 = $13 ^ 2147418112;
     $9 = $18;
     $13 = $9;
     $12 = $1;
     $9 = $2;
     $9 = $9 | $10;
     if (!($13 | $12 | $9)) {
      $9 = $4;
      $13 = $9 ^ 2147418112;
      $1 = $13;
      $9 = $5;
      $10 = $3;
      $12 = $10;
      $13 = $6;
      $10 = $1;
      $10 = $13 | $10;
      if (!($9 | $12 | $10)) {
       $1 = 0;
       $2 = 0;
       $33 = 2147450880;
       break label$2;
      }
      $13 = $35;
      $35 = $13;
      $10 = $33;
      $9 = $10 | 2147418112;
      $33 = $9;
      $1 = 0;
      $2 = 0;
      break label$2;
     }
     $9 = $4;
     $13 = $9 ^ 2147418112;
     $10 = $3;
     $9 = $10;
     $12 = $5;
     $10 = $6;
     $10 = $13 | $10;
     if (!($9 | $12 | $10)) {
      $1 = 0;
      $2 = 0;
      break label$2;
     }
     $9 = $17;
     $10 = $2;
     $9 = $9 | $10;
     $13 = $1;
     $12 = $18;
     if (!($9 | ($13 | $12))) {
      break label$1
     }
     $13 = $6;
     $9 = $4;
     $13 = $13 | $9;
     $12 = $5;
     $10 = $3;
     if (!($13 | ($12 | $10))) {
      $9 = $35;
      $35 = $9;
      $13 = $33;
      $10 = $13 | 2147418112;
      $33 = $10;
      $1 = 0;
      $2 = 0;
      break label$2;
     }
     $10 = $17;
     $13 = $18;
     if (($10 | 0) == 65535 & $13 >>> 0 <= 4294967295 | $10 >>> 0 < 65535) {
      $23 = $19 + 176 | 0;
      $8 = $1;
      $13 = $2;
      $11 = $13;
      $17 = $25;
      $13 = $26;
      $7 = $13;
      $15 = !($13 | $25);
      $14 = $15;
      $9 = $14 ? $1 : $25;
      $13 = $2;
      $10 = $26;
      $12 = $14 ? $13 : $10;
      $13 = Math_clz32($12);
      $9 = ($13 | 0) == 32 ? Math_clz32($9) + 32 | 0 : $13;
      $13 = $15 << 6;
      $10 = $13 + $9 | 0;
      $10 >>> 0 < $13 >>> 0;
      $9 = $7;
      __ashlti3($23, $8, $11, $17, $9, $10 + -15 | 0);
      $15 = 16 - $10 | 0;
      $14 = $19;
      $9 = HEAP32[$14 + 184 >> 2];
      $25 = $9;
      $11 = HEAP32[$14 + 188 >> 2];
      $26 = $11;
      $9 = HEAP32[$14 + 180 >> 2];
      $2 = $9;
      $11 = HEAP32[$14 + 176 >> 2];
      $1 = $11;
     }
     $9 = $4;
     $14 = $3;
     if (($9 | 0) == 65535 & $14 >>> 0 > 4294967295 | $9 >>> 0 > 65535) {
      break label$3
     }
     $17 = $19 + 160 | 0;
     $7 = $5;
     $14 = $6;
     $10 = $14;
     $8 = $36;
     $14 = $37;
     $4 = $14;
     $3 = !($14 | $36);
     $12 = $3;
     $11 = $12 ? $5 : $36;
     $14 = $6;
     $9 = $37;
     $13 = $12 ? $14 : $9;
     $14 = Math_clz32($13);
     $11 = ($14 | 0) == 32 ? Math_clz32($11) + 32 | 0 : $14;
     $14 = $3 << 6;
     $9 = $14 + $11 | 0;
     $9 >>> 0 < $14 >>> 0;
     $11 = $4;
     __ashlti3($17, $7, $10, $8, $11, $9 + -15 | 0);
     $15 = ($15 + $9 | 0) + -16 | 0;
     $12 = $19;
     $11 = HEAP32[$12 + 168 >> 2];
     $36 = $11;
     $10 = HEAP32[$12 + 172 >> 2];
     $37 = $10;
     $10 = HEAP32[$12 + 160 >> 2];
     $5 = $10;
     $11 = HEAP32[$12 + 164 >> 2];
     $6 = $11;
    }
    $11 = $37;
    $10 = $11 | 65536;
    $41 = $10;
    $12 = $36;
    $42 = $12;
    $11 = $12;
    $12 = $10 << 15 | $11 >>> 17;
    $4 = $12;
    $12 = $6;
    $14 = $12 >>> 17 | 0;
    $12 = $11 << 15;
    $3 = $12 | $14;
    $14 = $3;
    $13 = -102865788 - $14 | 0;
    $7 = $13;
    $11 = 0;
    $10 = $11;
    $11 = $4;
    $10 = $10 | $11;
    $4 = $10;
    $9 = $10 + (4192101508 < $14 >>> 0) | 0;
    $9 = 1963258675 - $9 | 0;
    $8 = $9;
    $9 = $10;
    $10 = $8;
    __multi3($19 + 144 | 0, $3, $9, 0, 0, $13, $10, 0, 0);
    $11 = $19;
    $14 = HEAP32[$11 + 152 >> 2];
    $9 = $14;
    $12 = 0 - $9 | 0;
    $10 = HEAP32[$11 + 156 >> 2];
    $13 = $10 + (0 < $9 >>> 0) | 0;
    $13 = 0 - $13 | 0;
    $10 = $8;
    __multi3($19 + 128 | 0, $12, $13, 0, 0, $7, $10, 0, 0);
    $11 = $19;
    $9 = HEAP32[$11 + 136 >> 2];
    $10 = HEAP32[$11 + 140 >> 2];
    $7 = $9 << 1;
    $9 = $10 << 1 | $9 >>> 31;
    $8 = $9;
    $10 = $19;
    $9 = HEAP32[$10 + 128 >> 2];
    $11 = HEAP32[$10 + 132 >> 2];
    $9 = 0;
    $10 = $9;
    $13 = $11 >>> 31 | 0;
    $11 = $7;
    $7 = $13 | $11;
    $9 = $8;
    $10 = $9 | $10;
    $8 = $10;
    $9 = $4;
    __multi3($19 + 112 | 0, $7, $10, 0, 0, $3, $9, 0, 0);
    $11 = $19;
    $13 = HEAP32[$11 + 120 >> 2];
    $10 = $13;
    $14 = 0 - $10 | 0;
    $9 = HEAP32[$11 + 124 >> 2];
    $12 = $9 + (0 < $10 >>> 0) | 0;
    $12 = 0 - $12 | 0;
    $9 = $12;
    $10 = $11 + 96 | 0;
    $12 = $8;
    __multi3($10, $7, $12, 0, 0, $14, $9, 0, 0);
    $11 = $19;
    $10 = HEAP32[$11 + 104 >> 2];
    $9 = HEAP32[$11 + 108 >> 2];
    $7 = $10 << 1;
    $10 = $9 << 1 | $10 >>> 31;
    $8 = $10;
    $9 = $19;
    $10 = HEAP32[$9 + 96 >> 2];
    $11 = HEAP32[$9 + 100 >> 2];
    $12 = $11 >>> 31 | 0;
    $11 = $7;
    $7 = $12 | $11;
    $10 = 0;
    $9 = $10;
    $10 = $8;
    $9 = $9 | $10;
    $8 = $9;
    $10 = $4;
    __multi3($19 + 80 | 0, $7, $9, 0, 0, $3, $10, 0, 0);
    $11 = $19;
    $12 = HEAP32[$11 + 88 >> 2];
    $9 = $12;
    $13 = 0 - $9 | 0;
    $10 = HEAP32[$11 + 92 >> 2];
    $14 = $10 + (0 < $9 >>> 0) | 0;
    $14 = 0 - $14 | 0;
    $10 = $14;
    $9 = $11 - -64 | 0;
    $14 = $8;
    __multi3($9, $7, $14, 0, 0, $13, $10, 0, 0);
    $11 = $19;
    $9 = HEAP32[$11 + 72 >> 2];
    $10 = HEAP32[$11 + 76 >> 2];
    $7 = $9 << 1;
    $9 = $10 << 1 | $9 >>> 31;
    $8 = $9;
    $10 = $19;
    $9 = HEAP32[$10 + 64 >> 2];
    $11 = HEAP32[$10 + 68 >> 2];
    $9 = 0;
    $10 = $9;
    $14 = $11 >>> 31 | 0;
    $11 = $7;
    $7 = $14 | $11;
    $9 = $8;
    $10 = $9 | $10;
    $8 = $10;
    $9 = $4;
    __multi3($19 + 48 | 0, $7, $10, 0, 0, $3, $9, 0, 0);
    $11 = $19;
    $14 = HEAP32[$11 + 56 >> 2];
    $10 = $14;
    $12 = 0 - $10 | 0;
    $9 = HEAP32[$11 + 60 >> 2];
    $13 = $9 + (0 < $10 >>> 0) | 0;
    $13 = 0 - $13 | 0;
    $9 = $13;
    $10 = $11 + 32 | 0;
    $13 = $8;
    __multi3($10, $7, $13, 0, 0, $12, $9, 0, 0);
    $11 = $19;
    $10 = HEAP32[$11 + 40 >> 2];
    $9 = HEAP32[$11 + 44 >> 2];
    $7 = $10 << 1;
    $10 = $9 << 1 | $10 >>> 31;
    $8 = $10;
    $9 = $19;
    $10 = HEAP32[$9 + 32 >> 2];
    $11 = HEAP32[$9 + 36 >> 2];
    $13 = $11 >>> 31 | 0;
    $11 = $7;
    $7 = $13 | $11;
    $10 = 0;
    $9 = $10;
    $10 = $8;
    $9 = $9 | $10;
    $8 = $9;
    $10 = $4;
    __multi3($19 + 16 | 0, $7, $9, 0, 0, $3, $10, 0, 0);
    $11 = $19;
    $13 = HEAP32[$11 + 24 >> 2];
    $9 = $13;
    $14 = 0 - $9 | 0;
    $10 = HEAP32[$11 + 28 >> 2];
    $12 = $10 + (0 < $9 >>> 0) | 0;
    $12 = 0 - $12 | 0;
    $10 = $12;
    $12 = $8;
    __multi3($19, $7, $12, 0, 0, $14, $10, 0, 0);
    $38 = ($16 - $38 | 0) + $15 | 0;
    $11 = $19;
    $9 = HEAP32[$11 + 8 >> 2];
    $10 = HEAP32[$11 + 12 >> 2];
    $8 = $9 << 1;
    $9 = $10 << 1 | $9 >>> 31;
    $7 = $9;
    $10 = $19;
    $9 = HEAP32[$10 >> 2];
    $11 = HEAP32[$10 + 4 >> 2];
    $9 = 0;
    $10 = $9;
    $9 = $7;
    $10 = $9 | $10;
    $12 = $11 >>> 31 | 0;
    $11 = $8;
    $9 = $12 | $11;
    $14 = $10 + -1 | 0;
    $13 = $9 + -1 | 0;
    if ($13 >>> 0 < 4294967295) {
     $14 = $14 + 1 | 0
    }
    $17 = $14;
    $9 = 0;
    $8 = $9;
    $10 = $13;
    $7 = $10;
    $10 = 0;
    $23 = $10;
    $9 = $4;
    $27 = $9;
    $14 = __wasm_i64_mul($13, $8, $9, $10);
    $28 = $14;
    $10 = i64toi32_i32$HIGH_BITS;
    $29 = $10;
    $14 = 0;
    $15 = $14;
    $9 = $3;
    $20 = $9;
    $14 = $17;
    $18 = $14;
    $9 = 0;
    $17 = $9;
    $10 = __wasm_i64_mul($3, $21, $14, $9);
    $12 = $10;
    $9 = i64toi32_i32$HIGH_BITS;
    $10 = $9;
    $9 = $29;
    $13 = $9 + $10 | 0;
    $14 = $28;
    $11 = $12 + $14 | 0;
    if ($11 >>> 0 < $12 >>> 0) {
     $13 = $13 + 1 | 0
    }
    $3 = $11;
    $4 = $13;
    $9 = $11;
    $16 = $9;
    $14 = $8;
    $9 = $15;
    $9 = __wasm_i64_mul($7, $14, $20, $9);
    $12 = $9;
    $14 = i64toi32_i32$HIGH_BITS;
    $9 = $14;
    $11 = $9 + $11 | 0;
    $13 = $31;
    $10 = $13 + $12 | 0;
    if ($10 >>> 0 < $12 >>> 0) {
     $11 = $11 + 1 | 0
    }
    $20 = $10;
    $13 = $16;
    $15 = $11;
    $12 = $22;
    $16 = ($13 | 0) == ($11 | 0) & $10 >>> 0 < $12 >>> 0 | $11 >>> 0 < $13 >>> 0;
    $14 = $17;
    $11 = $23;
    $11 = __wasm_i64_mul($18, $14, $27, $11);
    $9 = $11;
    $14 = i64toi32_i32$HIGH_BITS;
    $10 = $14;
    $14 = $4;
    $11 = $29;
    $12 = $3;
    $13 = $28;
    $13 = ($14 | 0) == ($11 | 0) & $12 >>> 0 < $13 >>> 0 | $14 >>> 0 < $11 >>> 0;
    $3 = $13;
    $13 = 0;
    $12 = $13;
    $13 = $3;
    $12 = $13 | $12;
    $3 = $12;
    $13 = $9;
    $14 = 0;
    $11 = $4;
    $11 = $14 | $11;
    $9 = $13 + $11 | 0;
    $12 = $10;
    $14 = $3;
    $10 = $12 + $14 | 0;
    $3 = $9;
    $10 = $9 >>> 0 < $11 >>> 0 ? $10 + 1 | 0 : $10;
    $9 = $10;
    $12 = $16;
    $11 = $3;
    $14 = $12 + $11 | 0;
    if ($14 >>> 0 < $11 >>> 0) {
     $9 = $9 + 1 | 0
    }
    $24 = $14;
    $21 = $9;
    $9 = $6;
    $10 = $5;
    $9 = ($9 & 131071) << 15 | $10 >>> 17;
    $27 = $9;
    $10 = 0;
    $23 = $10;
    $9 = $8;
    $9 = __wasm_i64_mul($27, $10, $7, $9);
    $28 = $9;
    $10 = i64toi32_i32$HIGH_BITS;
    $29 = $10;
    $10 = $6;
    $12 = $5;
    $10 = $12 << 15;
    $22 = $10 & -32768;
    $12 = 0;
    $16 = $12;
    $10 = $17;
    $10 = __wasm_i64_mul($22, $12, $18, $10);
    $11 = $10;
    $12 = i64toi32_i32$HIGH_BITS;
    $10 = $12;
    $12 = $29;
    $14 = $12 + $10 | 0;
    $9 = $28;
    $13 = $9 + $11 | 0;
    if ($13 >>> 0 < $11 >>> 0) {
     $14 = $14 + 1 | 0
    }
    $3 = $13;
    $4 = $14;
    $12 = $13;
    $9 = $12;
    $31 = $9;
    $9 = $21;
    $21 = $9;
    $34 = $20;
    $9 = $15;
    $32 = $9;
    $9 = $8;
    $12 = $16;
    $12 = __wasm_i64_mul($7, $9, $22, $12);
    $11 = $12;
    $9 = i64toi32_i32$HIGH_BITS;
    $12 = $9;
    $9 = $13;
    $13 = $9 + $12 | 0;
    $14 = $39;
    $10 = $14 + $11 | 0;
    if ($10 >>> 0 < $11 >>> 0) {
     $13 = $13 + 1 | 0
    }
    $14 = $31;
    $9 = $10;
    $11 = $30;
    $22 = ($14 | 0) == ($13 | 0) & $9 >>> 0 < $11 >>> 0 | $13 >>> 0 < $14 >>> 0;
    $9 = $17;
    $13 = $23;
    $13 = __wasm_i64_mul($18, $9, $27, $13);
    $10 = $13;
    $9 = i64toi32_i32$HIGH_BITS;
    $16 = $9;
    $13 = $29;
    $9 = $4;
    $11 = $3;
    $14 = $28;
    $14 = ($13 | 0) == ($9 | 0) & $11 >>> 0 < $14 >>> 0 | $9 >>> 0 < $13 >>> 0;
    $9 = $14;
    $14 = 0;
    $11 = $14;
    $11 = $9 | $11;
    $9 = $4;
    $13 = $9;
    $9 = 0;
    $13 = $13 | $9;
    $14 = $10;
    $12 = $13 + $14 | 0;
    $9 = $11;
    $11 = $16;
    $10 = $9 + $11 | 0;
    $3 = $12;
    $10 = $12 >>> 0 < $13 >>> 0 ? $10 + 1 | 0 : $10;
    $12 = $10;
    $13 = $3;
    $11 = $22;
    $9 = $13 + $11 | 0;
    if ($9 >>> 0 < $13 >>> 0) {
     $12 = $12 + 1 | 0
    }
    $13 = $9;
    $11 = $12;
    $12 = $32;
    $9 = $12 + $11 | 0;
    $10 = $34;
    $14 = $13 + $10 | 0;
    if ($14 >>> 0 < $13 >>> 0) {
     $9 = $9 + 1 | 0
    }
    $3 = $14;
    $4 = $9;
    $10 = $15;
    $12 = $14;
    $13 = $20;
    $10 = ($9 | 0) == ($10 | 0) & $12 >>> 0 < $13 >>> 0 | $9 >>> 0 < $10 >>> 0;
    $12 = $21;
    $14 = $12;
    $13 = $24;
    $11 = $13 + $10 | 0;
    if ($11 >>> 0 < $10 >>> 0) {
     $14 = $14 + 1 | 0
    }
    $10 = $11;
    $9 = $14;
    $12 = $3;
    $14 = $4;
    $13 = ($12 | 0) != 0 | ($14 | 0) != 0;
    $12 = $9;
    $11 = $12;
    $9 = $13 + $10 | 0;
    if ($9 >>> 0 < $13 >>> 0) {
     $11 = $11 + 1 | 0
    }
    $14 = 0 - $9 | 0;
    $10 = $11;
    $9 = $10 + (0 < $9 >>> 0) | 0;
    $9 = 0 - $9 | 0;
    $11 = $14;
    $12 = 0;
    $23 = $12;
    $11 = $8;
    $11 = __wasm_i64_mul($14, $12, $7, $11);
    $28 = $11;
    $12 = i64toi32_i32$HIGH_BITS;
    $29 = $12;
    $21 = $11;
    $27 = $12;
    $12 = $17;
    $11 = $23;
    $11 = __wasm_i64_mul($18, $12, $14, $11);
    $22 = $11;
    $12 = i64toi32_i32$HIGH_BITS;
    $16 = $12;
    $12 = $9;
    $30 = $12;
    $11 = 0;
    $31 = $11;
    $9 = $8;
    $9 = __wasm_i64_mul($12, $11, $7, $9);
    $13 = $9;
    $11 = i64toi32_i32$HIGH_BITS;
    $9 = $11;
    $11 = $16;
    $14 = $9 + $11 | 0;
    $12 = $22;
    $10 = $13 + $12 | 0;
    if ($10 >>> 0 < $13 >>> 0) {
     $14 = $14 + 1 | 0
    }
    $20 = $10;
    $15 = $14;
    $12 = $27;
    $10 = $12 + $10 | 0;
    $13 = 0;
    $14 = $21;
    $9 = $13 + $14 | 0;
    if ($9 >>> 0 < $13 >>> 0) {
     $10 = $10 + 1 | 0
    }
    $27 = $9;
    $23 = $10;
    $14 = $29;
    $13 = $28;
    $28 = ($10 | 0) == ($14 | 0) & $9 >>> 0 < $13 >>> 0 | $10 >>> 0 < $14 >>> 0;
    $12 = $17;
    $10 = $31;
    $10 = __wasm_i64_mul($18, $12, $30, $10);
    $9 = $10;
    $12 = i64toi32_i32$HIGH_BITS;
    $29 = $12;
    $12 = $15;
    $10 = $16;
    $13 = $20;
    $14 = $22;
    $14 = ($12 | 0) == ($10 | 0) & $13 >>> 0 < $14 >>> 0 | $12 >>> 0 < $10 >>> 0;
    $12 = $14;
    $14 = 0;
    $13 = $14;
    $14 = $12;
    $13 = $13 | $14;
    $16 = $13;
    $12 = 0;
    $10 = $15;
    $10 = $12 | $10;
    $14 = $9;
    $11 = $10 + $14 | 0;
    $13 = $29;
    $12 = $16;
    $9 = $13 + $12 | 0;
    $12 = $11;
    $9 = $11 >>> 0 < $10 >>> 0 ? $9 + 1 | 0 : $9;
    $11 = $9;
    $13 = $28;
    $10 = $12;
    $12 = $13 + $10 | 0;
    if ($12 >>> 0 < $10 >>> 0) {
     $11 = $11 + 1 | 0
    }
    $24 = $12;
    $21 = $11;
    $10 = $3;
    $14 = 0 - $10 | 0;
    $13 = $4;
    $12 = $13 + (0 < $10 >>> 0) | 0;
    $12 = 0 - $12 | 0;
    $20 = $12;
    $15 = 0;
    $11 = $8;
    $11 = __wasm_i64_mul($12, $15, $7, $11);
    $28 = $11;
    $9 = i64toi32_i32$HIGH_BITS;
    $29 = $9;
    $12 = $14;
    $22 = $12;
    $11 = 0;
    $16 = $11;
    $12 = $17;
    $12 = __wasm_i64_mul($14, $11, $18, $12);
    $10 = $12;
    $11 = i64toi32_i32$HIGH_BITS;
    $12 = $11;
    $11 = $29;
    $14 = $12 + $11 | 0;
    $9 = $28;
    $13 = $9 + $10 | 0;
    if ($13 >>> 0 < $10 >>> 0) {
     $14 = $14 + 1 | 0
    }
    $3 = $13;
    $4 = $14;
    $11 = $13;
    $9 = $11;
    $31 = $9;
    $9 = $21;
    $21 = $9;
    $34 = $27;
    $9 = $23;
    $32 = $9;
    $30 = 0;
    $9 = $8;
    $11 = $16;
    $11 = __wasm_i64_mul($7, $9, $22, $11);
    $10 = $11;
    $9 = i64toi32_i32$HIGH_BITS;
    $11 = $9;
    $9 = $13;
    $13 = $9 + $11 | 0;
    $14 = $30;
    $12 = $10 + $14 | 0;
    if ($12 >>> 0 < $10 >>> 0) {
     $13 = $13 + 1 | 0
    }
    $14 = $31;
    $9 = $12;
    $10 = $30;
    $16 = ($14 | 0) == ($13 | 0) & $9 >>> 0 < $10 >>> 0 | $13 >>> 0 < $14 >>> 0;
    $9 = $15;
    $13 = $17;
    $13 = __wasm_i64_mul($20, $9, $18, $13);
    $7 = $13;
    $9 = i64toi32_i32$HIGH_BITS;
    $8 = $9;
    $13 = $29;
    $9 = $4;
    $10 = $3;
    $14 = $28;
    $14 = ($13 | 0) == ($9 | 0) & $10 >>> 0 < $14 >>> 0 | $9 >>> 0 < $13 >>> 0;
    $9 = $14;
    $14 = 0;
    $10 = $14;
    $10 = $10 | $9;
    $9 = $4;
    $13 = $9;
    $9 = 0;
    $13 = $13 | $9;
    $14 = $7;
    $11 = $13 + $14 | 0;
    $9 = $10;
    $10 = $8;
    $12 = $9 + $10 | 0;
    $3 = $11;
    $12 = $11 >>> 0 < $13 >>> 0 ? $12 + 1 | 0 : $12;
    $11 = $12;
    $13 = $3;
    $10 = $16;
    $9 = $13 + $10 | 0;
    if ($9 >>> 0 < $13 >>> 0) {
     $11 = $11 + 1 | 0
    }
    $13 = $9;
    $10 = $11;
    $11 = $32;
    $9 = $10 + $11 | 0;
    $12 = $34;
    $14 = $13 + $12 | 0;
    if ($14 >>> 0 < $13 >>> 0) {
     $9 = $9 + 1 | 0
    }
    $3 = $14;
    $4 = $9;
    $12 = $23;
    $11 = $14;
    $13 = $27;
    $12 = ($9 | 0) == ($12 | 0) & $11 >>> 0 < $13 >>> 0 | $9 >>> 0 < $12 >>> 0;
    $11 = $21;
    $14 = $11;
    $13 = $24;
    $10 = $13 + $12 | 0;
    if ($10 >>> 0 < $12 >>> 0) {
     $14 = $14 + 1 | 0
    }
    $7 = $10;
    $8 = $14;
    $14 = $4;
    $10 = $14 + -1 | 0;
    $11 = $3;
    $9 = $11 + -2 | 0;
    if ($9 >>> 0 < 4294967294) {
     $10 = $10 + 1 | 0
    }
    $28 = $9;
    $29 = $10;
    $11 = $4;
    $12 = $3;
    $11 = ($10 | 0) == ($11 | 0) & $9 >>> 0 < $12 >>> 0 | $10 >>> 0 < $11 >>> 0;
    $14 = $8;
    $9 = $14;
    $12 = $7;
    $13 = $12 + $11 | 0;
    if ($13 >>> 0 < $11 >>> 0) {
     $9 = $9 + 1 | 0
    }
    $14 = $13;
    $13 = $9 + -1 | 0;
    $10 = $14 + -1 | 0;
    if ($10 >>> 0 < 4294967295) {
     $13 = $13 + 1 | 0
    }
    $15 = $13;
    $14 = 0;
    $4 = $14;
    $9 = $10;
    $3 = $9;
    $13 = $25;
    $8 = $13 << 2;
    $14 = $26;
    $9 = $14 << 2 | $13 >>> 30;
    $7 = $9;
    $9 = $2;
    $11 = $9 >>> 30 | 0;
    $13 = 0;
    $14 = $13;
    $13 = $7;
    $9 = $8;
    $13 = $9 | $11;
    $7 = $13;
    $9 = 0;
    $8 = $9;
    $13 = __wasm_i64_mul($10, $40, $7, $9);
    $27 = $13;
    $9 = i64toi32_i32$HIGH_BITS;
    $23 = $9;
    $9 = $15;
    $20 = $9;
    $13 = 0;
    $15 = $13;
    $13 = $2;
    $9 = $1;
    $13 = ($13 & 1073741823) << 2 | $9 >>> 30;
    $18 = $13;
    $9 = 0;
    $17 = $9;
    $13 = __wasm_i64_mul($20, $43, $18, $9);
    $11 = $13;
    $9 = i64toi32_i32$HIGH_BITS;
    $13 = $9;
    $9 = $23;
    $10 = $13 + $9 | 0;
    $14 = $27;
    $12 = $14 + $11 | 0;
    if ($12 >>> 0 < $11 >>> 0) {
     $10 = $10 + 1 | 0
    }
    $22 = $12;
    $16 = $10;
    $14 = $23;
    $9 = $12;
    $11 = $27;
    $24 = ($10 | 0) == ($14 | 0) & $9 >>> 0 < $11 >>> 0 | $10 >>> 0 < $14 >>> 0;
    $9 = $26;
    $11 = $25;
    $9 = ($9 & 1073741823) << 2 | $11 >>> 30;
    $10 = $9 & -262145;
    $25 = $10 | 262144;
    $11 = 0;
    $9 = $11;
    $26 = $9;
    $10 = 0;
    $23 = $10;
    $10 = $9;
    $9 = $29;
    $27 = $9;
    $11 = $23;
    $11 = __wasm_i64_mul($25, $10, $9, $11);
    $9 = $11;
    $10 = i64toi32_i32$HIGH_BITS;
    $11 = $16;
    $12 = $10 + $11 | 0;
    $14 = $22;
    $13 = $9 + $14 | 0;
    if ($13 >>> 0 < $14 >>> 0) {
     $12 = $12 + 1 | 0
    }
    $30 = $13;
    $9 = $16;
    $31 = $12;
    $10 = $13;
    $9 = ($9 | 0) == ($12 | 0) & $10 >>> 0 < $22 >>> 0 | $12 >>> 0 < $9 >>> 0;
    $13 = 0;
    $14 = $24;
    $11 = $9 + $14 | 0;
    if ($11 >>> 0 < $9 >>> 0) {
     $13 = 1
    }
    $10 = $11;
    $9 = $13;
    $13 = $15;
    $14 = $26;
    $14 = __wasm_i64_mul($20, $13, $25, $14);
    $12 = $14;
    $13 = i64toi32_i32$HIGH_BITS;
    $14 = $13;
    $13 = $9;
    $11 = $13 + $14 | 0;
    $9 = $12;
    $12 = $9 + $10 | 0;
    if ($12 >>> 0 < $9 >>> 0) {
     $11 = $11 + 1 | 0
    }
    $34 = $12;
    $32 = $11;
    $11 = $4;
    $10 = $26;
    $10 = __wasm_i64_mul($3, $11, $25, $10);
    $24 = $10;
    $11 = i64toi32_i32$HIGH_BITS;
    $21 = $11;
    $11 = $8;
    $10 = $15;
    $10 = __wasm_i64_mul($7, $11, $20, $10);
    $9 = $10;
    $11 = i64toi32_i32$HIGH_BITS;
    $10 = $11;
    $11 = $21;
    $12 = $10 + $11 | 0;
    $13 = $24;
    $14 = $13 + $9 | 0;
    if ($14 >>> 0 < $9 >>> 0) {
     $12 = $12 + 1 | 0
    }
    $22 = $14;
    $13 = $21;
    $16 = $12;
    $11 = $14;
    $9 = $24;
    $9 = ($13 | 0) == ($12 | 0) & $11 >>> 0 < $9 >>> 0 | $12 >>> 0 < $13 >>> 0;
    $12 = $9;
    $9 = 0;
    $11 = $9;
    $9 = $12;
    $11 = $9 | $11;
    $12 = $16;
    $13 = $12;
    $12 = 0;
    $13 = $13 | $12;
    $9 = $34;
    $10 = $13 + $9 | 0;
    $12 = $11;
    $11 = $32;
    $14 = $12 + $11 | 0;
    $14 = $10 >>> 0 < $13 >>> 0 ? $14 + 1 | 0 : $14;
    $21 = $10;
    $24 = $14;
    $11 = $22;
    $14 = $31;
    $9 = $14;
    $10 = $9 + $11 | 0;
    $13 = 0;
    $14 = $30;
    $12 = $13 + $14 | 0;
    if ($12 >>> 0 < $13 >>> 0) {
     $10 = $10 + 1 | 0
    }
    $22 = $12;
    $16 = $10;
    $14 = $31;
    $9 = $12;
    $13 = $30;
    $14 = ($10 | 0) == ($14 | 0) & $9 >>> 0 < $13 >>> 0 | $10 >>> 0 < $14 >>> 0;
    $9 = $24;
    $12 = $9;
    $13 = $21;
    $11 = $13 + $14 | 0;
    if ($11 >>> 0 < $14 >>> 0) {
     $12 = $12 + 1 | 0
    }
    $34 = $11;
    $32 = $12;
    $12 = $17;
    $13 = $23;
    $13 = __wasm_i64_mul($18, $12, $27, $13);
    $24 = $13;
    $12 = i64toi32_i32$HIGH_BITS;
    $21 = $12;
    $9 = $28;
    $28 = $9;
    $13 = 0;
    $29 = $13;
    $9 = $8;
    $9 = __wasm_i64_mul($28, $13, $7, $9);
    $14 = $9;
    $13 = i64toi32_i32$HIGH_BITS;
    $9 = $13;
    $13 = $21;
    $11 = $13 + $9 | 0;
    $12 = $24;
    $10 = $12 + $14 | 0;
    if ($10 >>> 0 < $14 >>> 0) {
     $11 = $11 + 1 | 0
    }
    $30 = $10;
    $12 = $21;
    $31 = $11;
    $14 = $24;
    $13 = $32;
    $32 = $13;
    $40 = ($12 | 0) == ($11 | 0) & $10 >>> 0 < $14 >>> 0 | $11 >>> 0 < $12 >>> 0;
    $13 = $2;
    $14 = $1;
    $13 = $14 << 2;
    $24 = $13 & -4;
    $14 = 0;
    $21 = $14;
    $13 = $4;
    $13 = __wasm_i64_mul($24, $14, $3, $13);
    $11 = $13;
    $13 = $31;
    $14 = i64toi32_i32$HIGH_BITS;
    $10 = $13 + $14 | 0;
    $12 = $30;
    $9 = $12 + $11 | 0;
    if ($9 >>> 0 < $12 >>> 0) {
     $10 = $10 + 1 | 0
    }
    $2 = $9;
    $39 = $10;
    $11 = $31;
    $11 = ($10 | 0) == ($11 | 0) & $9 >>> 0 < $30 >>> 0 | $10 >>> 0 < $11 >>> 0;
    $9 = 0;
    $12 = $40;
    $13 = $12 + $11 | 0;
    if ($13 >>> 0 < $11 >>> 0) {
     $9 = 1
    }
    $14 = $13;
    $12 = $16;
    $13 = $12 + $9 | 0;
    $11 = $22;
    $10 = $14 + $11 | 0;
    if ($10 >>> 0 < $11 >>> 0) {
     $13 = $13 + 1 | 0
    }
    $30 = $10;
    $31 = $13;
    $14 = $16;
    $9 = $10;
    $14 = ($13 | 0) == ($14 | 0) & $9 >>> 0 < $22 >>> 0 | $13 >>> 0 < $14 >>> 0;
    $9 = $32;
    $10 = $9;
    $11 = $34;
    $12 = $14 + $11 | 0;
    if ($12 >>> 0 < $14 >>> 0) {
     $10 = $10 + 1 | 0
    }
    $34 = $12;
    $32 = $10;
    $10 = $15;
    $11 = $21;
    $11 = __wasm_i64_mul($20, $10, $24, $11);
    $22 = $11;
    $10 = i64toi32_i32$HIGH_BITS;
    $16 = $10;
    $10 = $26;
    $11 = $29;
    $11 = __wasm_i64_mul($25, $10, $28, $11);
    $14 = $11;
    $10 = i64toi32_i32$HIGH_BITS;
    $11 = $10;
    $10 = $16;
    $12 = $10 + $11 | 0;
    $9 = $22;
    $13 = $9 + $14 | 0;
    if ($13 >>> 0 < $14 >>> 0) {
     $12 = $12 + 1 | 0
    }
    $20 = $13;
    $15 = $12;
    $12 = $8;
    $9 = $23;
    $9 = __wasm_i64_mul($7, $12, $27, $9);
    $14 = $9;
    $12 = i64toi32_i32$HIGH_BITS;
    $9 = $12;
    $12 = $15;
    $13 = $9 + $12 | 0;
    $10 = $20;
    $11 = $10 + $14 | 0;
    if ($11 >>> 0 < $14 >>> 0) {
     $13 = $13 + 1 | 0
    }
    $7 = $11;
    $8 = $13;
    $13 = $4;
    $10 = $17;
    $10 = __wasm_i64_mul($3, $13, $18, $10);
    $14 = $10;
    $13 = i64toi32_i32$HIGH_BITS;
    $10 = $13;
    $13 = $8;
    $11 = $13 + $10 | 0;
    $12 = $7;
    $9 = $12 + $14 | 0;
    if ($9 >>> 0 < $14 >>> 0) {
     $11 = $11 + 1 | 0
    }
    $3 = $9;
    $12 = 0;
    $26 = $12;
    $12 = $32;
    $4 = $12;
    $25 = $30;
    $12 = $31;
    $32 = $12;
    $40 = $11;
    $12 = $26;
    $26 = $12;
    $12 = $11;
    $14 = $7;
    $7 = ($8 | 0) == ($12 | 0) & $9 >>> 0 < $14 >>> 0 | $12 >>> 0 < $13 >>> 0;
    $12 = $15;
    $11 = $13;
    $13 = $20;
    $8 = ($12 | 0) == ($11 | 0) & $14 >>> 0 < $13 >>> 0 | $11 >>> 0 < $12 >>> 0;
    $14 = $12;
    $11 = $16;
    $12 = $22;
    $11 = ($14 | 0) == ($11 | 0) & $13 >>> 0 < $12 >>> 0 | $14 >>> 0 < $11 >>> 0;
    $9 = 0;
    $12 = $8;
    $10 = $12 + $11 | 0;
    if ($10 >>> 0 < $11 >>> 0) {
     $9 = 1
    }
    $11 = $10;
    $10 = $9;
    $13 = $7;
    $14 = $13 + $11 | 0;
    $14 >>> 0 < $11 >>> 0;
    $9 = $14;
    $13 = $26;
    $9 = $13 | $9;
    $7 = $9;
    $13 = $25;
    $10 = $40;
    $11 = $44;
    $11 = $10 | $11;
    $12 = $13 + $11 | 0;
    $9 = $32;
    $10 = $7;
    $14 = $9 + $10 | 0;
    $20 = $12;
    $13 = $31;
    $14 = $12 >>> 0 < $11 >>> 0 ? $14 + 1 | 0 : $14;
    $15 = $14;
    $9 = $12;
    $11 = $30;
    $13 = ($13 | 0) == ($14 | 0) & $9 >>> 0 < $11 >>> 0 | $14 >>> 0 < $13 >>> 0;
    $9 = $4;
    $12 = $9;
    $11 = $34;
    $10 = $13 + $11 | 0;
    if ($10 >>> 0 < $13 >>> 0) {
     $12 = $12 + 1 | 0
    }
    $25 = $10;
    $26 = $12;
    $12 = $23;
    $11 = $21;
    $11 = __wasm_i64_mul($27, $12, $24, $11);
    $7 = $11;
    $12 = i64toi32_i32$HIGH_BITS;
    $8 = $12;
    $12 = $17;
    $11 = $29;
    $11 = __wasm_i64_mul($18, $12, $28, $11);
    $13 = $11;
    $12 = i64toi32_i32$HIGH_BITS;
    $11 = $12;
    $12 = $8;
    $10 = $12 + $11 | 0;
    $9 = $7;
    $14 = $13 + $9 | 0;
    if ($14 >>> 0 < $13 >>> 0) {
     $10 = $10 + 1 | 0
    }
    $9 = 0;
    $16 = $9;
    $17 = $10;
    $9 = $10;
    $10 = $14;
    $13 = $7;
    $13 = ($9 | 0) == ($8 | 0) & $10 >>> 0 < $13 >>> 0 | $9 >>> 0 < $12 >>> 0;
    $9 = $16;
    $13 = $13 | $9;
    $4 = $13;
    $9 = $2;
    $12 = 0;
    $10 = $17;
    $12 = $12 | $10;
    $11 = $9 + $12 | 0;
    $13 = $39;
    $10 = $4;
    $14 = $13 + $10 | 0;
    $7 = $11;
    $9 = $13;
    $14 = $11 >>> 0 < $12 >>> 0 ? $14 + 1 | 0 : $14;
    $8 = $14;
    $12 = $2;
    $18 = ($9 | 0) == ($14 | 0) & $11 >>> 0 < $12 >>> 0 | $14 >>> 0 < $9 >>> 0;
    $13 = $26;
    $2 = $13;
    $4 = $20;
    $13 = $15;
    $17 = $13;
    $12 = $3;
    $14 = $8;
    $11 = $12 + $14 | 0;
    $13 = $7;
    $9 = 0;
    $10 = $13 + $9 | 0;
    if ($10 >>> 0 < $9 >>> 0) {
     $11 = $11 + 1 | 0
    }
    $13 = $8;
    $9 = $7;
    $13 = ($11 | 0) == ($13 | 0) & $10 >>> 0 < $9 >>> 0 | $11 >>> 0 < $13 >>> 0;
    $10 = 0;
    $9 = $18;
    $12 = $13 + $9 | 0;
    if ($12 >>> 0 < $13 >>> 0) {
     $10 = 1
    }
    $13 = $12;
    $9 = $10;
    $10 = $17;
    $12 = $9 + $10 | 0;
    $14 = $4;
    $11 = $13 + $14 | 0;
    if ($11 >>> 0 < $13 >>> 0) {
     $12 = $12 + 1 | 0
    }
    $7 = $11;
    $8 = $12;
    $14 = $15;
    $10 = $11;
    $13 = $20;
    $14 = ($12 | 0) == ($14 | 0) & $10 >>> 0 < $13 >>> 0 | $12 >>> 0 < $14 >>> 0;
    $10 = $2;
    $11 = $10;
    $13 = $25;
    $9 = $13 + $14 | 0;
    if ($9 >>> 0 < $14 >>> 0) {
     $11 = $11 + 1 | 0
    }
    $3 = $9;
    $4 = $11;
    label$12 : {
     if (($11 | 0) == 131071 & $9 >>> 0 <= 4294967295 | $11 >>> 0 < 131071) {
      $14 = $1;
      $11 = $14 << 17;
      $9 = $11;
      $10 = $7;
      $1 = $10;
      $10 = 0;
      $17 = $10;
      $14 = 0;
      $2 = $14;
      $10 = $14;
      $11 = $5;
      $18 = $11;
      $11 = $17;
      $11 = __wasm_i64_mul($7, $10, $18, $11);
      $20 = $11;
      $10 = i64toi32_i32$HIGH_BITS;
      $15 = $10;
      $13 = $45;
      $11 = ($11 | 0) != 0 | ($10 | 0) != 0;
      $12 = $13 - $11 | 0;
      $21 = $12;
      $14 = $9;
      $9 = $13 >>> 0 < $11 >>> 0;
      $9 = $14 - $9 | 0;
      $24 = $9;
      $11 = $20;
      $10 = 0 - $11 | 0;
      $28 = $10;
      $13 = $15;
      $12 = $13 + (0 < $11 >>> 0) | 0;
      $12 = 0 - $12 | 0;
      $29 = $12;
      $30 = $10;
      $34 = $12;
      $14 = 0;
      $15 = $14;
      $12 = $17;
      $14 = $12;
      $12 = $8;
      $20 = $12;
      $9 = $15;
      $9 = __wasm_i64_mul($18, $14, $12, $9);
      $22 = $9;
      $14 = i64toi32_i32$HIGH_BITS;
      $16 = $14;
      $14 = $6;
      $27 = $14;
      $9 = 0;
      $23 = $9;
      $12 = $2;
      $12 = __wasm_i64_mul($14, $9, $7, $12);
      $11 = $12;
      $9 = i64toi32_i32$HIGH_BITS;
      $12 = $9;
      $9 = $16;
      $10 = $9 + $12 | 0;
      $14 = $22;
      $13 = $14 + $11 | 0;
      if ($13 >>> 0 < $11 >>> 0) {
       $10 = $10 + 1 | 0
      }
      $25 = $13;
      $26 = $10;
      $9 = $13;
      $31 = $9;
      $14 = $34;
      $10 = $30;
      $30 = 0;
      $11 = $30;
      $9 = ($9 | 0) == ($14 | 0) & $10 >>> 0 < $11 >>> 0 | $14 >>> 0 < $9 >>> 0;
      $11 = $21;
      $12 = $11 - $9 | 0;
      $21 = $12;
      $10 = $24;
      $13 = $11 >>> 0 < $9 >>> 0;
      $13 = $10 - $13 | 0;
      $24 = $13;
      $11 = 0;
      $10 = $2;
      $10 = __wasm_i64_mul($36, $11, $1, $10);
      $1 = $10;
      $11 = i64toi32_i32$HIGH_BITS;
      $10 = 0;
      $13 = $17;
      $13 = __wasm_i64_mul($3, $10, $18, $13);
      $9 = $13;
      $10 = i64toi32_i32$HIGH_BITS;
      $13 = $10;
      $10 = $11;
      $12 = $13 + $10 | 0;
      $11 = $1;
      $14 = $9 + $11 | 0;
      if ($14 >>> 0 < $9 >>> 0) {
       $12 = $12 + 1 | 0
      }
      $10 = $14;
      $1 = $12;
      $12 = $15;
      $11 = $23;
      $11 = __wasm_i64_mul($20, $12, $27, $11);
      $9 = $11;
      $12 = i64toi32_i32$HIGH_BITS;
      $11 = $12;
      $12 = $1;
      $14 = $12 + $11 | 0;
      $13 = $9 + $10 | 0;
      if ($13 >>> 0 < $9 >>> 0) {
       $14 = $14 + 1 | 0
      }
      $1 = $14;
      $10 = $16;
      $14 = $26;
      $12 = $25;
      $9 = $22;
      $9 = ($10 | 0) == ($14 | 0) & $12 >>> 0 < $9 >>> 0 | $14 >>> 0 < $10 >>> 0;
      $14 = $9;
      $9 = 0;
      $12 = $9;
      $9 = $14;
      $12 = $9 | $12;
      $2 = $12;
      $9 = $13;
      $14 = $26;
      $10 = $14;
      $14 = 0;
      $10 = $10 | $14;
      $11 = $9 + $10 | 0;
      $12 = $1;
      $14 = $2;
      $13 = $12 + $14 | 0;
      $1 = $11;
      $13 = $11 >>> 0 < $10 >>> 0 ? $13 + 1 | 0 : $13;
      $2 = $13;
      $13 = $4;
      $9 = 0;
      $12 = $6;
      $12 = __wasm_i64_mul($13, $9, $5, $12);
      $10 = $12;
      $9 = i64toi32_i32$HIGH_BITS;
      $11 = $9;
      $9 = $41;
      $12 = 0;
      $13 = $8;
      $13 = __wasm_i64_mul($9, $12, $7, $13);
      $14 = $13;
      $12 = i64toi32_i32$HIGH_BITS;
      $13 = $12;
      $12 = $11;
      $11 = $13 + $12 | 0;
      $9 = $10;
      $10 = $14;
      $14 = $9 + $10 | 0;
      if ($14 >>> 0 < $10 >>> 0) {
       $11 = $11 + 1 | 0
      }
      $12 = $14;
      $10 = $11;
      $11 = $4;
      $9 = $23;
      $9 = __wasm_i64_mul($3, $11, $27, $9);
      $13 = $9;
      $11 = i64toi32_i32$HIGH_BITS;
      $9 = $11;
      $11 = $10;
      $14 = $9 + $11 | 0;
      $10 = $13;
      $13 = $12 + $10 | 0;
      if ($13 >>> 0 < $10 >>> 0) {
       $14 = $14 + 1 | 0
      }
      $11 = $13;
      $9 = $14;
      $14 = $15;
      $12 = $37;
      $12 = __wasm_i64_mul($20, $14, $36, $12);
      $10 = $12;
      $14 = i64toi32_i32$HIGH_BITS;
      $12 = $14;
      $14 = $9;
      $13 = $12 + $14 | 0;
      $9 = $10 + $11 | 0;
      $9 >>> 0 < $10 >>> 0;
      $11 = $2;
      $9 = $9 + $11 | 0;
      $13 = $1;
      $10 = $46;
      $12 = $13 + $10 | 0;
      if ($12 >>> 0 < $10 >>> 0) {
       $9 = $9 + 1 | 0
      }
      $13 = $9;
      $11 = $21;
      $10 = $12;
      $14 = $11 - $10 | 0;
      $18 = $14;
      $9 = $24;
      $12 = $13 + ($11 >>> 0 < $10 >>> 0) | 0;
      $12 = $9 - $12 | 0;
      $17 = $12;
      $38 = $38 + -1 | 0;
      $9 = $28;
      $10 = $30;
      $13 = $9 - $10 | 0;
      $1 = $13;
      $12 = $29;
      $11 = $31;
      $14 = $11 + ($9 >>> 0 < $10 >>> 0) | 0;
      $14 = $12 - $14 | 0;
      $11 = $14;
      break label$12;
     }
     $14 = $8;
     $27 = $14 >>> 1 | 0;
     $9 = 0;
     $23 = $9;
     $14 = $1;
     $12 = $14 << 16;
     $13 = $12;
     $9 = $3;
     $14 = $9 << 31;
     $1 = $14;
     $14 = $8;
     $9 = $14 >>> 1 | 0;
     $12 = $7;
     $10 = ($14 & 1) << 31 | $12 >>> 1;
     $12 = $9;
     $9 = $1;
     $12 = $9 | $12;
     $8 = $12;
     $14 = 0;
     $7 = $10 | $14;
     $9 = $7;
     $1 = $9;
     $9 = 0;
     $17 = $9;
     $2 = 0;
     $9 = $2;
     $12 = $5;
     $18 = $12;
     $12 = $17;
     $12 = __wasm_i64_mul($7, $9, $18, $12);
     $20 = $12;
     $9 = i64toi32_i32$HIGH_BITS;
     $15 = $9;
     $10 = $47;
     $12 = ($12 | 0) != 0 | ($9 | 0) != 0;
     $11 = $10 - $12 | 0;
     $34 = $11;
     $14 = $13;
     $13 = $10 >>> 0 < $12 >>> 0;
     $13 = $14 - $13 | 0;
     $32 = $13;
     $12 = $20;
     $9 = 0 - $12 | 0;
     $28 = $9;
     $10 = $15;
     $11 = $10 + (0 < $12 >>> 0) | 0;
     $11 = 0 - $11 | 0;
     $29 = $11;
     $24 = $9;
     $39 = $11;
     $11 = $6;
     $20 = $11;
     $14 = 0;
     $15 = $14;
     $13 = $2;
     $13 = __wasm_i64_mul($11, $14, $7, $13);
     $22 = $13;
     $14 = i64toi32_i32$HIGH_BITS;
     $16 = $14;
     $11 = $3;
     $14 = $4;
     $13 = $14 << 31 | $11 >>> 1;
     $9 = $13;
     $12 = $11 << 31;
     $14 = $27;
     $30 = $12 | $14;
     $13 = $23;
     $11 = $9;
     $11 = $13 | $11;
     $31 = $11;
     $13 = $30;
     $25 = $13;
     $14 = 0;
     $26 = $14;
     $13 = $17;
     $13 = __wasm_i64_mul($25, $14, $18, $13);
     $12 = $13;
     $14 = i64toi32_i32$HIGH_BITS;
     $13 = $14;
     $14 = $16;
     $9 = $13 + $14 | 0;
     $11 = $22;
     $10 = $12 + $11 | 0;
     if ($10 >>> 0 < $12 >>> 0) {
      $9 = $9 + 1 | 0
     }
     $27 = $10;
     $23 = $9;
     $21 = $10;
     $11 = $39;
     $9 = $24;
     $24 = 0;
     $12 = $24;
     $14 = ($10 | 0) == ($11 | 0) & $9 >>> 0 < $12 >>> 0 | $11 >>> 0 < $10 >>> 0;
     $12 = $34;
     $13 = $12 - $14 | 0;
     $9 = $32;
     $10 = $12 >>> 0 < $14 >>> 0;
     $10 = $9 - $10 | 0;
     $39 = $10;
     $10 = $15;
     $12 = $26;
     $12 = __wasm_i64_mul($20, $10, $25, $12);
     $34 = $12;
     $10 = i64toi32_i32$HIGH_BITS;
     $32 = $10;
     $40 = $13;
     $10 = $39;
     $39 = $10;
     $10 = $4;
     $12 = $10 >>> 1 | 0;
     $9 = $3;
     $25 = ($10 & 1) << 31 | $9 >>> 1;
     $26 = $12;
     $9 = 0;
     $10 = $17;
     $10 = __wasm_i64_mul($25, $9, $18, $10);
     $14 = $10;
     $9 = i64toi32_i32$HIGH_BITS;
     $10 = $9;
     $9 = $32;
     $13 = $9 + $10 | 0;
     $12 = $34;
     $11 = $12 + $14 | 0;
     if ($11 >>> 0 < $14 >>> 0) {
      $13 = $13 + 1 | 0
     }
     $3 = $11;
     $12 = 0;
     $9 = $2;
     $9 = __wasm_i64_mul($36, $12, $1, $9);
     $14 = $9;
     $12 = i64toi32_i32$HIGH_BITS;
     $9 = $12;
     $12 = $13;
     $11 = $9 + $12 | 0;
     $13 = $3;
     $10 = $13 + $14 | 0;
     if ($10 >>> 0 < $14 >>> 0) {
      $11 = $11 + 1 | 0
     }
     $1 = $11;
     $13 = $16;
     $11 = $23;
     $12 = $27;
     $14 = $22;
     $14 = ($13 | 0) == ($11 | 0) & $12 >>> 0 < $14 >>> 0 | $11 >>> 0 < $13 >>> 0;
     $11 = $14;
     $14 = 0;
     $12 = $14;
     $12 = $12 | $11;
     $2 = $12;
     $11 = $23;
     $13 = $11;
     $11 = 0;
     $13 = $13 | $11;
     $9 = $13 + $10 | 0;
     $12 = $1;
     $11 = $2;
     $10 = $12 + $11 | 0;
     $1 = $9;
     $10 = $9 >>> 0 < $13 >>> 0 ? $10 + 1 | 0 : $10;
     $2 = $10;
     $14 = 0;
     $12 = $14;
     $10 = $6;
     $14 = $10;
     $10 = $4;
     $12 = __wasm_i64_mul($5, $14, $10 >>> 1 | 0, $12);
     $3 = $12;
     $14 = i64toi32_i32$HIGH_BITS;
     $4 = $14;
     $14 = $41;
     $12 = 0;
     $10 = $8;
     $10 = __wasm_i64_mul($14, $12, $7, $10);
     $13 = $10;
     $12 = i64toi32_i32$HIGH_BITS;
     $10 = $12;
     $12 = $4;
     $9 = $12 + $10 | 0;
     $14 = $3;
     $11 = $13 + $14 | 0;
     if ($11 >>> 0 < $13 >>> 0) {
      $9 = $9 + 1 | 0
     }
     $12 = $11;
     $3 = $9;
     $9 = $15;
     $14 = $26;
     $14 = __wasm_i64_mul($20, $9, $25, $14);
     $13 = $14;
     $9 = i64toi32_i32$HIGH_BITS;
     $14 = $9;
     $9 = $3;
     $11 = $9 + $14 | 0;
     $10 = $13 + $12 | 0;
     if ($10 >>> 0 < $13 >>> 0) {
      $11 = $11 + 1 | 0
     }
     $9 = $10;
     $3 = $11;
     $11 = $31;
     $12 = $37;
     $12 = __wasm_i64_mul($30, $11, $36, $12);
     $13 = $12;
     $11 = i64toi32_i32$HIGH_BITS;
     $12 = $11;
     $11 = $3;
     $10 = $12 + $11 | 0;
     $14 = $13 + $9 | 0;
     $14 >>> 0 < $13 >>> 0;
     $11 = $14;
     $9 = $2;
     $14 = $9 + $11 | 0;
     $13 = $48;
     $10 = $1;
     $12 = $13 + $10 | 0;
     if ($12 >>> 0 < $13 >>> 0) {
      $14 = $14 + 1 | 0
     }
     $10 = $14;
     $9 = $40;
     $11 = $9 - $12 | 0;
     $18 = $11;
     $14 = $39;
     $12 = $10 + ($9 >>> 0 < $12 >>> 0) | 0;
     $12 = $14 - $12 | 0;
     $17 = $12;
     $3 = $25;
     $12 = $26;
     $4 = $12;
     $14 = $28;
     $13 = $24;
     $10 = $14 - $13 | 0;
     $1 = $10;
     $12 = $29;
     $9 = $21;
     $11 = $9 + ($14 >>> 0 < $13 >>> 0) | 0;
     $11 = $12 - $11 | 0;
    }
    $2 = $11;
    if (($38 | 0) >= 16384) {
     $12 = $35;
     $35 = $12;
     $11 = $33;
     $14 = $11 | 2147418112;
     $33 = $14;
     $1 = 0;
     $2 = 0;
     break label$2;
    }
    $16 = $38 + 16383 | 0;
    if (($38 | 0) <= -16383) {
     label$16 : {
      if ($16) {
       break label$16
      }
      $11 = $1;
      $1 = $11 << 1;
      $14 = $2;
      $12 = $14 << 1 | $11 >>> 31;
      $11 = $6;
      $14 = $1;
      $13 = $5;
      $6 = ($12 | 0) == ($11 | 0) & $14 >>> 0 > $13 >>> 0 | $12 >>> 0 > $11 >>> 0;
      $13 = $18;
      $5 = $13 << 1;
      $14 = $17;
      $12 = $14 << 1 | $13 >>> 31;
      $1 = $12;
      $12 = $2;
      $11 = $12 >>> 31 | 0;
      $13 = 0;
      $14 = $13;
      $13 = $1;
      $14 = $13 | $14;
      $12 = $5;
      $1 = $12 | $11;
      $13 = $1;
      $12 = $41;
      $11 = $42;
      $2 = ($12 | 0) == ($14 | 0) & $13 >>> 0 > $11 >>> 0 | $14 >>> 0 > $12 >>> 0;
      $13 = $14;
      $11 = $1;
      $14 = $12;
      $12 = $42;
      $14 = ($11 | 0) == ($12 | 0) & ($13 | 0) == ($14 | 0) ? $6 : $2;
      $11 = $8;
      $10 = $11;
      $12 = $7;
      $9 = $12 + $14 | 0;
      if ($9 >>> 0 < $14 >>> 0) {
       $10 = $10 + 1 | 0
      }
      $1 = $9;
      $12 = $8;
      $2 = $10;
      $14 = $7;
      $5 = ($12 | 0) == ($10 | 0) & $9 >>> 0 < $14 >>> 0 | $10 >>> 0 < $12 >>> 0;
      $11 = $4;
      $10 = $11 & 65535;
      $14 = $3;
      $12 = $14;
      $11 = $5;
      $13 = $12 + $11 | 0;
      $14 = $10;
      $9 = $14;
      $5 = $13;
      $9 = $13 >>> 0 < $12 >>> 0 ? $9 + 1 | 0 : $9;
      $6 = $9;
      $11 = $9 & 65536;
      if (!$11) {
       break label$16
      }
      $9 = $5;
      $35 = $9 | $35;
      $10 = $33;
      $11 = $6;
      $10 = $10 | $11;
      $33 = $10;
      break label$2;
     }
     $1 = 0;
     $2 = 0;
     break label$2;
    }
    $10 = $33;
    $15 = $10;
    $11 = $1;
    $1 = $11 << 1;
    $10 = $2;
    $9 = $10 << 1 | $11 >>> 31;
    $11 = $6;
    $10 = $1;
    $12 = $5;
    $6 = ($9 | 0) == ($11 | 0) & $10 >>> 0 >= $12 >>> 0 | $9 >>> 0 > $11 >>> 0;
    $12 = $18;
    $5 = $12 << 1;
    $10 = $17;
    $9 = $10 << 1 | $12 >>> 31;
    $1 = $9;
    $9 = $2;
    $11 = $9 >>> 31 | 0;
    $12 = 0;
    $10 = $12;
    $12 = $1;
    $10 = $12 | $10;
    $9 = $5;
    $1 = $9 | $11;
    $12 = $1;
    $9 = $41;
    $11 = $42;
    $2 = ($9 | 0) == ($10 | 0) & $12 >>> 0 >= $11 >>> 0 | $10 >>> 0 > $9 >>> 0;
    $12 = $10;
    $11 = $1;
    $10 = $9;
    $9 = $42;
    $10 = ($11 | 0) == ($9 | 0) & ($10 | 0) == ($12 | 0) ? $6 : $2;
    $11 = $8;
    $13 = $11;
    $9 = $7;
    $14 = $9 + $10 | 0;
    if ($14 >>> 0 < $10 >>> 0) {
     $13 = $13 + 1 | 0
    }
    $1 = $14;
    $2 = $13;
    $9 = $8;
    $11 = $14;
    $10 = $7;
    $5 = ($13 | 0) == ($9 | 0) & $11 >>> 0 < $10 >>> 0 | $13 >>> 0 < $9 >>> 0;
    $11 = $4;
    $13 = $11 & 65535;
    $11 = $16;
    $10 = $11 << 16;
    $11 = $10;
    $10 = $13;
    $11 = $10 | $11;
    $13 = $3;
    $9 = 0;
    $9 = $13 | $9;
    $10 = $5;
    $12 = $9 + $10 | 0;
    $13 = $11;
    $14 = $12 >>> 0 < $9 >>> 0 ? $13 + 1 | 0 : $13;
    $9 = $12;
    $35 = $9 | $49;
    $10 = $14;
    $14 = $15;
    $10 = $10 | $14;
    $33 = $10;
   }
   $11 = $0;
   HEAP32[$11 >> 2] = $1;
   $10 = $2;
   HEAP32[$11 + 4 >> 2] = $10;
   HEAP32[$11 + 8 >> 2] = $35;
   $10 = $33;
   HEAP32[$11 + 12 >> 2] = $10;
   global$0 = $19 + 192 | 0;
   return;
  }
  $11 = $0;
  HEAP32[$11 >> 2] = 0;
  HEAP32[$11 + 4 >> 2] = 0;
  $10 = $4;
  $11 = $6;
  $11 = $10 | $11;
  $9 = $5;
  $14 = $3;
  $10 = $9 | $14;
  $13 = ($10 | 0) != 0 | ($11 | 0) != 0;
  $14 = $13 ? $35 : 0;
  $1 = $14;
  $14 = $0;
  HEAP32[$14 + 8 >> 2] = $1;
  $10 = $33;
  $9 = $13 ? $10 : 2147450880;
  HEAP32[$14 + 12 >> 2] = $9;
  global$0 = $19 + 192 | 0;
 }
 
 function __extenddftf2($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0;
  $9 = global$0 - 16 | 0;
  global$0 = $9;
  wasm2js_scratch_store_f64(+$1);
  $6 = wasm2js_scratch_load_i32(1) | 0;
  $10 = wasm2js_scratch_load_i32(0) | 0;
  $12 = $6;
  $3 = $6 & -2147483648;
  $13 = $3;
  $3 = $6;
  $6 = $10;
  $7 = $3 & 2147483647;
  $2 = $7 + -1048576 | 0;
  $3 = $6;
  $5 = $3;
  if ($3 >>> 0 < 0) {
   $2 = $2 + 1 | 0
  }
  label$1 : {
   if (($2 | 0) == 2145386495 & $5 >>> 0 <= 4294967295 | $2 >>> 0 < 2145386495) {
    $4 = $6;
    $2 = $4 << 28;
    $11 = $2;
    $2 = $7;
    $4 = $2 >>> 4 | 0;
    $2 = ($2 & 15) << 28 | $6 >>> 4;
    $5 = $4 + 1006632960 | 0;
    $6 = $2;
    if ($2 >>> 0 < 0) {
     $5 = $5 + 1 | 0
    }
    $8 = $6;
    $2 = $5;
    break label$1;
   }
   $5 = $7;
   $4 = $6;
   if (($5 | 0) == 2146435072 & $4 >>> 0 >= 0 | $5 >>> 0 > 2146435072) {
    $3 = $10;
    $5 = $3 << 28;
    $11 = $5;
    $5 = $12;
    $3 = $5 >>> 4 | 0;
    $4 = $10;
    $5 = ($5 & 15) << 28 | $4 >>> 4;
    $8 = $5;
    $4 = $3 | 2147418112;
    $2 = $4;
    break label$1;
   }
   $4 = $7;
   if (!($4 | $6)) {
    $2 = 0;
    break label$1;
   }
   $5 = $9;
   $2 = $6;
   $4 = $7;
   $3 = $6;
   if (($7 | 0) == 1 & $3 >>> 0 >= 0 | $7 >>> 0 > 1) {
    $3 = $7;
    $8 = Math_clz32($3);
   } else {
    $8 = Math_clz32($10) + 32 | 0
   }
   __ashlti3($5, $2, $4, 0, 0, $8 + 49 | 0);
   $3 = $9;
   $2 = HEAP32[$3 >> 2];
   $14 = $2;
   $4 = HEAP32[$3 + 4 >> 2];
   $11 = $4;
   $2 = HEAP32[$3 + 12 >> 2];
   $4 = HEAP32[$3 + 8 >> 2];
   $3 = $4;
   $7 = $3;
   $4 = $2 ^ 65536;
   $6 = $4;
   $2 = 15372 - $8 | 0;
   $3 = $2 << 16;
   $2 = $3;
   $4 = $7;
   $5 = 0;
   $8 = $4 | $5;
   $3 = $6;
   $2 = $3 | $2;
  }
  $7 = $2;
  $4 = $0;
  HEAP32[$4 >> 2] = $14;
  $2 = $11;
  HEAP32[$4 + 4 >> 2] = $2;
  $6 = $8;
  $3 = $6;
  $5 = $15;
  $0 = $3 | $5;
  $3 = $4;
  HEAP32[$3 + 8 >> 2] = $0;
  $4 = $13;
  $2 = $7;
  $4 = $4 | $2;
  HEAP32[$3 + 12 >> 2] = $4;
  global$0 = $9 + 16 | 0;
 }
 
 function __extendsftf2($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0;
  $7 = global$0 - 16 | 0;
  global$0 = $7;
  $4 = (wasm2js_scratch_store_f32($1), wasm2js_scratch_load_i32(0));
  $9 = $4 & -2147483648;
  $5 = $4 & 2147483647;
  label$1 : {
   if ($5 + -8388608 >>> 0 <= 2130706431) {
    $4 = $5 >>> 7 | 0;
    $2 = $5 << 25;
    $3 = $4 + 1065353216 | 0;
    $8 = $2;
    if ($2 >>> 0 < 0) {
     $3 = $3 + 1 | 0
    }
    $6 = $3;
    break label$1;
   }
   if ($5 >>> 0 >= 2139095040) {
    $2 = $4 >>> 7 | 0;
    $3 = $4 << 25;
    $8 = $3;
    $4 = $2 | 2147418112;
    $6 = $4;
    break label$1;
   }
   if (!$5) {
    $6 = 0;
    break label$1;
   }
   $2 = $5;
   $5 = Math_clz32($5);
   __ashlti3($7, $2, 0, 0, 0, $5 + 81 | 0);
   $2 = $7;
   $3 = HEAP32[$2 >> 2];
   $10 = $3;
   $4 = HEAP32[$2 + 4 >> 2];
   $11 = $4;
   $3 = HEAP32[$2 + 12 >> 2];
   $4 = HEAP32[$2 + 8 >> 2];
   $2 = $4;
   $6 = $2;
   $4 = $3 ^ 65536;
   $12 = $4;
   $3 = 16265 - $5 | 0;
   $2 = $3 << 16;
   $3 = $2;
   $4 = $6;
   $8 = $4;
   $2 = $12;
   $3 = $2 | $3;
   $6 = $3;
  }
  $4 = $0;
  HEAP32[$4 >> 2] = $10;
  $3 = $11;
  HEAP32[$4 + 4 >> 2] = $3;
  $2 = $9;
  $4 = $2;
  $3 = 0;
  $2 = $3 | $8;
  $3 = $0;
  HEAP32[$3 + 8 >> 2] = $2;
  $2 = $6;
  $2 = $4 | $2;
  HEAP32[$3 + 12 >> 2] = $2;
  global$0 = $7 + 16 | 0;
 }
 
 function __floatsitf($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  $3 = global$0 - 16 | 0;
  global$0 = $3;
  $6 = $0;
  label$1 : {
   if (!$1) {
    $1 = 0;
    break label$1;
   }
   $2 = $1 >> 31;
   $2 = $2 ^ $1 + $2;
   $4 = $2;
   $2 = Math_clz32($2);
   __ashlti3($3, $4, 0, 0, 0, $2 + 81 | 0);
   $7 = HEAP32[$3 >> 2];
   $8 = HEAP32[$3 + 4 >> 2];
   $2 = (HEAP32[$3 + 12 >> 2] ^ 65536) + (16414 - $2 << 16) | 0;
   $4 = 0 + HEAP32[$3 + 8 >> 2] | 0;
   if ($4 >>> 0 < $5 >>> 0) {
    $2 = $2 + 1 | 0
   }
   $5 = $2;
   $2 = $4;
   $4 = 0 | $2;
   $1 = $1 & -2147483648 | $5;
  }
  $2 = $6;
  HEAP32[$2 >> 2] = $7;
  HEAP32[$2 + 4 >> 2] = $8;
  HEAP32[$0 + 8 >> 2] = $4;
  HEAP32[$2 + 12 >> 2] = $1;
  global$0 = $3 + 16 | 0;
 }
 
 function __floatunsitf($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  $2 = global$0 - 16 | 0;
  global$0 = $2;
  $4 = $0;
  label$1 : {
   if (!$1) {
    $3 = 0;
    break label$1;
   }
   $3 = $1;
   $1 = Math_clz32($1) ^ 31;
   __ashlti3($2, $3, 0, 0, 0, 112 - $1 | 0);
   $6 = HEAP32[$2 >> 2];
   $7 = HEAP32[$2 + 4 >> 2];
   $1 = (HEAP32[$2 + 12 >> 2] ^ 65536) + ($1 + 16383 << 16) | 0;
   $5 = 0 + HEAP32[$2 + 8 >> 2] | 0;
   if ($5 >>> 0 < $8 >>> 0) {
    $1 = $1 + 1 | 0
   }
   $3 = $1;
  }
  HEAP32[$4 >> 2] = $6;
  $1 = $7;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$0 + 8 >> 2] = $5;
  $1 = $3;
  HEAP32[$0 + 12 >> 2] = $1;
  global$0 = $2 + 16 | 0;
 }
 
 function __lshrti3($0, $1, $2, $3, $4, $5) {
  var $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
  label$1 : {
   if ($5 & 64) {
    $7 = $4;
    $8 = $3;
    $9 = $5 + -64 | 0;
    $6 = $9 & 31;
    if (32 <= ($9 & 63) >>> 0) {
     $1 = $7 >>> $6 | 0
    } else {
     $10 = $7 >>> $6 | 0;
     $1 = ((1 << $6) - 1 & $7) << 32 - $6 | $8 >>> $6;
    }
    $2 = $10;
    $3 = 0;
    $4 = 0;
    break label$1;
   }
   if (!$5) {
    break label$1
   }
   $10 = $4;
   $7 = $3;
   $9 = 64 - $5 | 0;
   $6 = $9 & 31;
   if (32 <= ($9 & 63) >>> 0) {
    $8 = $7 << $6;
    $11 = 0;
   } else {
    $8 = (1 << $6) - 1 & $7 >>> 32 - $6 | $10 << $6;
    $11 = $7 << $6;
   }
   $12 = $8;
   $8 = $2;
   $10 = $1;
   $7 = 0;
   $13 = $5;
   $9 = $5;
   $6 = $9 & 31;
   if (32 <= ($9 & 63) >>> 0) {
    $9 = $8 >>> $6 | 0
   } else {
    $7 = $8 >>> $6 | 0;
    $9 = ((1 << $6) - 1 & $8) << 32 - $6 | $10 >>> $6;
   }
   $10 = $7;
   $8 = $11;
   $1 = $8 | $9;
   $7 = $12;
   $10 = $7 | $10;
   $2 = $10;
   $10 = $4;
   $7 = $3;
   $8 = 0;
   $9 = $13;
   $6 = $9 & 31;
   if (32 <= ($9 & 63) >>> 0) {
    $3 = $10 >>> $6 | 0
   } else {
    $8 = $10 >>> $6 | 0;
    $3 = ((1 << $6) - 1 & $10) << 32 - $6 | $7 >>> $6;
   }
   $4 = $8;
  }
  $7 = $0;
  HEAP32[$7 >> 2] = $1;
  $8 = $2;
  HEAP32[$7 + 4 >> 2] = $8;
  HEAP32[$7 + 8 >> 2] = $3;
  $8 = $4;
  HEAP32[$7 + 12 >> 2] = $8;
 }
 
 function __multf3($0, $1, $2, $3, $4, $5, $6, $7, $8) {
  var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0;
  $16 = global$0 - 96 | 0;
  global$0 = $16;
  $10 = $3;
  $13 = 0;
  $11 = $2;
  $27 = $13 | $11;
  $10 = 0;
  $9 = $10;
  $10 = $3;
  $9 = $9 | $10;
  $22 = $9;
  $10 = $7;
  $13 = $10 << 15;
  $12 = $13;
  $13 = $6;
  $10 = $13 >>> 17 | 0;
  $9 = $5;
  $11 = ($13 & 131071) << 15 | $9 >>> 17;
  $13 = 0;
  $26 = $13 | $11;
  $9 = $10;
  $10 = $12;
  $9 = $9 | $10;
  $9 = $8;
  $13 = $9 & 65535;
  $28 = $13;
  $10 = $7;
  $23 = $10;
  $9 = $10;
  $14 = $9 << 15;
  $10 = $13 << 15 | $9 >>> 17;
  $12 = $10;
  $10 = $6;
  $11 = $10 >>> 17 | 0;
  $9 = 0;
  $13 = $9;
  $10 = $14;
  $35 = $10 | $11;
  $9 = $12;
  $13 = $9 | $13;
  $31 = $13;
  $13 = $4;
  $10 = $8;
  $10 = $13 ^ $10;
  $9 = $3;
  $11 = $7;
  $9 = $10 & -2147483648;
  $15 = $9;
  $9 = $4;
  $13 = $9 & 65535;
  $24 = $13;
  $10 = $3;
  $25 = $10;
  $32 = $13;
  $10 = 0;
  $36 = $10;
  $10 = $28;
  $9 = $10 >>> 17 | 0;
  $38 = ($10 & 131071) << 15 | $11 >>> 17;
  $9 = $8;
  $20 = $9 >>> 16 & 32767;
  $13 = $4;
  $33 = $13 >>> 16 & 32767;
  label$1 : {
   label$2 : {
    if ($33 + -1 >>> 0 <= 32765) {
     $21 = 0;
     if ($20 + -1 >>> 0 < 32766) {
      break label$2
     }
    }
    $10 = $2;
    $14 = !($10 | $1);
    $10 = $4;
    $9 = $10 & 2147483647;
    $29 = $9;
    $13 = $3;
    $17 = $13;
    $10 = $13;
    $12 = ($9 | 0) == 2147418112 & $10 >>> 0 < 0 | $9 >>> 0 < 2147418112;
    $10 = $9;
    $11 = $13;
    if (!(!$11 & ($10 | 0) == 2147418112 ? $14 : $12)) {
     $13 = $3;
     $18 = $13;
     $11 = $4;
     $10 = $11 | 32768;
     $15 = $10;
     break label$1;
    }
    $10 = $6;
    $14 = !($10 | $5);
    $10 = $8;
    $13 = $10 & 2147483647;
    $4 = $13;
    $11 = $7;
    $3 = $11;
    $10 = $11;
    $12 = ($13 | 0) == 2147418112 & $10 >>> 0 < 0 | $13 >>> 0 < 2147418112;
    $10 = $13;
    $9 = $11;
    if (!(!$9 & ($10 | 0) == 2147418112 ? $14 : $12)) {
     $11 = $7;
     $18 = $11;
     $9 = $8;
     $10 = $9 | 32768;
     $15 = $10;
     $1 = $5;
     $10 = $6;
     $2 = $10;
     break label$1;
    }
    $10 = $29;
    $11 = $10 ^ 2147418112;
    $13 = $1;
    $9 = $17;
    $10 = $9;
    $9 = $2;
    $9 = $9 | $11;
    if (!($13 | $10 | $9)) {
     $9 = $4;
     $10 = $6;
     $10 = $9 | $10;
     $13 = $5;
     $11 = $3;
     if (!($10 | ($13 | $11))) {
      $15 = 2147450880;
      $1 = 0;
      $2 = 0;
      break label$1;
     }
     $9 = $18;
     $18 = $9;
     $10 = $15;
     $11 = $10 | 2147418112;
     $15 = $11;
     $1 = 0;
     $2 = 0;
     break label$1;
    }
    $11 = $4;
    $9 = $11 ^ 2147418112;
    $13 = $5;
    $10 = $3;
    $11 = $10;
    $10 = $6;
    $10 = $9 | $10;
    if (!($13 | $11 | $10)) {
     $9 = $1;
     $13 = $17;
     $3 = $9 | $13;
     $10 = $2;
     $11 = $29;
     $11 = $10 | $11;
     $1 = 0;
     $2 = 0;
     if (!($11 | $3)) {
      $15 = 2147450880;
      break label$1;
     }
     $10 = $18;
     $18 = $10;
     $11 = $15;
     $9 = $11 | 2147418112;
     $15 = $9;
     break label$1;
    }
    $9 = $2;
    $10 = $29;
    $10 = $9 | $10;
    $13 = $17;
    $11 = $1;
    if (!($10 | ($13 | $11))) {
     $1 = 0;
     $2 = 0;
     break label$1;
    }
    $10 = $4;
    $11 = $6;
    $11 = $10 | $11;
    $9 = $3;
    $13 = $5;
    if (!($11 | ($9 | $13))) {
     $1 = 0;
     $2 = 0;
     break label$1;
    }
    $11 = $29;
    $10 = $17;
    if (($11 | 0) == 65535 & $10 >>> 0 <= 4294967295 | $11 >>> 0 < 65535) {
     $22 = $16 + 80 | 0;
     $17 = $1;
     $10 = $2;
     $12 = $10;
     $8 = $25;
     $10 = $24;
     $7 = $10;
     $19 = !($10 | $25);
     $14 = $19;
     $9 = $14 ? $1 : $25;
     $10 = $2;
     $11 = $24;
     $13 = $14 ? $10 : $11;
     $10 = Math_clz32($13);
     $9 = ($10 | 0) == 32 ? Math_clz32($9) + 32 | 0 : $10;
     $10 = $19 << 6;
     $11 = $9 + $10 | 0;
     $11 >>> 0 < $10 >>> 0;
     $9 = $7;
     __ashlti3($22, $17, $12, $8, $9, $11 + -15 | 0);
     $14 = $16;
     $9 = HEAP32[$14 + 88 >> 2];
     $25 = $9;
     $12 = HEAP32[$14 + 92 >> 2];
     $24 = $12;
     $12 = $14;
     $9 = HEAP32[$12 + 80 >> 2];
     $1 = $9;
     $14 = HEAP32[$12 + 84 >> 2];
     $2 = $14;
     $9 = 0;
     $12 = $9;
     $10 = $14;
     $14 = 0;
     $27 = $10 | $14;
     $9 = $25;
     $12 = $9 | $12;
     $22 = $12;
     $12 = $24;
     $32 = $12;
     $36 = 0;
     $19 = 16 - $11 | 0;
    }
    $14 = $4;
    $12 = $3;
    $21 = $19;
    if (($14 | 0) == 65535 & $12 >>> 0 > 4294967295 | $14 >>> 0 > 65535) {
     break label$2
    }
    $8 = $16 - -64 | 0;
    $7 = $5;
    $12 = $6;
    $11 = $12;
    $4 = $23;
    $12 = $28;
    $3 = $12;
    $21 = !($12 | $23);
    $13 = $21;
    $9 = $13 ? $5 : $23;
    $12 = $6;
    $14 = $28;
    $10 = $13 ? $12 : $14;
    $12 = Math_clz32($10);
    $9 = ($12 | 0) == 32 ? Math_clz32($9) + 32 | 0 : $12;
    $12 = $21 << 6;
    $14 = $9 + $12 | 0;
    $14 >>> 0 < $12 >>> 0;
    $9 = $3;
    __ashlti3($8, $7, $11, $4, $9, $14 + -15 | 0);
    $13 = $16;
    $9 = HEAP32[$13 + 72 >> 2];
    $3 = $9;
    $11 = HEAP32[$13 + 76 >> 2];
    $4 = $11;
    $13 = $9;
    $9 = $11 << 15 | $9 >>> 17;
    $8 = $13 << 15;
    $7 = $9;
    $11 = $16;
    $9 = HEAP32[$11 + 64 >> 2];
    $5 = $9;
    $13 = HEAP32[$11 + 68 >> 2];
    $6 = $13;
    $12 = $13 >>> 17 | 0;
    $9 = 0;
    $11 = $9;
    $13 = $8;
    $35 = $13 | $12;
    $9 = $7;
    $11 = $9 | $11;
    $31 = $11;
    $9 = $3;
    $13 = $9 << 15;
    $7 = $13;
    $13 = $6;
    $9 = $13 >>> 17 | 0;
    $11 = $5;
    $12 = ($13 & 131071) << 15 | $11 >>> 17;
    $11 = $9;
    $13 = 0;
    $26 = $13 | $12;
    $9 = $7;
    $11 = $9 | $11;
    $11 = $4;
    $13 = $11 >>> 17 | 0;
    $9 = $3;
    $38 = ($11 & 131071) << 15 | $9 >>> 17;
    $21 = ($19 - $14 | 0) + 16 | 0;
   }
   $11 = $26;
   $3 = $11;
   $11 = 0;
   $8 = $11;
   $9 = 0;
   $4 = $9;
   $11 = $9;
   $13 = $1;
   $7 = $13;
   $13 = $8;
   $13 = __wasm_i64_mul($3, $11, $1, $13);
   $34 = $13;
   $11 = i64toi32_i32$HIGH_BITS;
   $37 = $11;
   $11 = $6;
   $9 = $5;
   $11 = $9 << 15;
   $1 = $11 & -32768;
   $11 = 0;
   $6 = $11;
   $9 = 0;
   $2 = $9;
   $11 = $9;
   $13 = $27;
   $5 = $13;
   $13 = $6;
   $13 = __wasm_i64_mul($1, $11, $5, $13);
   $12 = $13;
   $11 = i64toi32_i32$HIGH_BITS;
   $13 = $11;
   $11 = $37;
   $14 = $13 + $11 | 0;
   $9 = $34;
   $10 = $9 + $12 | 0;
   if ($10 >>> 0 < $12 >>> 0) {
    $14 = $14 + 1 | 0
   }
   $27 = $10;
   $22 = $14;
   $9 = $10;
   $28 = $9;
   $23 = 0;
   $9 = $2;
   $11 = $8;
   $11 = __wasm_i64_mul($1, $9, $7, $11);
   $12 = $11;
   $9 = i64toi32_i32$HIGH_BITS;
   $11 = $9;
   $9 = $10;
   $10 = $9 + $11 | 0;
   $14 = $23;
   $13 = $14 + $12 | 0;
   if ($13 >>> 0 < $12 >>> 0) {
    $10 = $10 + 1 | 0
   }
   $26 = $13;
   $19 = $10;
   $14 = $28;
   $9 = $13;
   $12 = $23;
   $30 = ($10 | 0) == ($14 | 0) & $9 >>> 0 < $12 >>> 0 | $10 >>> 0 < $14 >>> 0;
   $9 = $4;
   $10 = $6;
   $10 = __wasm_i64_mul($3, $9, $5, $10);
   $43 = $10;
   $9 = i64toi32_i32$HIGH_BITS;
   $44 = $9;
   $12 = $25;
   $23 = $12;
   $10 = 0;
   $28 = $10;
   $12 = $2;
   $12 = __wasm_i64_mul($23, $10, $1, $12);
   $14 = $12;
   $10 = i64toi32_i32$HIGH_BITS;
   $12 = $10;
   $10 = $44;
   $13 = $10 + $12 | 0;
   $9 = $43;
   $11 = $9 + $14 | 0;
   if ($11 >>> 0 < $14 >>> 0) {
    $13 = $13 + 1 | 0
   }
   $17 = $11;
   $29 = $13;
   $10 = $35;
   $25 = $10;
   $9 = 0;
   $24 = $9;
   $10 = $8;
   $10 = __wasm_i64_mul($25, $9, $7, $10);
   $14 = $10;
   $9 = i64toi32_i32$HIGH_BITS;
   $10 = $9;
   $9 = $29;
   $11 = $9 + $10 | 0;
   $13 = $17;
   $12 = $13 + $14 | 0;
   if ($12 >>> 0 < $14 >>> 0) {
    $11 = $11 + 1 | 0
   }
   $35 = $12;
   $31 = $11;
   $13 = $37;
   $11 = $22;
   $9 = $27;
   $14 = $34;
   $14 = ($13 | 0) == ($11 | 0) & $9 >>> 0 < $14 >>> 0 | $11 >>> 0 < $13 >>> 0;
   $11 = $14;
   $14 = 0;
   $9 = $14;
   $9 = $9 | $11;
   $14 = $9;
   $11 = $22;
   $13 = $11;
   $11 = 0;
   $13 = $13 | $11;
   $10 = $13 + $12 | 0;
   $9 = $31;
   $11 = $14;
   $12 = $9 + $11 | 0;
   $34 = $10;
   $12 = $10 >>> 0 < $13 >>> 0 ? $12 + 1 | 0 : $12;
   $37 = $12;
   $12 = $4;
   $14 = $28;
   $14 = __wasm_i64_mul($3, $12, $23, $14);
   $45 = $14;
   $12 = i64toi32_i32$HIGH_BITS;
   $46 = $12;
   $9 = $32;
   $27 = $9 | 65536;
   $12 = $36;
   $22 = $12;
   $9 = $2;
   $9 = __wasm_i64_mul($27, $12, $1, $9);
   $13 = $9;
   $14 = i64toi32_i32$HIGH_BITS;
   $9 = $14;
   $14 = $46;
   $10 = $9 + $14 | 0;
   $12 = $45;
   $11 = $13 + $12 | 0;
   if ($11 >>> 0 < $13 >>> 0) {
    $10 = $10 + 1 | 0
   }
   $32 = $11;
   $36 = $10;
   $10 = $6;
   $12 = $24;
   $12 = __wasm_i64_mul($5, $10, $25, $12);
   $13 = $12;
   $10 = i64toi32_i32$HIGH_BITS;
   $12 = $10;
   $10 = $36;
   $11 = $10 + $12 | 0;
   $14 = $32;
   $9 = $13 + $14 | 0;
   if ($9 >>> 0 < $13 >>> 0) {
    $11 = $11 + 1 | 0
   }
   $40 = $9;
   $41 = $11;
   $42 = $34;
   $11 = $37;
   $39 = $11;
   $10 = $38;
   $11 = $10 & 2147483647;
   $1 = $11 | -2147483648;
   $14 = 0;
   $10 = $14;
   $2 = $10;
   $10 = $8;
   $11 = $14;
   $11 = __wasm_i64_mul($7, $10, $1, $11);
   $13 = $11;
   $10 = i64toi32_i32$HIGH_BITS;
   $11 = $10;
   $10 = $41;
   $9 = $10 + $11 | 0;
   $14 = $40;
   $12 = $13 + $14 | 0;
   if ($12 >>> 0 < $13 >>> 0) {
    $9 = $9 + 1 | 0
   }
   $38 = $12;
   $47 = $9;
   $10 = $12;
   $14 = $39;
   $12 = $10 + $14 | 0;
   $9 = $42;
   $13 = 0;
   $11 = $9 + $13 | 0;
   if ($11 >>> 0 < $13 >>> 0) {
    $12 = $12 + 1 | 0
   }
   $39 = $11;
   $42 = $12;
   $11 = $12;
   $13 = $30;
   $14 = $39;
   $10 = $13 + $14 | 0;
   if ($10 >>> 0 < $13 >>> 0) {
    $11 = $11 + 1 | 0
   }
   $7 = $10;
   $8 = $11;
   $20 = (($20 + $33 | 0) + $21 | 0) + -16383 | 0;
   $11 = $28;
   $14 = $24;
   $14 = __wasm_i64_mul($23, $11, $25, $14);
   $30 = $14;
   $11 = i64toi32_i32$HIGH_BITS;
   $21 = $11;
   $11 = $4;
   $14 = $22;
   $14 = __wasm_i64_mul($3, $11, $27, $14);
   $13 = $14;
   $11 = i64toi32_i32$HIGH_BITS;
   $14 = $11;
   $11 = $21;
   $10 = $11 + $14 | 0;
   $12 = $30;
   $9 = $13 + $12 | 0;
   if ($9 >>> 0 < $13 >>> 0) {
    $10 = $10 + 1 | 0
   }
   $3 = $9;
   $4 = $10;
   $12 = $21;
   $13 = $30;
   $30 = ($10 | 0) == ($12 | 0) & $9 >>> 0 < $13 >>> 0 | $10 >>> 0 < $12 >>> 0;
   $11 = $2;
   $10 = $6;
   $10 = __wasm_i64_mul($1, $11, $5, $10);
   $13 = $10;
   $10 = $4;
   $11 = i64toi32_i32$HIGH_BITS;
   $9 = $10 + $11 | 0;
   $12 = $3;
   $14 = $13 + $12 | 0;
   if ($14 >>> 0 < $12 >>> 0) {
    $9 = $9 + 1 | 0
   }
   $5 = $14;
   $6 = $9;
   $13 = $4;
   $11 = $14;
   $13 = ($9 | 0) == ($13 | 0) & $11 >>> 0 < $3 >>> 0 | $9 >>> 0 < $13 >>> 0;
   $14 = 0;
   $12 = $30;
   $10 = $13 + $12 | 0;
   if ($10 >>> 0 < $13 >>> 0) {
    $14 = 1
   }
   $21 = $10;
   $30 = $14;
   $4 = $5;
   $14 = $6;
   $3 = $14;
   $14 = $29;
   $12 = $44;
   $11 = $17;
   $13 = $43;
   $9 = ($14 | 0) == ($12 | 0) & $11 >>> 0 < $13 >>> 0 | $14 >>> 0 < $12 >>> 0;
   $11 = $31;
   $13 = $35;
   $12 = $17;
   $14 = ($14 | 0) == ($11 | 0) & $13 >>> 0 < $12 >>> 0 | $11 >>> 0 < $14 >>> 0;
   $10 = 0;
   $12 = $9;
   $9 = $14 + $12 | 0;
   if ($9 >>> 0 < $14 >>> 0) {
    $10 = 1
   }
   $14 = $9;
   $12 = $10;
   $10 = $3;
   $9 = $10 + $12 | 0;
   $13 = $4;
   $11 = $13 + $14 | 0;
   if ($11 >>> 0 < $14 >>> 0) {
    $9 = $9 + 1 | 0
   }
   $3 = $11;
   $4 = $9;
   $13 = $6;
   $10 = $11;
   $14 = $5;
   $13 = ($9 | 0) == ($13 | 0) & $10 >>> 0 < $14 >>> 0 | $9 >>> 0 < $13 >>> 0;
   $10 = $30;
   $11 = $10;
   $14 = $21;
   $12 = $13 + $14 | 0;
   if ($12 >>> 0 < $13 >>> 0) {
    $11 = $11 + 1 | 0
   }
   $10 = $12;
   $5 = $11;
   $11 = $2;
   $14 = $22;
   $14 = __wasm_i64_mul($1, $11, $27, $14);
   $13 = $14;
   $11 = i64toi32_i32$HIGH_BITS;
   $14 = $11;
   $11 = $5;
   $12 = $11 + $14 | 0;
   $9 = $13 + $10 | 0;
   if ($9 >>> 0 < $13 >>> 0) {
    $12 = $12 + 1 | 0
   }
   $29 = $9;
   $17 = $12;
   $12 = $2;
   $10 = $28;
   $10 = __wasm_i64_mul($1, $12, $23, $10);
   $5 = $10;
   $12 = i64toi32_i32$HIGH_BITS;
   $6 = $12;
   $12 = $24;
   $10 = $22;
   $10 = __wasm_i64_mul($25, $12, $27, $10);
   $13 = $10;
   $12 = i64toi32_i32$HIGH_BITS;
   $10 = $12;
   $12 = $6;
   $9 = $10 + $12 | 0;
   $11 = $5;
   $14 = $13 + $11 | 0;
   if ($14 >>> 0 < $13 >>> 0) {
    $9 = $9 + 1 | 0
   }
   $1 = $14;
   $2 = $9;
   $11 = $6;
   $12 = $14;
   $13 = $5;
   $13 = ($9 | 0) == ($11 | 0) & $12 >>> 0 < $13 >>> 0 | $9 >>> 0 < $11 >>> 0;
   $9 = $13;
   $13 = 0;
   $12 = $13;
   $13 = $9;
   $12 = $13 | $12;
   $13 = $29;
   $9 = 0;
   $11 = $2;
   $11 = $9 | $11;
   $10 = $13 + $11 | 0;
   $9 = $12;
   $12 = $17;
   $14 = $9 + $12 | 0;
   $14 = $10 >>> 0 < $11 >>> 0 ? $14 + 1 | 0 : $14;
   $6 = $10;
   $5 = $14;
   $12 = $1;
   $14 = $4;
   $13 = $14;
   $10 = $13 + $12 | 0;
   $11 = 0;
   $14 = $3;
   $9 = $11 + $14 | 0;
   if ($9 >>> 0 < $11 >>> 0) {
    $10 = $10 + 1 | 0
   }
   $1 = $9;
   $2 = $10;
   $14 = $4;
   $11 = $3;
   $14 = ($10 | 0) == ($14 | 0) & $9 >>> 0 < $11 >>> 0 | $10 >>> 0 < $14 >>> 0;
   $13 = $5;
   $9 = $13;
   $11 = $6;
   $12 = $11 + $14 | 0;
   if ($12 >>> 0 < $14 >>> 0) {
    $9 = $9 + 1 | 0
   }
   $4 = $12;
   $3 = $9;
   $9 = $47;
   $11 = $41;
   $13 = $38;
   $14 = $40;
   $6 = ($9 | 0) == ($11 | 0) & $13 >>> 0 < $14 >>> 0 | $9 >>> 0 < $11 >>> 0;
   $9 = $46;
   $13 = $36;
   $14 = $32;
   $11 = $45;
   $5 = ($9 | 0) == ($13 | 0) & $14 >>> 0 < $11 >>> 0 | $13 >>> 0 < $9 >>> 0;
   $14 = $41;
   $11 = $40;
   $9 = $32;
   $13 = ($14 | 0) == ($13 | 0) & $11 >>> 0 < $9 >>> 0 | $14 >>> 0 < $13 >>> 0;
   $12 = 0;
   $9 = $5;
   $10 = $9 + $13 | 0;
   if ($10 >>> 0 < $13 >>> 0) {
    $12 = 1
   }
   $13 = $10;
   $9 = $12;
   $10 = $9;
   $11 = $6;
   $14 = $13 + $11 | 0;
   $14 >>> 0 < $13 >>> 0;
   $12 = $14;
   $11 = $47;
   $13 = $11;
   $11 = $48;
   $5 = $13 | $11;
   $12 = 0;
   $10 = $12;
   $12 = $14;
   $10 = $10 | $12;
   $11 = $2;
   $14 = $10 + $11 | 0;
   $13 = $1;
   $12 = $5;
   $9 = $13 + $12 | 0;
   if ($9 >>> 0 < $13 >>> 0) {
    $14 = $14 + 1 | 0
   }
   $5 = $9;
   $6 = $14;
   $12 = $2;
   $12 = ($14 | 0) == ($12 | 0) & $9 >>> 0 < $1 >>> 0 | $14 >>> 0 < $12 >>> 0;
   $10 = $3;
   $9 = $10;
   $13 = $4;
   $11 = $13 + $12 | 0;
   if ($11 >>> 0 < $12 >>> 0) {
    $9 = $9 + 1 | 0
   }
   $24 = $11;
   $17 = $9;
   $2 = $5;
   $9 = $6;
   $1 = $9;
   $9 = $37;
   $13 = $31;
   $10 = $34;
   $12 = $35;
   $3 = ($9 | 0) == ($13 | 0) & $10 >>> 0 < $12 >>> 0 | $9 >>> 0 < $13 >>> 0;
   $10 = $42;
   $12 = $39;
   $13 = $34;
   $9 = ($10 | 0) == ($9 | 0) & $12 >>> 0 < $13 >>> 0 | $10 >>> 0 < $9 >>> 0;
   $11 = 0;
   $13 = $3;
   $14 = $9 + $13 | 0;
   if ($14 >>> 0 < $9 >>> 0) {
    $11 = 1
   }
   $9 = $14;
   $13 = $11;
   $11 = $1;
   $14 = $13 + $11 | 0;
   $12 = $2;
   $10 = $9 + $12 | 0;
   if ($10 >>> 0 < $9 >>> 0) {
    $14 = $14 + 1 | 0
   }
   $3 = $10;
   $4 = $14;
   $12 = $6;
   $9 = $5;
   $12 = ($14 | 0) == ($12 | 0) & $10 >>> 0 < $9 >>> 0 | $14 >>> 0 < $12 >>> 0;
   $11 = $17;
   $10 = $11;
   $9 = $24;
   $13 = $9 + $12 | 0;
   if ($13 >>> 0 < $12 >>> 0) {
    $10 = $10 + 1 | 0
   }
   $1 = $13;
   $2 = $10;
   $9 = $10 & 65536;
   label$13 : {
    if ($9) {
     $20 = $20 + 1 | 0;
     break label$13;
    }
    $9 = $19;
    $5 = $9 >>> 31 | 0;
    $11 = 0;
    $6 = $11;
    $9 = $1;
    $1 = $9 << 1;
    $11 = $2;
    $10 = $11 << 1 | $9 >>> 31;
    $2 = $10;
    $10 = $4;
    $12 = $10 >>> 31 | 0;
    $9 = 0;
    $11 = $9;
    $10 = $1;
    $1 = $10 | $12;
    $9 = $2;
    $11 = $9 | $11;
    $2 = $11;
    $9 = $3;
    $3 = $9 << 1;
    $11 = $4;
    $10 = $11 << 1 | $9 >>> 31;
    $4 = $10;
    $10 = $8;
    $12 = $10 >>> 31 | 0;
    $9 = 0;
    $11 = $9;
    $10 = $3;
    $3 = $10 | $12;
    $9 = $4;
    $11 = $9 | $11;
    $4 = $11;
    $9 = $26;
    $26 = $9 << 1;
    $11 = $19;
    $10 = $11 << 1 | $9 >>> 31;
    $19 = $10;
    $10 = $8;
    $11 = $7;
    $9 = $10 << 1 | $11 >>> 31;
    $10 = $11 << 1;
    $12 = $5;
    $7 = $10 | $12;
    $11 = $6;
    $11 = $11 | $9;
    $8 = $11;
   }
   if (($20 | 0) >= 32767) {
    $9 = $18;
    $18 = $9;
    $11 = $15;
    $10 = $11 | 2147418112;
    $15 = $10;
    $1 = 0;
    $2 = 0;
    break label$1;
   }
   $5 = $18;
   $10 = $15;
   $6 = $10;
   label$16 : {
    if (($20 | 0) <= 0) {
     $33 = 1 - $20 | 0;
     if ($33 >>> 0 <= 127) {
      $10 = $19;
      $9 = $8;
      $20 = $20 + 127 | 0;
      __ashlti3($16 + 48 | 0, $26, $10, $7, $9, $20);
      $9 = $4;
      $10 = $2;
      __ashlti3($16 + 32 | 0, $3, $9, $1, $10, $20);
      $10 = $19;
      $9 = $8;
      __lshrti3($16 + 16 | 0, $26, $10, $7, $9, $33);
      $9 = $4;
      $10 = $2;
      __lshrti3($16, $3, $9, $1, $10, $33);
      $11 = $16;
      $10 = HEAP32[$11 + 48 >> 2];
      $2 = $10;
      $9 = HEAP32[$11 + 52 >> 2];
      $1 = $9;
      $9 = HEAP32[$11 + 56 >> 2];
      $12 = $9;
      $10 = HEAP32[$11 + 60 >> 2];
      $9 = $10;
      $10 = $1;
      $9 = $9 | $10;
      $11 = $2;
      $10 = $11 | $12;
      $3 = ($10 | 0) != 0 | ($9 | 0) != 0;
      $12 = $16;
      $10 = HEAP32[$12 + 32 >> 2];
      $2 = $10;
      $9 = HEAP32[$12 + 36 >> 2];
      $1 = $9;
      $9 = HEAP32[$12 + 16 >> 2];
      $11 = $9;
      $10 = HEAP32[$12 + 20 >> 2];
      $9 = $10;
      $10 = $1;
      $9 = $9 | $10;
      $10 = $3;
      $12 = $2;
      $11 = $11 | $12;
      $26 = $10 | $11;
      $19 = $9;
      $9 = $16;
      $12 = HEAP32[$9 + 40 >> 2];
      $2 = $12;
      $10 = HEAP32[$9 + 44 >> 2];
      $1 = $10;
      $10 = HEAP32[$9 + 24 >> 2];
      $12 = HEAP32[$9 + 28 >> 2];
      $9 = $2;
      $7 = $9 | $10;
      $10 = $12;
      $12 = $1;
      $10 = $10 | $12;
      $8 = $10;
      $12 = $16;
      $10 = HEAP32[$12 >> 2];
      $3 = $10;
      $9 = HEAP32[$12 + 4 >> 2];
      $4 = $9;
      $10 = HEAP32[$12 + 12 >> 2];
      $9 = HEAP32[$12 + 8 >> 2];
      break label$16;
     }
     $1 = 0;
     $2 = 0;
     break label$1;
    }
    $10 = $2;
    $9 = $10 & 65535;
    $10 = $20;
    $12 = $10 << 16;
    $10 = $12;
    $10 = $10 | $9;
    $9 = $1;
    $11 = 0;
    $9 = $9 | $11;
   }
   $11 = $5;
   $12 = $9;
   $18 = $11 | $12;
   $9 = $6;
   $9 = $9 | $10;
   $15 = $9;
   $9 = $19;
   $2 = !($9 | $26);
   $10 = $7;
   $9 = $8;
   $1 = ($9 | 0) > -1 ? 1 : ($9 | 0) >= -1 ? ($10 >>> 0 <= 4294967295 ? 0 : 1) : 0;
   $11 = $10;
   $10 = $8;
   if (!(!$11 & ($10 | 0) == -2147483648 ? $2 : $1)) {
    $11 = $15;
    $5 = $11;
    $11 = $4;
    $13 = $11;
    $12 = $3;
    $14 = $12 + 1 | 0;
    if ($14 >>> 0 < 1) {
     $13 = $13 + 1 | 0
    }
    $1 = $14;
    $2 = $13;
    $12 = $4;
    $11 = $14;
    $9 = $3;
    $12 = ($13 | 0) == ($12 | 0) & $11 >>> 0 < $9 >>> 0 | $13 >>> 0 < $12 >>> 0;
    $11 = $5;
    $14 = $11;
    $9 = $18;
    $10 = $9 + $12 | 0;
    if ($10 >>> 0 < $12 >>> 0) {
     $14 = $14 + 1 | 0
    }
    $18 = $10;
    $15 = $14;
    break label$1;
   }
   $14 = $8;
   $9 = $14 ^ -2147483648;
   $11 = $9;
   $14 = $26;
   $12 = $7;
   $9 = $19;
   $11 = $9 | $11;
   if ($14 | $12 | $11) {
    $1 = $3;
    $11 = $4;
    $2 = $11;
    break label$1;
   }
   $14 = 0;
   $1 = $14;
   $11 = $4;
   $14 = $11;
   $11 = $3;
   $9 = $11;
   $12 = $9 & 1;
   $13 = $9 + $12 | 0;
   $9 = $1;
   $10 = $14 + $9 | 0;
   $1 = $13;
   $10 = $13 >>> 0 < $12 >>> 0 ? $10 + 1 | 0 : $10;
   $2 = $10;
   $11 = $14;
   $12 = $3;
   $11 = ($10 | 0) == ($11 | 0) & $13 >>> 0 < $12 >>> 0 | $10 >>> 0 < $11 >>> 0;
   $14 = $15;
   $13 = $14;
   $12 = $18;
   $9 = $11 + $12 | 0;
   if ($9 >>> 0 < $11 >>> 0) {
    $13 = $13 + 1 | 0
   }
   $18 = $9;
   $15 = $13;
  }
  $12 = $0;
  HEAP32[$12 >> 2] = $1;
  $13 = $2;
  HEAP32[$12 + 4 >> 2] = $13;
  HEAP32[$12 + 8 >> 2] = $18;
  $13 = $15;
  HEAP32[$12 + 12 >> 2] = $13;
  global$0 = $16 + 96 | 0;
 }
 
 function __multi3($0, $1, $2, $3, $4, $5, $6, $7, $8) {
  var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
  $9 = $4;
  $13 = $6;
  $13 = __wasm_i64_mul($3, $9, $5, $13);
  $11 = $13;
  $9 = i64toi32_i32$HIGH_BITS;
  $3 = $9;
  $9 = $2;
  $13 = $8;
  $13 = __wasm_i64_mul($1, $9, $7, $13);
  $14 = $13;
  $9 = i64toi32_i32$HIGH_BITS;
  $13 = $9;
  $9 = $3;
  $12 = $9 + $13 | 0;
  $10 = $11 + $14 | 0;
  if ($10 >>> 0 < $14 >>> 0) {
   $12 = $12 + 1 | 0
  }
  $13 = $10;
  $10 = $12;
  $11 = 0;
  $4 = $11;
  $9 = 0;
  $8 = $9;
  $12 = $2;
  $3 = $12;
  $11 = $6;
  $7 = $11;
  $12 = __wasm_i64_mul($2, $4, $11, $9);
  $14 = $12;
  $9 = i64toi32_i32$HIGH_BITS;
  $12 = $9;
  $9 = $10;
  $10 = $9 + $12 | 0;
  $11 = $13;
  $13 = $11 + $14 | 0;
  if ($13 >>> 0 < $14 >>> 0) {
   $10 = $10 + 1 | 0
  }
  $12 = $10;
  $9 = $1;
  $1 = $9;
  $11 = 0;
  $2 = $11;
  $10 = $5;
  $5 = $10;
  $9 = 0;
  $6 = $9;
  $9 = $2;
  $10 = $6;
  $10 = __wasm_i64_mul($1, $9, $5, $10);
  $16 = $10;
  $9 = i64toi32_i32$HIGH_BITS;
  $14 = $9;
  $15 = $13;
  $9 = $12;
  $17 = $9;
  $9 = $4;
  $10 = $6;
  $10 = __wasm_i64_mul($3, $9, $5, $10);
  $3 = $10;
  $9 = i64toi32_i32$HIGH_BITS;
  $10 = 0;
  $11 = $10;
  $10 = $9;
  $13 = $11 + $10 | 0;
  $9 = $3;
  $12 = $9 + $14 | 0;
  if ($12 >>> 0 < $14 >>> 0) {
   $13 = $13 + 1 | 0
  }
  $5 = $12;
  $6 = $13;
  $9 = 0;
  $10 = $9;
  $9 = $17;
  $12 = $9 + $10 | 0;
  $13 = $15;
  $14 = $6;
  $11 = $13 + $14 | 0;
  if ($11 >>> 0 < $14 >>> 0) {
   $12 = $12 + 1 | 0
  }
  $3 = $11;
  $4 = $12;
  $15 = $0;
  $12 = $2;
  $13 = $8;
  $13 = __wasm_i64_mul($1, $12, $7, $13);
  $12 = i64toi32_i32$HIGH_BITS;
  $1 = $12;
  $9 = $5;
  $14 = $9;
  $12 = $13;
  $10 = $9 + $12 | 0;
  $13 = 0;
  $9 = $13;
  $13 = $1;
  $11 = $9 + $13 | 0;
  $5 = $10;
  $11 = $10 >>> 0 < $14 >>> 0 ? $11 + 1 | 0 : $11;
  $6 = $11;
  $12 = 0;
  $13 = $12;
  $12 = $4;
  $10 = $13 + $12 | 0;
  $11 = $3;
  $14 = $6;
  $9 = $11 + $14 | 0;
  if ($9 >>> 0 < $14 >>> 0) {
   $10 = $10 + 1 | 0
  }
  $11 = $15;
  HEAP32[$11 + 8 >> 2] = $9;
  HEAP32[$11 + 12 >> 2] = $10;
  $11 = 0;
  $1 = $11;
  $12 = $16;
  $11 = $12;
  $14 = 0;
  $2 = $11 | $14;
  $11 = $0;
  HEAP32[$11 >> 2] = $2;
  $10 = $5;
  $12 = $1;
  $10 = $10 | $12;
  HEAP32[$11 + 4 >> 2] = $10;
 }
 
 function __subtf3($0, $1, $2, $3, $4, $5, $6, $7, $8) {
  var $9 = 0, $10 = 0, $11 = 0;
  $10 = global$0 - 16 | 0;
  global$0 = $10;
  $11 = $8 ^ -2147483648;
  $9 = $4;
  $8 = $6;
  $4 = $11;
  __addtf3($10, $1, $2, $3, $9, $5, $8, $7, $4);
  $9 = $10;
  $4 = HEAP32[$9 >> 2];
  $8 = HEAP32[$9 + 4 >> 2];
  HEAP32[$0 >> 2] = $4;
  HEAP32[$0 + 4 >> 2] = $8;
  $4 = HEAP32[$9 + 12 >> 2];
  $8 = HEAP32[$9 + 8 >> 2];
  HEAP32[$0 + 8 >> 2] = $8;
  HEAP32[$0 + 12 >> 2] = $4;
  global$0 = $9 + 16 | 0;
 }
 
 function __trunctfdf2($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
  $12 = global$0 - 32 | 0;
  global$0 = $12;
  $7 = $2;
  $8 = $7;
  $4 = $3;
  $4 = $4 & 2147483647;
  $9 = $4;
  $5 = $4 + -1006698496 | 0;
  $4 = $8;
  $6 = $4;
  if ($6 >>> 0 < 0) {
   $5 = $5 + 1 | 0
  }
  $13 = $6;
  $10 = $5;
  $5 = $9;
  $6 = $5 + -1140785152 | 0;
  $4 = $8;
  $7 = $4;
  if ($7 >>> 0 < 0) {
   $6 = $6 + 1 | 0
  }
  $4 = $6;
  $6 = $10;
  $5 = $13;
  label$1 : {
   if (($4 | 0) == ($6 | 0) & $5 >>> 0 < $7 >>> 0 | $6 >>> 0 < $4 >>> 0) {
    $9 = $2 << 4;
    $5 = $3;
    $6 = $5 << 4 | $2 >>> 28;
    $7 = $6;
    $2 = 0;
    $5 = $2;
    $6 = $1;
    $4 = $6 >>> 28 | 0;
    $6 = $9;
    $8 = $4 | $6;
    $2 = $7;
    $5 = $2 | $5;
    $9 = $5;
    $5 = $1;
    $6 = $5 & 268435455;
    $1 = $6;
    $5 = $0;
    if (($6 | 0) == 134217728 & $5 >>> 0 >= 1 | $6 >>> 0 > 134217728) {
     $5 = $9;
     $7 = $5 + 1073741824 | 0;
     $4 = $8;
     $4 = $4 + 1 | 0;
     if ($4 >>> 0 < 1) {
      $7 = $7 + 1 | 0
     }
     $11 = $4;
     $10 = $7;
     break label$1;
    }
    $5 = $8;
    $11 = $5;
    $7 = $9;
    $4 = ($5 >>> 0 < 0) + -1073741824 | 0;
    $4 = $7 - $4 | 0;
    $10 = $4;
    $4 = $1;
    $5 = $4 ^ 134217728;
    $7 = $0;
    $4 = $7;
    if ($4 | $5) {
     break label$1
    }
    $5 = 0;
    $2 = $5;
    $4 = $10;
    $5 = $4;
    $4 = $11;
    $7 = $4 & 1;
    $4 = $4 + $7 | 0;
    $6 = $5 + $2 | 0;
    $11 = $4;
    $6 = $4 >>> 0 < $7 >>> 0 ? $6 + 1 | 0 : $6;
    $10 = $6;
    break label$1;
   }
   $6 = $1;
   $10 = !($6 | $0);
   $6 = $9;
   $5 = $8;
   $4 = ($6 | 0) == 2147418112 & $5 >>> 0 < 0 | $6 >>> 0 < 2147418112;
   $5 = $6;
   $7 = $8;
   if (!(!$7 & ($5 | 0) == 2147418112 ? $10 : $4)) {
    $4 = $2;
    $0 = $4 << 4;
    $7 = $3;
    $5 = $7 << 4 | $4 >>> 28;
    $4 = 0;
    $7 = $4;
    $7 = $5 | $7;
    $5 = $1;
    $6 = $5 >>> 28 | 0;
    $5 = $0;
    $4 = $6 | $5;
    $5 = $7 & 524287;
    $11 = $4;
    $4 = $5 | 2146959360;
    $10 = $4;
    break label$1;
   }
   $10 = 2146435072;
   $4 = $9;
   $5 = $8;
   if (($4 | 0) == 1140785151 & $5 >>> 0 > 4294967295 | $4 >>> 0 > 1140785151) {
    break label$1
   }
   $10 = 0;
   $5 = $9;
   $7 = $5 >>> 16 | 0;
   if ($7 >>> 0 < 15249) {
    break label$1
   }
   $4 = $3;
   $6 = $4 & 65535;
   $5 = $2;
   $8 = $5;
   $5 = $6 | 65536;
   $9 = $5;
   $5 = $1;
   $4 = $9;
   __ashlti3($12 + 16 | 0, $0, $5, $8, $4, $7 + -15233 | 0);
   $4 = $5;
   $5 = $9;
   __lshrti3($12, $0, $4, $8, $5, 15361 - $7 | 0);
   $6 = $12;
   $5 = HEAP32[$6 + 8 >> 2];
   $4 = HEAP32[$6 + 12 >> 2];
   $1 = $5 << 4;
   $5 = $4 << 4 | $5 >>> 28;
   $0 = $5;
   $6 = HEAP32[$12 + 4 >> 2];
   $9 = $6;
   $4 = $12;
   $5 = HEAP32[$4 >> 2];
   $8 = $5;
   $7 = $6 >>> 28 | 0;
   $6 = $1;
   $11 = $7 | $6;
   $5 = 0;
   $4 = $5;
   $5 = $0;
   $4 = $4 | $5;
   $10 = $4;
   $5 = $12;
   $4 = HEAP32[$5 + 16 >> 2];
   $1 = $4;
   $6 = HEAP32[$5 + 20 >> 2];
   $0 = $6;
   $6 = HEAP32[$5 + 24 >> 2];
   $7 = $6;
   $4 = HEAP32[$5 + 28 >> 2];
   $6 = $4;
   $4 = $0;
   $6 = $4 | $6;
   $5 = $1;
   $4 = $7 | $5;
   $0 = ($4 | 0) != 0 | ($6 | 0) != 0;
   $4 = $9;
   $6 = $4 & 268435455;
   $4 = $0;
   $7 = $8;
   $5 = $7;
   $8 = $4 | $5;
   $7 = $6;
   $9 = $6;
   $6 = $8;
   if (($7 | 0) == 134217728 & $6 >>> 0 >= 1 | $7 >>> 0 > 134217728) {
    $6 = $10;
    $4 = $6;
    $5 = $11;
    $2 = $5 + 1 | 0;
    if ($2 >>> 0 < 1) {
     $4 = $4 + 1 | 0
    }
    $11 = $2;
    $10 = $4;
    break label$1;
   }
   $4 = $9;
   $5 = $4 ^ 134217728;
   $4 = $8;
   if ($4 | $5) {
    break label$1
   }
   $5 = 0;
   $0 = $5;
   $4 = $10;
   $5 = $4;
   $4 = $11;
   $6 = $4 & 1;
   $7 = $4 + $6 | 0;
   $4 = $0;
   $2 = $5 + $4 | 0;
   $11 = $7;
   $2 = $7 >>> 0 < $6 >>> 0 ? $2 + 1 | 0 : $2;
   $10 = $2;
  }
  global$0 = $12 + 32 | 0;
  $2 = $3;
  $4 = $2 & -2147483648;
  $5 = $4;
  $4 = $10;
  $5 = $4 | $5;
  $2 = $11;
  $6 = 0;
  wasm2js_scratch_store_i32(0, $2 | $6);
  wasm2js_scratch_store_i32(1, $5 | 0);
  return +wasm2js_scratch_load_f64();
 }
 
 function __trunctfsf2($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
  $12 = global$0 - 32 | 0;
  global$0 = $12;
  $8 = $2;
  $4 = $3 & 2147483647;
  $10 = $4;
  $7 = $4 + -1065418752 | 0;
  $5 = $8;
  if ($5 >>> 0 < 0) {
   $7 = $7 + 1 | 0
  }
  $11 = $5;
  $13 = $7;
  $7 = $10;
  $5 = $7 + -1082064896 | 0;
  $4 = $8;
  $6 = $4;
  if ($4 >>> 0 < 0) {
   $5 = $5 + 1 | 0
  }
  $4 = $5;
  $5 = $13;
  $7 = $11;
  label$1 : {
   if (($4 | 0) == ($5 | 0) & $7 >>> 0 < $6 >>> 0 | $5 >>> 0 < $4 >>> 0) {
    $7 = $3;
    $6 = $2;
    $9 = ($7 & 33554431) << 7 | $6 >>> 25;
    $6 = 0;
    $10 = $6;
    $5 = $1;
    $11 = !($5 | $0);
    $7 = $2;
    $8 = $7 & 33554431;
    $5 = $8;
    $7 = !$6 & $5 >>> 0 < 16777216 | $6 >>> 0 < 0;
    $5 = $6;
    $4 = $8;
    if (!(!$5 & ($4 | 0) == 16777216 ? $11 : $7)) {
     $9 = $9 + 1073741825 | 0;
     break label$1;
    }
    $9 = $9 + 1073741824 | 0;
    $4 = $10;
    $5 = $4;
    $7 = $8;
    $4 = $7 ^ 16777216;
    $7 = $1;
    $7 = $7 | $5;
    $6 = $0;
    $5 = $6 | $4;
    if ($5 | $7) {
     break label$1
    }
    $9 = ($9 & 1) + $9 | 0;
    break label$1;
   }
   $5 = $1;
   $7 = !($5 | $0);
   $5 = $10;
   $6 = $8;
   $11 = ($5 | 0) == 2147418112 & $6 >>> 0 < 0 | $5 >>> 0 < 2147418112;
   $6 = $5;
   $4 = $8;
   if (!(!$4 & ($6 | 0) == 2147418112 ? $7 : $11)) {
    $4 = $3;
    $7 = $2;
    $9 = (($4 & 33554431) << 7 | $7 >>> 25) & 4194303 | 2143289344;
    break label$1;
   }
   $9 = 2139095040;
   if (($10 | 0) == 1082064895 & $8 >>> 0 > 4294967295 | $6 >>> 0 > 1082064895) {
    break label$1
   }
   $9 = 0;
   $4 = $10;
   $7 = $4 >>> 16 | 0;
   if ($7 >>> 0 < 16145) {
    break label$1
   }
   $6 = $3;
   $5 = $6 & 65535;
   $4 = $2;
   $8 = $4;
   $4 = $5 | 65536;
   $10 = $4;
   $4 = $1;
   $6 = $10;
   __ashlti3($12 + 16 | 0, $0, $4, $8, $6, $7 + -16129 | 0);
   $6 = $4;
   $4 = $10;
   __lshrti3($12, $0, $6, $8, $4, 16257 - $7 | 0);
   $5 = $12;
   $4 = HEAP32[$5 + 8 >> 2];
   $8 = $4;
   $6 = HEAP32[$5 + 12 >> 2];
   $10 = $6;
   $5 = $8;
   $9 = ($6 & 33554431) << 7 | $5 >>> 25;
   $6 = $12;
   $4 = HEAP32[$6 >> 2];
   $0 = $4;
   $5 = HEAP32[$6 + 4 >> 2];
   $1 = $5;
   $5 = HEAP32[$6 + 16 >> 2];
   $7 = $5;
   $4 = HEAP32[$6 + 20 >> 2];
   $11 = $4;
   $4 = HEAP32[$6 + 24 >> 2];
   $13 = $4;
   $5 = HEAP32[$6 + 28 >> 2];
   $4 = $5;
   $5 = $11;
   $4 = $4 | $5;
   $6 = $7;
   $7 = $13;
   $5 = $6 | $7;
   $6 = ($5 | 0) != 0 | ($4 | 0) != 0;
   $5 = $1;
   $4 = $5;
   $1 = $4;
   $7 = $0;
   $0 = $6 | $7;
   $11 = !($4 | $0);
   $5 = $8;
   $8 = $5 & 33554431;
   $7 = 0;
   $10 = $7;
   $4 = $8;
   $5 = !$7 & $4 >>> 0 < 16777216 | $7 >>> 0 < 0;
   $4 = $7;
   $6 = $8;
   if (!(!$4 & ($6 | 0) == 16777216 ? $11 : $5)) {
    $9 = $9 + 1 | 0;
    break label$1;
   }
   $6 = $10;
   $4 = $6;
   $5 = $8;
   $6 = $5 ^ 16777216;
   $5 = $1;
   $5 = $5 | $4;
   $7 = $0;
   $4 = $7 | $6;
   if ($4 | $5) {
    break label$1
   }
   $9 = ($9 & 1) + $9 | 0;
  }
  global$0 = $12 + 32 | 0;
  $4 = $3;
  return wasm2js_scratch_store_i32(0, $4 & -2147483648 | $9), wasm2js_scratch_load_f32();
 }
 
 function setThrew($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  if (!HEAP32[6013]) {
   HEAP32[6014] = $1;
   HEAP32[6013] = $0;
  }
 }
 
 function __cos($0, $1) {
  var $2 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0.0;
  $2 = $0 * $0;
  $3 = $2 * .5;
  $4 = 1.0 - $3;
  $3 = 1.0 - $4 - $3;
  $5 = $3;
  $3 = $2 * $2;
  return $4 + ($5 + ($2 * ($2 * ($2 * ($2 * 2.480158728947673e-05 + -.001388888888887411) + .0416666666666666) + $3 * $3 * ($2 * ($2 * -1.1359647557788195e-11 + 2.087572321298175e-09) + -2.7557314351390663e-07)) - $0 * $1));
 }
 
 function floor($0) {
  return Math_floor($0);
 }
 
 function __rem_pio2_large($0, $1, $2, $3, $4) {
  var $5 = 0.0, $6 = 0, $7 = 0, $8 = 0, $9 = 0.0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0.0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0.0, $22 = 0, $23 = 0, $24 = 0;
  $8 = global$0 - 560 | 0;
  global$0 = $8;
  $7 = ($2 + -3 | 0) / 24 | 0;
  $6 = ($7 | 0) > 0;
  $19 = $6 ? $7 : 0;
  $17 = Math_imul($19, -24) + $2 | 0;
  $11 = HEAP32[($4 << 2) + 15424 >> 2];
  $14 = $3 + -1 | 0;
  if (($11 + $14 | 0) >= 0) {
   $6 = $3 + $11 | 0;
   $2 = $19 - $14 | 0;
   $7 = 0;
   while (1) {
    HEAPF64[($8 + 320 | 0) + ($7 << 3) >> 3] = ($2 | 0) < 0 ? 0.0 : +HEAP32[($2 << 2) + 15440 >> 2];
    $2 = $2 + 1 | 0;
    $7 = $7 + 1 | 0;
    if (($7 | 0) != ($6 | 0)) {
     continue
    }
    break;
   };
  }
  $13 = $17 + -24 | 0;
  $6 = 0;
  $20 = ($11 | 0) > 0 ? $11 : 0;
  $12 = ($3 | 0) < 1;
  while (1) {
   label$6 : {
    if ($12) {
     $5 = 0.0;
     break label$6;
    }
    $7 = $6 + $14 | 0;
    $2 = 0;
    $5 = 0.0;
    while (1) {
     $5 = $5 + HEAPF64[($2 << 3) + $0 >> 3] * HEAPF64[($8 + 320 | 0) + ($7 - $2 << 3) >> 3];
     $2 = $2 + 1 | 0;
     if (($3 | 0) != ($2 | 0)) {
      continue
     }
     break;
    };
   }
   HEAPF64[($6 << 3) + $8 >> 3] = $5;
   $2 = ($6 | 0) == ($20 | 0);
   $6 = $6 + 1 | 0;
   if (!$2) {
    continue
   }
   break;
  };
  $24 = 23 - $13 | 0;
  $22 = 24 - $13 | 0;
  $6 = $11;
  label$9 : {
   while (1) {
    $5 = HEAPF64[($6 << 3) + $8 >> 3];
    $2 = 0;
    $7 = $6;
    $12 = ($6 | 0) < 1;
    if (!$12) {
     while (1) {
      $14 = ($8 + 480 | 0) + ($2 << 2) | 0;
      $15 = $5;
      $9 = $5 * 5.9604644775390625e-08;
      label$14 : {
       if (Math_abs($9) < 2147483648.0) {
        $10 = ~~$9;
        break label$14;
       }
       $10 = -2147483648;
      }
      $9 = +($10 | 0);
      $5 = $15 + $9 * -16777216.0;
      label$13 : {
       if (Math_abs($5) < 2147483648.0) {
        $10 = ~~$5;
        break label$13;
       }
       $10 = -2147483648;
      }
      HEAP32[$14 >> 2] = $10;
      $7 = $7 + -1 | 0;
      $5 = HEAPF64[($7 << 3) + $8 >> 3] + $9;
      $2 = $2 + 1 | 0;
      if (($6 | 0) != ($2 | 0)) {
       continue
      }
      break;
     }
    }
    $5 = scalbn($5, $13);
    $9 = floor($5 * .125) * -8.0;
    $5 = $5 + $9;
    label$17 : {
     if (Math_abs($5) < 2147483648.0) {
      $16 = ~~$5;
      break label$17;
     }
     $16 = -2147483648;
    }
    $5 = $5 - +($16 | 0);
    label$19 : {
     label$20 : {
      label$21 : {
       $23 = ($13 | 0) < 1;
       label$22 : {
        if (!$23) {
         $2 = (($6 << 2) + $8 | 0) + 476 | 0;
         $10 = $2;
         $2 = HEAP32[$2 >> 2];
         $7 = $2;
         $2 = $2 >> $22;
         $7 = $7 - ($2 << $22) | 0;
         HEAP32[$10 >> 2] = $7;
         $16 = $2 + $16 | 0;
         $10 = $7 >> $24;
         break label$22;
        }
        if ($13) {
         break label$21
        }
        $10 = HEAP32[(($6 << 2) + $8 | 0) + 476 >> 2] >> 23;
       }
       if (($10 | 0) < 1) {
        break label$19
       }
       break label$20;
      }
      $10 = 2;
      if (!!($5 >= .5)) {
       break label$20
      }
      $10 = 0;
      break label$19;
     }
     $2 = 0;
     $18 = 0;
     if (!$12) {
      while (1) {
       $14 = ($8 + 480 | 0) + ($2 << 2) | 0;
       $7 = HEAP32[$14 >> 2];
       label$26 : {
        label$27 : {
         if ($18) {
          $12 = 16777215
         } else {
          if (!$7) {
           break label$27
          }
          $18 = 1;
          $12 = 16777216;
         }
         HEAP32[$14 >> 2] = $12 - $7;
         break label$26;
        }
        $18 = 0;
       }
       $2 = $2 + 1 | 0;
       if (($6 | 0) != ($2 | 0)) {
        continue
       }
       break;
      }
     }
     label$30 : {
      if ($23) {
       break label$30
      }
      $2 = $13 + -1 | 0;
      if ($2 >>> 0 > 1) {
       break label$30
      }
      if ($2 - 1) {
       $2 = (($6 << 2) + $8 | 0) + 476 | 0;
       $7 = HEAP32[$2 >> 2] & 8388607;
       HEAP32[$2 >> 2] = $7;
       break label$30;
      }
      $2 = (($6 << 2) + $8 | 0) + 476 | 0;
      $7 = HEAP32[$2 >> 2] & 4194303;
      HEAP32[$2 >> 2] = $7;
     }
     $16 = $16 + 1 | 0;
     if (($10 | 0) != 2) {
      break label$19
     }
     $5 = 1.0 - $5;
     $10 = 2;
     if (!$18) {
      break label$19
     }
     $5 = $5 - scalbn(1.0, $13);
    }
    if ($5 == 0.0) {
     $7 = 0;
     label$33 : {
      $2 = $6;
      if (($2 | 0) <= ($11 | 0)) {
       break label$33
      }
      while (1) {
       $2 = $2 + -1 | 0;
       $7 = HEAP32[($8 + 480 | 0) + ($2 << 2) >> 2] | $7;
       if (($2 | 0) > ($11 | 0)) {
        continue
       }
       break;
      };
      if (!$7) {
       break label$33
      }
      $17 = $13;
      while (1) {
       $17 = $17 + -24 | 0;
       $6 = $6 + -1 | 0;
       if (!HEAP32[($8 + 480 | 0) + ($6 << 2) >> 2]) {
        continue
       }
       break;
      };
      break label$9;
     }
     $2 = 1;
     while (1) {
      $7 = $2;
      $2 = $2 + 1 | 0;
      if (!HEAP32[($8 + 480 | 0) + ($11 - $7 << 2) >> 2]) {
       continue
      }
      break;
     };
     $12 = $6 + $7 | 0;
     while (1) {
      $7 = $3 + $6 | 0;
      $6 = $6 + 1 | 0;
      HEAPF64[($8 + 320 | 0) + ($7 << 3) >> 3] = HEAP32[($19 + $6 << 2) + 15440 >> 2];
      $2 = 0;
      $5 = 0.0;
      if (($3 | 0) >= 1) {
       while (1) {
        $5 = $5 + HEAPF64[($2 << 3) + $0 >> 3] * HEAPF64[($8 + 320 | 0) + ($7 - $2 << 3) >> 3];
        $2 = $2 + 1 | 0;
        if (($3 | 0) != ($2 | 0)) {
         continue
        }
        break;
       }
      }
      HEAPF64[($6 << 3) + $8 >> 3] = $5;
      if (($6 | 0) < ($12 | 0)) {
       continue
      }
      break;
     };
     $6 = $12;
     continue;
    }
    break;
   };
   $5 = scalbn($5, 0 - $13 | 0);
   label$40 : {
    if (!!($5 >= 16777216.0)) {
     $3 = ($8 + 480 | 0) + ($6 << 2) | 0;
     $15 = $5;
     $9 = $5 * 5.9604644775390625e-08;
     label$43 : {
      if (Math_abs($9) < 2147483648.0) {
       $2 = ~~$9;
       break label$43;
      }
      $2 = -2147483648;
     }
     $5 = $15 + +($2 | 0) * -16777216.0;
     label$42 : {
      if (Math_abs($5) < 2147483648.0) {
       $0 = ~~$5;
       break label$42;
      }
      $0 = -2147483648;
     }
     HEAP32[$3 >> 2] = $0;
     $6 = $6 + 1 | 0;
     break label$40;
    }
    if (Math_abs($5) < 2147483648.0) {
     $2 = ~~$5
    } else {
     $2 = -2147483648
    }
    $17 = $13;
   }
   HEAP32[($8 + 480 | 0) + ($6 << 2) >> 2] = $2;
  }
  $5 = scalbn(1.0, $17);
  if (($6 | 0) >= 0) {
   $2 = $6;
   while (1) {
    HEAPF64[($2 << 3) + $8 >> 3] = $5 * +HEAP32[($8 + 480 | 0) + ($2 << 2) >> 2];
    $5 = $5 * 5.9604644775390625e-08;
    $11 = 0;
    $3 = ($2 | 0) > 0;
    $2 = $2 + -1 | 0;
    if ($3) {
     continue
    }
    break;
   };
   $7 = $6;
   while (1) {
    $0 = $20 >>> 0 < $11 >>> 0 ? $20 : $11;
    $12 = $6 - $7 | 0;
    $2 = 0;
    $5 = 0.0;
    while (1) {
     $5 = $5 + HEAPF64[($2 << 3) + 18208 >> 3] * HEAPF64[($2 + $7 << 3) + $8 >> 3];
     $3 = ($0 | 0) != ($2 | 0);
     $2 = $2 + 1 | 0;
     if ($3) {
      continue
     }
     break;
    };
    HEAPF64[($8 + 160 | 0) + ($12 << 3) >> 3] = $5;
    $7 = $7 + -1 | 0;
    $2 = ($6 | 0) != ($11 | 0);
    $11 = $11 + 1 | 0;
    if ($2) {
     continue
    }
    break;
   };
  }
  label$52 : {
   if ($4 >>> 0 > 3) {
    break label$52
   }
   label$53 : {
    label$54 : {
     switch ($4 - 1 | 0) {
     case 2:
      label$57 : {
       if (($6 | 0) < 1) {
        break label$57
       }
       $0 = ($8 + 160 | 0) + ($6 << 3) | 0;
       $5 = HEAPF64[$0 >> 3];
       $2 = $6;
       while (1) {
        $3 = $2 + -1 | 0;
        $7 = ($8 + 160 | 0) + ($3 << 3) | 0;
        $9 = HEAPF64[$7 >> 3];
        $15 = $9;
        $9 = $9 + $5;
        HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3] = $5 + ($15 - $9);
        HEAPF64[$7 >> 3] = $9;
        $7 = ($2 | 0) > 1;
        $5 = $9;
        $2 = $3;
        if ($7) {
         continue
        }
        break;
       };
       if (($6 | 0) < 2) {
        break label$57
       }
       $5 = HEAPF64[$0 >> 3];
       $2 = $6;
       while (1) {
        $3 = $2 + -1 | 0;
        $7 = ($8 + 160 | 0) + ($3 << 3) | 0;
        $9 = HEAPF64[$7 >> 3];
        $15 = $9;
        $9 = $9 + $5;
        HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3] = $5 + ($15 - $9);
        HEAPF64[$7 >> 3] = $9;
        $7 = ($2 | 0) > 2;
        $5 = $9;
        $2 = $3;
        if ($7) {
         continue
        }
        break;
       };
       while (1) {
        $21 = $21 + HEAPF64[($8 + 160 | 0) + ($6 << 3) >> 3];
        $2 = ($6 | 0) > 2;
        $6 = $6 + -1 | 0;
        if ($2) {
         continue
        }
        break;
       };
      }
      $5 = HEAPF64[$8 + 160 >> 3];
      if ($10) {
       break label$53
      }
      HEAPF64[$1 >> 3] = $5;
      $0 = HEAP32[$8 + 172 >> 2];
      $2 = HEAP32[$8 + 168 >> 2];
      HEAPF64[$1 + 16 >> 3] = $21;
      HEAP32[$1 + 8 >> 2] = $2;
      HEAP32[$1 + 12 >> 2] = $0;
      break label$52;
     default:
      $5 = 0.0;
      if (($6 | 0) >= 0) {
       while (1) {
        $5 = $5 + HEAPF64[($8 + 160 | 0) + ($6 << 3) >> 3];
        $2 = ($6 | 0) > 0;
        $6 = $6 + -1 | 0;
        if ($2) {
         continue
        }
        break;
       }
      }
      HEAPF64[$1 >> 3] = $10 ? -$5 : $5;
      break label$52;
     case 0:
     case 1:
      break label$54;
     };
    }
    $5 = 0.0;
    if (($6 | 0) >= 0) {
     $2 = $6;
     while (1) {
      $5 = $5 + HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3];
      $3 = ($2 | 0) > 0;
      $2 = $2 + -1 | 0;
      if ($3) {
       continue
      }
      break;
     };
    }
    HEAPF64[$1 >> 3] = $10 ? -$5 : $5;
    $5 = HEAPF64[$8 + 160 >> 3] - $5;
    $2 = 1;
    if (($6 | 0) >= 1) {
     while (1) {
      $5 = $5 + HEAPF64[($8 + 160 | 0) + ($2 << 3) >> 3];
      $3 = ($2 | 0) != ($6 | 0);
      $2 = $2 + 1 | 0;
      if ($3) {
       continue
      }
      break;
     }
    }
    HEAPF64[$1 + 8 >> 3] = $10 ? -$5 : $5;
    break label$52;
   }
   HEAPF64[$1 >> 3] = -$5;
   $5 = HEAPF64[$8 + 168 >> 3];
   HEAPF64[$1 + 16 >> 3] = -$21;
   HEAPF64[$1 + 8 >> 3] = -$5;
  }
  global$0 = $8 + 560 | 0;
  return $16 & 7;
 }
 
 function __rem_pio2($0, $1) {
  var $2 = 0.0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0.0, $9 = 0, $10 = 0, $11 = 0.0, $12 = 0.0;
  $7 = global$0 - 48 | 0;
  global$0 = $7;
  label$1 : {
   label$2 : {
    wasm2js_scratch_store_f64(+$0);
    $5 = wasm2js_scratch_load_i32(1) | 0;
    $6 = wasm2js_scratch_load_i32(0) | 0;
    $4 = $5;
    $3 = $5 & 2147483647;
    label$3 : {
     if ($3 >>> 0 <= 1074752122) {
      if (($4 & 1048575) == 598523) {
       break label$3
      }
      if ($3 >>> 0 <= 1073928572) {
       if (($5 | 0) > 0 ? 1 : ($5 | 0) >= 0 ? ($6 >>> 0 < 0 ? 0 : 1) : 0) {
        $0 = $0 + -1.5707963267341256;
        $2 = $0 + -6.077100506506192e-11;
        HEAPF64[$1 >> 3] = $2;
        HEAPF64[$1 + 8 >> 3] = $0 - $2 + -6.077100506506192e-11;
        $3 = 1;
        break label$1;
       }
       $0 = $0 + 1.5707963267341256;
       $2 = $0 + 6.077100506506192e-11;
       HEAPF64[$1 >> 3] = $2;
       HEAPF64[$1 + 8 >> 3] = $0 - $2 + 6.077100506506192e-11;
       $3 = -1;
       break label$1;
      }
      if (($5 | 0) > 0 ? 1 : ($5 | 0) >= 0 ? ($6 >>> 0 < 0 ? 0 : 1) : 0) {
       $0 = $0 + -3.1415926534682512;
       $2 = $0 + -1.2154201013012384e-10;
       HEAPF64[$1 >> 3] = $2;
       HEAPF64[$1 + 8 >> 3] = $0 - $2 + -1.2154201013012384e-10;
       $3 = 2;
       break label$1;
      }
      $0 = $0 + 3.1415926534682512;
      $2 = $0 + 1.2154201013012384e-10;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + 1.2154201013012384e-10;
      $3 = -2;
      break label$1;
     }
     if ($3 >>> 0 <= 1075594811) {
      if ($3 >>> 0 <= 1075183036) {
       if (($3 | 0) == 1074977148) {
        break label$3
       }
       if (($5 | 0) > 0 ? 1 : ($5 | 0) >= 0 ? ($6 >>> 0 < 0 ? 0 : 1) : 0) {
        $0 = $0 + -4.712388980202377;
        $2 = $0 + -1.8231301519518578e-10;
        HEAPF64[$1 >> 3] = $2;
        HEAPF64[$1 + 8 >> 3] = $0 - $2 + -1.8231301519518578e-10;
        $3 = 3;
        break label$1;
       }
       $0 = $0 + 4.712388980202377;
       $2 = $0 + 1.8231301519518578e-10;
       HEAPF64[$1 >> 3] = $2;
       HEAPF64[$1 + 8 >> 3] = $0 - $2 + 1.8231301519518578e-10;
       $3 = -3;
       break label$1;
      }
      if (($3 | 0) == 1075388923) {
       break label$3
      }
      if (($5 | 0) > 0 ? 1 : ($5 | 0) >= 0 ? ($6 >>> 0 < 0 ? 0 : 1) : 0) {
       $0 = $0 + -6.2831853069365025;
       $2 = $0 + -2.430840202602477e-10;
       HEAPF64[$1 >> 3] = $2;
       HEAPF64[$1 + 8 >> 3] = $0 - $2 + -2.430840202602477e-10;
       $3 = 4;
       break label$1;
      }
      $0 = $0 + 6.2831853069365025;
      $2 = $0 + 2.430840202602477e-10;
      HEAPF64[$1 >> 3] = $2;
      HEAPF64[$1 + 8 >> 3] = $0 - $2 + 2.430840202602477e-10;
      $3 = -4;
      break label$1;
     }
     if ($3 >>> 0 > 1094263290) {
      break label$2
     }
    }
    $2 = $0 * .6366197723675814 + 6755399441055744.0 + -6755399441055744.0;
    $8 = $0 + $2 * -1.5707963267341256;
    $11 = $2 * 6.077100506506192e-11;
    $0 = $8 - $11;
    HEAPF64[$1 >> 3] = $0;
    $9 = $3 >>> 20 | 0;
    wasm2js_scratch_store_f64(+$0);
    $10 = wasm2js_scratch_load_i32(1) | 0;
    wasm2js_scratch_load_i32(0) | 0;
    $4 = ($9 - ($10 >>> 20 & 2047) | 0) < 17;
    if (Math_abs($2) < 2147483648.0) {
     $3 = ~~$2
    } else {
     $3 = -2147483648
    }
    label$14 : {
     if ($4) {
      break label$14
     }
     $0 = $2 * 6.077100506303966e-11;
     $12 = $8 - $0;
     $11 = $2 * 2.0222662487959506e-21 - ($8 - $12 - $0);
     $0 = $12 - $11;
     HEAPF64[$1 >> 3] = $0;
     wasm2js_scratch_store_f64(+$0);
     $4 = wasm2js_scratch_load_i32(1) | 0;
     wasm2js_scratch_load_i32(0) | 0;
     if (($9 - ($4 >>> 20 & 2047) | 0) < 50) {
      $8 = $12;
      break label$14;
     }
     $0 = $2 * 2.0222662487111665e-21;
     $8 = $12 - $0;
     $11 = $2 * 8.4784276603689e-32 - ($12 - $8 - $0);
     $0 = $8 - $11;
     HEAPF64[$1 >> 3] = $0;
    }
    HEAPF64[$1 + 8 >> 3] = $8 - $0 - $11;
    break label$1;
   }
   if ($3 >>> 0 >= 2146435072) {
    $0 = $0 - $0;
    HEAPF64[$1 >> 3] = $0;
    HEAPF64[$1 + 8 >> 3] = $0;
    $3 = 0;
    break label$1;
   }
   $10 = $5 & 1048575;
   $4 = $10 | 1096810496;
   wasm2js_scratch_store_i32(0, $6 | 0);
   wasm2js_scratch_store_i32(1, $4 | 0);
   $0 = +wasm2js_scratch_load_f64();
   $4 = 0;
   while (1) {
    $9 = $4;
    $10 = ($7 + 16 | 0) + ($4 << 3) | 0;
    if (Math_abs($0) < 2147483648.0) {
     $4 = ~~$0
    } else {
     $4 = -2147483648
    }
    $2 = +($4 | 0);
    HEAPF64[$10 >> 3] = $2;
    $0 = ($0 - $2) * 16777216.0;
    $4 = 1;
    if (!$9) {
     continue
    }
    break;
   };
   HEAPF64[$7 + 32 >> 3] = $0;
   label$20 : {
    if ($0 != 0.0) {
     $4 = 2;
     break label$20;
    }
    $9 = 1;
    while (1) {
     $4 = $9;
     $9 = $4 + -1 | 0;
     if (HEAPF64[($7 + 16 | 0) + ($4 << 3) >> 3] == 0.0) {
      continue
     }
     break;
    };
   }
   $3 = __rem_pio2_large($7 + 16 | 0, $7, ($3 >>> 20 | 0) + -1046 | 0, $4 + 1 | 0, 1);
   $0 = HEAPF64[$7 >> 3];
   if (($5 | 0) < -1 ? 1 : ($5 | 0) <= -1 ? ($6 >>> 0 > 4294967295 ? 0 : 1) : 0) {
    HEAPF64[$1 >> 3] = -$0;
    HEAPF64[$1 + 8 >> 3] = -HEAPF64[$7 + 8 >> 3];
    $3 = 0 - $3 | 0;
    break label$1;
   }
   HEAPF64[$1 >> 3] = $0;
   $4 = HEAP32[$7 + 12 >> 2];
   $10 = HEAP32[$7 + 8 >> 2];
   HEAP32[$1 + 8 >> 2] = $10;
   HEAP32[$1 + 12 >> 2] = $4;
  }
  global$0 = $7 + 48 | 0;
  return $3;
 }
 
 function __sin($0, $1, $2) {
  var $3 = 0.0, $4 = 0.0, $5 = 0.0;
  $3 = $0 * $0;
  $4 = $3 * $3;
  $5 = $3 * $4 * ($3 * 1.58969099521155e-10 + -2.5050760253406863e-08) + ($3 * ($3 * 2.7557313707070068e-06 + -1.984126982985795e-04) + .00833333333332249);
  $4 = $3 * $0;
  if (!$2) {
   return $4 * ($3 * $5 + -.16666666666666632) + $0
  }
  return $0 - ($3 * ($1 * .5 - $4 * $5) - $1 + $4 * .16666666666666632);
 }
 
 function cos($0) {
  var $1 = 0, $2 = 0.0, $3 = 0;
  $1 = global$0 - 16 | 0;
  global$0 = $1;
  wasm2js_scratch_store_f64(+$0);
  $3 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  $3 = $3 & 2147483647;
  label$1 : {
   if ($3 >>> 0 <= 1072243195) {
    $2 = 1.0;
    if ($3 >>> 0 < 1044816030) {
     break label$1
    }
    $2 = __cos($0, 0.0);
    break label$1;
   }
   $2 = $0 - $0;
   if ($3 >>> 0 >= 2146435072) {
    break label$1
   }
   $3 = __rem_pio2($0, $1) & 3;
   if ($3 >>> 0 <= 2) {
    label$4 : {
     switch ($3 - 1 | 0) {
     default:
      $2 = __cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
      break label$1;
     case 0:
      $2 = -__sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
      break label$1;
     case 1:
      break label$4;
     };
    }
    $2 = -__cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
    break label$1;
   }
   $2 = __sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
  }
  global$0 = $1 + 16 | 0;
  $0 = $2;
  return $0;
 }
 
 function sin($0) {
  var $1 = 0, $2 = 0;
  $1 = global$0 - 16 | 0;
  global$0 = $1;
  wasm2js_scratch_store_f64(+$0);
  $2 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  $2 = $2 & 2147483647;
  label$1 : {
   if ($2 >>> 0 <= 1072243195) {
    if ($2 >>> 0 < 1045430272) {
     break label$1
    }
    $0 = __sin($0, 0.0, 0);
    break label$1;
   }
   if ($2 >>> 0 >= 2146435072) {
    $0 = $0 - $0;
    break label$1;
   }
   $2 = __rem_pio2($0, $1) & 3;
   if ($2 >>> 0 <= 2) {
    label$5 : {
     switch ($2 - 1 | 0) {
     default:
      $0 = __sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
      break label$1;
     case 0:
      $0 = __cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
      break label$1;
     case 1:
      break label$5;
     };
    }
    $0 = -__sin(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3], 1);
    break label$1;
   }
   $0 = -__cos(HEAPF64[$1 >> 3], HEAPF64[$1 + 8 >> 3]);
  }
  global$0 = $1 + 16 | 0;
  return $0;
 }
 
 function __tan($0, $1, $2) {
  var $3 = 0.0, $4 = 0, $5 = 0, $6 = 0.0, $7 = 0, $8 = 0.0, $9 = 0.0, $10 = 0, $11 = 0;
  wasm2js_scratch_store_f64(+$0);
  $4 = wasm2js_scratch_load_i32(1) | 0;
  $10 = wasm2js_scratch_load_i32(0) | 0;
  $11 = $4;
  $7 = $4 & 2147483640;
  $4 = 0;
  $7 = ($7 | 0) == 1072010279 & $4 >>> 0 < 1 | $7 >>> 0 < 1072010279;
  if (!$7) {
   $5 = $10;
   $4 = $11;
   $5 = ($4 | 0) < 0 ? 1 : ($4 | 0) <= 0 ? ($5 >>> 0 >= 0 ? 0 : 1) : 0;
   $0 = .7853981633974483 - ($5 ? -$0 : $0) + (3.061616997868383e-17 - ($5 ? -$1 : $1));
   $5 = $4;
   $5 = $5 >>> 31 | 0;
   $1 = 0.0;
  }
  $6 = $0 * $0;
  $8 = $0 * $6;
  $9 = $8 * .3333333333333341;
  $3 = $6 * $6;
  $6 = $9 + ($1 + $6 * ($1 + $8 * ($3 * ($3 * ($3 * ($3 * ($3 * -1.8558637485527546e-05 + 7.817944429395571e-05) + 5.880412408202641e-04) + 3.5920791075913124e-03) + .021869488294859542) + .13333333333320124 + $6 * ($3 * ($3 * ($3 * ($3 * ($3 * 2.590730518636337e-05 + 7.140724913826082e-05) + 2.464631348184699e-04) + 1.4562094543252903e-03) + .0088632398235993) + .05396825397622605))));
  $3 = $0 + $6;
  if (!$7) {
   $1 = +(1 - ($2 << 1) | 0);
   $3 = $0 + ($6 - $3 * $3 / ($3 + $1));
   $0 = $3 + $3;
   $3 = $1 - $0;
   return $5 ? -$3 : $3;
  }
  if ($2) {
   wasm2js_scratch_store_f64(+$3);
   $4 = wasm2js_scratch_load_i32(1) | 0;
   wasm2js_scratch_load_i32(0) | 0;
   wasm2js_scratch_store_i32(0, 0);
   wasm2js_scratch_store_i32(1, $4 | 0);
   $8 = +wasm2js_scratch_load_f64();
   $1 = -1.0 / $3;
   wasm2js_scratch_store_f64(+$1);
   $4 = wasm2js_scratch_load_i32(1) | 0;
   wasm2js_scratch_load_i32(0) | 0;
   $5 = $4;
   wasm2js_scratch_store_i32(0, 0);
   wasm2js_scratch_store_i32(1, $5 | 0);
   $3 = +wasm2js_scratch_load_f64();
   $9 = $8 * $3 + 1.0;
   $0 = $1 * ($9 + ($6 - ($8 - $0)) * $3) + $3;
  } else {
   $0 = $3
  }
  return $0;
 }
 
 function tan($0) {
  var $1 = 0, $2 = 0;
  $2 = global$0 - 16 | 0;
  global$0 = $2;
  wasm2js_scratch_store_f64(+$0);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  $1 = $1 & 2147483647;
  label$1 : {
   if ($1 >>> 0 <= 1072243195) {
    if ($1 >>> 0 < 1044381696) {
     break label$1
    }
    $0 = __tan($0, 0.0, 0);
    break label$1;
   }
   if ($1 >>> 0 >= 2146435072) {
    $0 = $0 - $0;
    break label$1;
   }
   $1 = __rem_pio2($0, $2);
   $0 = __tan(HEAPF64[$2 >> 3], HEAPF64[$2 + 8 >> 3], $1 & 1);
  }
  global$0 = $2 + 16 | 0;
  return $0;
 }
 
 function sqrt($0) {
  return Math_sqrt($0);
 }
 
 function acos($0) {
  var $1 = 0.0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0, $7 = 0.0;
  wasm2js_scratch_store_f64(+$0);
  $2 = wasm2js_scratch_load_i32(1) | 0;
  $4 = wasm2js_scratch_load_i32(0) | 0;
  $6 = $2;
  $5 = $2 & 2147483647;
  if ($5 >>> 0 >= 1072693248) {
   if (!($5 + -1072693248 | $4)) {
    $2 = $4;
    return (($6 | 0) < 0 ? 1 : ($6 | 0) <= 0 ? ($2 >>> 0 >= 0 ? 0 : 1) : 0) ? 3.141592653589793 : 0.0;
   }
   return 0.0 / ($0 - $0);
  }
  label$3 : {
   if ($5 >>> 0 <= 1071644671) {
    $1 = 1.5707963267948966;
    if ($5 >>> 0 < 1012924417) {
     break label$3
    }
    $1 = $0 * $0;
    $3 = $1 * 3.479331075960212e-05 + 7.915349942898145e-04;
    return 6.123233995736766e-17 - $1 * ($1 * ($1 * ($1 * ($1 * $3 + -.04005553450067941) + .20121253213486293) + -.3255658186224009) + .16666666666666666) / ($1 * ($1 * ($1 * ($1 * .07703815055590194 + -.6882839716054533) + 2.0209457602335057) + -2.403394911734414) + 1.0) * $0 - $0 + 1.5707963267948966;
   }
   if (($2 | 0) < -1 ? 1 : ($6 | 0) <= -1 ? ($4 >>> 0 > 4294967295 ? 0 : 1) : 0) {
    $0 = ($0 + 1.0) * .5;
    $1 = sqrt($0);
    $0 = 1.5707963267948966 - ($1 + ($1 * ($0 * ($0 * ($0 * ($0 * ($0 * ($0 * 3.479331075960212e-05 + 7.915349942898145e-04) + -.04005553450067941) + .20121253213486293) + -.3255658186224009) + .16666666666666666) / ($0 * ($0 * ($0 * ($0 * .07703815055590194 + -.6882839716054533) + 2.0209457602335057) + -2.403394911734414) + 1.0)) + -6.123233995736766e-17));
    return $0 + $0;
   }
   $0 = (1.0 - $0) * .5;
   $1 = $0 * 3.479331075960212e-05 + 7.915349942898145e-04;
   $1 = $0 * ($0 * ($0 * ($0 * ($0 * $1 + -.04005553450067941) + .20121253213486293) + -.3255658186224009) + .16666666666666666) / ($0 * ($0 * ($0 * ($0 * .07703815055590194 + -.6882839716054533) + 2.0209457602335057) + -2.403394911734414) + 1.0);
   $3 = sqrt($0);
   $7 = $1 * $3;
   wasm2js_scratch_store_f64(+$3);
   $2 = wasm2js_scratch_load_i32(1) | 0;
   wasm2js_scratch_load_i32(0) | 0;
   wasm2js_scratch_store_i32(0, 0);
   wasm2js_scratch_store_i32(1, $2 | 0);
   $1 = +wasm2js_scratch_load_f64();
   $0 = $7 + ($0 - $1 * $1) / ($3 + $1) + $1;
   $1 = $0 + $0;
  }
  return $1;
 }
 
 function asin($0) {
  var $1 = 0.0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0.0;
  label$1 : {
   label$2 : {
    wasm2js_scratch_store_f64(+$0);
    $4 = wasm2js_scratch_load_i32(1) | 0;
    $5 = wasm2js_scratch_load_i32(0) | 0;
    $2 = $4 & 2147483647;
    if ($2 >>> 0 >= 1072693248) {
     if ($2 + -1072693248 | $5) {
      break label$2
     }
     return $0 * 1.5707963267948966 + 7.52316384526264e-37;
    }
    if ($2 >>> 0 <= 1071644671) {
     if ($2 + -1048576 >>> 0 < 1044381696) {
      break label$1
     }
     $1 = $0 * $0;
     $3 = $1 * 3.479331075960212e-05 + 7.915349942898145e-04;
     return $1 * ($1 * ($1 * ($1 * ($1 * $3 + -.04005553450067941) + .20121253213486293) + -.3255658186224009) + .16666666666666666) / ($1 * ($1 * ($1 * ($1 * .07703815055590194 + -.6882839716054533) + 2.0209457602335057) + -2.403394911734414) + 1.0) * $0 + $0;
    }
    $0 = (1.0 - fabs($0)) * .5;
    $1 = $0 * 3.479331075960212e-05 + 7.915349942898145e-04;
    $6 = $0 * ($0 * ($0 * ($0 * ($0 * $1 + -.04005553450067941) + .20121253213486293) + -.3255658186224009) + .16666666666666666) / ($0 * ($0 * ($0 * ($0 * .07703815055590194 + -.6882839716054533) + 2.0209457602335057) + -2.403394911734414) + 1.0);
    $1 = sqrt($0);
    label$5 : {
     if ($2 >>> 0 >= 1072640819) {
      $0 = $1 + $1 * $6;
      $0 = 1.5707963267948966 - ($0 + $0 + -6.123233995736766e-17);
      break label$5;
     }
     wasm2js_scratch_store_f64(+$1);
     $2 = wasm2js_scratch_load_i32(1) | 0;
     wasm2js_scratch_load_i32(0) | 0;
     wasm2js_scratch_store_i32(0, 0);
     wasm2js_scratch_store_i32(1, $2 | 0);
     $3 = +wasm2js_scratch_load_f64();
     $0 = ($0 - $3 * $3) / ($1 + $3);
     $0 = .7853981633974483 - ($3 + $3) - (($1 + $1) * $6 - (6.123233995736766e-17 - ($0 + $0))) + .7853981633974483;
    }
    return (($4 | 0) < 0 ? 1 : ($4 | 0) <= 0 ? ($5 >>> 0 >= 0 ? 0 : 1) : 0) ? -$0 : $0;
   }
   $0 = 0.0 / ($0 - $0);
  }
  return $0;
 }
 
 function atan($0) {
  var $1 = 0, $2 = 0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
  wasm2js_scratch_store_f64(+$0);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  $6 = wasm2js_scratch_load_i32(0) | 0;
  $7 = $1;
  $1 = $1 & 2147483647;
  if ($1 >>> 0 < 1141899264) {
   label$2 : {
    label$3 : {
     if ($1 >>> 0 <= 1071382527) {
      $2 = -1;
      if ($1 >>> 0 >= 1044381696) {
       break label$3
      }
      break label$2;
     }
     $0 = fabs($0);
     if ($1 >>> 0 <= 1072889855) {
      if ($1 >>> 0 <= 1072037887) {
       $0 = ($0 + $0 + -1.0) / ($0 + 2.0);
       $2 = 0;
       break label$3;
      }
      $0 = ($0 + -1.0) / ($0 + 1.0);
      $2 = 1;
      break label$3;
     }
     if ($1 >>> 0 <= 1073971199) {
      $0 = ($0 + -1.5) / ($0 * 1.5 + 1.0);
      $2 = 2;
      break label$3;
     }
     $0 = -1.0 / $0;
     $2 = 3;
    }
    $5 = $0 * $0;
    $3 = $5 * $5;
    $4 = $3 * -.036531572744216916 + -.058335701337905735;
    $4 = $3 * ($3 * ($3 * ($3 * $4 + -.0769187620504483) + -.11111110405462356) + -.19999999999876483);
    $3 = $5 * ($3 * ($3 * ($3 * ($3 * ($3 * .016285820115365782 + .049768779946159324) + .06661073137387531) + .09090887133436507) + .14285714272503466) + .3333333333333293);
    $1 = $2;
    if (($1 | 0) <= -1) {
     return $0 - $0 * ($4 + $3)
    }
    $1 = $1 << 3;
    $0 = HEAPF64[$1 + 18272 >> 3] - ($0 * ($4 + $3) - HEAPF64[$1 + 18304 >> 3] - $0);
    $1 = $6;
    $2 = $7;
    $0 = (($2 | 0) < 0 ? 1 : ($2 | 0) <= 0 ? ($1 >>> 0 >= 0 ? 0 : 1) : 0) ? -$0 : $0;
   }
   return $0;
  }
  wasm2js_scratch_store_f64(1.5707963267948966);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  $8 = wasm2js_scratch_load_i32(0) | 0;
  $2 = $1 & 2147483647;
  $9 = $2;
  wasm2js_scratch_store_f64(+$0);
  $2 = wasm2js_scratch_load_i32(1) | 0;
  wasm2js_scratch_load_i32(0) | 0;
  $1 = $2 & -2147483648;
  $1 = $9 | $1;
  $2 = $8;
  wasm2js_scratch_store_i32(0, $10 | $2);
  wasm2js_scratch_store_i32(1, $1 | 0);
  $3 = +wasm2js_scratch_load_f64();
  $1 = $7;
  $2 = $1 & 2147483647;
  $1 = $6;
  return ($2 | 0) == 2146435072 & $1 >>> 0 > 0 | $2 >>> 0 > 2146435072 ? $0 : $3;
 }
 
 function atan2($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0.0, $10 = 0, $11 = 0, $12 = 0;
  wasm2js_scratch_store_f64(+$1);
  $2 = wasm2js_scratch_load_i32(1) | 0;
  $8 = wasm2js_scratch_load_i32(0) | 0;
  $5 = $2;
  label$1 : {
   $3 = $2 & 2147483647;
   $4 = $8;
   $2 = $4;
   if (($3 | 0) == 2146435072 & $2 >>> 0 <= 0 | $3 >>> 0 < 2146435072) {
    wasm2js_scratch_store_f64(+$0);
    $2 = wasm2js_scratch_load_i32(1) | 0;
    $10 = wasm2js_scratch_load_i32(0) | 0;
    $6 = $2;
    $3 = $2 & 2147483647;
    $2 = $10;
    if (($3 | 0) == 2146435072 & $2 >>> 0 < 1 | $3 >>> 0 < 2146435072) {
     break label$1
    }
   }
   return $0 + $1;
  }
  $4 = $8;
  $8 = $4;
  $2 = $5;
  $7 = $2;
  if (!($4 | $2 + -1072693248)) {
   return atan($0)
  }
  $3 = $5;
  $3 = $3 >>> 30 & 2;
  $4 = $6;
  $5 = $3 | $4 >>> 31;
  label$4 : {
   label$5 : {
    $4 = $10;
    $2 = $6;
    $6 = $2 & 2147483647;
    if (!($6 | $4)) {
     label$7 : {
      switch ($5 - 2 | 0) {
      case 0:
       break label$5;
      case 1:
       break label$7;
      default:
       break label$4;
      };
     }
     return -3.141592653589793;
    }
    $7 = $7 & 2147483647;
    if (!($8 | $7)) {
     wasm2js_scratch_store_f64(1.5707963267948966);
     $3 = wasm2js_scratch_load_i32(1) | 0;
     $2 = wasm2js_scratch_load_i32(0) | 0;
     $5 = $2;
     $4 = $3 & 2147483647;
     $6 = $4;
     wasm2js_scratch_store_f64(+$0);
     $4 = wasm2js_scratch_load_i32(1) | 0;
     wasm2js_scratch_load_i32(0) | 0;
     $2 = $4 & -2147483648;
     $3 = $2;
     $2 = $6;
     $3 = $2 | $3;
     $4 = $5;
     wasm2js_scratch_store_i32(0, $11 | $4);
     wasm2js_scratch_store_i32(1, $3 | 0);
     return +wasm2js_scratch_load_f64();
    }
    label$9 : {
     if (($7 | 0) == 2146435072) {
      if (($6 | 0) != 2146435072) {
       break label$9
      }
      return HEAPF64[($5 << 3) + 18336 >> 3];
     }
     if (!($7 + 67108864 >>> 0 >= $6 >>> 0 ? ($6 | 0) != 2146435072 : 0)) {
      wasm2js_scratch_store_f64(1.5707963267948966);
      $3 = wasm2js_scratch_load_i32(1) | 0;
      $2 = wasm2js_scratch_load_i32(0) | 0;
      $5 = $2;
      $4 = $3 & 2147483647;
      $6 = $4;
      wasm2js_scratch_store_f64(+$0);
      $4 = wasm2js_scratch_load_i32(1) | 0;
      wasm2js_scratch_load_i32(0) | 0;
      $2 = $4 & -2147483648;
      $3 = $2;
      $2 = $6;
      $3 = $2 | $3;
      $4 = $5;
      wasm2js_scratch_store_i32(0, $12 | $4);
      wasm2js_scratch_store_i32(1, $3 | 0);
      return +wasm2js_scratch_load_f64();
     }
     label$12 : {
      if ($3) {
       $9 = 0.0;
       if ($6 + 67108864 >>> 0 < $7 >>> 0) {
        break label$12
       }
      }
      $9 = atan(fabs($0 / $1));
     }
     $1 = $9;
     if ($5 >>> 0 <= 2) {
      $0 = $1;
      label$15 : {
       switch ($5 - 1 | 0) {
       case 0:
        return -$1;
       case 1:
        break label$15;
       default:
        break label$4;
       };
      }
      return 3.141592653589793 - ($1 + -1.2246467991473532e-16);
     }
     return $1 + -1.2246467991473532e-16 + -3.141592653589793;
    }
    return HEAPF64[($5 << 3) + 18368 >> 3];
   }
   $0 = 3.141592653589793;
  }
  return $0;
 }
 
 function exp($0) {
  var $1 = 0.0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0, $7 = 0.0;
  wasm2js_scratch_store_f64(+$0);
  $2 = wasm2js_scratch_load_i32(1) | 0;
  $5 = wasm2js_scratch_load_i32(0) | 0;
  $6 = $2;
  $4 = $2 >>> 31 | 0;
  label$1 : {
   label$2 : {
    label$3 : {
     label$4 : {
      $3 = $0;
      label$5 : {
       label$6 : {
        $2 = $6 & 2147483647;
        label$7 : {
         if ($2 >>> 0 >= 1082532651) {
          $2 = $6 & 2147483647;
          if (($2 | 0) == 2146435072 & $5 >>> 0 > 0 | $2 >>> 0 > 2146435072) {
           return $0
          }
          if (!!($0 > 709.782712893384)) {
           return $0 * 8988465674311579538646525.0e283
          }
          if (!($0 < -708.3964185322641)) {
           break label$7
          }
          if (!($0 < -745.1332191019411)) {
           break label$7
          }
          break label$2;
         }
         if ($2 >>> 0 < 1071001155) {
          break label$4
         }
         if ($2 >>> 0 < 1072734898) {
          break label$6
         }
        }
        $1 = $0 * 1.4426950408889634 + HEAPF64[($4 << 3) + 18400 >> 3];
        if (Math_abs($1) < 2147483648.0) {
         $2 = ~~$1;
         break label$5;
        }
        $2 = -2147483648;
        break label$5;
       }
       $2 = ($4 ^ 1) - $4 | 0;
      }
      $1 = +($2 | 0);
      $0 = $3 + $1 * -.6931471803691238;
      $7 = $1 * 1.9082149292705877e-10;
      $3 = $0 - $7;
      break label$3;
     }
     if ($2 >>> 0 <= 1043333120) {
      break label$1
     }
     $2 = 0;
     $3 = $0;
    }
    $1 = $3 * $3;
    $1 = $3 - $1 * ($1 * ($1 * ($1 * ($1 * 4.1381367970572385e-08 + -1.6533902205465252e-06) + 6.613756321437934e-05) + -2.7777777777015593e-03) + .16666666666666602);
    $1 = $0 + ($3 * $1 / (2.0 - $1) - $7) + 1.0;
    if (!$2) {
     break label$2
    }
    $1 = scalbn($1, $2);
   }
   return $1;
  }
  return $0 + 1.0;
 }
 
 function log($0) {
  var $1 = 0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0, $7 = 0.0, $8 = 0.0, $9 = 0.0, $10 = 0.0, $11 = 0.0;
  wasm2js_scratch_store_f64(+$0);
  $1 = wasm2js_scratch_load_i32(1) | 0;
  $4 = wasm2js_scratch_load_i32(0) | 0;
  label$1 : {
   label$2 : {
    label$3 : {
     label$4 : {
      if (($1 | 0) > 0 ? 1 : ($1 | 0) >= 0 ? ($4 >>> 0 < 0 ? 0 : 1) : 0) {
       $5 = $1;
       if ($1 >>> 0 > 1048575) {
        break label$4
       }
      }
      $2 = $1 & 2147483647;
      if (!($2 | $4)) {
       return -1.0 / ($0 * $0)
      }
      if (($1 | 0) > -1 ? 1 : ($1 | 0) >= -1 ? ($4 >>> 0 <= 4294967295 ? 0 : 1) : 0) {
       break label$3
      }
      return ($0 - $0) / 0.0;
     }
     if ($5 >>> 0 > 2146435071) {
      break label$1
     }
     $2 = 1072693248;
     $6 = -1023;
     if (($5 | 0) != 1072693248) {
      $2 = $5;
      break label$2;
     }
     if ($4) {
      break label$2
     }
     return 0.0;
    }
    wasm2js_scratch_store_f64(+($0 * 18014398509481984.0));
    $1 = wasm2js_scratch_load_i32(1) | 0;
    $4 = wasm2js_scratch_load_i32(0) | 0;
    $2 = $1;
    $6 = -1077;
   }
   $5 = $2 + 614242 | 0;
   $3 = +(($5 >>> 20 | 0) + $6 | 0);
   $8 = $3 * .6931471803691238;
   $2 = ($5 & 1048575) + 1072079006 | 0;
   $1 = 0;
   $2 = $1 | $2;
   wasm2js_scratch_store_i32(0, $4 | 0);
   wasm2js_scratch_store_i32(1, $2 | 0);
   $0 = +wasm2js_scratch_load_f64() + -1.0;
   $9 = $0;
   $10 = $3 * 1.9082149292705877e-10;
   $3 = $0 / ($0 + 2.0);
   $11 = $3;
   $7 = $0 * ($0 * .5);
   $3 = $3 * $3;
   $0 = $3 * $3;
   $0 = $8 + ($9 + ($10 + $11 * ($7 + ($0 * ($0 * ($0 * .15313837699209373 + .22222198432149784) + .3999999999940942) + $3 * ($0 * ($0 * ($0 * .14798198605116586 + .1818357216161805) + .2857142874366239) + .6666666666666735))) - $7));
  }
  return $0;
 }
 
 function pow($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0.0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0, $14 = 0.0, $15 = 0, $16 = 0.0, $17 = 0, $18 = 0, $19 = 0.0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0;
  $4 = 1.0;
  wasm2js_scratch_store_f64(+$1);
  $3 = wasm2js_scratch_load_i32(1) | 0;
  $13 = wasm2js_scratch_load_i32(0) | 0;
  $18 = $3;
  $2 = $3;
  folding_inner1 : {
   folding_inner0 : {
    $9 = $2;
    $5 = $2 & 2147483647;
    $6 = $13;
    label$1 : {
     if (!($5 | $6)) {
      break label$1
     }
     wasm2js_scratch_store_f64(+$0);
     $2 = wasm2js_scratch_load_i32(1) | 0;
     $3 = wasm2js_scratch_load_i32(0) | 0;
     $7 = $2;
     $17 = $3;
     if (($2 | 0) == 1072693248 ? !$3 : 0) {
      break label$1
     }
     label$2 : {
      $2 = $7 & 2147483647;
      if (!($2 >>> 0 > 2146435072 | ($2 | 0) == 2146435072 & ($17 | 0) != 0 | $5 >>> 0 > 2146435072)) {
       if (!$6 | ($5 | 0) != 2146435072) {
        break label$2
       }
      }
      return $0 + $1;
     }
     label$4 : {
      label$5 : {
       label$6 : {
        $3 = 0;
        label$7 : {
         if (($7 | 0) > -1) {
          break label$7
         }
         $3 = 2;
         if ($5 >>> 0 > 1128267775) {
          break label$7
         }
         $3 = 0;
         if ($5 >>> 0 < 1072693248) {
          break label$7
         }
         $15 = $5 >>> 20 | 0;
         if ($5 >>> 0 < 1094713344) {
          break label$6
         }
         $15 = 1075 - $15 | 0;
         $8 = $6 >>> $15 | 0;
         $3 = 0;
         if ($8 << $15 != ($6 | 0)) {
          break label$7
         }
         $3 = 2 - ($8 & 1) | 0;
        }
        $8 = $3;
        $3 = $8;
        if (!$6) {
         break label$5
        }
        break label$4;
       }
       if ($6) {
        break label$4
       }
       $6 = 1043 - $15 | 0;
       $15 = $5 >>> $6 | 0;
       $3 = 0;
       if ($15 << $6 != ($5 | 0)) {
        break label$5
       }
       $3 = 2 - ($15 & 1) | 0;
      }
      $8 = $3;
      if (($5 | 0) == 2146435072) {
       if (!($2 + -1072693248 | $17)) {
        break label$1
       }
       if ($2 >>> 0 >= 1072693248) {
        return ($9 | 0) > -1 ? $1 : 0.0
       }
       return ($9 | 0) > -1 ? 0.0 : -$1;
      }
      if (($5 | 0) == 1072693248) {
       if (($9 | 0) > -1) {
        return $0
       }
       return 1.0 / $0;
      }
      if (($9 | 0) == 1073741824) {
       return $0 * $0
      }
      if (($9 | 0) != 1071644672 | ($7 | 0) < 0) {
       break label$4
      }
      return sqrt($0);
     }
     $4 = fabs($0);
     if (!((($2 | 1073741824) != 2146435072 ? $2 : 0) | $17)) {
      $4 = ($9 | 0) < 0 ? 1.0 / $4 : $4;
      if (($7 | 0) > -1) {
       break label$1
      }
      if (!($2 + -1072693248 | $8)) {
       $1 = $4 - $4;
       return $1 / $1;
      }
      return ($8 | 0) == 1 ? -$4 : $4;
     }
     $16 = 1.0;
     if (!(($7 | 0) > -1 | $8 >>> 0 > 1)) {
      if ($8 - 1) {
       $1 = $0 - $0;
       return $1 / $1;
      }
      $16 = -1.0;
     }
     label$17 : {
      if ($5 >>> 0 >= 1105199105) {
       if ($5 >>> 0 >= 1139802113) {
        if ($2 >>> 0 <= 1072693247) {
         return ($9 | 0) < 0 ? infinity : 0.0
        }
        return ($9 | 0) > 0 ? infinity : 0.0;
       }
       if ($2 >>> 0 <= 1072693246) {
        return ($9 | 0) < 0 ? $16 * 1.e+300 * 1.e+300 : $16 * 1.0e-300 * 1.0e-300
       }
       if ($2 >>> 0 >= 1072693249) {
        return ($9 | 0) > 0 ? $16 * 1.e+300 * 1.e+300 : $16 * 1.0e-300 * 1.0e-300
       }
       $0 = $4 + -1.0;
       $4 = $0 * 1.4426950216293335;
       $11 = $0 * 1.9259629911266175e-08 + $0 * $0 * (.5 - $0 * ($0 * -.25 + .3333333333333333)) * -1.4426950408889634;
       wasm2js_scratch_store_f64(+($4 + $11));
       $8 = wasm2js_scratch_load_i32(1) | 0;
       wasm2js_scratch_load_i32(0) | 0;
       $3 = $8;
       wasm2js_scratch_store_i32(0, 0);
       wasm2js_scratch_store_i32(1, $3 | 0);
       $0 = +wasm2js_scratch_load_f64();
       $14 = $0 - $4;
       break label$17;
      }
      $0 = $4 * 9007199254740992.0;
      $5 = $2 >>> 0 < 1048576;
      $4 = $5 ? $0 : $4;
      wasm2js_scratch_store_f64(+$0);
      $3 = wasm2js_scratch_load_i32(1) | 0;
      wasm2js_scratch_load_i32(0) | 0;
      $9 = $5 ? $3 : $2;
      $6 = $9 & 1048575;
      $7 = $6 | 1072693248;
      $9 = ($9 >> 20) + ($5 ? -1076 : -1023) | 0;
      $5 = 0;
      label$23 : {
       if ($6 >>> 0 < 235663) {
        break label$23
       }
       if ($6 >>> 0 < 767610) {
        $5 = 1;
        break label$23;
       }
       $7 = $7 + -1048576 | 0;
       $9 = $9 + 1 | 0;
      }
      $6 = $5 << 3;
      $14 = HEAPF64[$6 + 18448 >> 3];
      wasm2js_scratch_store_f64(+$4);
      wasm2js_scratch_load_i32(1) | 0;
      $3 = wasm2js_scratch_load_i32(0) | 0;
      $17 = $3;
      $2 = $7;
      $8 = 0;
      $3 = $8;
      $2 = $3 | $2;
      $8 = $17;
      wasm2js_scratch_store_i32(0, $8 | 0);
      wasm2js_scratch_store_i32(1, $2 | 0);
      $10 = +wasm2js_scratch_load_f64();
      $11 = HEAPF64[$6 + 18416 >> 3];
      $12 = $10 - $11;
      $19 = 1.0 / ($11 + $10);
      $4 = $12 * $19;
      wasm2js_scratch_store_f64(+$4);
      $2 = wasm2js_scratch_load_i32(1) | 0;
      wasm2js_scratch_load_i32(0) | 0;
      wasm2js_scratch_store_i32(0, 0);
      wasm2js_scratch_store_i32(1, $2 | 0);
      $0 = +wasm2js_scratch_load_f64();
      $21 = $0;
      $20 = $0 * $0;
      $22 = $20 + 3.0;
      $23 = $4 + $0;
      $24 = $12;
      $2 = (($7 >> 1 | 536870912) + ($5 << 18) | 0) + 524288 | 0;
      wasm2js_scratch_store_i32(0, 0);
      wasm2js_scratch_store_i32(1, $2 | 0);
      $12 = +wasm2js_scratch_load_f64();
      $10 = $19 * ($24 - $0 * $12 - $0 * ($10 - ($12 - $11)));
      $0 = $4 * $4;
      $11 = $23 * $10 + $0 * $0 * ($0 * ($0 * ($0 * ($0 * ($0 * .20697501780033842 + .23066074577556175) + .272728123808534) + .33333332981837743) + .4285714285785502) + .5999999999999946);
      wasm2js_scratch_store_f64(+($22 + $11));
      $3 = wasm2js_scratch_load_i32(1) | 0;
      wasm2js_scratch_load_i32(0) | 0;
      $2 = $3;
      wasm2js_scratch_store_i32(0, 0);
      wasm2js_scratch_store_i32(1, $2 | 0);
      $0 = +wasm2js_scratch_load_f64();
      $12 = $21 * $0;
      $4 = $10 * $0 + $4 * ($11 - ($0 + -3.0 - $20));
      wasm2js_scratch_store_f64(+($12 + $4));
      $2 = wasm2js_scratch_load_i32(1) | 0;
      wasm2js_scratch_load_i32(0) | 0;
      wasm2js_scratch_store_i32(0, 0);
      wasm2js_scratch_store_i32(1, $2 | 0);
      $0 = +wasm2js_scratch_load_f64();
      $10 = $0 * .9617967009544373;
      $11 = HEAPF64[$6 + 18432 >> 3] + (($4 - ($0 - $12)) * .9617966939259756 + $0 * -7.028461650952758e-09);
      $4 = +($9 | 0);
      wasm2js_scratch_store_f64(+($14 + ($10 + $11) + $4));
      $8 = wasm2js_scratch_load_i32(1) | 0;
      wasm2js_scratch_load_i32(0) | 0;
      $3 = $8;
      wasm2js_scratch_store_i32(0, 0);
      wasm2js_scratch_store_i32(1, $3 | 0);
      $0 = +wasm2js_scratch_load_f64();
      $14 = $0 - $4 - $14 - $10;
     }
     $3 = $18;
     $2 = $3;
     wasm2js_scratch_store_i32(0, 0);
     wasm2js_scratch_store_i32(1, $2 | 0);
     $10 = +wasm2js_scratch_load_f64();
     $4 = $0 * $10;
     $1 = ($11 - $14) * $1 + ($1 - $10) * $0;
     $0 = $4 + $1;
     wasm2js_scratch_store_f64(+$0);
     $2 = wasm2js_scratch_load_i32(1) | 0;
     $13 = wasm2js_scratch_load_i32(0) | 0;
     $18 = $2;
     label$25 : {
      $5 = $13;
      $7 = $2;
      if (($2 | 0) >= 1083179008) {
       if ($7 + -1083179008 | $5) {
        break folding_inner0
       }
       if (!($1 + 8.008566259537294e-17 > $0 - $4)) {
        break label$25
       }
       break folding_inner0;
      }
      if (($7 & 2147482624) >>> 0 < 1083231232) {
       break label$25
      }
      if ($7 + 1064252416 | $5) {
       break folding_inner1
      }
      if (!($1 <= $0 - $4)) {
       break label$25
      }
      break folding_inner1;
     }
     $5 = 0;
     $6 = $7 & 2147483647;
     if ($6 >>> 0 >= 1071644673) {
      $6 = (1048576 >>> ($6 >>> 20 | 0) + -1022 | 0) + $7 | 0;
      $9 = $6 >>> 20 & 2047;
      $5 = ($6 & 1048575 | 1048576) >>> 1043 - $9 | 0;
      $5 = ($7 | 0) < 0 ? 0 - $5 | 0 : $5;
      $2 = -1048576 >> $9 + -1023 & $6;
      wasm2js_scratch_store_i32(0, 0);
      wasm2js_scratch_store_i32(1, $2 | 0);
      $4 = $4 - +wasm2js_scratch_load_f64();
      wasm2js_scratch_store_f64(+($1 + $4));
      $3 = wasm2js_scratch_load_i32(1) | 0;
      $8 = wasm2js_scratch_load_i32(0) | 0;
     } else {
      $8 = $13;
      $3 = $18;
     }
     $2 = $3;
     wasm2js_scratch_store_i32(0, 0);
     wasm2js_scratch_store_i32(1, $2 | 0);
     $0 = +wasm2js_scratch_load_f64();
     $10 = $0 * .6931471824645996;
     $4 = ($1 - ($0 - $4)) * .6931471805599453 + $0 * -1.904654299957768e-09;
     $1 = $10 + $4;
     $0 = $1 * $1;
     $14 = $0 * 4.1381367970572385e-08 + -1.6533902205465252e-06;
     $0 = $1 - $0 * ($0 * ($0 * ($0 * $14 + 6.613756321437934e-05) + -2.7777777777015593e-03) + .16666666666666602);
     $14 = $1 * $0 / ($0 + -2.0);
     $0 = $4 - ($1 - $10);
     $12 = $1 * $0;
     $1 = $1 - ($14 - ($0 + $12)) + 1.0;
     wasm2js_scratch_store_f64(+$1);
     $2 = wasm2js_scratch_load_i32(1) | 0;
     $13 = wasm2js_scratch_load_i32(0) | 0;
     $7 = ($5 << 20) + $2 | 0;
     label$31 : {
      if (($7 | 0) <= 1048575) {
       $0 = scalbn($1, $5);
       break label$31;
      }
      $3 = 0;
      $2 = $3;
      $8 = $2 | $7;
      $3 = $13;
      wasm2js_scratch_store_i32(0, $3 | 0);
      wasm2js_scratch_store_i32(1, $8 | 0);
      $0 = +wasm2js_scratch_load_f64();
     }
     $4 = $16 * $0;
    }
    return $4;
   }
   return $16 * 1.e+300 * 1.e+300;
  }
  return $16 * 1.0e-300 * 1.0e-300;
 }
 
 function dlmalloc($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0;
  $12 = global$0 - 16 | 0;
  global$0 = $12;
  label$1 : {
   label$2 : {
    label$3 : {
     label$4 : {
      if ($0 >>> 0 <= 244) {
       $6 = HEAP32[6015];
       $4 = $0 >>> 0 < 11 ? 16 : $0 + 11 & -8;
       $1 = $4 >>> 3 | 0;
       $0 = $6 >>> $1 | 0;
       if ($0 & 3) {
        $2 = (($0 ^ -1) & 1) + $1 | 0;
        $4 = $2 << 3;
        $1 = HEAP32[$4 + 24108 >> 2];
        $0 = HEAP32[$1 + 8 >> 2];
        $4 = $4 + 24100 | 0;
        label$7 : {
         if (($0 | 0) == ($4 | 0)) {
          HEAP32[6015] = __wasm_rotl_i32(-2, $2) & $6;
          break label$7;
         }
         if (HEAP32[$0 + 12 >> 2] != ($1 | 0) | HEAPU32[6019] > $0 >>> 0) {
          break label$3
         }
         HEAP32[$0 + 12 >> 2] = $4;
         HEAP32[$4 + 8 >> 2] = $0;
        }
        $0 = $1 + 8 | 0;
        $2 = $2 << 3;
        HEAP32[$1 + 4 >> 2] = $2 | 3;
        $1 = $1 + $2 | 0;
        $2 = HEAP32[$1 + 4 >> 2] | 1;
        HEAP32[$1 + 4 >> 2] = $2;
        break label$1;
       }
       $8 = HEAP32[6017];
       if ($4 >>> 0 <= $8 >>> 0) {
        break label$4
       }
       if ($0) {
        $2 = $0 << $1;
        $0 = 2 << $1;
        $1 = 0 - $0 | 0;
        $0 = ($0 | $1) & $2;
        $1 = 0 - $0 | 0;
        $0 = ($0 & $1) + -1 | 0;
        $2 = $0;
        $0 = $0 >>> 12 & 16;
        $1 = $2 >>> $0 | 0;
        $2 = $1 >>> 5 & 8;
        $3 = $0 | $2;
        $0 = $1 >>> $2 | 0;
        $1 = $0 >>> 2 & 4;
        $2 = $3 | $1;
        $0 = $0 >>> $1 | 0;
        $1 = $0 >>> 1 & 2;
        $2 = $2 | $1;
        $0 = $0 >>> $1 | 0;
        $1 = $0 >>> 1 & 1;
        $2 = $2 | $1;
        $2 = $2 + ($0 >>> $1 | 0) | 0;
        $3 = $2 << 3;
        $0 = HEAP32[$3 + 24108 >> 2];
        $1 = HEAP32[$0 + 8 >> 2];
        $3 = $3 + 24100 | 0;
        label$10 : {
         if (($1 | 0) == ($3 | 0)) {
          $6 = __wasm_rotl_i32(-2, $2) & $6;
          HEAP32[6015] = $6;
          break label$10;
         }
         if (HEAP32[$1 + 12 >> 2] != ($0 | 0) | HEAPU32[6019] > $1 >>> 0) {
          break label$3
         }
         HEAP32[$1 + 12 >> 2] = $3;
         HEAP32[$3 + 8 >> 2] = $1;
        }
        HEAP32[$0 + 4 >> 2] = $4 | 3;
        $3 = $0 + $4 | 0;
        $1 = $2 << 3;
        $2 = $1 - $4 | 0;
        HEAP32[$3 + 4 >> 2] = $2 | 1;
        HEAP32[$0 + $1 >> 2] = $2;
        if ($8) {
         $5 = $8 >>> 3 | 0;
         $4 = ($5 << 3) + 24100 | 0;
         $1 = HEAP32[6020];
         $5 = 1 << $5;
         label$13 : {
          if (!($6 & $5)) {
           HEAP32[6015] = $5 | $6;
           $5 = $4;
           break label$13;
          }
          $5 = HEAP32[$4 + 8 >> 2];
          if (HEAPU32[6019] > $5 >>> 0) {
           break label$3
          }
         }
         HEAP32[$4 + 8 >> 2] = $1;
         HEAP32[$5 + 12 >> 2] = $1;
         HEAP32[$1 + 12 >> 2] = $4;
         HEAP32[$1 + 8 >> 2] = $5;
        }
        $0 = $0 + 8 | 0;
        HEAP32[6020] = $3;
        HEAP32[6017] = $2;
        break label$1;
       }
       $9 = HEAP32[6016];
       if (!$9) {
        break label$4
       }
       $0 = (0 - $9 & $9) + -1 | 0;
       $2 = $0;
       $0 = $0 >>> 12 & 16;
       $1 = $2 >>> $0 | 0;
       $2 = $1 >>> 5 & 8;
       $3 = $0 | $2;
       $0 = $1 >>> $2 | 0;
       $1 = $0 >>> 2 & 4;
       $2 = $3 | $1;
       $0 = $0 >>> $1 | 0;
       $1 = $0 >>> 1 & 2;
       $2 = $2 | $1;
       $0 = $0 >>> $1 | 0;
       $1 = $0 >>> 1 & 1;
       $2 = $2 | $1;
       $3 = HEAP32[($2 + ($0 >>> $1 | 0) << 2) + 24364 >> 2];
       $1 = (HEAP32[$3 + 4 >> 2] & -8) - $4 | 0;
       $2 = $3;
       while (1) {
        label$16 : {
         $0 = HEAP32[$2 + 16 >> 2];
         if (!$0) {
          $0 = HEAP32[$2 + 20 >> 2];
          if (!$0) {
           break label$16
          }
         }
         $2 = (HEAP32[$0 + 4 >> 2] & -8) - $4 | 0;
         $5 = $2;
         $2 = $2 >>> 0 < $1 >>> 0;
         $1 = $2 ? $5 : $1;
         $3 = $2 ? $0 : $3;
         $2 = $0;
         continue;
        }
        break;
       };
       $13 = HEAP32[6019];
       if ($13 >>> 0 > $3 >>> 0) {
        break label$3
       }
       $11 = $3 + $4 | 0;
       if ($11 >>> 0 <= $3 >>> 0) {
        break label$3
       }
       $10 = HEAP32[$3 + 24 >> 2];
       $5 = HEAP32[$3 + 12 >> 2];
       label$18 : {
        if (($5 | 0) != ($3 | 0)) {
         $0 = HEAP32[$3 + 8 >> 2];
         if ($13 >>> 0 > $0 >>> 0 | HEAP32[$0 + 12 >> 2] != ($3 | 0) | HEAP32[$5 + 8 >> 2] != ($3 | 0)) {
          break label$3
         }
         HEAP32[$0 + 12 >> 2] = $5;
         HEAP32[$5 + 8 >> 2] = $0;
         break label$18;
        }
        label$20 : {
         $2 = $3 + 20 | 0;
         $0 = HEAP32[$2 >> 2];
         if (!$0) {
          $0 = HEAP32[$3 + 16 >> 2];
          if (!$0) {
           break label$20
          }
          $2 = $3 + 16 | 0;
         }
         while (1) {
          $7 = $2;
          $5 = $0;
          $2 = $0 + 20 | 0;
          $0 = HEAP32[$2 >> 2];
          if ($0) {
           continue
          }
          $2 = $5 + 16 | 0;
          $0 = HEAP32[$5 + 16 >> 2];
          if ($0) {
           continue
          }
          break;
         };
         if ($13 >>> 0 > $7 >>> 0) {
          break label$3
         }
         HEAP32[$7 >> 2] = 0;
         break label$18;
        }
        $5 = 0;
       }
       label$23 : {
        if (!$10) {
         break label$23
        }
        $2 = HEAP32[$3 + 28 >> 2];
        $0 = ($2 << 2) + 24364 | 0;
        label$24 : {
         if (HEAP32[$0 >> 2] == ($3 | 0)) {
          HEAP32[$0 >> 2] = $5;
          if ($5) {
           break label$24
          }
          HEAP32[6016] = __wasm_rotl_i32(-2, $2) & $9;
          break label$23;
         }
         if (HEAPU32[6019] > $10 >>> 0) {
          break label$3
         }
         HEAP32[(HEAP32[$10 + 16 >> 2] == ($3 | 0) ? 16 : 20) + $10 >> 2] = $5;
         if (!$5) {
          break label$23
         }
        }
        $2 = HEAP32[6019];
        if ($2 >>> 0 > $5 >>> 0) {
         break label$3
        }
        HEAP32[$5 + 24 >> 2] = $10;
        $0 = HEAP32[$3 + 16 >> 2];
        if ($0) {
         if ($2 >>> 0 > $0 >>> 0) {
          break label$3
         }
         HEAP32[$5 + 16 >> 2] = $0;
         HEAP32[$0 + 24 >> 2] = $5;
        }
        $0 = HEAP32[$3 + 20 >> 2];
        if (!$0) {
         break label$23
        }
        if (HEAPU32[6019] > $0 >>> 0) {
         break label$3
        }
        HEAP32[$5 + 20 >> 2] = $0;
        HEAP32[$0 + 24 >> 2] = $5;
       }
       label$27 : {
        if ($1 >>> 0 <= 15) {
         $0 = $1 + $4 | 0;
         HEAP32[$3 + 4 >> 2] = $0 | 3;
         $0 = $0 + $3 | 0;
         $1 = HEAP32[$0 + 4 >> 2] | 1;
         HEAP32[$0 + 4 >> 2] = $1;
         break label$27;
        }
        HEAP32[$3 + 4 >> 2] = $4 | 3;
        HEAP32[$11 + 4 >> 2] = $1 | 1;
        HEAP32[$1 + $11 >> 2] = $1;
        if ($8) {
         $4 = $8 >>> 3 | 0;
         $2 = ($4 << 3) + 24100 | 0;
         $0 = HEAP32[6020];
         $4 = 1 << $4;
         label$30 : {
          if (!($6 & $4)) {
           HEAP32[6015] = $4 | $6;
           $4 = $2;
           break label$30;
          }
          $4 = HEAP32[$2 + 8 >> 2];
          if (HEAPU32[6019] > $4 >>> 0) {
           break label$3
          }
         }
         HEAP32[$2 + 8 >> 2] = $0;
         HEAP32[$4 + 12 >> 2] = $0;
         HEAP32[$0 + 12 >> 2] = $2;
         HEAP32[$0 + 8 >> 2] = $4;
        }
        HEAP32[6020] = $11;
        HEAP32[6017] = $1;
       }
       $0 = $3 + 8 | 0;
       break label$1;
      }
      $4 = -1;
      if ($0 >>> 0 > 4294967231) {
       break label$4
      }
      $0 = $0 + 11 | 0;
      $4 = $0 & -8;
      $8 = HEAP32[6016];
      if (!$8) {
       break label$4
      }
      $0 = $0 >>> 8 | 0;
      $7 = 0;
      label$32 : {
       if (!$0) {
        break label$32
       }
       $7 = 31;
       if ($4 >>> 0 > 16777215) {
        break label$32
       }
       $1 = $0 + 1048320 >>> 16 & 8;
       $0 = $0 << $1;
       $2 = $0;
       $0 = $0 + 520192 >>> 16 & 4;
       $3 = $2 << $0;
       $2 = $3 + 245760 >>> 16 & 2;
       $0 = ($3 << $2 >>> 15 | 0) - ($0 | $1 | $2) | 0;
       $1 = $0 << 1;
       $7 = ($1 | $4 >>> $0 + 21 & 1) + 28 | 0;
      }
      $2 = 0 - $4 | 0;
      $1 = HEAP32[($7 << 2) + 24364 >> 2];
      label$33 : {
       label$34 : {
        label$35 : {
         if (!$1) {
          $0 = 0;
          break label$35;
         }
         $3 = $4 << (($7 | 0) == 31 ? 0 : 25 - ($7 >>> 1 | 0) | 0);
         $0 = 0;
         while (1) {
          label$38 : {
           $6 = (HEAP32[$1 + 4 >> 2] & -8) - $4 | 0;
           if ($6 >>> 0 >= $2 >>> 0) {
            break label$38
           }
           $5 = $1;
           $2 = $6;
           if ($2) {
            break label$38
           }
           $2 = 0;
           $0 = $1;
           break label$34;
          }
          $6 = HEAP32[$1 + 20 >> 2];
          $1 = HEAP32[(($3 >>> 29 & 4) + $1 | 0) + 16 >> 2];
          $0 = $6 ? (($6 | 0) == ($1 | 0) ? $0 : $6) : $0;
          $3 = $3 << (($1 | 0) != 0);
          if ($1) {
           continue
          }
          break;
         };
        }
        if (!($0 | $5)) {
         $0 = 2 << $7;
         $1 = 0 - $0 | 0;
         $0 = ($0 | $1) & $8;
         if (!$0) {
          break label$4
         }
         $0 = (0 - $0 & $0) + -1 | 0;
         $1 = $0;
         $0 = $0 >>> 12 & 16;
         $1 = $1 >>> $0 | 0;
         $3 = $1 >>> 5 & 8;
         $7 = $0 | $3;
         $0 = $1 >>> $3 | 0;
         $1 = $0 >>> 2 & 4;
         $3 = $7 | $1;
         $0 = $0 >>> $1 | 0;
         $1 = $0 >>> 1 & 2;
         $3 = $3 | $1;
         $0 = $0 >>> $1 | 0;
         $1 = $0 >>> 1 & 1;
         $3 = $3 | $1;
         $0 = HEAP32[($3 + ($0 >>> $1 | 0) << 2) + 24364 >> 2];
        }
        if (!$0) {
         break label$33
        }
       }
       while (1) {
        $6 = (HEAP32[$0 + 4 >> 2] & -8) - $4 | 0;
        $3 = $6 >>> 0 < $2 >>> 0;
        $2 = $3 ? $6 : $2;
        $5 = $3 ? $0 : $5;
        $1 = HEAP32[$0 + 16 >> 2];
        if ($1) {
         $0 = $1
        } else {
         $0 = HEAP32[$0 + 20 >> 2]
        }
        if ($0) {
         continue
        }
        break;
       };
      }
      if (!$5 | $2 >>> 0 >= HEAP32[6017] - $4 >>> 0) {
       break label$4
      }
      $10 = HEAP32[6019];
      if ($10 >>> 0 > $5 >>> 0) {
       break label$3
      }
      $7 = $4 + $5 | 0;
      if ($7 >>> 0 <= $5 >>> 0) {
       break label$3
      }
      $9 = HEAP32[$5 + 24 >> 2];
      $3 = HEAP32[$5 + 12 >> 2];
      label$43 : {
       if (($5 | 0) != ($3 | 0)) {
        $0 = HEAP32[$5 + 8 >> 2];
        if ($10 >>> 0 > $0 >>> 0 | HEAP32[$0 + 12 >> 2] != ($5 | 0) | HEAP32[$3 + 8 >> 2] != ($5 | 0)) {
         break label$3
        }
        HEAP32[$0 + 12 >> 2] = $3;
        HEAP32[$3 + 8 >> 2] = $0;
        break label$43;
       }
       label$45 : {
        $1 = $5 + 20 | 0;
        $0 = HEAP32[$1 >> 2];
        if (!$0) {
         $0 = HEAP32[$5 + 16 >> 2];
         if (!$0) {
          break label$45
         }
         $1 = $5 + 16 | 0;
        }
        while (1) {
         $6 = $1;
         $3 = $0;
         $1 = $0 + 20 | 0;
         $0 = HEAP32[$1 >> 2];
         if ($0) {
          continue
         }
         $1 = $3 + 16 | 0;
         $0 = HEAP32[$3 + 16 >> 2];
         if ($0) {
          continue
         }
         break;
        };
        if ($10 >>> 0 > $6 >>> 0) {
         break label$3
        }
        HEAP32[$6 >> 2] = 0;
        break label$43;
       }
       $3 = 0;
      }
      label$48 : {
       if (!$9) {
        break label$48
       }
       $1 = HEAP32[$5 + 28 >> 2];
       $0 = ($1 << 2) + 24364 | 0;
       label$49 : {
        if (HEAP32[$0 >> 2] == ($5 | 0)) {
         HEAP32[$0 >> 2] = $3;
         if ($3) {
          break label$49
         }
         $8 = __wasm_rotl_i32(-2, $1) & $8;
         HEAP32[6016] = $8;
         break label$48;
        }
        if (HEAPU32[6019] > $9 >>> 0) {
         break label$3
        }
        HEAP32[(HEAP32[$9 + 16 >> 2] == ($5 | 0) ? 16 : 20) + $9 >> 2] = $3;
        if (!$3) {
         break label$48
        }
       }
       $1 = HEAP32[6019];
       if ($1 >>> 0 > $3 >>> 0) {
        break label$3
       }
       HEAP32[$3 + 24 >> 2] = $9;
       $0 = HEAP32[$5 + 16 >> 2];
       if ($0) {
        if ($1 >>> 0 > $0 >>> 0) {
         break label$3
        }
        HEAP32[$3 + 16 >> 2] = $0;
        HEAP32[$0 + 24 >> 2] = $3;
       }
       $0 = HEAP32[$5 + 20 >> 2];
       if (!$0) {
        break label$48
       }
       if (HEAPU32[6019] > $0 >>> 0) {
        break label$3
       }
       HEAP32[$3 + 20 >> 2] = $0;
       HEAP32[$0 + 24 >> 2] = $3;
      }
      label$52 : {
       if ($2 >>> 0 <= 15) {
        $0 = $2 + $4 | 0;
        HEAP32[$5 + 4 >> 2] = $0 | 3;
        $0 = $0 + $5 | 0;
        $1 = HEAP32[$0 + 4 >> 2] | 1;
        HEAP32[$0 + 4 >> 2] = $1;
        break label$52;
       }
       HEAP32[$5 + 4 >> 2] = $4 | 3;
       HEAP32[$7 + 4 >> 2] = $2 | 1;
       HEAP32[$2 + $7 >> 2] = $2;
       if ($2 >>> 0 <= 255) {
        $1 = $2 >>> 3 | 0;
        $0 = ($1 << 3) + 24100 | 0;
        $1 = 1 << $1;
        $2 = HEAP32[6015];
        label$55 : {
         if (!($1 & $2)) {
          HEAP32[6015] = $1 | $2;
          $1 = $0;
          break label$55;
         }
         $1 = HEAP32[$0 + 8 >> 2];
         if (HEAPU32[6019] > $1 >>> 0) {
          break label$3
         }
        }
        HEAP32[$0 + 8 >> 2] = $7;
        HEAP32[$1 + 12 >> 2] = $7;
        HEAP32[$7 + 12 >> 2] = $0;
        HEAP32[$7 + 8 >> 2] = $1;
        break label$52;
       }
       $6 = $7;
       $1 = $2 >>> 8 | 0;
       $0 = 0;
       label$57 : {
        if (!$1) {
         break label$57
        }
        $0 = 31;
        if ($2 >>> 0 > 16777215) {
         break label$57
        }
        $0 = $1 + 1048320 >>> 16 & 8;
        $1 = $1 << $0;
        $3 = $1;
        $1 = $1 + 520192 >>> 16 & 4;
        $4 = $3 << $1;
        $3 = $4;
        $4 = $4 + 245760 >>> 16 & 2;
        $0 = ($3 << $4 >>> 15 | 0) - ($0 | $1 | $4) | 0;
        $1 = $0 << 1;
        $0 = ($1 | $2 >>> $0 + 21 & 1) + 28 | 0;
       }
       HEAP32[$6 + 28 >> 2] = $0;
       HEAP32[$7 + 16 >> 2] = 0;
       HEAP32[$7 + 20 >> 2] = 0;
       $1 = ($0 << 2) + 24364 | 0;
       label$58 : {
        $4 = 1 << $0;
        label$59 : {
         if (!($8 & $4)) {
          HEAP32[6016] = $4 | $8;
          HEAP32[$1 >> 2] = $7;
          break label$59;
         }
         $0 = $2 << (($0 | 0) == 31 ? 0 : 25 - ($0 >>> 1 | 0) | 0);
         $4 = HEAP32[$1 >> 2];
         while (1) {
          $1 = $4;
          if ((HEAP32[$1 + 4 >> 2] & -8) == ($2 | 0)) {
           break label$58
          }
          $4 = $0 >>> 29 | 0;
          $0 = $0 << 1;
          $3 = (($4 & 4) + $1 | 0) + 16 | 0;
          $4 = HEAP32[$3 >> 2];
          if ($4) {
           continue
          }
          break;
         };
         if (HEAPU32[6019] > $3 >>> 0) {
          break label$3
         }
         HEAP32[$3 >> 2] = $7;
        }
        HEAP32[$7 + 24 >> 2] = $1;
        HEAP32[$7 + 12 >> 2] = $7;
        HEAP32[$7 + 8 >> 2] = $7;
        break label$52;
       }
       $2 = HEAP32[6019];
       if ($2 >>> 0 > $1 >>> 0) {
        break label$3
       }
       $0 = HEAP32[$1 + 8 >> 2];
       if ($2 >>> 0 > $0 >>> 0) {
        break label$3
       }
       HEAP32[$0 + 12 >> 2] = $7;
       HEAP32[$1 + 8 >> 2] = $7;
       HEAP32[$7 + 24 >> 2] = 0;
       HEAP32[$7 + 12 >> 2] = $1;
       HEAP32[$7 + 8 >> 2] = $0;
      }
      $0 = $5 + 8 | 0;
      break label$1;
     }
     $0 = HEAP32[6017];
     if ($0 >>> 0 >= $4 >>> 0) {
      $1 = HEAP32[6020];
      $2 = $0 - $4 | 0;
      label$63 : {
       if ($2 >>> 0 >= 16) {
        HEAP32[6017] = $2;
        $3 = $1 + $4 | 0;
        HEAP32[6020] = $3;
        HEAP32[$3 + 4 >> 2] = $2 | 1;
        HEAP32[$0 + $1 >> 2] = $2;
        HEAP32[$1 + 4 >> 2] = $4 | 3;
        break label$63;
       }
       HEAP32[6020] = 0;
       HEAP32[6017] = 0;
       HEAP32[$1 + 4 >> 2] = $0 | 3;
       $0 = $0 + $1 | 0;
       $2 = HEAP32[$0 + 4 >> 2] | 1;
       HEAP32[$0 + 4 >> 2] = $2;
      }
      $0 = $1 + 8 | 0;
      break label$1;
     }
     $3 = HEAP32[6018];
     if ($3 >>> 0 > $4 >>> 0) {
      $1 = $3 - $4 | 0;
      HEAP32[6018] = $1;
      $0 = HEAP32[6021];
      $2 = $4 + $0 | 0;
      HEAP32[6021] = $2;
      HEAP32[$2 + 4 >> 2] = $1 | 1;
      HEAP32[$0 + 4 >> 2] = $4 | 3;
      $0 = $0 + 8 | 0;
      break label$1;
     }
     $0 = 0;
     $8 = $4 + 47 | 0;
     $2 = $8;
     if (HEAP32[6133]) {
      $1 = HEAP32[6135]
     } else {
      HEAP32[6136] = -1;
      HEAP32[6137] = -1;
      HEAP32[6134] = 4096;
      HEAP32[6135] = 4096;
      HEAP32[6133] = $12 + 12 & -16 ^ 1431655768;
      HEAP32[6138] = 0;
      HEAP32[6126] = 0;
      $1 = 4096;
     }
     $6 = $2 + $1 | 0;
     $7 = 0 - $1 | 0;
     $5 = $6 & $7;
     if ($5 >>> 0 <= $4 >>> 0) {
      break label$1
     }
     $1 = HEAP32[6125];
     if ($1) {
      $2 = HEAP32[6123];
      $9 = $5 + $2 | 0;
      if ($9 >>> 0 <= $2 >>> 0 | $9 >>> 0 > $1 >>> 0) {
       break label$1
      }
     }
     label$69 : {
      if (!(HEAPU8[24504] & 4)) {
       label$71 : {
        label$72 : {
         label$73 : {
          label$74 : {
           $1 = HEAP32[6021];
           if ($1) {
            $0 = 24508;
            while (1) {
             $2 = HEAP32[$0 >> 2];
             if (HEAP32[$0 + 4 >> 2] + $2 >>> 0 > $1 >>> 0 ? $2 >>> 0 <= $1 >>> 0 : 0) {
              break label$74
             }
             $0 = HEAP32[$0 + 8 >> 2];
             if ($0) {
              continue
             }
             break;
            };
           }
           $3 = sbrk(0);
           if (($3 | 0) == -1) {
            break label$71
           }
           $6 = $5;
           $0 = HEAP32[6134];
           $1 = $0 + -1 | 0;
           if ($3 & $1) {
            $6 = ($5 - $3 | 0) + ($1 + $3 & 0 - $0) | 0
           }
           if ($6 >>> 0 <= $4 >>> 0 | $6 >>> 0 > 2147483646) {
            break label$71
           }
           $0 = HEAP32[6125];
           if ($0) {
            $1 = HEAP32[6123];
            $2 = $6 + $1 | 0;
            if ($2 >>> 0 <= $1 >>> 0 | $2 >>> 0 > $0 >>> 0) {
             break label$71
            }
           }
           $0 = sbrk($6);
           if (($3 | 0) != ($0 | 0)) {
            break label$73
           }
           break label$69;
          }
          $6 = $6 - $3 & $7;
          if ($6 >>> 0 > 2147483646) {
           break label$71
          }
          $3 = sbrk($6);
          if (($3 | 0) == (HEAP32[$0 + 4 >> 2] + HEAP32[$0 >> 2] | 0)) {
           break label$72
          }
          $0 = $3;
         }
         if (!(($0 | 0) == -1 | $4 + 48 >>> 0 <= $6 >>> 0)) {
          $1 = HEAP32[6135];
          $2 = $1 + ($8 - $6 | 0) | 0;
          $1 = $2 & 0 - $1;
          if ($1 >>> 0 > 2147483646) {
           $3 = $0;
           break label$69;
          }
          if ((sbrk($1) | 0) != -1) {
           $6 = $1 + $6 | 0;
           $3 = $0;
           break label$69;
          }
          sbrk(0 - $6 | 0);
          break label$71;
         }
         $3 = $0;
         if (($0 | 0) != -1) {
          break label$69
         }
         break label$71;
        }
        if (($3 | 0) != -1) {
         break label$69
        }
       }
       HEAP32[6126] = HEAP32[6126] | 4;
      }
      if ($5 >>> 0 > 2147483646) {
       break label$2
      }
      $3 = sbrk($5);
      $0 = sbrk(0);
      if ($3 >>> 0 >= $0 >>> 0 | ($3 | 0) == -1 | ($0 | 0) == -1) {
       break label$2
      }
      $6 = $0 - $3 | 0;
      if ($6 >>> 0 <= $4 + 40 >>> 0) {
       break label$2
      }
     }
     $0 = HEAP32[6123] + $6 | 0;
     HEAP32[6123] = $0;
     if ($0 >>> 0 > HEAPU32[6124]) {
      HEAP32[6124] = $0
     }
     label$84 : {
      label$85 : {
       label$86 : {
        $1 = HEAP32[6021];
        if ($1) {
         $0 = 24508;
         while (1) {
          $2 = HEAP32[$0 >> 2];
          $5 = HEAP32[$0 + 4 >> 2];
          if (($2 + $5 | 0) == ($3 | 0)) {
           break label$86
          }
          $0 = HEAP32[$0 + 8 >> 2];
          if ($0) {
           continue
          }
          break;
         };
         break label$85;
        }
        $0 = HEAP32[6019];
        $1 = $3 >>> 0 >= $0 >>> 0;
        if (!($1 ? $0 : 0)) {
         HEAP32[6019] = $3
        }
        $0 = 0;
        HEAP32[6128] = $6;
        HEAP32[6127] = $3;
        HEAP32[6023] = -1;
        HEAP32[6024] = HEAP32[6133];
        HEAP32[6130] = 0;
        while (1) {
         $1 = $0 << 3;
         $2 = $1 + 24100 | 0;
         HEAP32[$1 + 24108 >> 2] = $2;
         HEAP32[$1 + 24112 >> 2] = $2;
         $0 = $0 + 1 | 0;
         if (($0 | 0) != 32) {
          continue
         }
         break;
        };
        $0 = $6 + -40 | 0;
        $1 = $3 + 8 & 7 ? -8 - $3 & 7 : 0;
        $2 = $0 - $1 | 0;
        HEAP32[6018] = $2;
        $1 = $1 + $3 | 0;
        HEAP32[6021] = $1;
        HEAP32[$1 + 4 >> 2] = $2 | 1;
        HEAP32[($0 + $3 | 0) + 4 >> 2] = 40;
        HEAP32[6022] = HEAP32[6137];
        break label$84;
       }
       if (HEAPU8[$0 + 12 | 0] & 8 | $3 >>> 0 <= $1 >>> 0 | $2 >>> 0 > $1 >>> 0) {
        break label$85
       }
       HEAP32[$0 + 4 >> 2] = $5 + $6;
       $0 = $1 + 8 & 7 ? -8 - $1 & 7 : 0;
       $2 = $1 + $0 | 0;
       HEAP32[6021] = $2;
       $3 = HEAP32[6018] + $6 | 0;
       $0 = $3 - $0 | 0;
       HEAP32[6018] = $0;
       HEAP32[$2 + 4 >> 2] = $0 | 1;
       HEAP32[($1 + $3 | 0) + 4 >> 2] = 40;
       HEAP32[6022] = HEAP32[6137];
       break label$84;
      }
      $5 = HEAP32[6019];
      if ($3 >>> 0 < $5 >>> 0) {
       HEAP32[6019] = $3;
       $5 = $3;
      }
      $2 = $3 + $6 | 0;
      $0 = 24508;
      label$92 : {
       label$93 : {
        label$94 : {
         while (1) {
          if (HEAP32[$0 >> 2] != ($2 | 0)) {
           $0 = HEAP32[$0 + 8 >> 2];
           if ($0) {
            continue
           }
           break label$94;
          }
          break;
         };
         if (!(HEAPU8[$0 + 12 | 0] & 8)) {
          break label$93
         }
        }
        $0 = 24508;
        while (1) {
         $2 = HEAP32[$0 >> 2];
         if ($2 >>> 0 <= $1 >>> 0) {
          $2 = HEAP32[$0 + 4 >> 2] + $2 | 0;
          if ($2 >>> 0 > $1 >>> 0) {
           break label$92
          }
         }
         $0 = HEAP32[$0 + 8 >> 2];
         continue;
        };
       }
       HEAP32[$0 >> 2] = $3;
       HEAP32[$0 + 4 >> 2] = HEAP32[$0 + 4 >> 2] + $6;
       $7 = ($3 + 8 & 7 ? -8 - $3 & 7 : 0) + $3 | 0;
       HEAP32[$7 + 4 >> 2] = $4 | 3;
       $3 = ($2 + 8 & 7 ? -8 - $2 & 7 : 0) + $2 | 0;
       $0 = ($3 - $7 | 0) - $4 | 0;
       $2 = $4 + $7 | 0;
       label$99 : {
        if (($1 | 0) == ($3 | 0)) {
         HEAP32[6021] = $2;
         $0 = HEAP32[6018] + $0 | 0;
         HEAP32[6018] = $0;
         HEAP32[$2 + 4 >> 2] = $0 | 1;
         break label$99;
        }
        if (HEAP32[6020] == ($3 | 0)) {
         HEAP32[6020] = $2;
         $0 = HEAP32[6017] + $0 | 0;
         HEAP32[6017] = $0;
         HEAP32[$2 + 4 >> 2] = $0 | 1;
         HEAP32[$0 + $2 >> 2] = $0;
         break label$99;
        }
        $9 = HEAP32[$3 + 4 >> 2];
        if (($9 & 3) == 1) {
         label$103 : {
          if ($9 >>> 0 <= 255) {
           $1 = HEAP32[$3 + 12 >> 2];
           $4 = HEAP32[$3 + 8 >> 2];
           $8 = $9 >>> 3 | 0;
           $6 = ($8 << 3) + 24100 | 0;
           if (HEAP32[$4 + 12 >> 2] != ($3 | 0) | $5 >>> 0 > $4 >>> 0 ? ($4 | 0) != ($6 | 0) : 0) {
            break label$3
           }
           if (($1 | 0) == ($4 | 0)) {
            HEAP32[6015] = HEAP32[6015] & __wasm_rotl_i32(-2, $8);
            break label$103;
           }
           if (HEAP32[$1 + 8 >> 2] != ($3 | 0) | $5 >>> 0 > $1 >>> 0 ? ($1 | 0) != ($6 | 0) : 0) {
            break label$3
           }
           HEAP32[$4 + 12 >> 2] = $1;
           HEAP32[$1 + 8 >> 2] = $4;
           break label$103;
          }
          $10 = HEAP32[$3 + 24 >> 2];
          $6 = HEAP32[$3 + 12 >> 2];
          label$108 : {
           if (($6 | 0) != ($3 | 0)) {
            $1 = HEAP32[$3 + 8 >> 2];
            if ($5 >>> 0 > $1 >>> 0 | HEAP32[$1 + 12 >> 2] != ($3 | 0) | HEAP32[$6 + 8 >> 2] != ($3 | 0)) {
             break label$3
            }
            HEAP32[$1 + 12 >> 2] = $6;
            HEAP32[$6 + 8 >> 2] = $1;
            break label$108;
           }
           label$110 : {
            $1 = $3 + 20 | 0;
            $4 = HEAP32[$1 >> 2];
            if ($4) {
             break label$110
            }
            $1 = $3 + 16 | 0;
            $4 = HEAP32[$1 >> 2];
            if ($4) {
             break label$110
            }
            $6 = 0;
            break label$108;
           }
           while (1) {
            $8 = $1;
            $6 = $4;
            $1 = $4 + 20 | 0;
            $4 = HEAP32[$1 >> 2];
            if ($4) {
             continue
            }
            $1 = $6 + 16 | 0;
            $4 = HEAP32[$6 + 16 >> 2];
            if ($4) {
             continue
            }
            break;
           };
           if ($5 >>> 0 > $8 >>> 0) {
            break label$3
           }
           HEAP32[$8 >> 2] = 0;
          }
          if (!$10) {
           break label$103
          }
          $4 = HEAP32[$3 + 28 >> 2];
          $1 = ($4 << 2) + 24364 | 0;
          label$112 : {
           if (HEAP32[$1 >> 2] == ($3 | 0)) {
            HEAP32[$1 >> 2] = $6;
            if ($6) {
             break label$112
            }
            HEAP32[6016] = HEAP32[6016] & __wasm_rotl_i32(-2, $4);
            break label$103;
           }
           if (HEAPU32[6019] > $10 >>> 0) {
            break label$3
           }
           HEAP32[(HEAP32[$10 + 16 >> 2] == ($3 | 0) ? 16 : 20) + $10 >> 2] = $6;
           if (!$6) {
            break label$103
           }
          }
          $4 = HEAP32[6019];
          if ($4 >>> 0 > $6 >>> 0) {
           break label$3
          }
          HEAP32[$6 + 24 >> 2] = $10;
          $1 = HEAP32[$3 + 16 >> 2];
          if ($1) {
           if ($4 >>> 0 > $1 >>> 0) {
            break label$3
           }
           HEAP32[$6 + 16 >> 2] = $1;
           HEAP32[$1 + 24 >> 2] = $6;
          }
          $1 = HEAP32[$3 + 20 >> 2];
          if (!$1) {
           break label$103
          }
          if (HEAPU32[6019] > $1 >>> 0) {
           break label$3
          }
          HEAP32[$6 + 20 >> 2] = $1;
          HEAP32[$1 + 24 >> 2] = $6;
         }
         $1 = $9 & -8;
         $0 = $1 + $0 | 0;
         $3 = $1 + $3 | 0;
        }
        HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] & -2;
        HEAP32[$2 + 4 >> 2] = $0 | 1;
        HEAP32[$0 + $2 >> 2] = $0;
        if ($0 >>> 0 <= 255) {
         $1 = $0 >>> 3 | 0;
         $0 = ($1 << 3) + 24100 | 0;
         $1 = 1 << $1;
         $4 = HEAP32[6015];
         label$116 : {
          if (!($1 & $4)) {
           HEAP32[6015] = $1 | $4;
           $1 = $0;
           break label$116;
          }
          $1 = HEAP32[$0 + 8 >> 2];
          if (HEAPU32[6019] > $1 >>> 0) {
           break label$3
          }
         }
         HEAP32[$0 + 8 >> 2] = $2;
         HEAP32[$1 + 12 >> 2] = $2;
         HEAP32[$2 + 12 >> 2] = $0;
         HEAP32[$2 + 8 >> 2] = $1;
         break label$99;
        }
        $6 = $2;
        $4 = $0 >>> 8 | 0;
        $1 = 0;
        label$118 : {
         if (!$4) {
          break label$118
         }
         $1 = 31;
         if ($0 >>> 0 > 16777215) {
          break label$118
         }
         $1 = $4 + 1048320 >>> 16 & 8;
         $3 = $4 << $1;
         $4 = $3 + 520192 >>> 16 & 4;
         $3 = $3 << $4;
         $5 = $3;
         $3 = $3 + 245760 >>> 16 & 2;
         $1 = ($5 << $3 >>> 15 | 0) - ($1 | $4 | $3) | 0;
         $3 = $1 << 1;
         $1 = ($3 | $0 >>> $1 + 21 & 1) + 28 | 0;
        }
        HEAP32[$6 + 28 >> 2] = $1;
        HEAP32[$2 + 16 >> 2] = 0;
        HEAP32[$2 + 20 >> 2] = 0;
        $4 = ($1 << 2) + 24364 | 0;
        label$119 : {
         $3 = HEAP32[6016];
         $5 = 1 << $1;
         label$120 : {
          if (!($3 & $5)) {
           HEAP32[6016] = $3 | $5;
           HEAP32[$4 >> 2] = $2;
           break label$120;
          }
          $1 = $0 << (($1 | 0) == 31 ? 0 : 25 - ($1 >>> 1 | 0) | 0);
          $3 = HEAP32[$4 >> 2];
          while (1) {
           $4 = $3;
           if ((HEAP32[$3 + 4 >> 2] & -8) == ($0 | 0)) {
            break label$119
           }
           $3 = $1 >>> 29 | 0;
           $1 = $1 << 1;
           $5 = (($3 & 4) + $4 | 0) + 16 | 0;
           $3 = HEAP32[$5 >> 2];
           if ($3) {
            continue
           }
           break;
          };
          if (HEAPU32[6019] > $5 >>> 0) {
           break label$3
          }
          HEAP32[$5 >> 2] = $2;
         }
         HEAP32[$2 + 24 >> 2] = $4;
         HEAP32[$2 + 12 >> 2] = $2;
         HEAP32[$2 + 8 >> 2] = $2;
         break label$99;
        }
        $1 = HEAP32[6019];
        if ($1 >>> 0 > $4 >>> 0) {
         break label$3
        }
        $0 = HEAP32[$4 + 8 >> 2];
        if ($1 >>> 0 > $0 >>> 0) {
         break label$3
        }
        HEAP32[$0 + 12 >> 2] = $2;
        HEAP32[$4 + 8 >> 2] = $2;
        HEAP32[$2 + 24 >> 2] = 0;
        HEAP32[$2 + 12 >> 2] = $4;
        HEAP32[$2 + 8 >> 2] = $0;
       }
       $0 = $7 + 8 | 0;
       break label$1;
      }
      $0 = $6 + -40 | 0;
      $5 = $3 + 8 & 7 ? -8 - $3 & 7 : 0;
      $7 = $0 - $5 | 0;
      HEAP32[6018] = $7;
      $5 = $3 + $5 | 0;
      HEAP32[6021] = $5;
      HEAP32[$5 + 4 >> 2] = $7 | 1;
      HEAP32[($0 + $3 | 0) + 4 >> 2] = 40;
      HEAP32[6022] = HEAP32[6137];
      $0 = (($2 + -39 & 7 ? 39 - $2 & 7 : 0) + $2 | 0) + -47 | 0;
      $5 = $0 >>> 0 < $1 + 16 >>> 0 ? $1 : $0;
      HEAP32[$5 + 4 >> 2] = 27;
      $0 = HEAP32[6130];
      $7 = HEAP32[6129];
      HEAP32[$5 + 16 >> 2] = $7;
      HEAP32[$5 + 20 >> 2] = $0;
      $7 = HEAP32[6128];
      $0 = HEAP32[6127];
      HEAP32[$5 + 8 >> 2] = $0;
      HEAP32[$5 + 12 >> 2] = $7;
      HEAP32[6129] = $5 + 8;
      HEAP32[6128] = $6;
      HEAP32[6127] = $3;
      HEAP32[6130] = 0;
      $0 = $5 + 24 | 0;
      while (1) {
       HEAP32[$0 + 4 >> 2] = 7;
       $3 = $0 + 8 | 0;
       $0 = $0 + 4 | 0;
       if ($2 >>> 0 > $3 >>> 0) {
        continue
       }
       break;
      };
      if (($1 | 0) == ($5 | 0)) {
       break label$84
      }
      HEAP32[$5 + 4 >> 2] = HEAP32[$5 + 4 >> 2] & -2;
      $6 = $5 - $1 | 0;
      HEAP32[$1 + 4 >> 2] = $6 | 1;
      HEAP32[$5 >> 2] = $6;
      if ($6 >>> 0 <= 255) {
       $2 = $6 >>> 3 | 0;
       $0 = ($2 << 3) + 24100 | 0;
       $3 = HEAP32[6015];
       $2 = 1 << $2;
       label$125 : {
        if (!($3 & $2)) {
         HEAP32[6015] = $3 | $2;
         $2 = $0;
         break label$125;
        }
        $2 = HEAP32[$0 + 8 >> 2];
        if (HEAPU32[6019] > $2 >>> 0) {
         break label$3
        }
       }
       HEAP32[$0 + 8 >> 2] = $1;
       HEAP32[$2 + 12 >> 2] = $1;
       HEAP32[$1 + 12 >> 2] = $0;
       HEAP32[$1 + 8 >> 2] = $2;
       break label$84;
      }
      HEAP32[$1 + 16 >> 2] = 0;
      HEAP32[$1 + 20 >> 2] = 0;
      $7 = $1;
      $2 = $6 >>> 8 | 0;
      $0 = 0;
      label$127 : {
       if (!$2) {
        break label$127
       }
       $0 = 31;
       if ($6 >>> 0 > 16777215) {
        break label$127
       }
       $0 = $2 + 1048320 >>> 16 & 8;
       $3 = $2 << $0;
       $2 = $3 + 520192 >>> 16 & 4;
       $3 = $3 << $2;
       $5 = $3;
       $3 = $3 + 245760 >>> 16 & 2;
       $0 = ($5 << $3 >>> 15 | 0) - ($0 | $2 | $3) | 0;
       $2 = $0 << 1;
       $0 = ($2 | $6 >>> $0 + 21 & 1) + 28 | 0;
      }
      HEAP32[$7 + 28 >> 2] = $0;
      $2 = ($0 << 2) + 24364 | 0;
      label$128 : {
       $3 = HEAP32[6016];
       $5 = 1 << $0;
       label$129 : {
        if (!($3 & $5)) {
         HEAP32[6016] = $3 | $5;
         HEAP32[$2 >> 2] = $1;
         break label$129;
        }
        $0 = $6 << (($0 | 0) == 31 ? 0 : 25 - ($0 >>> 1 | 0) | 0);
        $3 = HEAP32[$2 >> 2];
        while (1) {
         $2 = $3;
         if ((HEAP32[$3 + 4 >> 2] & -8) == ($6 | 0)) {
          break label$128
         }
         $3 = $0 >>> 29 | 0;
         $0 = $0 << 1;
         $5 = (($3 & 4) + $2 | 0) + 16 | 0;
         $3 = HEAP32[$5 >> 2];
         if ($3) {
          continue
         }
         break;
        };
        if (HEAPU32[6019] > $5 >>> 0) {
         break label$3
        }
        HEAP32[$5 >> 2] = $1;
       }
       HEAP32[$1 + 24 >> 2] = $2;
       HEAP32[$1 + 12 >> 2] = $1;
       HEAP32[$1 + 8 >> 2] = $1;
       break label$84;
      }
      $3 = HEAP32[6019];
      if ($3 >>> 0 > $2 >>> 0) {
       break label$3
      }
      $0 = HEAP32[$2 + 8 >> 2];
      if ($3 >>> 0 > $0 >>> 0) {
       break label$3
      }
      HEAP32[$0 + 12 >> 2] = $1;
      HEAP32[$2 + 8 >> 2] = $1;
      HEAP32[$1 + 24 >> 2] = 0;
      HEAP32[$1 + 12 >> 2] = $2;
      HEAP32[$1 + 8 >> 2] = $0;
     }
     $0 = HEAP32[6018];
     if ($0 >>> 0 <= $4 >>> 0) {
      break label$2
     }
     $1 = $0 - $4 | 0;
     HEAP32[6018] = $1;
     $0 = HEAP32[6021];
     $2 = $4 + $0 | 0;
     HEAP32[6021] = $2;
     HEAP32[$2 + 4 >> 2] = $1 | 1;
     HEAP32[$0 + 4 >> 2] = $4 | 3;
     $0 = $0 + 8 | 0;
     break label$1;
    }
    abort();
    abort();
   }
   HEAP32[__errno_location() >> 2] = 48;
   $0 = 0;
  }
  global$0 = $12 + 16 | 0;
  return $0 | 0;
 }
 
 function dlfree($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  folding_inner0 : {
   label$1 : {
    label$2 : {
     if (!$0) {
      break label$2
     }
     $4 = $0 + -8 | 0;
     $6 = HEAP32[6019];
     if ($4 >>> 0 < $6 >>> 0) {
      break label$1
     }
     $1 = HEAP32[$0 + -4 >> 2];
     $3 = $1 & 3;
     if (($3 | 0) == 1) {
      break label$1
     }
     $0 = $1 & -8;
     $5 = $4 + $0 | 0;
     label$3 : {
      if ($1 & 1) {
       break label$3
      }
      if (!$3) {
       break label$2
      }
      $1 = HEAP32[$4 >> 2];
      $4 = $4 - $1 | 0;
      if ($4 >>> 0 < $6 >>> 0) {
       break label$1
      }
      $0 = $0 + $1 | 0;
      if (HEAP32[6020] != ($4 | 0)) {
       if ($1 >>> 0 <= 255) {
        $3 = HEAP32[$4 + 12 >> 2];
        $7 = $1 >>> 3 | 0;
        $1 = ($7 << 3) + 24100 | 0;
        $2 = HEAP32[$4 + 8 >> 2];
        if (HEAP32[$2 + 12 >> 2] != ($4 | 0) | $6 >>> 0 > $2 >>> 0 ? ($1 | 0) != ($2 | 0) : 0) {
         break label$1
        }
        if (($2 | 0) == ($3 | 0)) {
         HEAP32[6015] = HEAP32[6015] & __wasm_rotl_i32(-2, $7);
         break label$3;
        }
        if (HEAP32[$3 + 8 >> 2] != ($4 | 0) | $6 >>> 0 > $3 >>> 0 ? ($1 | 0) != ($3 | 0) : 0) {
         break label$1
        }
        HEAP32[$2 + 12 >> 2] = $3;
        HEAP32[$3 + 8 >> 2] = $2;
        break label$3;
       }
       $8 = HEAP32[$4 + 24 >> 2];
       $2 = HEAP32[$4 + 12 >> 2];
       label$9 : {
        if (($2 | 0) != ($4 | 0)) {
         $1 = HEAP32[$4 + 8 >> 2];
         if ($6 >>> 0 > $1 >>> 0 | HEAP32[$1 + 12 >> 2] != ($4 | 0) | HEAP32[$2 + 8 >> 2] != ($4 | 0)) {
          break label$1
         }
         HEAP32[$1 + 12 >> 2] = $2;
         HEAP32[$2 + 8 >> 2] = $1;
         break label$9;
        }
        label$11 : {
         $1 = $4 + 20 | 0;
         $3 = HEAP32[$1 >> 2];
         if ($3) {
          break label$11
         }
         $1 = $4 + 16 | 0;
         $3 = HEAP32[$1 >> 2];
         if ($3) {
          break label$11
         }
         $2 = 0;
         break label$9;
        }
        while (1) {
         $7 = $1;
         $2 = $3;
         $1 = $2 + 20 | 0;
         $3 = HEAP32[$1 >> 2];
         if ($3) {
          continue
         }
         $1 = $2 + 16 | 0;
         $3 = HEAP32[$2 + 16 >> 2];
         if ($3) {
          continue
         }
         break;
        };
        if ($6 >>> 0 > $7 >>> 0) {
         break label$1
        }
        HEAP32[$7 >> 2] = 0;
       }
       if (!$8) {
        break label$3
       }
       $3 = HEAP32[$4 + 28 >> 2];
       $1 = ($3 << 2) + 24364 | 0;
       label$13 : {
        if (HEAP32[$1 >> 2] == ($4 | 0)) {
         HEAP32[$1 >> 2] = $2;
         if ($2) {
          break label$13
         }
         HEAP32[6016] = HEAP32[6016] & __wasm_rotl_i32(-2, $3);
         break label$3;
        }
        if (HEAPU32[6019] > $8 >>> 0) {
         break label$1
        }
        HEAP32[(HEAP32[$8 + 16 >> 2] == ($4 | 0) ? 16 : 20) + $8 >> 2] = $2;
        if (!$2) {
         break label$3
        }
       }
       $3 = HEAP32[6019];
       if ($3 >>> 0 > $2 >>> 0) {
        break label$1
       }
       HEAP32[$2 + 24 >> 2] = $8;
       $1 = HEAP32[$4 + 16 >> 2];
       if ($1) {
        if ($3 >>> 0 > $1 >>> 0) {
         break label$1
        }
        HEAP32[$2 + 16 >> 2] = $1;
        HEAP32[$1 + 24 >> 2] = $2;
       }
       $1 = HEAP32[$4 + 20 >> 2];
       if (!$1) {
        break label$3
       }
       if (HEAPU32[6019] > $1 >>> 0) {
        break label$1
       }
       HEAP32[$2 + 20 >> 2] = $1;
       HEAP32[$1 + 24 >> 2] = $2;
       break label$3;
      }
      $1 = HEAP32[$5 + 4 >> 2];
      if (($1 & 3) != 3) {
       break label$3
      }
      HEAP32[6017] = $0;
      HEAP32[$5 + 4 >> 2] = $1 & -2;
      break folding_inner0;
     }
     if ($5 >>> 0 <= $4 >>> 0) {
      break label$1
     }
     $7 = HEAP32[$5 + 4 >> 2];
     if (!($7 & 1)) {
      break label$1
     }
     label$16 : {
      if (!($7 & 2)) {
       if (HEAP32[6021] == ($5 | 0)) {
        HEAP32[6021] = $4;
        $0 = HEAP32[6018] + $0 | 0;
        HEAP32[6018] = $0;
        HEAP32[$4 + 4 >> 2] = $0 | 1;
        if (HEAP32[6020] != ($4 | 0)) {
         break label$2
        }
        HEAP32[6017] = 0;
        HEAP32[6020] = 0;
        return;
       }
       if (HEAP32[6020] == ($5 | 0)) {
        HEAP32[6020] = $4;
        $0 = HEAP32[6017] + $0 | 0;
        HEAP32[6017] = $0;
        break folding_inner0;
       }
       label$20 : {
        if ($7 >>> 0 <= 255) {
         $1 = HEAP32[$5 + 12 >> 2];
         $6 = $7 >>> 3 | 0;
         $2 = ($6 << 3) + 24100 | 0;
         $3 = HEAP32[$5 + 8 >> 2];
         if (HEAP32[$3 + 12 >> 2] != ($5 | 0) | HEAPU32[6019] > $3 >>> 0 ? ($2 | 0) != ($3 | 0) : 0) {
          break label$1
         }
         if (($1 | 0) == ($3 | 0)) {
          HEAP32[6015] = HEAP32[6015] & __wasm_rotl_i32(-2, $6);
          break label$20;
         }
         if (HEAP32[$1 + 8 >> 2] != ($5 | 0) | HEAPU32[6019] > $1 >>> 0 ? ($1 | 0) != ($2 | 0) : 0) {
          break label$1
         }
         HEAP32[$3 + 12 >> 2] = $1;
         HEAP32[$1 + 8 >> 2] = $3;
         break label$20;
        }
        $8 = HEAP32[$5 + 24 >> 2];
        $2 = HEAP32[$5 + 12 >> 2];
        label$25 : {
         if (($5 | 0) != ($2 | 0)) {
          $1 = HEAP32[$5 + 8 >> 2];
          if (HEAPU32[6019] > $1 >>> 0 | HEAP32[$1 + 12 >> 2] != ($5 | 0) | HEAP32[$2 + 8 >> 2] != ($5 | 0)) {
           break label$1
          }
          HEAP32[$1 + 12 >> 2] = $2;
          HEAP32[$2 + 8 >> 2] = $1;
          break label$25;
         }
         label$27 : {
          $1 = $5 + 20 | 0;
          $3 = HEAP32[$1 >> 2];
          if ($3) {
           break label$27
          }
          $1 = $5 + 16 | 0;
          $3 = HEAP32[$1 >> 2];
          if ($3) {
           break label$27
          }
          $2 = 0;
          break label$25;
         }
         while (1) {
          $6 = $1;
          $2 = $3;
          $1 = $2 + 20 | 0;
          $3 = HEAP32[$1 >> 2];
          if ($3) {
           continue
          }
          $1 = $2 + 16 | 0;
          $3 = HEAP32[$2 + 16 >> 2];
          if ($3) {
           continue
          }
          break;
         };
         if (HEAPU32[6019] > $6 >>> 0) {
          break label$1
         }
         HEAP32[$6 >> 2] = 0;
        }
        if (!$8) {
         break label$20
        }
        $3 = HEAP32[$5 + 28 >> 2];
        $1 = ($3 << 2) + 24364 | 0;
        label$29 : {
         if (HEAP32[$1 >> 2] == ($5 | 0)) {
          HEAP32[$1 >> 2] = $2;
          if ($2) {
           break label$29
          }
          HEAP32[6016] = HEAP32[6016] & __wasm_rotl_i32(-2, $3);
          break label$20;
         }
         if (HEAPU32[6019] > $8 >>> 0) {
          break label$1
         }
         HEAP32[(HEAP32[$8 + 16 >> 2] == ($5 | 0) ? 16 : 20) + $8 >> 2] = $2;
         if (!$2) {
          break label$20
         }
        }
        $3 = HEAP32[6019];
        if ($3 >>> 0 > $2 >>> 0) {
         break label$1
        }
        HEAP32[$2 + 24 >> 2] = $8;
        $1 = HEAP32[$5 + 16 >> 2];
        if ($1) {
         if ($3 >>> 0 > $1 >>> 0) {
          break label$1
         }
         HEAP32[$2 + 16 >> 2] = $1;
         HEAP32[$1 + 24 >> 2] = $2;
        }
        $1 = HEAP32[$5 + 20 >> 2];
        if (!$1) {
         break label$20
        }
        if (HEAPU32[6019] > $1 >>> 0) {
         break label$1
        }
        HEAP32[$2 + 20 >> 2] = $1;
        HEAP32[$1 + 24 >> 2] = $2;
       }
       $0 = ($7 & -8) + $0 | 0;
       HEAP32[$4 + 4 >> 2] = $0 | 1;
       HEAP32[$0 + $4 >> 2] = $0;
       if (HEAP32[6020] != ($4 | 0)) {
        break label$16
       }
       HEAP32[6017] = $0;
       return;
      }
      HEAP32[$5 + 4 >> 2] = $7 & -2;
      HEAP32[$4 + 4 >> 2] = $0 | 1;
      HEAP32[$0 + $4 >> 2] = $0;
     }
     if ($0 >>> 0 <= 255) {
      $1 = $0 >>> 3 | 0;
      $0 = ($1 << 3) + 24100 | 0;
      $1 = 1 << $1;
      $3 = HEAP32[6015];
      label$33 : {
       if (!($1 & $3)) {
        HEAP32[6015] = $1 | $3;
        $1 = $0;
        break label$33;
       }
       $1 = HEAP32[$0 + 8 >> 2];
       if (HEAPU32[6019] > $1 >>> 0) {
        break label$1
       }
      }
      HEAP32[$0 + 8 >> 2] = $4;
      HEAP32[$1 + 12 >> 2] = $4;
      HEAP32[$4 + 12 >> 2] = $0;
      HEAP32[$4 + 8 >> 2] = $1;
      return;
     }
     HEAP32[$4 + 16 >> 2] = 0;
     HEAP32[$4 + 20 >> 2] = 0;
     $6 = $4;
     $3 = $0 >>> 8 | 0;
     $1 = 0;
     label$35 : {
      if (!$3) {
       break label$35
      }
      $1 = 31;
      if ($0 >>> 0 > 16777215) {
       break label$35
      }
      $1 = $3 + 1048320 >>> 16 & 8;
      $2 = $3 << $1;
      $3 = $2 + 520192 >>> 16 & 4;
      $2 = $2 << $3;
      $7 = $2;
      $2 = $2 + 245760 >>> 16 & 2;
      $1 = ($7 << $2 >>> 15 | 0) - ($1 | $3 | $2) | 0;
      $2 = $1 << 1;
      $1 = ($2 | $0 >>> $1 + 21 & 1) + 28 | 0;
     }
     HEAP32[$6 + 28 >> 2] = $1;
     $3 = ($1 << 2) + 24364 | 0;
     label$36 : {
      label$37 : {
       $2 = HEAP32[6016];
       $5 = 1 << $1;
       label$38 : {
        if (!($2 & $5)) {
         HEAP32[6016] = $2 | $5;
         HEAP32[$3 >> 2] = $4;
         break label$38;
        }
        $1 = $0 << (($1 | 0) == 31 ? 0 : 25 - ($1 >>> 1 | 0) | 0);
        $2 = HEAP32[$3 >> 2];
        while (1) {
         $3 = $2;
         if ((HEAP32[$2 + 4 >> 2] & -8) == ($0 | 0)) {
          break label$37
         }
         $2 = $1 >>> 29 | 0;
         $1 = $1 << 1;
         $5 = (($2 & 4) + $3 | 0) + 16 | 0;
         $2 = HEAP32[$5 >> 2];
         if ($2) {
          continue
         }
         break;
        };
        if (HEAPU32[6019] > $5 >>> 0) {
         break label$1
        }
        HEAP32[$5 >> 2] = $4;
       }
       HEAP32[$4 + 24 >> 2] = $3;
       HEAP32[$4 + 12 >> 2] = $4;
       HEAP32[$4 + 8 >> 2] = $4;
       break label$36;
      }
      $1 = HEAP32[6019];
      if ($1 >>> 0 > $3 >>> 0) {
       break label$1
      }
      $0 = HEAP32[$3 + 8 >> 2];
      if ($1 >>> 0 > $0 >>> 0) {
       break label$1
      }
      HEAP32[$0 + 12 >> 2] = $4;
      HEAP32[$3 + 8 >> 2] = $4;
      HEAP32[$4 + 24 >> 2] = 0;
      HEAP32[$4 + 12 >> 2] = $3;
      HEAP32[$4 + 8 >> 2] = $0;
     }
     $4 = HEAP32[6023] + -1 | 0;
     HEAP32[6023] = $4;
     if ($4) {
      break label$2
     }
     $4 = 24516;
     while (1) {
      $0 = HEAP32[$4 >> 2];
      $4 = $0 + 8 | 0;
      if ($0) {
       continue
      }
      break;
     };
     HEAP32[6023] = -1;
    }
    return;
   }
   abort();
   abort();
  }
  HEAP32[$4 + 4 >> 2] = $0 | 1;
  HEAP32[$0 + $4 >> 2] = $0;
 }
 
 function dlcalloc($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  $2 = 0;
  label$2 : {
   if (!$0) {
    break label$2
   }
   $3 = __wasm_i64_mul($1, 0, $0, 0);
   $4 = i64toi32_i32$HIGH_BITS;
   $2 = $3;
   if (($0 | $1) >>> 0 < 65536) {
    break label$2
   }
   $2 = $4 ? -1 : $3;
  }
  $3 = $2;
  $0 = dlmalloc($3);
  if (!(!$0 | !(HEAPU8[$0 + -4 | 0] & 3))) {
   memset($0, 0, $3)
  }
  return $0;
 }
 
 function dlrealloc($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0, $3 = 0;
  if (!$0) {
   return dlmalloc($1) | 0
  }
  if ($1 >>> 0 >= 4294967232) {
   HEAP32[__errno_location() >> 2] = 48;
   return 0;
  }
  $2 = try_realloc_chunk($0 + -8 | 0, $1 >>> 0 < 11 ? 16 : $1 + 11 & -8);
  if ($2) {
   return $2 + 8 | 0
  }
  $2 = dlmalloc($1);
  if (!$2) {
   return 0
  }
  $3 = HEAP32[$0 + -4 >> 2];
  $3 = ($3 & -8) - ($3 & 3 ? 4 : 8) | 0;
  memcpy($2, $0, $3 >>> 0 < $1 >>> 0 ? $3 : $1);
  dlfree($0);
  return $2 | 0;
 }
 
 function try_realloc_chunk($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0;
  label$1 : {
   label$2 : {
    $7 = HEAP32[6019];
    if ($7 >>> 0 > $0 >>> 0) {
     break label$2
    }
    $6 = HEAP32[$0 + 4 >> 2];
    $4 = $6 & 3;
    if (($4 | 0) == 1) {
     break label$2
    }
    $2 = $6 & -8;
    $3 = $2 + $0 | 0;
    if ($3 >>> 0 <= $0 >>> 0) {
     break label$2
    }
    $5 = HEAP32[$3 + 4 >> 2];
    if (!($5 & 1)) {
     break label$2
    }
    if (!$4) {
     $4 = 0;
     if ($1 >>> 0 < 256) {
      break label$1
     }
     if ($2 >>> 0 >= $1 + 4 >>> 0) {
      $4 = $0;
      if ($2 - $1 >>> 0 <= HEAP32[6135] << 1 >>> 0) {
       break label$1
      }
     }
     $4 = 0;
     break label$1;
    }
    if ($2 >>> 0 >= $1 >>> 0) {
     $2 = $2 - $1 | 0;
     if ($2 >>> 0 >= 16) {
      HEAP32[$0 + 4 >> 2] = $6 & 1 | $1 | 2;
      $1 = $0 + $1 | 0;
      HEAP32[$1 + 4 >> 2] = $2 | 3;
      HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] | 1;
      dispose_chunk($1, $2);
     }
     return $0;
    }
    $4 = 0;
    if (HEAP32[6021] == ($3 | 0)) {
     $3 = HEAP32[6018] + $2 | 0;
     if ($3 >>> 0 <= $1 >>> 0) {
      break label$1
     }
     HEAP32[$0 + 4 >> 2] = $6 & 1 | $1 | 2;
     $2 = $0 + $1 | 0;
     $1 = $3 - $1 | 0;
     HEAP32[$2 + 4 >> 2] = $1 | 1;
     HEAP32[6018] = $1;
     HEAP32[6021] = $2;
     return $0;
    }
    if (HEAP32[6020] == ($3 | 0)) {
     $3 = HEAP32[6017] + $2 | 0;
     if ($3 >>> 0 < $1 >>> 0) {
      break label$1
     }
     $2 = $3 - $1 | 0;
     label$9 : {
      if ($2 >>> 0 >= 16) {
       HEAP32[$0 + 4 >> 2] = $6 & 1 | $1 | 2;
       $1 = $0 + $1 | 0;
       HEAP32[$1 + 4 >> 2] = $2 | 1;
       $3 = $0 + $3 | 0;
       HEAP32[$3 >> 2] = $2;
       HEAP32[$3 + 4 >> 2] = HEAP32[$3 + 4 >> 2] & -2;
       break label$9;
      }
      HEAP32[$0 + 4 >> 2] = $6 & 1 | $3 | 2;
      $1 = $0 + $3 | 0;
      $4 = HEAP32[$1 + 4 >> 2] | 1;
      HEAP32[$1 + 4 >> 2] = $4;
      $2 = 0;
      $1 = 0;
     }
     HEAP32[6020] = $1;
     HEAP32[6017] = $2;
     return $0;
    }
    if ($5 & 2) {
     break label$1
    }
    $8 = ($5 & -8) + $2 | 0;
    if ($8 >>> 0 < $1 >>> 0) {
     break label$1
    }
    label$11 : {
     if ($5 >>> 0 <= 255) {
      $2 = HEAP32[$3 + 12 >> 2];
      $4 = HEAP32[$3 + 8 >> 2];
      $9 = $5 >>> 3 | 0;
      $5 = ($9 << 3) + 24100 | 0;
      if (HEAP32[$4 + 12 >> 2] != ($3 | 0) | $7 >>> 0 > $4 >>> 0 ? ($4 | 0) != ($5 | 0) : 0) {
       break label$2
      }
      if (($2 | 0) == ($4 | 0)) {
       HEAP32[6015] = HEAP32[6015] & __wasm_rotl_i32(-2, $9);
       break label$11;
      }
      if (HEAP32[$2 + 8 >> 2] != ($3 | 0) | $7 >>> 0 > $2 >>> 0 ? ($2 | 0) != ($5 | 0) : 0) {
       break label$2
      }
      HEAP32[$4 + 12 >> 2] = $2;
      HEAP32[$2 + 8 >> 2] = $4;
      break label$11;
     }
     $10 = HEAP32[$3 + 24 >> 2];
     $5 = HEAP32[$3 + 12 >> 2];
     label$16 : {
      if (($5 | 0) != ($3 | 0)) {
       $2 = HEAP32[$3 + 8 >> 2];
       if ($7 >>> 0 > $2 >>> 0 | HEAP32[$2 + 12 >> 2] != ($3 | 0) | HEAP32[$5 + 8 >> 2] != ($3 | 0)) {
        break label$2
       }
       HEAP32[$2 + 12 >> 2] = $5;
       HEAP32[$5 + 8 >> 2] = $2;
       break label$16;
      }
      label$18 : {
       $2 = $3 + 20 | 0;
       $4 = HEAP32[$2 >> 2];
       if ($4) {
        break label$18
       }
       $2 = $3 + 16 | 0;
       $4 = HEAP32[$2 >> 2];
       if ($4) {
        break label$18
       }
       $5 = 0;
       break label$16;
      }
      while (1) {
       $9 = $2;
       $5 = $4;
       $2 = $5 + 20 | 0;
       $4 = HEAP32[$2 >> 2];
       if ($4) {
        continue
       }
       $2 = $5 + 16 | 0;
       $4 = HEAP32[$5 + 16 >> 2];
       if ($4) {
        continue
       }
       break;
      };
      if ($7 >>> 0 > $9 >>> 0) {
       break label$2
      }
      HEAP32[$9 >> 2] = 0;
     }
     if (!$10) {
      break label$11
     }
     $4 = HEAP32[$3 + 28 >> 2];
     $2 = ($4 << 2) + 24364 | 0;
     label$20 : {
      if (HEAP32[$2 >> 2] == ($3 | 0)) {
       HEAP32[$2 >> 2] = $5;
       if ($5) {
        break label$20
       }
       HEAP32[6016] = HEAP32[6016] & __wasm_rotl_i32(-2, $4);
       break label$11;
      }
      if (HEAPU32[6019] > $10 >>> 0) {
       break label$2
      }
      HEAP32[(HEAP32[$10 + 16 >> 2] == ($3 | 0) ? 16 : 20) + $10 >> 2] = $5;
      if (!$5) {
       break label$11
      }
     }
     $4 = HEAP32[6019];
     if ($4 >>> 0 > $5 >>> 0) {
      break label$2
     }
     HEAP32[$5 + 24 >> 2] = $10;
     $2 = HEAP32[$3 + 16 >> 2];
     if ($2) {
      if ($4 >>> 0 > $2 >>> 0) {
       break label$2
      }
      HEAP32[$5 + 16 >> 2] = $2;
      HEAP32[$2 + 24 >> 2] = $5;
     }
     $3 = HEAP32[$3 + 20 >> 2];
     if (!$3) {
      break label$11
     }
     if (HEAPU32[6019] > $3 >>> 0) {
      break label$2
     }
     HEAP32[$5 + 20 >> 2] = $3;
     HEAP32[$3 + 24 >> 2] = $5;
    }
    $3 = $8 - $1 | 0;
    if ($3 >>> 0 <= 15) {
     HEAP32[$0 + 4 >> 2] = $6 & 1 | $8 | 2;
     $1 = $0 + $8 | 0;
     $4 = HEAP32[$1 + 4 >> 2] | 1;
     HEAP32[$1 + 4 >> 2] = $4;
     return $0;
    }
    HEAP32[$0 + 4 >> 2] = $6 & 1 | $1 | 2;
    $1 = $0 + $1 | 0;
    HEAP32[$1 + 4 >> 2] = $3 | 3;
    $2 = $0 + $8 | 0;
    $4 = HEAP32[$2 + 4 >> 2] | 1;
    HEAP32[$2 + 4 >> 2] = $4;
    dispose_chunk($1, $3);
    return $0;
   }
   abort();
   abort();
  }
  return $4;
 }
 
 function dispose_chunk($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  $5 = $0 + $1 | 0;
  label$1 : {
   label$2 : {
    label$3 : {
     $2 = HEAP32[$0 + 4 >> 2];
     if ($2 & 1) {
      break label$3
     }
     if (!($2 & 3)) {
      break label$2
     }
     $2 = HEAP32[$0 >> 2];
     $0 = $0 - $2 | 0;
     $7 = HEAP32[6019];
     if ($0 >>> 0 < $7 >>> 0) {
      break label$1
     }
     $1 = $1 + $2 | 0;
     if (HEAP32[6020] != ($0 | 0)) {
      if ($2 >>> 0 <= 255) {
       $4 = HEAP32[$0 + 12 >> 2];
       $6 = $2 >>> 3 | 0;
       $2 = ($6 << 3) + 24100 | 0;
       $3 = HEAP32[$0 + 8 >> 2];
       if (HEAP32[$3 + 12 >> 2] != ($0 | 0) | $7 >>> 0 > $3 >>> 0 ? ($2 | 0) != ($3 | 0) : 0) {
        break label$1
       }
       if (($3 | 0) == ($4 | 0)) {
        HEAP32[6015] = HEAP32[6015] & __wasm_rotl_i32(-2, $6);
        break label$3;
       }
       if (HEAP32[$4 + 8 >> 2] != ($0 | 0) | $7 >>> 0 > $4 >>> 0 ? ($2 | 0) != ($4 | 0) : 0) {
        break label$1
       }
       HEAP32[$3 + 12 >> 2] = $4;
       HEAP32[$4 + 8 >> 2] = $3;
       break label$3;
      }
      $8 = HEAP32[$0 + 24 >> 2];
      $3 = HEAP32[$0 + 12 >> 2];
      label$9 : {
       if (($3 | 0) != ($0 | 0)) {
        $2 = HEAP32[$0 + 8 >> 2];
        if ($7 >>> 0 > $2 >>> 0 | HEAP32[$2 + 12 >> 2] != ($0 | 0) | HEAP32[$3 + 8 >> 2] != ($0 | 0)) {
         break label$1
        }
        HEAP32[$2 + 12 >> 2] = $3;
        HEAP32[$3 + 8 >> 2] = $2;
        break label$9;
       }
       label$11 : {
        $2 = $0 + 20 | 0;
        $4 = HEAP32[$2 >> 2];
        if ($4) {
         break label$11
        }
        $2 = $0 + 16 | 0;
        $4 = HEAP32[$2 >> 2];
        if ($4) {
         break label$11
        }
        $3 = 0;
        break label$9;
       }
       while (1) {
        $6 = $2;
        $3 = $4;
        $2 = $3 + 20 | 0;
        $4 = HEAP32[$2 >> 2];
        if ($4) {
         continue
        }
        $2 = $3 + 16 | 0;
        $4 = HEAP32[$3 + 16 >> 2];
        if ($4) {
         continue
        }
        break;
       };
       if ($7 >>> 0 > $6 >>> 0) {
        break label$1
       }
       HEAP32[$6 >> 2] = 0;
      }
      if (!$8) {
       break label$3
      }
      $4 = HEAP32[$0 + 28 >> 2];
      $2 = ($4 << 2) + 24364 | 0;
      label$13 : {
       if (HEAP32[$2 >> 2] == ($0 | 0)) {
        HEAP32[$2 >> 2] = $3;
        if ($3) {
         break label$13
        }
        HEAP32[6016] = HEAP32[6016] & __wasm_rotl_i32(-2, $4);
        break label$3;
       }
       if (HEAPU32[6019] > $8 >>> 0) {
        break label$1
       }
       HEAP32[(HEAP32[$8 + 16 >> 2] == ($0 | 0) ? 16 : 20) + $8 >> 2] = $3;
       if (!$3) {
        break label$3
       }
      }
      $4 = HEAP32[6019];
      if ($4 >>> 0 > $3 >>> 0) {
       break label$1
      }
      HEAP32[$3 + 24 >> 2] = $8;
      $2 = HEAP32[$0 + 16 >> 2];
      if ($2) {
       if ($4 >>> 0 > $2 >>> 0) {
        break label$1
       }
       HEAP32[$3 + 16 >> 2] = $2;
       HEAP32[$2 + 24 >> 2] = $3;
      }
      $2 = HEAP32[$0 + 20 >> 2];
      if (!$2) {
       break label$3
      }
      if (HEAPU32[6019] > $2 >>> 0) {
       break label$1
      }
      HEAP32[$3 + 20 >> 2] = $2;
      HEAP32[$2 + 24 >> 2] = $3;
      break label$3;
     }
     $2 = HEAP32[$5 + 4 >> 2];
     if (($2 & 3) != 3) {
      break label$3
     }
     HEAP32[6017] = $1;
     HEAP32[$5 + 4 >> 2] = $2 & -2;
     HEAP32[$0 + 4 >> 2] = $1 | 1;
     HEAP32[$5 >> 2] = $1;
     return;
    }
    $8 = HEAP32[6019];
    if ($5 >>> 0 < $8 >>> 0) {
     break label$1
    }
    $7 = HEAP32[$5 + 4 >> 2];
    label$16 : {
     if (!($7 & 2)) {
      if (HEAP32[6021] == ($5 | 0)) {
       HEAP32[6021] = $0;
       $1 = HEAP32[6018] + $1 | 0;
       HEAP32[6018] = $1;
       HEAP32[$0 + 4 >> 2] = $1 | 1;
       if (HEAP32[6020] != ($0 | 0)) {
        break label$2
       }
       HEAP32[6017] = 0;
       HEAP32[6020] = 0;
       return;
      }
      if (HEAP32[6020] == ($5 | 0)) {
       HEAP32[6020] = $0;
       $1 = HEAP32[6017] + $1 | 0;
       HEAP32[6017] = $1;
       HEAP32[$0 + 4 >> 2] = $1 | 1;
       HEAP32[$0 + $1 >> 2] = $1;
       return;
      }
      label$20 : {
       if ($7 >>> 0 <= 255) {
        $2 = HEAP32[$5 + 12 >> 2];
        $6 = $7 >>> 3 | 0;
        $3 = ($6 << 3) + 24100 | 0;
        $4 = HEAP32[$5 + 8 >> 2];
        if (HEAP32[$4 + 12 >> 2] != ($5 | 0) | $8 >>> 0 > $4 >>> 0 ? ($3 | 0) != ($4 | 0) : 0) {
         break label$1
        }
        if (($2 | 0) == ($4 | 0)) {
         HEAP32[6015] = HEAP32[6015] & __wasm_rotl_i32(-2, $6);
         break label$20;
        }
        if (HEAP32[$2 + 8 >> 2] != ($5 | 0) | $8 >>> 0 > $2 >>> 0 ? ($2 | 0) != ($3 | 0) : 0) {
         break label$1
        }
        HEAP32[$4 + 12 >> 2] = $2;
        HEAP32[$2 + 8 >> 2] = $4;
        break label$20;
       }
       $9 = HEAP32[$5 + 24 >> 2];
       $3 = HEAP32[$5 + 12 >> 2];
       label$25 : {
        if (($5 | 0) != ($3 | 0)) {
         $2 = HEAP32[$5 + 8 >> 2];
         if ($8 >>> 0 > $2 >>> 0 | HEAP32[$2 + 12 >> 2] != ($5 | 0) | HEAP32[$3 + 8 >> 2] != ($5 | 0)) {
          break label$1
         }
         HEAP32[$2 + 12 >> 2] = $3;
         HEAP32[$3 + 8 >> 2] = $2;
         break label$25;
        }
        label$27 : {
         $2 = $5 + 20 | 0;
         $4 = HEAP32[$2 >> 2];
         if ($4) {
          break label$27
         }
         $2 = $5 + 16 | 0;
         $4 = HEAP32[$2 >> 2];
         if ($4) {
          break label$27
         }
         $3 = 0;
         break label$25;
        }
        while (1) {
         $6 = $2;
         $3 = $4;
         $2 = $3 + 20 | 0;
         $4 = HEAP32[$2 >> 2];
         if ($4) {
          continue
         }
         $2 = $3 + 16 | 0;
         $4 = HEAP32[$3 + 16 >> 2];
         if ($4) {
          continue
         }
         break;
        };
        if ($8 >>> 0 > $6 >>> 0) {
         break label$1
        }
        HEAP32[$6 >> 2] = 0;
       }
       if (!$9) {
        break label$20
       }
       $4 = HEAP32[$5 + 28 >> 2];
       $2 = ($4 << 2) + 24364 | 0;
       label$29 : {
        if (HEAP32[$2 >> 2] == ($5 | 0)) {
         HEAP32[$2 >> 2] = $3;
         if ($3) {
          break label$29
         }
         HEAP32[6016] = HEAP32[6016] & __wasm_rotl_i32(-2, $4);
         break label$20;
        }
        if (HEAPU32[6019] > $9 >>> 0) {
         break label$1
        }
        HEAP32[(HEAP32[$9 + 16 >> 2] == ($5 | 0) ? 16 : 20) + $9 >> 2] = $3;
        if (!$3) {
         break label$20
        }
       }
       $4 = HEAP32[6019];
       if ($4 >>> 0 > $3 >>> 0) {
        break label$1
       }
       HEAP32[$3 + 24 >> 2] = $9;
       $2 = HEAP32[$5 + 16 >> 2];
       if ($2) {
        if ($4 >>> 0 > $2 >>> 0) {
         break label$1
        }
        HEAP32[$3 + 16 >> 2] = $2;
        HEAP32[$2 + 24 >> 2] = $3;
       }
       $2 = HEAP32[$5 + 20 >> 2];
       if (!$2) {
        break label$20
       }
       if (HEAPU32[6019] > $2 >>> 0) {
        break label$1
       }
       HEAP32[$3 + 20 >> 2] = $2;
       HEAP32[$2 + 24 >> 2] = $3;
      }
      $1 = ($7 & -8) + $1 | 0;
      HEAP32[$0 + 4 >> 2] = $1 | 1;
      HEAP32[$0 + $1 >> 2] = $1;
      if (HEAP32[6020] != ($0 | 0)) {
       break label$16
      }
      HEAP32[6017] = $1;
      return;
     }
     HEAP32[$5 + 4 >> 2] = $7 & -2;
     HEAP32[$0 + 4 >> 2] = $1 | 1;
     HEAP32[$0 + $1 >> 2] = $1;
    }
    if ($1 >>> 0 <= 255) {
     $2 = $1 >>> 3 | 0;
     $1 = ($2 << 3) + 24100 | 0;
     $2 = 1 << $2;
     $4 = HEAP32[6015];
     label$33 : {
      if (!($2 & $4)) {
       HEAP32[6015] = $2 | $4;
       $2 = $1;
       break label$33;
      }
      $2 = HEAP32[$1 + 8 >> 2];
      if (HEAPU32[6019] > $2 >>> 0) {
       break label$1
      }
     }
     HEAP32[$1 + 8 >> 2] = $0;
     HEAP32[$2 + 12 >> 2] = $0;
     HEAP32[$0 + 12 >> 2] = $1;
     HEAP32[$0 + 8 >> 2] = $2;
     return;
    }
    HEAP32[$0 + 16 >> 2] = 0;
    HEAP32[$0 + 20 >> 2] = 0;
    $6 = $0;
    $4 = $1 >>> 8 | 0;
    $2 = 0;
    label$35 : {
     if (!$4) {
      break label$35
     }
     $2 = 31;
     if ($1 >>> 0 > 16777215) {
      break label$35
     }
     $2 = $4 + 1048320 >>> 16 & 8;
     $3 = $4 << $2;
     $4 = $3 + 520192 >>> 16 & 4;
     $3 = $3 << $4;
     $5 = $3;
     $3 = $3 + 245760 >>> 16 & 2;
     $2 = ($5 << $3 >>> 15 | 0) - ($2 | $4 | $3) | 0;
     $3 = $2 << 1;
     $2 = ($3 | $1 >>> $2 + 21 & 1) + 28 | 0;
    }
    HEAP32[$6 + 28 >> 2] = $2;
    $4 = ($2 << 2) + 24364 | 0;
    label$36 : {
     $3 = HEAP32[6016];
     $5 = 1 << $2;
     label$37 : {
      if (!($3 & $5)) {
       HEAP32[6016] = $3 | $5;
       HEAP32[$4 >> 2] = $0;
       break label$37;
      }
      $2 = $1 << (($2 | 0) == 31 ? 0 : 25 - ($2 >>> 1 | 0) | 0);
      $3 = HEAP32[$4 >> 2];
      while (1) {
       $4 = $3;
       if ((HEAP32[$3 + 4 >> 2] & -8) == ($1 | 0)) {
        break label$36
       }
       $3 = $2 >>> 29 | 0;
       $2 = $2 << 1;
       $5 = (($3 & 4) + $4 | 0) + 16 | 0;
       $3 = HEAP32[$5 >> 2];
       if ($3) {
        continue
       }
       break;
      };
      if (HEAPU32[6019] > $5 >>> 0) {
       break label$1
      }
      HEAP32[$5 >> 2] = $0;
     }
     HEAP32[$0 + 24 >> 2] = $4;
     HEAP32[$0 + 12 >> 2] = $0;
     HEAP32[$0 + 8 >> 2] = $0;
     return;
    }
    $2 = HEAP32[6019];
    if ($2 >>> 0 > $4 >>> 0) {
     break label$1
    }
    $1 = HEAP32[$4 + 8 >> 2];
    if ($2 >>> 0 > $1 >>> 0) {
     break label$1
    }
    HEAP32[$1 + 12 >> 2] = $0;
    HEAP32[$4 + 8 >> 2] = $0;
    HEAP32[$0 + 24 >> 2] = 0;
    HEAP32[$0 + 12 >> 2] = $4;
    HEAP32[$0 + 8 >> 2] = $1;
   }
   return;
  }
  abort();
  abort();
 }
 
 function sbrk($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  $1 = emscripten_get_sbrk_ptr();
  $3 = __wasm_memory_size();
  label$1 : {
   $2 = HEAP32[$1 >> 2];
   $0 = $2 + ($0 + 3 & -4) | 0;
   if ($0 >>> 0 <= $3 << 16 >>> 0) {
    break label$1
   }
   if (emscripten_resize_heap($0 | 0)) {
    break label$1
   }
   HEAP32[__errno_location() >> 2] = 48;
   return -1;
  }
  HEAP32[$1 >> 2] = $0;
  return $2;
 }
 
 function fmod($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0;
  wasm2js_scratch_store_f64(+$1);
  $4 = wasm2js_scratch_load_i32(1) | 0;
  $13 = wasm2js_scratch_load_i32(0) | 0;
  $15 = $4;
  $6 = $13;
  $3 = $4 << 1 | $6 >>> 31;
  $7 = $6 << 1;
  $11 = $3;
  label$1 : {
   label$2 : {
    if (!($3 | $7)) {
     break label$2
    }
    $3 = $15;
    $6 = $3 & 2147483647;
    $4 = $13;
    $3 = $4;
    if (($6 | 0) == 2146435072 & $3 >>> 0 > 0 | $6 >>> 0 > 2146435072) {
     break label$2
    }
    wasm2js_scratch_store_f64(+$0);
    $3 = wasm2js_scratch_load_i32(1) | 0;
    $5 = wasm2js_scratch_load_i32(0) | 0;
    $16 = $3;
    $9 = $3 >>> 20 & 2047;
    if (($9 | 0) != 2047) {
     break label$1
    }
   }
   $1 = $0 * $1;
   return $1 / $1;
  }
  $6 = $16;
  $3 = $5;
  $2 = $6 << 1 | $3 >>> 31;
  $10 = $3 << 1;
  $3 = $11;
  $12 = $2;
  $6 = $10;
  $4 = $7;
  if (($3 | 0) == ($2 | 0) & $6 >>> 0 > $4 >>> 0 | $2 >>> 0 > $3 >>> 0) {
   $6 = $15;
   $14 = $6 >>> 20 & 2047;
   label$4 : {
    if (!$9) {
     $9 = 0;
     $6 = $5;
     $7 = $6 << 12;
     $2 = $16;
     $4 = $2 << 12 | $6 >>> 20;
     $11 = $4;
     $2 = $7;
     if (($4 | 0) > 0 ? 1 : ($4 | 0) >= 0 ? ($2 >>> 0 < 0 ? 0 : 1) : 0) {
      while (1) {
       $9 = $9 + -1 | 0;
       $3 = $7;
       $7 = $3 << 1;
       $2 = $11;
       $4 = $2 << 1 | $3 >>> 31;
       $11 = $4;
       $2 = $7;
       if (($4 | 0) > -1 ? 1 : ($4 | 0) >= -1 ? ($2 >>> 0 <= 4294967295 ? 0 : 1) : 0) {
        continue
       }
       break;
      }
     }
     $2 = $16;
     $6 = $5;
     $3 = 1 - $9 | 0;
     $5 = $3 & 31;
     if (32 <= ($3 & 63) >>> 0) {
      $4 = $6 << $5;
      $7 = 0;
     } else {
      $4 = (1 << $5) - 1 & $6 >>> 32 - $5 | $2 << $5;
      $7 = $6 << $5;
     }
     $2 = $4;
     break label$4;
    }
    $4 = $16;
    $6 = $4 & 1048575;
    $2 = $5;
    $7 = $2;
    $2 = $6 | 1048576;
   }
   $11 = $2;
   $8 = $7;
   $17 = $2;
   label$8 : {
    if (!$14) {
     $14 = 0;
     $6 = $13;
     $10 = $6 << 12;
     $2 = $15;
     $4 = $2 << 12 | $6 >>> 20;
     $12 = $4;
     $2 = $10;
     if (($4 | 0) > 0 ? 1 : ($4 | 0) >= 0 ? ($2 >>> 0 < 0 ? 0 : 1) : 0) {
      while (1) {
       $14 = $14 + -1 | 0;
       $3 = $10;
       $10 = $3 << 1;
       $2 = $12;
       $4 = $2 << 1 | $3 >>> 31;
       $12 = $4;
       $2 = $10;
       if (($4 | 0) > -1 ? 1 : ($4 | 0) >= -1 ? ($2 >>> 0 <= 4294967295 ? 0 : 1) : 0) {
        continue
       }
       break;
      }
     }
     $2 = $15;
     $6 = $13;
     $3 = 1 - $14 | 0;
     $5 = $3 & 31;
     if (32 <= ($3 & 63) >>> 0) {
      $4 = $6 << $5;
      $13 = 0;
     } else {
      $4 = (1 << $5) - 1 & $6 >>> 32 - $5 | $2 << $5;
      $13 = $6 << $5;
     }
     $2 = $4;
     break label$8;
    }
    $4 = $15;
    $6 = $4 & 1048575;
    $2 = $13;
    $13 = $2;
    $2 = $6 | 1048576;
   }
   $15 = $2;
   $6 = $8;
   $3 = $13;
   $5 = $6 - $3 | 0;
   $10 = $5;
   $2 = $17;
   $4 = $15;
   $8 = $4 + ($6 >>> 0 < $3 >>> 0) | 0;
   $8 = $2 - $8 | 0;
   $12 = $8;
   $2 = $5;
   $2 = ($8 | 0) > -1 ? 1 : ($8 | 0) >= -1 ? ($2 >>> 0 <= 4294967295 ? 0 : 1) : 0;
   if (($9 | 0) > ($14 | 0)) {
    while (1) {
     label$14 : {
      if (!$2) {
       break label$14
      }
      $2 = $12;
      $11 = $2;
      $7 = $10;
      $3 = $7;
      if ($3 | $2) {
       break label$14
      }
      return $0 * 0.0;
     }
     $3 = $11;
     $6 = $7;
     $2 = $3 << 1 | $6 >>> 31;
     $7 = $6 << 1;
     $3 = $7;
     $8 = $13;
     $4 = $3 - $8 | 0;
     $10 = $4;
     $11 = $2;
     $6 = $15;
     $5 = $6 + ($3 >>> 0 < $8 >>> 0) | 0;
     $5 = $2 - $5 | 0;
     $12 = $5;
     $2 = $4;
     $2 = ($5 | 0) > -1 ? 1 : ($5 | 0) >= -1 ? ($2 >>> 0 <= 4294967295 ? 0 : 1) : 0;
     $9 = $9 + -1 | 0;
     if (($9 | 0) > ($14 | 0)) {
      continue
     }
     break;
    };
    $9 = $14;
   }
   label$15 : {
    if (!$2) {
     break label$15
    }
    $2 = $12;
    $11 = $2;
    $7 = $10;
    if ($7 | $2) {
     break label$15
    }
    return $0 * 0.0;
   }
   $8 = $11;
   $3 = $7;
   label$16 : {
    if (($8 | 0) == 1048575 & $3 >>> 0 > 4294967295 | $8 >>> 0 > 1048575) {
     $10 = $7;
     $3 = $11;
     $12 = $3;
     break label$16;
    }
    while (1) {
     $9 = $9 + -1 | 0;
     $3 = $11;
     $5 = $7;
     $14 = ($3 | 0) == 524288 & $5 >>> 0 < 0 | $3 >>> 0 < 524288;
     $2 = $5;
     $10 = $2 << 1;
     $3 = $3 << 1 | $2 >>> 31;
     $12 = $3;
     $7 = $10;
     $11 = $3;
     if ($14) {
      continue
     }
     break;
    };
   }
   if (($9 | 0) >= 1) {
    $3 = $12;
    $4 = $3 + -1048576 | 0;
    $5 = $10;
    $6 = $5;
    if ($6 >>> 0 < 0) {
     $4 = $4 + 1 | 0
    }
    $2 = $4;
    $4 = $6;
    $7 = $4 | 0;
    $3 = $9;
    $5 = $3 << 20;
    $3 = $5;
    $5 = $2;
    $3 = $3 | $5;
    $2 = $3;
   } else {
    $3 = $12;
    $5 = $10;
    $4 = 0;
    $8 = 1 - $9 | 0;
    $2 = $8 & 31;
    if (32 <= ($8 & 63) >>> 0) {
     $7 = $3 >>> $2 | 0
    } else {
     $4 = $3 >>> $2 | 0;
     $7 = ((1 << $2) - 1 & $3) << 32 - $2 | $5 >>> $2;
    }
    $2 = $4;
   }
   $4 = $16;
   $5 = $4 & -2147483648;
   $3 = $5;
   $5 = $2;
   $3 = $3 | $5;
   $4 = $7;
   $8 = 0;
   wasm2js_scratch_store_i32(0, $4 | $8);
   wasm2js_scratch_store_i32(1, $3 | 0);
   return +wasm2js_scratch_load_f64();
  }
  $5 = $7;
  $8 = $10;
  $4 = $12;
  return ($5 | 0) == ($8 | 0) & ($4 | 0) == ($11 | 0) ? $0 * 0.0 : $0;
 }
 
 function fmodl($0, $1, $2, $3, $4, $5, $6, $7, $8) {
  var $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
  $16 = global$0 - 128 | 0;
  global$0 = $16;
  label$1 : {
   label$2 : {
    $11 = $6;
    $10 = $8;
    label$3 : {
     if (!__letf2($5, $11, $7, $10, 0, 0, 0, 0)) {
      break label$3
     }
     $9 = $6;
     $12 = $8;
     $14 = __fpclassifyl($5, $9, $7, $12);
     $12 = $4;
     $24 = $12 >>> 16 | 0;
     $18 = $24 & 32767;
     if (($18 | 0) == 32767) {
      break label$3
     }
     if ($14) {
      break label$2
     }
    }
    $9 = $2;
    $10 = $4;
    $12 = $6;
    $11 = $8;
    __multf3($16 + 16 | 0, $1, $9, $3, $10, $5, $12, $7, $11);
    $10 = $16;
    $11 = HEAP32[$10 + 16 >> 2];
    $7 = $11;
    $12 = HEAP32[$10 + 20 >> 2];
    $8 = $12;
    $11 = HEAP32[$10 + 28 >> 2];
    $6 = $11;
    $12 = HEAP32[$10 + 24 >> 2];
    $5 = $12;
    $11 = $8;
    $12 = $6;
    $10 = $11;
    $9 = $12;
    __divtf3($16, $7, $10, $5, $9, $7, $10, $5, $9);
    $12 = $16;
    $9 = HEAP32[$12 + 8 >> 2];
    $3 = $9;
    $10 = HEAP32[$12 + 12 >> 2];
    $4 = $10;
    $10 = HEAP32[$12 >> 2];
    $7 = $10;
    $9 = HEAP32[$12 + 4 >> 2];
    $8 = $9;
    break label$1;
   }
   $9 = $4;
   $10 = $9 & 65535;
   $9 = $18;
   $12 = $9 << 16;
   $9 = $12;
   $9 = $10 | $9;
   $17 = $9;
   $11 = 0;
   $10 = $3;
   $15 = $11 | $10;
   $9 = $8;
   $10 = $9 & 65535;
   $8 = $10;
   $12 = $7;
   $20 = 0 | $12;
   $22 = $9 >>> 16 & 32767;
   $10 = $22;
   $9 = $10 << 16;
   $10 = $9;
   $9 = $8;
   $10 = $10 | $9;
   $19 = $10;
   $10 = $2;
   $12 = $17;
   $9 = $6;
   $11 = $19;
   if ((__letf2($1, $10, $15, $12, $5, $9, $20, $11) | 0) <= 0) {
    $11 = $2;
    $9 = $17;
    $12 = $6;
    $10 = $19;
    if (__letf2($1, $11, $15, $9, $5, $12, $20, $10)) {
     $7 = $1;
     $10 = $2;
     $8 = $10;
     break label$1;
    }
    $10 = $2;
    $12 = $4;
    __multf3($16 + 112 | 0, $1, $10, $3, $12, 0, 0, 0, 0);
    $12 = $16;
    $11 = HEAP32[$12 + 120 >> 2];
    $3 = $11;
    $9 = HEAP32[$12 + 124 >> 2];
    $4 = $9;
    $9 = HEAP32[$12 + 112 >> 2];
    $7 = $9;
    $11 = HEAP32[$12 + 116 >> 2];
    $8 = $11;
    break label$1;
   }
   if ($18) {
    $7 = $1;
    $11 = $2;
    $9 = $11;
   } else {
    $11 = $2;
    $9 = $17;
    __multf3($16 + 96 | 0, $1, $11, $15, $9, 0, 0, 0, 1081540608);
    $12 = HEAP32[$16 + 108 >> 2];
    $17 = $12;
    $9 = $16;
    $10 = HEAP32[$9 + 104 >> 2];
    $15 = $10;
    $18 = ($12 >>> 16 | 0) + -120 | 0;
    $10 = HEAP32[$9 + 96 >> 2];
    $7 = $10;
    $9 = HEAP32[$9 + 100 >> 2];
   }
   $8 = $9;
   if (!$22) {
    $9 = $6;
    $10 = $19;
    __multf3($16 + 80 | 0, $5, $9, $20, $10, 0, 0, 0, 1081540608);
    $12 = HEAP32[$16 + 92 >> 2];
    $19 = $12;
    $10 = $16;
    $11 = HEAP32[$10 + 88 >> 2];
    $20 = $11;
    $22 = ($12 >>> 16 | 0) + -120 | 0;
    $11 = HEAP32[$10 + 80 >> 2];
    $5 = $11;
    $10 = HEAP32[$10 + 84 >> 2];
    $6 = $10;
   }
   $10 = $17;
   $11 = $10 & 65535;
   $12 = $15;
   $10 = $12;
   $15 = $10;
   $12 = $11 | 65536;
   $17 = $12;
   $12 = $19;
   $10 = $12 & 65535;
   $11 = $20;
   $12 = $11;
   $26 = $11;
   $11 = $10 | 65536;
   $25 = $11;
   $10 = $15;
   $9 = $12;
   $14 = $10 - $9 | 0;
   $11 = $17;
   $12 = $25;
   $13 = $12 + ($10 >>> 0 < $9 >>> 0) | 0;
   $13 = $11 - $13 | 0;
   $19 = $13;
   $10 = $6;
   $13 = $8;
   $11 = $7;
   $9 = $5;
   $10 = ($10 | 0) == ($13 | 0) & $11 >>> 0 < $9 >>> 0 | $13 >>> 0 < $10 >>> 0;
   $9 = $14;
   $12 = $9 - $10 | 0;
   $21 = $12;
   $11 = $19;
   $14 = $9 >>> 0 < $10 >>> 0;
   $14 = $11 - $14 | 0;
   $23 = $14;
   $11 = $12;
   $14 = ($14 | 0) > -1 ? 1 : ($14 | 0) >= -1 ? ($11 >>> 0 <= 4294967295 ? 0 : 1) : 0;
   $10 = $7;
   $9 = $5;
   $13 = $10 - $9 | 0;
   $20 = $13;
   $11 = $8;
   $12 = $6 + ($10 >>> 0 < $9 >>> 0) | 0;
   $12 = $11 - $12 | 0;
   $19 = $12;
   if (($18 | 0) > ($22 | 0)) {
    while (1) {
     label$11 : {
      if ($14 & 1) {
       $10 = $23;
       $12 = $19;
       $10 = $10 | $12;
       $11 = $20;
       $9 = $21;
       if (!($10 | ($11 | $9))) {
        $10 = $2;
        $11 = $4;
        __multf3($16 + 32 | 0, $1, $10, $3, $11, 0, 0, 0, 0);
        $11 = $16;
        $9 = HEAP32[$11 + 40 >> 2];
        $3 = $9;
        $12 = HEAP32[$11 + 44 >> 2];
        $4 = $12;
        $12 = HEAP32[$11 + 32 >> 2];
        $7 = $12;
        $9 = HEAP32[$11 + 36 >> 2];
        $8 = $9;
        break label$1;
       }
       $9 = $19;
       $15 = $9 >>> 31 | 0;
       $12 = 0;
       $17 = $12;
       $9 = $21;
       $21 = $9 << 1;
       $12 = $23;
       $11 = $12 << 1 | $9 >>> 31;
       $12 = $11;
       $14 = 1;
       break label$11;
      }
      $20 = $7;
      $11 = $8;
      $19 = $11;
      $12 = $15;
      $15 = $12 << 1;
      $11 = $17;
      $9 = $11 << 1 | $12 >>> 31;
      $17 = $9;
      $9 = $8;
      $21 = $9 >>> 31 | 0;
      $12 = 0;
      $14 = 31;
     }
     $11 = $12;
     $12 = $17;
     $11 = $11 | $12;
     $17 = $11;
     $10 = $21;
     $9 = $15;
     $15 = $10 | $9;
     $12 = $15;
     $10 = $26;
     $14 = $12 - $10 | 0;
     $9 = $25;
     $13 = $9 + ($12 >>> 0 < $10 >>> 0) | 0;
     $13 = $11 - $13 | 0;
     $23 = $13;
     $13 = $19;
     $11 = $20;
     $12 = $13 << 1 | $11 >>> 31;
     $7 = $11 << 1;
     $11 = $6;
     $8 = $12;
     $13 = $7;
     $10 = $5;
     $11 = ($11 | 0) == ($12 | 0) & $13 >>> 0 < $10 >>> 0 | $12 >>> 0 < $11 >>> 0;
     $10 = $14;
     $9 = $10 - $11 | 0;
     $21 = $9;
     $13 = $23;
     $14 = $10 >>> 0 < $11 >>> 0;
     $14 = $13 - $14 | 0;
     $23 = $14;
     $14 = ($14 | 0) > -1 ? 1 : ($14 | 0) >= -1 ? ($9 >>> 0 <= 4294967295 ? 0 : 1) : 0;
     $11 = $7;
     $10 = $5;
     $12 = $11 - $10 | 0;
     $20 = $12;
     $13 = $8;
     $9 = $6 + ($11 >>> 0 < $10 >>> 0) | 0;
     $9 = $13 - $9 | 0;
     $19 = $9;
     $18 = $18 + -1 | 0;
     if (($18 | 0) > ($22 | 0)) {
      continue
     }
     break;
    };
    $18 = $22;
   }
   label$14 : {
    if (!$14) {
     break label$14
    }
    $9 = $19;
    $8 = $9;
    $9 = $23;
    $17 = $9;
    $11 = $9;
    $9 = $8;
    $11 = $11 | $9;
    $15 = $21;
    $10 = $15;
    $7 = $20;
    $13 = $7;
    $9 = $10 | $13;
    if ($9 | $11) {
     break label$14
    }
    $9 = $2;
    $11 = $4;
    __multf3($16 + 48 | 0, $1, $9, $3, $11, 0, 0, 0, 0);
    $11 = $16;
    $13 = HEAP32[$11 + 56 >> 2];
    $3 = $13;
    $10 = HEAP32[$11 + 60 >> 2];
    $4 = $10;
    $10 = HEAP32[$11 + 48 >> 2];
    $7 = $10;
    $13 = HEAP32[$11 + 52 >> 2];
    $8 = $13;
    break label$1;
   }
   $13 = $17;
   $11 = $15;
   if (($13 | 0) == 65535 & $11 >>> 0 <= 4294967295 | $13 >>> 0 < 65535) {
    while (1) {
     $9 = $7;
     $11 = $8;
     $5 = $11 >>> 31 | 0;
     $13 = 0;
     $6 = $13;
     $18 = $18 + -1 | 0;
     $7 = $9 << 1;
     $13 = $8;
     $9 = $13 << 1 | $9 >>> 31;
     $8 = $9;
     $13 = $15;
     $9 = $17;
     $11 = $9 << 1 | $13 >>> 31;
     $1 = $11;
     $10 = $13 << 1;
     $9 = $5;
     $15 = $10 | $9;
     $11 = $6;
     $13 = $1;
     $13 = $11 | $13;
     $17 = $13;
     $11 = $15;
     if (($13 | 0) == 65536 & $11 >>> 0 < 0 | $13 >>> 0 < 65536) {
      continue
     }
     break;
    }
   }
   $14 = $24 & 32768;
   if (($18 | 0) <= 0) {
    $11 = $17;
    $13 = $11 & 65535;
    $11 = $18 + 120 | $14;
    $10 = $11 << 16;
    $11 = $10;
    $10 = $13;
    $11 = $11 | $10;
    $1 = $11;
    $11 = $8;
    $9 = 0;
    $13 = $15;
    $2 = $9 | $13;
    $13 = $1;
    __multf3($16 - -64 | 0, $7, $11, $2, $13, 0, 0, 0, 1065811968);
    $13 = $16;
    $9 = HEAP32[$13 + 72 >> 2];
    $3 = $9;
    $10 = HEAP32[$13 + 76 >> 2];
    $4 = $10;
    $10 = HEAP32[$13 + 64 >> 2];
    $7 = $10;
    $9 = HEAP32[$13 + 68 >> 2];
    $8 = $9;
    break label$1;
   }
   $9 = $17;
   $10 = $9 & 65535;
   $1 = $10;
   $11 = 0;
   $13 = $15;
   $10 = $13;
   $3 = $11 | $10;
   $9 = $18 | $14;
   $13 = $9 << 16;
   $9 = $13;
   $13 = $1;
   $9 = $9 | $13;
   $4 = $9;
  }
  $10 = $0;
  HEAP32[$10 >> 2] = $7;
  $9 = $8;
  HEAP32[$10 + 4 >> 2] = $9;
  HEAP32[$10 + 8 >> 2] = $3;
  $9 = $4;
  HEAP32[$10 + 12 >> 2] = $9;
  global$0 = $16 + 128 | 0;
 }
 
 function log10($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0.0, $5 = 0.0, $6 = 0, $7 = 0.0, $8 = 0.0, $9 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0;
  wasm2js_scratch_store_f64(+$0);
  $2 = wasm2js_scratch_load_i32(1) | 0;
  $3 = wasm2js_scratch_load_i32(0) | 0;
  label$1 : {
   label$2 : {
    label$3 : {
     label$4 : {
      if (($2 | 0) > 0 ? 1 : ($2 | 0) >= 0 ? ($3 >>> 0 < 0 ? 0 : 1) : 0) {
       $1 = $2;
       if ($2 >>> 0 > 1048575) {
        break label$4
       }
      }
      $1 = $2 & 2147483647;
      if (!($1 | $3)) {
       return -1.0 / ($0 * $0)
      }
      if (($2 | 0) > -1 ? 1 : ($2 | 0) >= -1 ? ($3 >>> 0 <= 4294967295 ? 0 : 1) : 0) {
       break label$3
      }
      return ($0 - $0) / 0.0;
     }
     if ($1 >>> 0 > 2146435071) {
      break label$1
     }
     $6 = 1072693248;
     $9 = -1023;
     if (($1 | 0) != 1072693248) {
      $6 = $1;
      break label$2;
     }
     if ($3) {
      break label$2
     }
     return 0.0;
    }
    wasm2js_scratch_store_f64(+($0 * 18014398509481984.0));
    $2 = wasm2js_scratch_load_i32(1) | 0;
    $3 = wasm2js_scratch_load_i32(0) | 0;
    $6 = $2;
    $9 = -1077;
   }
   $1 = $6 + 614242 | 0;
   $10 = +(($1 >>> 20 | 0) + $9 | 0);
   $4 = $10 * .30102999566361177;
   $1 = ($1 & 1048575) + 1072079006 | 0;
   $2 = 0;
   $1 = $2 | $1;
   wasm2js_scratch_store_i32(0, $3 | 0);
   wasm2js_scratch_store_i32(1, $1 | 0);
   $0 = +wasm2js_scratch_load_f64() + -1.0;
   $5 = $0 * .5;
   $7 = $0 * $5;
   wasm2js_scratch_store_f64(+($0 - $7));
   $1 = wasm2js_scratch_load_i32(1) | 0;
   wasm2js_scratch_load_i32(0) | 0;
   wasm2js_scratch_store_i32(0, 0);
   wasm2js_scratch_store_i32(1, $1 | 0);
   $8 = +wasm2js_scratch_load_f64();
   $5 = $8 * .4342944818781689;
   $11 = $4 + $5;
   $4 = $4 - $11;
   $12 = $5 + $4;
   $13 = $0 - $8 - $7;
   $0 = $0 / ($0 + 2.0);
   $5 = $0;
   $4 = $0 * $0;
   $0 = $4 * $4;
   $0 = $13 + $5 * ($7 + ($0 * ($0 * ($0 * .15313837699209373 + .22222198432149784) + .3999999999940942) + $4 * ($0 * ($0 * ($0 * .14798198605116586 + .1818357216161805) + .2857142874366239) + .6666666666666735)));
   $0 = $11 + ($12 + ($0 * .4342944818781689 + ($10 * 3.694239077158931e-13 + ($0 + $8) * 2.5082946711645275e-11)));
  }
  return $0;
 }
 
 function scalbn($0, $1) {
  label$1 : {
   if (($1 | 0) >= 1024) {
    $0 = $0 * 8988465674311579538646525.0e283;
    if (($1 | 0) < 2047) {
     $1 = $1 + -1023 | 0;
     break label$1;
    }
    $0 = $0 * 8988465674311579538646525.0e283;
    $1 = (($1 | 0) < 3069 ? $1 : 3069) + -2046 | 0;
    break label$1;
   }
   if (($1 | 0) > -1023) {
    break label$1
   }
   $0 = $0 * 2.2250738585072014e-308;
   if (($1 | 0) > -2045) {
    $1 = $1 + 1022 | 0;
    break label$1;
   }
   $0 = $0 * 2.2250738585072014e-308;
   $1 = (($1 | 0) > -3066 ? $1 : -3066) + 2044 | 0;
  }
  $1 = $1 + 1023 << 20;
  wasm2js_scratch_store_i32(0, 0);
  wasm2js_scratch_store_i32(1, $1 | 0);
  return $0 * +wasm2js_scratch_load_f64();
 }
 
 function __fpclassifyl($0, $1, $2, $3) {
  var $4 = 0, $5 = 0;
  $4 = $3 & 65535;
  $5 = $3 >>> 16 & 32767;
  label$1 : {
   if (($5 | 0) != 32767) {
    $3 = 4;
    if ($5) {
     break label$1
    }
    return $0 | $2 | ($1 | $4) ? 3 : 2;
   }
   $3 = !($0 | $2 | ($1 | $4));
  }
  return $3;
 }
 
 function memcpy($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0;
  if ($2 >>> 0 >= 512) {
   emscripten_memcpy_big($0 | 0, $1 | 0, $2 | 0) | 0;
   return $0;
  }
  $4 = $0 + $2 | 0;
  label$2 : {
   if (!(($0 ^ $1) & 3)) {
    label$4 : {
     if (($2 | 0) < 1) {
      $2 = $0;
      break label$4;
     }
     if (!($0 & 3)) {
      $2 = $0;
      break label$4;
     }
     $2 = $0;
     while (1) {
      HEAP8[$2 | 0] = HEAPU8[$1 | 0];
      $1 = $1 + 1 | 0;
      $2 = $2 + 1 | 0;
      if ($2 >>> 0 >= $4 >>> 0) {
       break label$4
      }
      if ($2 & 3) {
       continue
      }
      break;
     };
    }
    $3 = $4 & -4;
    label$8 : {
     if ($3 >>> 0 < 64) {
      break label$8
     }
     $5 = $3 + -64 | 0;
     if ($2 >>> 0 > $5 >>> 0) {
      break label$8
     }
     while (1) {
      HEAP32[$2 >> 2] = HEAP32[$1 >> 2];
      HEAP32[$2 + 4 >> 2] = HEAP32[$1 + 4 >> 2];
      HEAP32[$2 + 8 >> 2] = HEAP32[$1 + 8 >> 2];
      HEAP32[$2 + 12 >> 2] = HEAP32[$1 + 12 >> 2];
      HEAP32[$2 + 16 >> 2] = HEAP32[$1 + 16 >> 2];
      HEAP32[$2 + 20 >> 2] = HEAP32[$1 + 20 >> 2];
      HEAP32[$2 + 24 >> 2] = HEAP32[$1 + 24 >> 2];
      HEAP32[$2 + 28 >> 2] = HEAP32[$1 + 28 >> 2];
      HEAP32[$2 + 32 >> 2] = HEAP32[$1 + 32 >> 2];
      HEAP32[$2 + 36 >> 2] = HEAP32[$1 + 36 >> 2];
      HEAP32[$2 + 40 >> 2] = HEAP32[$1 + 40 >> 2];
      HEAP32[$2 + 44 >> 2] = HEAP32[$1 + 44 >> 2];
      HEAP32[$2 + 48 >> 2] = HEAP32[$1 + 48 >> 2];
      HEAP32[$2 + 52 >> 2] = HEAP32[$1 + 52 >> 2];
      HEAP32[$2 + 56 >> 2] = HEAP32[$1 + 56 >> 2];
      HEAP32[$2 + 60 >> 2] = HEAP32[$1 + 60 >> 2];
      $1 = $1 - -64 | 0;
      $2 = $2 - -64 | 0;
      if ($2 >>> 0 <= $5 >>> 0) {
       continue
      }
      break;
     };
    }
    if ($2 >>> 0 >= $3 >>> 0) {
     break label$2
    }
    while (1) {
     HEAP32[$2 >> 2] = HEAP32[$1 >> 2];
     $1 = $1 + 4 | 0;
     $2 = $2 + 4 | 0;
     if ($2 >>> 0 < $3 >>> 0) {
      continue
     }
     break;
    };
    break label$2;
   }
   if ($4 >>> 0 < 4) {
    $2 = $0;
    break label$2;
   }
   $3 = $4 + -4 | 0;
   if ($3 >>> 0 < $0 >>> 0) {
    $2 = $0;
    break label$2;
   }
   $2 = $0;
   while (1) {
    HEAP8[$2 | 0] = HEAPU8[$1 | 0];
    HEAP8[$2 + 1 | 0] = HEAPU8[$1 + 1 | 0];
    HEAP8[$2 + 2 | 0] = HEAPU8[$1 + 2 | 0];
    HEAP8[$2 + 3 | 0] = HEAPU8[$1 + 3 | 0];
    $1 = $1 + 4 | 0;
    $2 = $2 + 4 | 0;
    if ($2 >>> 0 <= $3 >>> 0) {
     continue
    }
    break;
   };
  }
  if ($2 >>> 0 < $4 >>> 0) {
   while (1) {
    HEAP8[$2 | 0] = HEAPU8[$1 | 0];
    $1 = $1 + 1 | 0;
    $2 = $2 + 1 | 0;
    if (($4 | 0) != ($2 | 0)) {
     continue
    }
    break;
   }
  }
  return $0;
 }
 
 function memset($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  label$1 : {
   if (!$2) {
    break label$1
   }
   $3 = $0 + $2 | 0;
   HEAP8[$3 + -1 | 0] = $1;
   HEAP8[$0 | 0] = $1;
   if ($2 >>> 0 < 3) {
    break label$1
   }
   HEAP8[$3 + -2 | 0] = $1;
   HEAP8[$0 + 1 | 0] = $1;
   HEAP8[$3 + -3 | 0] = $1;
   HEAP8[$0 + 2 | 0] = $1;
   if ($2 >>> 0 < 7) {
    break label$1
   }
   HEAP8[$3 + -4 | 0] = $1;
   HEAP8[$0 + 3 | 0] = $1;
   if ($2 >>> 0 < 9) {
    break label$1
   }
   $4 = 0 - $0 & 3;
   $3 = $4 + $0 | 0;
   $1 = Math_imul($1 & 255, 16843009);
   HEAP32[$3 >> 2] = $1;
   $4 = $2 - $4 & -4;
   $2 = $4 + $3 | 0;
   HEAP32[$2 + -4 >> 2] = $1;
   if ($4 >>> 0 < 9) {
    break label$1
   }
   HEAP32[$3 + 8 >> 2] = $1;
   HEAP32[$3 + 4 >> 2] = $1;
   HEAP32[$2 + -8 >> 2] = $1;
   HEAP32[$2 + -12 >> 2] = $1;
   if ($4 >>> 0 < 25) {
    break label$1
   }
   HEAP32[$3 + 24 >> 2] = $1;
   HEAP32[$3 + 20 >> 2] = $1;
   HEAP32[$3 + 16 >> 2] = $1;
   HEAP32[$3 + 12 >> 2] = $1;
   HEAP32[$2 + -16 >> 2] = $1;
   HEAP32[$2 + -20 >> 2] = $1;
   HEAP32[$2 + -24 >> 2] = $1;
   HEAP32[$2 + -28 >> 2] = $1;
   $2 = $4;
   $4 = $3 & 4 | 24;
   $2 = $2 - $4 | 0;
   if ($2 >>> 0 < 32) {
    break label$1
   }
   $6 = $1;
   $5 = $1;
   $7 = $1;
   $1 = $3 + $4 | 0;
   while (1) {
    HEAP32[$1 + 24 >> 2] = $5;
    HEAP32[$1 + 28 >> 2] = $7;
    HEAP32[$1 + 16 >> 2] = $5;
    HEAP32[$1 + 20 >> 2] = $6;
    HEAP32[$1 + 8 >> 2] = $5;
    HEAP32[$1 + 12 >> 2] = $6;
    HEAP32[$1 >> 2] = $5;
    HEAP32[$1 + 4 >> 2] = $6;
    $1 = $1 + 32 | 0;
    $2 = $2 + -32 | 0;
    if ($2 >>> 0 > 31) {
     continue
    }
    break;
   };
  }
  return $0;
 }
 
 function memmove($0, $1, $2) {
  var $3 = 0, $4 = 0;
  label$1 : {
   if (($0 | 0) == ($1 | 0)) {
    break label$1
   }
   label$2 : {
    if ($1 + $2 >>> 0 > $0 >>> 0) {
     $4 = $0 + $2 | 0;
     if ($4 >>> 0 > $1 >>> 0) {
      break label$2
     }
    }
    return memcpy($0, $1, $2);
   }
   $3 = ($0 ^ $1) & 3;
   label$4 : {
    label$5 : {
     if ($0 >>> 0 < $1 >>> 0) {
      if ($3) {
       $3 = $0;
       break label$4;
      }
      if (!($0 & 3)) {
       $3 = $0;
       break label$5;
      }
      $3 = $0;
      while (1) {
       if (!$2) {
        break label$1
       }
       HEAP8[$3 | 0] = HEAPU8[$1 | 0];
       $1 = $1 + 1 | 0;
       $2 = $2 + -1 | 0;
       $3 = $3 + 1 | 0;
       if ($3 & 3) {
        continue
       }
       break;
      };
      break label$5;
     }
     label$10 : {
      if ($3) {
       break label$10
      }
      if ($4 & 3) {
       while (1) {
        if (!$2) {
         break label$1
        }
        $2 = $2 + -1 | 0;
        $3 = $2 + $0 | 0;
        HEAP8[$3 | 0] = HEAPU8[$1 + $2 | 0];
        if ($3 & 3) {
         continue
        }
        break;
       }
      }
      if ($2 >>> 0 <= 3) {
       break label$10
      }
      while (1) {
       $2 = $2 + -4 | 0;
       HEAP32[$2 + $0 >> 2] = HEAP32[$1 + $2 >> 2];
       if ($2 >>> 0 > 3) {
        continue
       }
       break;
      };
     }
     if (!$2) {
      break label$1
     }
     while (1) {
      $2 = $2 + -1 | 0;
      HEAP8[$2 + $0 | 0] = HEAPU8[$1 + $2 | 0];
      if ($2) {
       continue
      }
      break;
     };
     break label$1;
    }
    if ($2 >>> 0 <= 3) {
     break label$4
    }
    while (1) {
     HEAP32[$3 >> 2] = HEAP32[$1 >> 2];
     $1 = $1 + 4 | 0;
     $3 = $3 + 4 | 0;
     $2 = $2 + -4 | 0;
     if ($2 >>> 0 > 3) {
      continue
     }
     break;
    };
   }
   if (!$2) {
    break label$1
   }
   while (1) {
    HEAP8[$3 | 0] = HEAPU8[$1 | 0];
    $3 = $3 + 1 | 0;
    $1 = $1 + 1 | 0;
    $2 = $2 + -1 | 0;
    if ($2) {
     continue
    }
    break;
   };
  }
  return $0;
 }
 
 function __towrite($0) {
  var $1 = 0;
  $1 = HEAPU8[$0 + 74 | 0];
  HEAP8[$0 + 74 | 0] = $1 | $1 + -1;
  $1 = HEAP32[$0 >> 2];
  if ($1 & 8) {
   HEAP32[$0 >> 2] = $1 | 32;
   return -1;
  }
  HEAP32[$0 + 4 >> 2] = 0;
  HEAP32[$0 + 8 >> 2] = 0;
  $1 = HEAP32[$0 + 44 >> 2];
  HEAP32[$0 + 28 >> 2] = $1;
  HEAP32[$0 + 20 >> 2] = $1;
  HEAP32[$0 + 16 >> 2] = HEAP32[$0 + 48 >> 2] + $1;
  return 0;
 }
 
 function __overflow($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $3 = HEAP32[$2 + 8 >> 2];
   $4 = HEAP32[$2 + 12 >> 2];
   $2 = HEAP32[$2 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $2 = global$0 - 16 | 0;
   global$0 = $2;
   HEAP8[$2 + 15 | 0] = $1;
   $3 = HEAP32[$0 + 16 >> 2];
   $4 = !$3;
  }
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($4) {
      $3 = -1;
      if (__towrite($0)) {
       break label$5
      }
      $3 = HEAP32[$0 + 16 >> 2];
     }
     label$8 : {
      $4 = HEAP32[$0 + 20 >> 2];
      if ($4 >>> 0 >= $3 >>> 0) {
       break label$8
      }
      $3 = $1 & 255;
      if (($3 | 0) == HEAP8[$0 + 75 | 0]) {
       break label$8
      }
      HEAP32[$0 + 20 >> 2] = $4 + 1;
      HEAP8[$4 | 0] = $1;
      break label$5;
     }
     $3 = -1;
     $4 = HEAP32[$0 + 36 >> 2];
     $1 = $2 + 15 | 0;
    }
    if (global$2 ? !$5 : 1) {
     $5 = FUNCTION_TABLE[$4]($0, $1, 1) | 0;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $0 = $5;
    }
    if (!global$2) {
     if (($0 | 0) != 1) {
      break label$5
     }
     $3 = HEAPU8[$2 + 15 | 0];
    }
   }
   if (!global$2) {
    global$0 = $2 + 16 | 0;
    return $3;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $3;
  HEAP32[$5 + 12 >> 2] = $4;
  HEAP32[$5 + 16 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
  return 0;
 }
 
 function __fwritex($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -28;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $6 = HEAP32[$4 + 20 >> 2];
   $7 = HEAP32[$4 + 24 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $5 = HEAP32[$2 + 16 >> 2];
   $3 = !$5;
  }
  label$2 : {
   label$5 : {
    if (!global$2) {
     if ($3) {
      $3 = 0;
      if (__towrite($2)) {
       break label$5
      }
      $5 = HEAP32[$2 + 16 >> 2];
     }
     $6 = HEAP32[$2 + 20 >> 2];
     $3 = $5 - $6 >>> 0 < $1 >>> 0;
    }
    if ((global$2 | 0) == 2 | $3) {
     $3 = global$2 ? $3 : HEAP32[$2 + 36 >> 2];
     if (global$2 ? !$8 : 1) {
      $4 = FUNCTION_TABLE[$3]($2, $0, $1) | 0;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $0 = $4;
     }
     if (!global$2) {
      return $0
     }
    }
    if (!global$2) {
     $7 = 0;
     $3 = HEAP8[$2 + 75 | 0] < 0;
    }
    label$13 : {
     if (!global$2) {
      if ($3) {
       break label$13
      }
      $3 = $1;
      while (1) {
       $5 = $3;
       $3 = !$3;
       if ($3) {
        break label$13
       }
       $3 = $5 + -1 | 0;
       if (HEAPU8[$3 + $0 | 0] != 10) {
        continue
       }
       break;
      };
      $3 = HEAP32[$2 + 36 >> 2];
     }
     if (global$2 ? ($8 | 0) == 1 : 1) {
      $4 = FUNCTION_TABLE[$3]($2, $0, $5) | 0;
      $9 = 1;
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $3 = $4;
     }
     if (!global$2) {
      if ($3 >>> 0 < $5 >>> 0) {
       break label$5
      }
      $1 = $1 - $5 | 0;
      $6 = HEAP32[$2 + 20 >> 2];
      $7 = $5;
      $0 = $0 + $5 | 0;
     }
    }
    if (!global$2) {
     memcpy($6, $0, $1);
     HEAP32[$2 + 20 >> 2] = HEAP32[$2 + 20 >> 2] + $1;
     $3 = $1 + $7 | 0;
    }
   }
   if (!global$2) {
    return $3
   }
   abort();
  }
  $4 = $9;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  HEAP32[$4 + 20 >> 2] = $6;
  HEAP32[$4 + 24 >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 28;
  return 0;
 }
 
 function fwrite($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -24;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $5 = HEAP32[$4 + 16 >> 2];
   $6 = HEAP32[$4 + 20 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $7 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $6 = Math_imul($1, $2);
   $5 = HEAP32[$3 + 76 >> 2] <= -1;
  }
  label$2 : {
   label$4 : {
    if ((global$2 | 0) == 2 | $5) {
     if (global$2 ? !$7 : 1) {
      $4 = __fwritex($0, $6, $3);
      if ((global$2 | 0) == 1) {
       break label$2
      }
      $0 = $4;
     }
     if (!global$2) {
      break label$4
     }
    }
    if (!global$2) {
     $5 = __lockfile($3)
    }
    if (global$2 ? ($7 | 0) == 1 : 1) {
     $4 = __fwritex($0, $6, $3);
     $8 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $0 = $4;
    }
    if (!global$2) {
     if (!$5) {
      break label$4
     }
     __unlockfile($3);
    }
   }
   if (!global$2) {
    if (($0 | 0) == ($6 | 0)) {
     return $1 ? $2 : 0
    }
    return ($0 >>> 0) / ($1 >>> 0) | 0;
   }
   abort();
  }
  $4 = $8;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[$4 + 16 >> 2] = $5;
  HEAP32[$4 + 20 >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 24;
  return 0;
 }
 
 function fputs($0, $1) {
  var $2 = 0, $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $2 = strlen($0)
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    $3 = fwrite($0, 1, $2, $1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $3;
   }
   if (!global$2) {
    return ($0 | 0) != ($2 | 0) ? -1 : 0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
  return 0;
 }
 
 function iprintf($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $4 = HEAP32[$2 + 8 >> 2];
   $2 = HEAP32[$2 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $4 = global$0 - 16 | 0;
   global$0 = $4;
   HEAP32[$4 + 12 >> 2] = $1;
   $2 = HEAP32[3226];
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    $3 = vfiprintf($2, $0, $1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $1 = $3;
   }
   if (!global$2) {
    global$0 = $4 + 16 | 0;
    return $1;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $4;
  HEAP32[$3 + 12 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function puts($0) {
  $0 = $0 | 0;
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $4 = HEAP32[$1 + 8 >> 2];
   $3 = HEAP32[$1 + 12 >> 2];
   $2 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  if (!global$2) {
   $2 = HEAP32[3226];
   $3 = HEAP32[$2 + 76 >> 2] >= 0;
   if ($3) {
    $4 = __lockfile($2)
   } else {
    $4 = 0
   }
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $1 = fputs($0, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $1;
   }
   if (!global$2) {
    $3 = ($0 | 0) < 0;
    $0 = -1;
   }
   label$9 : {
    if (!global$2) {
     if ($3) {
      break label$9
     }
     label$11 : {
      $0 = HEAPU8[$2 + 75 | 0] == 10;
      if ($0) {
       break label$11
      }
      $0 = HEAP32[$2 + 20 >> 2];
      if ($0 >>> 0 >= HEAPU32[$2 + 16 >> 2]) {
       break label$11
      }
      HEAP32[$2 + 20 >> 2] = $0 + 1;
      HEAP8[$0 | 0] = 10;
      $0 = 0;
      break label$9;
     }
    }
    if (global$2 ? ($5 | 0) == 1 : 1) {
     $1 = __overflow($2, 10);
     $6 = 1;
     if ((global$2 | 0) == 1) {
      break label$2
     }
     $0 = $1;
    }
    $0 = global$2 ? $0 : $0 >> 31;
   }
   if (!global$2) {
    if ($4) {
     __unlockfile($2)
    }
    return $0 | 0;
   }
   abort();
  }
  $1 = $6;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $1 = HEAP32[global$3 >> 2];
  HEAP32[$1 >> 2] = $0;
  HEAP32[$1 + 4 >> 2] = $2;
  HEAP32[$1 + 8 >> 2] = $4;
  HEAP32[$1 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function __lockfile($0) {
  return 1;
 }
 
 function __unlockfile($0) {
  
 }
 
 function strlen($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  label$1 : {
   label$2 : {
    $1 = $0;
    if (!($1 & 3)) {
     break label$2
    }
    if (!HEAPU8[$0 | 0]) {
     return 0
    }
    while (1) {
     $1 = $1 + 1 | 0;
     if (!($1 & 3)) {
      break label$2
     }
     if (HEAPU8[$1 | 0]) {
      continue
     }
     break;
    };
    break label$1;
   }
   while (1) {
    $2 = $1;
    $1 = $1 + 4 | 0;
    $3 = HEAP32[$2 >> 2];
    if (!(($3 ^ -1) & $3 + -16843009 & -2139062144)) {
     continue
    }
    break;
   };
   if (!($3 & 255)) {
    return $2 - $0 | 0
   }
   while (1) {
    $3 = HEAPU8[$2 + 1 | 0];
    $1 = $2 + 1 | 0;
    $2 = $1;
    if ($3) {
     continue
    }
    break;
   };
  }
  return $1 - $0 | 0;
 }
 
 function dynCall_v($0) {
  $0 = $0 | 0;
  var $1 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $0 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $1 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   } else {
    $1 = 0
   }
   if (global$2 ? !$1 : 1) {
    FUNCTION_TABLE[$0]();
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  HEAP32[HEAP32[global$3 >> 2] >> 2] = $0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
 }
 
 function dynCall_vi($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   } else {
    $2 = 0
   }
   if (global$2 ? !$2 : 1) {
    FUNCTION_TABLE[$0]($1);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
 }
 
 function dynCall_vii($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   } else {
    $3 = 0
   }
   if (global$2 ? !$3 : 1) {
    FUNCTION_TABLE[$0]($1, $2);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
 }
 
 function dynCall_viii($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   } else {
    $4 = 0
   }
   if (global$2 ? !$4 : 1) {
    FUNCTION_TABLE[$0]($1, $2, $3);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
 }
 
 function dynCall_viiiiiii($0, $1, $2, $3, $4, $5, $6, $7) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  $6 = $6 | 0;
  $7 = $7 | 0;
  var $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -32;
   $7 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$7 >> 2];
   $1 = HEAP32[$7 + 4 >> 2];
   $2 = HEAP32[$7 + 8 >> 2];
   $3 = HEAP32[$7 + 12 >> 2];
   $4 = HEAP32[$7 + 16 >> 2];
   $5 = HEAP32[$7 + 20 >> 2];
   $6 = HEAP32[$7 + 24 >> 2];
   $7 = HEAP32[$7 + 28 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $8 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   } else {
    $8 = 0
   }
   if (global$2 ? !$8 : 1) {
    FUNCTION_TABLE[$0]($1, $2, $3, $4, $5, $6, $7);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $8 = HEAP32[global$3 >> 2];
  HEAP32[$8 >> 2] = $0;
  HEAP32[$8 + 4 >> 2] = $1;
  HEAP32[$8 + 8 >> 2] = $2;
  HEAP32[$8 + 12 >> 2] = $3;
  HEAP32[$8 + 16 >> 2] = $4;
  HEAP32[$8 + 20 >> 2] = $5;
  HEAP32[$8 + 24 >> 2] = $6;
  HEAP32[$8 + 28 >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 32;
 }
 
 function dynCall_ii($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  var $2 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -8;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $2 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $2 = 0
  }
  label$2 : {
   if (global$2 ? !$2 : 1) {
    $2 = FUNCTION_TABLE[$0]($1) | 0;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $2;
   }
   if (!global$2) {
    return $0 | 0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $2 = HEAP32[global$3 >> 2];
  HEAP32[$2 >> 2] = $0;
  HEAP32[$2 + 4 >> 2] = $1;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 8;
  return 0;
 }
 
 function dynCall_iii($0, $1, $2) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  var $3 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -12;
   $2 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$2 >> 2];
   $1 = HEAP32[$2 + 4 >> 2];
   $2 = HEAP32[$2 + 8 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $3 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $3 = 0
  }
  label$2 : {
   if (global$2 ? !$3 : 1) {
    $3 = FUNCTION_TABLE[$0]($1, $2) | 0;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $3;
   }
   if (!global$2) {
    return $0 | 0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $3 = HEAP32[global$3 >> 2];
  HEAP32[$3 >> 2] = $0;
  HEAP32[$3 + 4 >> 2] = $1;
  HEAP32[$3 + 8 >> 2] = $2;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 12;
  return 0;
 }
 
 function stackSave() {
  return global$0 | 0;
 }
 
 function stackAlloc($0) {
  $0 = $0 | 0;
  $0 = global$0 - $0 & -16;
  global$0 = $0;
  return $0 | 0;
 }
 
 function stackRestore($0) {
  $0 = $0 | 0;
  global$0 = $0;
 }
 
 function __growWasmMemory($0) {
  $0 = $0 | 0;
  return abort() | 0;
 }
 
 function dynCall_viiii($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $4 = HEAP32[$4 + 16 >> 2];
  }
  label$2 : {
   if ((global$2 | 0) == 2) {
    HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
    $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
   } else {
    $5 = 0
   }
   if (global$2 ? !$5 : 1) {
    FUNCTION_TABLE[$0]($1, $2, $3, $4);
    if ((global$2 | 0) == 1) {
     break label$2
    }
   }
   return;
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
 }
 
 function dynCall_iiii($0, $1, $2, $3) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  var $4 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -16;
   $3 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$3 >> 2];
   $1 = HEAP32[$3 + 4 >> 2];
   $2 = HEAP32[$3 + 8 >> 2];
   $3 = HEAP32[$3 + 12 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $4 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $4 = 0
  }
  label$2 : {
   if (global$2 ? !$4 : 1) {
    $4 = FUNCTION_TABLE[$0]($1, $2, $3) | 0;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $4;
   }
   if (!global$2) {
    return $0 | 0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $4 = HEAP32[global$3 >> 2];
  HEAP32[$4 >> 2] = $0;
  HEAP32[$4 + 4 >> 2] = $1;
  HEAP32[$4 + 8 >> 2] = $2;
  HEAP32[$4 + 12 >> 2] = $3;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 16;
  return 0;
 }
 
 function dynCall_jiji($0, $1, $2, $3, $4) {
  var $5 = 0, $6 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -20;
   $4 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$4 >> 2];
   $1 = HEAP32[$4 + 4 >> 2];
   $2 = HEAP32[$4 + 8 >> 2];
   $3 = HEAP32[$4 + 12 >> 2];
   $4 = HEAP32[$4 + 16 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $5 = 0
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = FUNCTION_TABLE[$0]($1, $2, $3, $4) | 0;
    $6 = i64toi32_i32$HIGH_BITS;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $3 = $6;
    $2 = $5;
   }
   if (!global$2) {
    i64toi32_i32$HIGH_BITS = $3;
    return $2;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 20;
  i64toi32_i32$HIGH_BITS = 0;
  return 0;
 }
 
 function dynCall_iidiiii($0, $1, $2, $3, $4, $5, $6) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = +$2;
  $3 = $3 | 0;
  $4 = $4 | 0;
  $5 = $5 | 0;
  $6 = $6 | 0;
  var $7 = 0, $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -32;
   $6 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$6 >> 2];
   $1 = HEAP32[$6 + 4 >> 2];
   $8 = HEAP32[$6 + 12 >> 2];
   wasm2js_scratch_store_i32(0, HEAP32[$6 + 8 >> 2]);
   wasm2js_scratch_store_i32(1, $8 | 0);
   $2 = +wasm2js_scratch_load_f64();
   $3 = HEAP32[$6 + 16 >> 2];
   $4 = HEAP32[$6 + 20 >> 2];
   $5 = HEAP32[$6 + 24 >> 2];
   $6 = HEAP32[$6 + 28 >> 2];
  }
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $7 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $7 = 0
  }
  label$2 : {
   if (global$2 ? !$7 : 1) {
    $7 = FUNCTION_TABLE[$0]($1, $2, $3, $4, $5, $6) | 0;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $0 = $7;
   }
   if (!global$2) {
    return $0 | 0
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $7 = HEAP32[global$3 >> 2];
  HEAP32[$7 >> 2] = $0;
  HEAP32[$7 + 4 >> 2] = $1;
  wasm2js_scratch_store_f64(+$2);
  $8 = wasm2js_scratch_load_i32(1) | 0;
  HEAP32[$7 + 8 >> 2] = wasm2js_scratch_load_i32(0);
  HEAP32[$7 + 12 >> 2] = $8;
  HEAP32[$7 + 16 >> 2] = $3;
  HEAP32[$7 + 20 >> 2] = $4;
  HEAP32[$7 + 24 >> 2] = $5;
  HEAP32[$7 + 28 >> 2] = $6;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 32;
  return 0;
 }
 
 function legalstub$dynCall_jiji($0, $1, $2, $3, $4) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2 = $2 | 0;
  $3 = $3 | 0;
  $4 = $4 | 0;
  var $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -28;
   $1 = HEAP32[global$3 >> 2];
   $0 = HEAP32[$1 >> 2];
   $2 = HEAP32[$1 + 8 >> 2];
   $3 = HEAP32[$1 + 12 >> 2];
   $4 = HEAP32[$1 + 16 >> 2];
   $6 = HEAP32[$1 + 20 >> 2];
   $7 = HEAP32[$1 + 24 >> 2];
   $1 = HEAP32[$1 + 4 >> 2];
  }
  $5 = global$2;
  $6 = $5 ? $6 : $2;
  $7 = $5 ? $7 : $3;
  if ((global$2 | 0) == 2) {
   HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + -4;
   $5 = HEAP32[HEAP32[global$3 >> 2] >> 2];
  } else {
   $5 = 0
  }
  label$2 : {
   if (global$2 ? !$5 : 1) {
    $5 = dynCall_jiji($0, $1, $6, $7, $4);
    $8 = i64toi32_i32$HIGH_BITS;
    if ((global$2 | 0) == 1) {
     break label$2
    }
    $7 = $8;
    $6 = $5;
   }
   if (!global$2) {
    setTempRet0($7 | 0);
    return $6 | 0;
   }
   abort();
  }
  HEAP32[HEAP32[global$3 >> 2] >> 2] = 0;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 4;
  $5 = HEAP32[global$3 >> 2];
  HEAP32[$5 >> 2] = $0;
  HEAP32[$5 + 4 >> 2] = $1;
  HEAP32[$5 + 8 >> 2] = $2;
  HEAP32[$5 + 12 >> 2] = $3;
  HEAP32[$5 + 16 >> 2] = $4;
  HEAP32[$5 + 20 >> 2] = $6;
  HEAP32[$5 + 24 >> 2] = $7;
  HEAP32[global$3 >> 2] = HEAP32[global$3 >> 2] + 28;
  return 0;
 }
 
 function legalfunc$__wasi_fd_seek($0, $1, $2, $3, $4) {
  return legalimport$__wasi_fd_seek($0 | 0, $1 | 0, $2 | 0, $3 | 0, $4 | 0) | 0;
 }
 
 function asyncify_start_unwind($0) {
  $0 = $0 | 0;
  global$2 = 1;
  global$3 = $0;
  if (HEAPU32[global$3 >> 2] > HEAPU32[global$3 + 4 >> 2]) {
   abort()
  }
 }
 
 function asyncify_stop_unwind() {
  global$2 = 0;
  if (HEAPU32[global$3 >> 2] > HEAPU32[global$3 + 4 >> 2]) {
   abort()
  }
 }
 
 function asyncify_start_rewind($0) {
  $0 = $0 | 0;
  global$2 = 2;
  global$3 = $0;
  if (HEAPU32[global$3 >> 2] > HEAPU32[global$3 + 4 >> 2]) {
   abort()
  }
 }
 
 function asyncify_stop_rewind() {
  global$2 = 0;
  if (HEAPU32[global$3 >> 2] > HEAPU32[global$3 + 4 >> 2]) {
   abort()
  }
 }
 
 function asyncify_get_state() {
  return global$2 | 0;
 }
 
 function legalfunc$wasm2js_scratch_store_i64($0, $1) {
  legalimport$wasm2js_scratch_store_i64($0 | 0, $1 | 0);
 }
 
 function _ZN17compiler_builtins3int3mul3Mul3mul17h070e9a1c69faec5bE($0, $1, $2, $3) {
  var $4 = 0, $5 = 0;
  $4 = $2 >>> 16 | 0;
  $5 = $0 >>> 16 | 0;
  $3 = (Math_imul($4, $5) + Math_imul($1, $2) | 0) + Math_imul($3, $0) | 0;
  $2 = $2 & 65535;
  $0 = $0 & 65535;
  $1 = Math_imul($2, $0);
  $2 = ($1 >>> 16 | 0) + Math_imul($2, $5) | 0;
  $3 = $3 + ($2 >>> 16 | 0) | 0;
  $2 = Math_imul($0, $4) + ($2 & 65535) | 0;
  i64toi32_i32$HIGH_BITS = $3 + ($2 >>> 16 | 0) | 0;
  return $1 & 65535 | $2 << 16;
 }
 
 function _ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0;
  label$1 : {
   label$2 : {
    label$3 : {
     label$4 : {
      label$5 : {
       label$6 : {
        label$7 : {
         label$8 : {
          label$9 : {
           label$11 : {
            $9 = $1;
            $7 = $9;
            if ($7) {
             $5 = $2;
             if (!$5) {
              break label$11
             }
             $4 = $3;
             if (!$4) {
              break label$9
             }
             $7 = Math_clz32($4) - Math_clz32($7) | 0;
             if ($7 >>> 0 <= 31) {
              break label$8
             }
             break label$2;
            }
            $6 = $3;
            $10 = $2;
            if (($6 | 0) == 1 & $10 >>> 0 >= 0 | $6 >>> 0 > 1) {
             break label$2
            }
            $7 = $0;
            $5 = $2;
            $7 = ($7 >>> 0) / ($5 >>> 0) | 0;
            legalfunc$wasm2js_scratch_store_i64($0 - Math_imul($7, $5) | 0, 0);
            i64toi32_i32$HIGH_BITS = 0;
            $6 = $7;
            return $6;
           }
           $6 = $3;
           $5 = $6;
           if (!$0) {
            break label$7
           }
           if (!$5) {
            break label$6
           }
           $4 = $5 + -1 | 0;
           if ($4 & $5) {
            break label$6
           }
           $6 = $7 & $4;
           $1 = $6;
           $10 = $0;
           $9 = $10;
           $4 = 0;
           $6 = 0;
           $10 = $6;
           $6 = $1;
           $10 = $10 | $6;
           legalfunc$wasm2js_scratch_store_i64($9 | $4, $10);
           $4 = $7 >>> (__wasm_ctz_i32($5) & 31) | 0;
           i64toi32_i32$HIGH_BITS = 0;
           return $4;
          }
          $4 = $5 + -1 | 0;
          if (!($4 & $5)) {
           break label$5
          }
          $7 = (Math_clz32($5) + 33 | 0) - Math_clz32($7) | 0;
          $5 = 0 - $7 | 0;
          break label$3;
         }
         $5 = 63 - $7 | 0;
         $7 = $7 + 1 | 0;
         break label$3;
        }
        $4 = ($7 >>> 0) / ($5 >>> 0) | 0;
        $6 = $7 - Math_imul($4, $5) | 0;
        legalfunc$wasm2js_scratch_store_i64(0, $6);
        i64toi32_i32$HIGH_BITS = 0;
        $6 = $4;
        return $6;
       }
       $7 = Math_clz32($5) - Math_clz32($7) | 0;
       if ($7 >>> 0 < 31) {
        break label$4
       }
       break label$2;
      }
      legalfunc$wasm2js_scratch_store_i64($0 & $4, 0);
      if (($5 | 0) == 1) {
       break label$1
      }
      $6 = $1;
      $9 = __wasm_ctz_i32($5);
      $4 = $0;
      $10 = 0;
      $8 = $9 & 31;
      if (32 <= ($9 & 63) >>> 0) {
       $4 = $6 >>> $8 | 0
      } else {
       $10 = $6 >>> $8 | 0;
       $4 = ((1 << $8) - 1 & $6) << 32 - $8 | $4 >>> $8;
      }
      i64toi32_i32$HIGH_BITS = $10;
      return $4;
     }
     $5 = 63 - $7 | 0;
     $7 = $7 + 1 | 0;
    }
    $4 = $1;
    $6 = $0;
    $10 = 0;
    $9 = $7 & 63;
    $8 = $9 & 31;
    if (32 <= ($9 & 63) >>> 0) {
     $11 = $4 >>> $8 | 0
    } else {
     $10 = $4 >>> $8 | 0;
     $11 = ((1 << $8) - 1 & $4) << 32 - $8 | $6 >>> $8;
    }
    $12 = $10;
    $10 = $1;
    $4 = $0;
    $9 = $5 & 63;
    $8 = $9 & 31;
    if (32 <= ($9 & 63) >>> 0) {
     $6 = $4 << $8;
     $0 = 0;
    } else {
     $6 = (1 << $8) - 1 & $4 >>> 32 - $8 | $10 << $8;
     $0 = $4 << $8;
    }
    $1 = $6;
    if ($7) {
     $6 = $3;
     $5 = $6 + -1 | 0;
     $10 = $2;
     $8 = $10 + -1 | 0;
     if ($8 >>> 0 < 4294967295) {
      $5 = $5 + 1 | 0
     }
     $15 = $8;
     $16 = $5;
     while (1) {
      $6 = $11;
      $4 = $6 << 1;
      $5 = $12;
      $10 = $5 << 1 | $6 >>> 31;
      $6 = 0;
      $5 = $6;
      $6 = $10;
      $5 = $6 | $5;
      $12 = $5;
      $10 = $1;
      $9 = $10 >>> 31 | 0;
      $10 = $4;
      $11 = $9 | $10;
      $6 = $15;
      $9 = $11;
      $4 = $6 - $9 | 0;
      $5 = $16;
      $10 = $12;
      $8 = $10 + ($6 >>> 0 < $9 >>> 0) | 0;
      $8 = $5 - $8 | 0;
      $13 = $8 >> 31;
      $6 = $8 >> 31;
      $14 = $6;
      $5 = $3;
      $5 = $6 & $5;
      $4 = $5;
      $6 = $9;
      $9 = $2;
      $8 = $13;
      $9 = $9 & $8;
      $10 = $6 - $9 | 0;
      $11 = $10;
      $5 = $12;
      $8 = $4;
      $4 = $8 + ($6 >>> 0 < $9 >>> 0) | 0;
      $4 = $5 - $4 | 0;
      $12 = $4;
      $4 = $1;
      $5 = $0;
      $6 = $4 << 1 | $5 >>> 31;
      $9 = $17;
      $4 = $5 << 1;
      $0 = $9 | $4;
      $5 = $18;
      $5 = $5 | $6;
      $1 = $5;
      $6 = $13;
      $13 = $6 & 1;
      $4 = 0;
      $14 = $4;
      $17 = $13;
      $7 = $7 + -1 | 0;
      if ($7) {
       continue
      }
      break;
     };
    }
    $4 = $12;
    legalfunc$wasm2js_scratch_store_i64($11, $4);
    $5 = $0;
    $0 = $5 << 1;
    $4 = $1;
    $6 = $4 << 1 | $5 >>> 31;
    $5 = $14;
    $5 = $6 | $5;
    i64toi32_i32$HIGH_BITS = $5;
    $9 = $13;
    $4 = $0;
    $4 = $9 | $4;
    return $4;
   }
   $4 = $1;
   legalfunc$wasm2js_scratch_store_i64($0, $4);
   $0 = 0;
   $1 = 0;
  }
  $4 = $1;
  i64toi32_i32$HIGH_BITS = $4;
  $5 = $0;
  return $5;
 }
 
 function __wasm_i64_mul($0, $1, $2, $3) {
  $3 = _ZN17compiler_builtins3int3mul3Mul3mul17h070e9a1c69faec5bE($0, $1, $2, $3);
  return $3;
 }
 
 function __wasm_i64_udiv($0, $1, $2, $3) {
  $3 = _ZN17compiler_builtins3int4udiv10divmod_u6417h6026910b5ed08e40E($0, $1, $2, $3);
  return $3;
 }
 
 function __wasm_rotl_i32($0, $1) {
  var $2 = 0;
  $2 = $1 & 31;
  $1 = 0 - $1 & 31;
  return (-1 >>> $2 & $0) << $2 | (-1 << $1 & $0) >>> $1;
 }
 
 function __wasm_ctz_i32($0) {
  if ($0) {
   return 31 - Math_clz32($0 + -1 ^ $0) | 0
  }
  return 32;
 }
 
 // EMSCRIPTEN_END_FUNCS
;
 FUNCTION_TABLE[1] = getenv;
 FUNCTION_TABLE[2] = atoi;
 FUNCTION_TABLE[3] = puts;
 FUNCTION_TABLE[4] = PicocInitialise;
 FUNCTION_TABLE[5] = strcmp;
 FUNCTION_TABLE[6] = PicocIncludeAllSystemHeaders;
 FUNCTION_TABLE[7] = PicocParseInteractive;
 FUNCTION_TABLE[8] = exit;
 FUNCTION_TABLE[9] = PicocPlatformScanFile;
 FUNCTION_TABLE[10] = PicocCallMain;
 FUNCTION_TABLE[11] = PicocCleanup;
 FUNCTION_TABLE[12] = putchar;
 FUNCTION_TABLE[13] = fflush;
 FUNCTION_TABLE[14] = em_exit;
 FUNCTION_TABLE[15] = LexInitParser;
 FUNCTION_TABLE[16] = LexInteractiveClear;
 FUNCTION_TABLE[17] = LexInteractiveStatementPrompt;
 FUNCTION_TABLE[18] = ParseStatement;
 FUNCTION_TABLE[19] = LexInteractiveCompleted;
 FUNCTION_TABLE[20] = ProgramFail;
 FUNCTION_TABLE[21] = PlatformPrintf;
 FUNCTION_TABLE[22] = StdErrnoSetupFunc;
 FUNCTION_TABLE[23] = MathSetupFunc;
 FUNCTION_TABLE[24] = StdboolSetupFunc;
 FUNCTION_TABLE[25] = StdioSetupFunc;
 FUNCTION_TABLE[26] = StdlibSetupFunc;
 FUNCTION_TABLE[27] = StringSetupFunc;
 FUNCTION_TABLE[28] = StdTimeSetupFunc;
 FUNCTION_TABLE[29] = UnistdSetupFunc;
 FUNCTION_TABLE[30] = BreakHandler;
 FUNCTION_TABLE[31] = UnixSetupFunc;
 FUNCTION_TABLE[32] = Ctest;
 FUNCTION_TABLE[33] = Clineno;
 FUNCTION_TABLE[34] = StdioFopen;
 FUNCTION_TABLE[35] = StdioFreopen;
 FUNCTION_TABLE[36] = StdioFclose;
 FUNCTION_TABLE[37] = StdioFread;
 FUNCTION_TABLE[38] = StdioFwrite;
 FUNCTION_TABLE[39] = StdioFgetc;
 FUNCTION_TABLE[40] = StdioFgets;
 FUNCTION_TABLE[41] = StdioFputc;
 FUNCTION_TABLE[42] = StdioFputs;
 FUNCTION_TABLE[43] = StdioRemove;
 FUNCTION_TABLE[44] = StdioRename;
 FUNCTION_TABLE[45] = StdioRewind;
 FUNCTION_TABLE[46] = StdioTmpfile;
 FUNCTION_TABLE[47] = StdioClearerr;
 FUNCTION_TABLE[48] = StdioFeof;
 FUNCTION_TABLE[49] = StdioFerror;
 FUNCTION_TABLE[50] = StdioFileno;
 FUNCTION_TABLE[51] = StdioFflush;
 FUNCTION_TABLE[52] = StdioFgetpos;
 FUNCTION_TABLE[53] = StdioFsetpos;
 FUNCTION_TABLE[54] = StdioFtell;
 FUNCTION_TABLE[55] = StdioFseek;
 FUNCTION_TABLE[56] = StdioPerror;
 FUNCTION_TABLE[57] = StdioPutc;
 FUNCTION_TABLE[58] = StdioPutchar;
 FUNCTION_TABLE[59] = StdioSetbuf;
 FUNCTION_TABLE[60] = StdioSetvbuf;
 FUNCTION_TABLE[61] = StdioUngetc;
 FUNCTION_TABLE[62] = StdioPuts;
 FUNCTION_TABLE[63] = StdioGets;
 FUNCTION_TABLE[64] = StdioGetchar;
 FUNCTION_TABLE[65] = StdioPrintf;
 FUNCTION_TABLE[66] = StdioFprintf;
 FUNCTION_TABLE[67] = StdioSprintf;
 FUNCTION_TABLE[68] = StdioSnprintf;
 FUNCTION_TABLE[69] = StdioScanf;
 FUNCTION_TABLE[70] = StdioFscanf;
 FUNCTION_TABLE[71] = StdioSscanf;
 FUNCTION_TABLE[72] = StdioVprintf;
 FUNCTION_TABLE[73] = StdioVfprintf;
 FUNCTION_TABLE[74] = StdioVsprintf;
 FUNCTION_TABLE[75] = StdioVsnprintf;
 FUNCTION_TABLE[76] = StdioVscanf;
 FUNCTION_TABLE[77] = StdioVfscanf;
 FUNCTION_TABLE[78] = StdioVsscanf;
 FUNCTION_TABLE[79] = MathAcos;
 FUNCTION_TABLE[80] = MathAsin;
 FUNCTION_TABLE[81] = MathAtan;
 FUNCTION_TABLE[82] = MathAtan2;
 FUNCTION_TABLE[83] = MathCeil;
 FUNCTION_TABLE[84] = MathCos;
 FUNCTION_TABLE[85] = MathCosh;
 FUNCTION_TABLE[86] = MathExp;
 FUNCTION_TABLE[87] = MathFabs;
 FUNCTION_TABLE[88] = MathFloor;
 FUNCTION_TABLE[89] = MathFmod;
 FUNCTION_TABLE[90] = MathFrexp;
 FUNCTION_TABLE[91] = MathLdexp;
 FUNCTION_TABLE[92] = MathLog;
 FUNCTION_TABLE[93] = MathLog10;
 FUNCTION_TABLE[94] = MathModf;
 FUNCTION_TABLE[95] = MathPow;
 FUNCTION_TABLE[96] = MathRound;
 FUNCTION_TABLE[97] = MathSin;
 FUNCTION_TABLE[98] = MathSinh;
 FUNCTION_TABLE[99] = MathSqrt;
 FUNCTION_TABLE[100] = MathTan;
 FUNCTION_TABLE[101] = MathTanh;
 FUNCTION_TABLE[102] = StringIndex;
 FUNCTION_TABLE[103] = StringRindex;
 FUNCTION_TABLE[104] = StringMemcpy;
 FUNCTION_TABLE[105] = StringMemmove;
 FUNCTION_TABLE[106] = StringMemchr;
 FUNCTION_TABLE[107] = StringMemcmp;
 FUNCTION_TABLE[108] = StringMemset;
 FUNCTION_TABLE[109] = StringStrcat;
 FUNCTION_TABLE[110] = StringStrncat;
 FUNCTION_TABLE[111] = StringStrchr;
 FUNCTION_TABLE[112] = StringStrrchr;
 FUNCTION_TABLE[113] = StringStrcmp;
 FUNCTION_TABLE[114] = StringStrncmp;
 FUNCTION_TABLE[115] = StringStrcoll;
 FUNCTION_TABLE[116] = StringStrcpy;
 FUNCTION_TABLE[117] = StringStrncpy;
 FUNCTION_TABLE[118] = StringStrerror;
 FUNCTION_TABLE[119] = StringStrlen;
 FUNCTION_TABLE[120] = StringStrspn;
 FUNCTION_TABLE[121] = StringStrcspn;
 FUNCTION_TABLE[122] = StringStrpbrk;
 FUNCTION_TABLE[123] = StringStrstr;
 FUNCTION_TABLE[124] = StringStrtok;
 FUNCTION_TABLE[125] = StringStrxfrm;
 FUNCTION_TABLE[126] = StringStrdup;
 FUNCTION_TABLE[127] = StringStrtok_r;
 FUNCTION_TABLE[128] = StdlibAtof;
 FUNCTION_TABLE[129] = StdlibStrtod;
 FUNCTION_TABLE[130] = StdlibAtoi;
 FUNCTION_TABLE[131] = StdlibAtol;
 FUNCTION_TABLE[132] = StdlibStrtol;
 FUNCTION_TABLE[133] = StdlibStrtoul;
 FUNCTION_TABLE[134] = StdlibMalloc;
 FUNCTION_TABLE[135] = StdlibCalloc;
 FUNCTION_TABLE[136] = StdlibRealloc;
 FUNCTION_TABLE[137] = StdlibFree;
 FUNCTION_TABLE[138] = StdlibRand;
 FUNCTION_TABLE[139] = StdlibSrand;
 FUNCTION_TABLE[140] = StdlibAbort;
 FUNCTION_TABLE[141] = StdlibExit;
 FUNCTION_TABLE[142] = StdlibGetenv;
 FUNCTION_TABLE[143] = StdlibSystem;
 FUNCTION_TABLE[144] = StdlibAbs;
 FUNCTION_TABLE[145] = StdlibLabs;
 FUNCTION_TABLE[146] = StdAsctime;
 FUNCTION_TABLE[147] = StdClock;
 FUNCTION_TABLE[148] = StdCtime;
 FUNCTION_TABLE[149] = StdDifftime;
 FUNCTION_TABLE[150] = StdGmtime;
 FUNCTION_TABLE[151] = StdLocaltime;
 FUNCTION_TABLE[152] = StdMktime;
 FUNCTION_TABLE[153] = StdTime;
 FUNCTION_TABLE[154] = StdStrftime;
 FUNCTION_TABLE[155] = StdStrptime;
 FUNCTION_TABLE[156] = StdGmtime_r;
 FUNCTION_TABLE[157] = StdTimegm;
 FUNCTION_TABLE[158] = StdIsalnum;
 FUNCTION_TABLE[159] = StdIsalpha;
 FUNCTION_TABLE[160] = StdIsblank;
 FUNCTION_TABLE[161] = StdIscntrl;
 FUNCTION_TABLE[162] = StdIsdigit;
 FUNCTION_TABLE[163] = StdIsgraph;
 FUNCTION_TABLE[164] = StdIslower;
 FUNCTION_TABLE[165] = StdIsprint;
 FUNCTION_TABLE[166] = StdIspunct;
 FUNCTION_TABLE[167] = StdIsspace;
 FUNCTION_TABLE[168] = StdIsupper;
 FUNCTION_TABLE[169] = StdIsxdigit;
 FUNCTION_TABLE[170] = StdTolower;
 FUNCTION_TABLE[171] = StdToupper;
 FUNCTION_TABLE[172] = StdIsascii;
 FUNCTION_TABLE[173] = StdToascii;
 FUNCTION_TABLE[174] = UnistdAccess;
 FUNCTION_TABLE[175] = UnistdAlarm;
 FUNCTION_TABLE[176] = UnistdChdir;
 FUNCTION_TABLE[177] = UnistdChroot;
 FUNCTION_TABLE[178] = UnistdChown;
 FUNCTION_TABLE[179] = UnistdClose;
 FUNCTION_TABLE[180] = UnistdConfstr;
 FUNCTION_TABLE[181] = UnistdCtermid;
 FUNCTION_TABLE[182] = UnistdDup;
 FUNCTION_TABLE[183] = UnistdDup2;
 FUNCTION_TABLE[184] = Unistd_Exit;
 FUNCTION_TABLE[185] = UnistdFchown;
 FUNCTION_TABLE[186] = UnistdFchdir;
 FUNCTION_TABLE[187] = UnistdFdatasync;
 FUNCTION_TABLE[188] = UnistdFork;
 FUNCTION_TABLE[189] = UnistdFpathconf;
 FUNCTION_TABLE[190] = UnistdFsync;
 FUNCTION_TABLE[191] = UnistdFtruncate;
 FUNCTION_TABLE[192] = UnistdGetcwd;
 FUNCTION_TABLE[193] = UnistdGetdtablesize;
 FUNCTION_TABLE[194] = UnistdGetegid;
 FUNCTION_TABLE[195] = UnistdGeteuid;
 FUNCTION_TABLE[196] = UnistdGetgid;
 FUNCTION_TABLE[197] = UnistdGethostid;
 FUNCTION_TABLE[198] = UnistdGetlogin;
 FUNCTION_TABLE[199] = UnistdGetlogin_r;
 FUNCTION_TABLE[200] = UnistdGetpagesize;
 FUNCTION_TABLE[201] = UnistdGetpass;
 FUNCTION_TABLE[202] = UnistdGetpgrp;
 FUNCTION_TABLE[203] = UnistdGetpid;
 FUNCTION_TABLE[204] = UnistdGetppid;
 FUNCTION_TABLE[205] = UnistdGetuid;
 FUNCTION_TABLE[206] = UnistdGetwd;
 FUNCTION_TABLE[207] = UnistdIsatty;
 FUNCTION_TABLE[208] = UnistdLchown;
 FUNCTION_TABLE[209] = UnistdLink;
 FUNCTION_TABLE[210] = UnistdLockf;
 FUNCTION_TABLE[211] = UnistdLseek;
 FUNCTION_TABLE[212] = UnistdNice;
 FUNCTION_TABLE[213] = UnistdPathconf;
 FUNCTION_TABLE[214] = UnistdPause;
 FUNCTION_TABLE[215] = UnistdRead;
 FUNCTION_TABLE[216] = UnistdReadlink;
 FUNCTION_TABLE[217] = UnistdRmdir;
 FUNCTION_TABLE[218] = UnistdSbrk;
 FUNCTION_TABLE[219] = UnistdSetgid;
 FUNCTION_TABLE[220] = UnistdSetpgid;
 FUNCTION_TABLE[221] = UnistdSetpgrp;
 FUNCTION_TABLE[222] = UnistdSetregid;
 FUNCTION_TABLE[223] = UnistdSetreuid;
 FUNCTION_TABLE[224] = UnistdSetsid;
 FUNCTION_TABLE[225] = UnistdSetuid;
 FUNCTION_TABLE[226] = UnistdSleep;
 FUNCTION_TABLE[227] = UnistdSymlink;
 FUNCTION_TABLE[228] = UnistdSync;
 FUNCTION_TABLE[229] = UnistdSysconf;
 FUNCTION_TABLE[230] = UnistdTcgetpgrp;
 FUNCTION_TABLE[231] = UnistdTcsetpgrp;
 FUNCTION_TABLE[232] = UnistdTruncate;
 FUNCTION_TABLE[233] = UnistdTtyname;
 FUNCTION_TABLE[234] = UnistdTtyname_r;
 FUNCTION_TABLE[235] = UnistdUalarm;
 FUNCTION_TABLE[236] = UnistdUnlink;
 FUNCTION_TABLE[237] = UnistdUsleep;
 FUNCTION_TABLE[238] = UnistdVfork;
 FUNCTION_TABLE[239] = UnistdWrite;
 FUNCTION_TABLE[240] = __stdio_close;
 FUNCTION_TABLE[241] = __stdio_write;
 FUNCTION_TABLE[242] = __stdio_seek;
 FUNCTION_TABLE[243] = __stdio_read;
 FUNCTION_TABLE[244] = fmt_fp;
 FUNCTION_TABLE[245] = pop_arg_long_double;
 FUNCTION_TABLE[246] = sn_write;
 FUNCTION_TABLE[247] = __emscripten_stdout_close;
 FUNCTION_TABLE[248] = __emscripten_stdout_seek;
 FUNCTION_TABLE[249] = do_read;
 FUNCTION_TABLE[250] = do_setxid;
 function __wasm_memory_size() {
  return buffer.byteLength / 65536 | 0;
 }
 
 return {
  "__wasm_call_ctors": __wasm_call_ctors, 
  "main": main, 
  "malloc": dlmalloc, 
  "free": dlfree, 
  "__errno_location": __errno_location, 
  "realloc": dlrealloc, 
  "_get_tzname": _get_tzname, 
  "_get_daylight": _get_daylight, 
  "_get_timezone": _get_timezone, 
  "setThrew": setThrew, 
  "dynCall_v": dynCall_v, 
  "dynCall_vi": dynCall_vi, 
  "dynCall_vii": dynCall_vii, 
  "dynCall_viii": dynCall_viii, 
  "dynCall_viiiiiii": dynCall_viiiiiii, 
  "dynCall_ii": dynCall_ii, 
  "dynCall_iii": dynCall_iii, 
  "stackSave": stackSave, 
  "stackAlloc": stackAlloc, 
  "stackRestore": stackRestore, 
  "__growWasmMemory": __growWasmMemory, 
  "dynCall_viiii": dynCall_viiii, 
  "dynCall_iiii": dynCall_iiii, 
  "dynCall_jiji": legalstub$dynCall_jiji, 
  "dynCall_iidiiii": dynCall_iidiiii, 
  "asyncify_start_unwind": asyncify_start_unwind, 
  "asyncify_stop_unwind": asyncify_stop_unwind, 
  "asyncify_start_rewind": asyncify_start_rewind, 
  "asyncify_stop_rewind": asyncify_stop_rewind, 
  "asyncify_get_state": asyncify_get_state
 };
}

for (var base64ReverseLookup = new Uint8Array(123/*'z'+1*/), i = 25; i >= 0; --i) {
    base64ReverseLookup[48+i] = 52+i; // '0-9'
    base64ReverseLookup[65+i] = i; // 'A-Z'
    base64ReverseLookup[97+i] = 26+i; // 'a-z'
  }
  base64ReverseLookup[43] = 62; // '+'
  base64ReverseLookup[47] = 63; // '/'
  /** @noinline Inlining this function would mean expanding the base64 string 4x times in the source code, which Closure seems to be happy to do. */
  function base64DecodeToExistingUint8Array(uint8Array, offset, b64) {
    var b1, b2, i = 0, j = offset, bLength = b64.length, end = offset + (bLength*3>>2);
    if (b64[bLength-2] == '=') --end;
    if (b64[bLength-1] == '=') --end;
    for (; i < bLength; i += 4, j += 3) {
      b1 = base64ReverseLookup[b64.charCodeAt(i+1)];
      b2 = base64ReverseLookup[b64.charCodeAt(i+2)];
      uint8Array[j] = base64ReverseLookup[b64.charCodeAt(i)] << 2 | b1 >> 4;
      if (j+1 < end) uint8Array[j+1] = b1 << 4 | b2 >> 2;
      if (j+2 < end) uint8Array[j+2] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i+3)];
    }
  }
var bufferView = new Uint8Array(wasmMemory.buffer);
base64DecodeToExistingUint8Array(bufferView, 1024, "KCk8Ojo+eyBNb2R1bGUub25FeGl0UGljb2MoKTsgfQBTVEFDS1NJWkUALXMALW0ALWkALQBGb3JtYXQ6IHBpY29jIDxjc291cmNlMS5jPi4uLiBbLSA8YXJnMT4uLi5dICAgIDogcnVuIGEgcHJvZ3JhbSAoY2FsbHMgbWFpbigpIHRvIHN0YXJ0IGl0KQogICAgICAgIHBpY29jIC1zIDxjc291cmNlMS5jPi4uLiBbLSA8YXJnMT4uLi5dIDogc2NyaXB0IG1vZGUgLSBydW5zIHRoZSBwcm9ncmFtIHdpdGhvdXQgY2FsbGluZyBtYWluKCkKICAgICAgICBwaWNvYyAtaSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGludGVyYWN0aXZlIG1vZGUAAG91dCBvZiBtZW1vcnkAb3V0IG9mIG1lbW9yeQBleHBlY3RlZCAiJyIAaWxsZWdhbCBjaGFyYWN0ZXIgJyVjJwBSZXNlcnZlU3BhY2UgPj0gTWVtVXNlZABsZXguYwBMZXhUb2tlbmlzZQBwaWNvYz4gACAgICAgPiAAcGMtPkludGVyYWN0aXZlQ3VycmVudExpbmUtPk5leHQgIT0gTlVMTABMZXhHZXRSYXdUb2tlbgBwYy0+SW50ZXJhY3RpdmVDdXJyZW50TGluZSAhPSBOVUxMAFRva2VuID49IFRva2VuTm9uZSAmJiBUb2tlbiA8PSBUb2tlbkVuZE9mRnVuY3Rpb24AaWRlbnRpZmllciBleHBlY3RlZAAnJXMnIGlzIHVuZGVmaW5lZAB2YWx1ZSBleHBlY3RlZAAjZWxzZSB3aXRob3V0ICNpZgAjZW5kaWYgd2l0aG91dCAjaWYASUxpbmUgIT0gTlVMTABMZXhDb3B5VG9rZW5zACNkZWZpbmUAI2Vsc2UAI2VuZGlmACNpZgAjaWZkZWYAI2lmbmRlZgAjaW5jbHVkZQBhdXRvAGJyZWFrAGNhc2UAY2hhcgBjb250aW51ZQBkZWZhdWx0AGRlbGV0ZQBkbwBkb3VibGUAZWxzZQBlbnVtAGV4dGVybgBmbG9hdABmb3IAZ290bwBpZgBpbnQAbG9uZwBuZXcAcmVnaXN0ZXIAcmV0dXJuAHNob3J0AHNpZ25lZABzaXplb2YAc3RhdGljAHN0cnVjdABzd2l0Y2gAdHlwZWRlZgB1bmlvbgB1bnNpZ25lZAB2b2lkAHdoaWxlAAAAAAMAAAADAAAAAAAAAAQAAAAEAAAACAAAAAQAAAABAAAAbmVzdGVkIGZ1bmN0aW9uIGRlZmluaXRpb25zIGFyZSBub3QgYWxsb3dlZAB0b28gbWFueSBwYXJhbWV0ZXJzICglZCBhbGxvd2VkKQBjb21tYSBleHBlY3RlZABiYWQgcGFyYW1ldGVyAG1haW4AbWFpbigpIHNob3VsZCByZXR1cm4gYW4gaW50IG9yIHZvaWQAYmFkIHBhcmFtZXRlcnMgdG8gbWFpbigpAGJhZCBmdW5jdGlvbiBkZWZpbml0aW9uAGZ1bmN0aW9uIGRlZmluaXRpb24gZXhwZWN0ZWQAJyVzJyBpcyBhbHJlYWR5IGRlZmluZWQAJXQgZnJvbSBhcnJheSBpbml0aWFsaXplcgB0b28gbWFueSBhcnJheSBlbGVtZW50cwBleHByZXNzaW9uIGV4cGVjdGVkACd9JyBleHBlY3RlZABpZGVudGlmaWVyIGV4cGVjdGVkAGNhbid0IGRlZmluZSBhIHZvaWQgdmFyaWFibGUAY2xvc2UgYnJhY2tldCBleHBlY3RlZAAnKCcgZXhwZWN0ZWQAc3RhdGVtZW50IGV4cGVjdGVkACc7JyBleHBlY3RlZAAnKScgZXhwZWN0ZWQAJ3snIGV4cGVjdGVkACd3aGlsZScgZXhwZWN0ZWQAImZpbGVuYW1lLmgiIGV4cGVjdGVkACc6JyBleHBlY3RlZAB2YWx1ZSByZXF1aXJlZCBpbiByZXR1cm4AdmFsdWUgaW4gcmV0dXJuIGZyb20gYSB2b2lkIGZ1bmN0aW9uACclcycgaXMgbm90IGRlZmluZWQAb3V0IG9mIG1lbW9yeQBwYXJzZSBlcnJvcgAKAHN0YXJ0aW5nIHBpY29jIHYyLjIgYmV0YSByMi4xCgBjYW4ndCBhc3NpZ24gdG8gdGhpcwBOVUxMIHBvaW50ZXIgZGVyZWZlcmVuY2UAJXQgZnJvbSAldABub3QgYW4gbHZhbHVlAGZyb20gYW4gYXJyYXkgb2Ygc2l6ZSAlZCB0byBvbmUgb2Ygc2l6ZSAlZAAldABmaXJzdCBhcmd1bWVudCB0byAnPycgc2hvdWxkIGJlIGEgbnVtYmVyAGNhbid0IGdldCB0aGUgYWRkcmVzcyBvZiB0aGlzAGludmFsaWQgb3BlcmF0aW9uAG5vdCBzdXBwb3J0ZWQAaW52YWxpZCBleHByZXNzaW9uAGFycmF5IGluZGV4IG11c3QgYmUgYW4gaW50ZWdlcgB0aGlzICV0IGlzIG5vdCBhbiBhcnJheQBUb3BPcGVyYXRvck5vZGUtPk9yZGVyICE9IE9yZGVyTm9uZQBleHByZXNzaW9uLmMARXhwcmVzc2lvblN0YWNrQ29sbGFwc2UAbmVlZCBhbiBzdHJ1Y3R1cmUgb3IgdW5pb24gbWVtYmVyIGFmdGVyICclcycALgAtPgBjYW4ndCB1c2UgJyVzJyBvbiBzb21ldGhpbmcgdGhhdCdzIG5vdCBhIHN0cnVjdCBvciB1bmlvbiAlcyA6IGl0J3MgYSAldABwb2ludGVyAABkb2Vzbid0IGhhdmUgYSBtZW1iZXIgY2FsbGVkICclcycAb3BlcmF0b3Igbm90IGV4cGVjdGVkIGhlcmUAYnJhY2tldHMgbm90IGNsb3NlZABpZGVudGlmaWVyIG5vdCBleHBlY3RlZCBoZXJlAG1hY3JvIGFyZ3VtZW50cyBtaXNzaW5nAGV4cHJlc3Npb24gZXhwZWN0ZWQAYSB2b2lkIHZhbHVlIGlzbid0IG11Y2ggdXNlIGhlcmUAdmFsdWUgbm90IGV4cGVjdGVkIGhlcmUAdHlwZSBub3QgZXhwZWN0ZWQgaGVyZQBvdXQgb2YgbWVtb3J5AHRvbyBtYW55IGFyZ3VtZW50cyB0byAlcygpAGNvbW1hIGV4cGVjdGVkAG5vdCBlbm91Z2ggYXJndW1lbnRzIHRvICclcycAJyVzJyBpcyB1bmRlZmluZWQAJXQgaXMgbm90IGEgZnVuY3Rpb24gLSBjYW4ndCBjYWxsAGZ1bmN0aW9uIGJvZHkgZXhwZWN0ZWQAbWFpbgBubyB2YWx1ZSByZXR1cm5lZCBmcm9tIGEgZnVuY3Rpb24gcmV0dXJuaW5nICV0AGNvdWxkbid0IGZpbmQgZ290byBsYWJlbCAnJXMnAGludGVnZXIgdmFsdWUgZXhwZWN0ZWQgaW5zdGVhZCBvZiAldABub25lACwAPQArPQAtPQAqPQAvPQAlPQA8PD0APj49ACY9AHw9AF49AD8AOgB8fAAmJgB8AF4AJgA9PQAhPQA8AD4APD0APj0APDwAPj4AKwAtACoALwAlACsrAC0tACEAfgBzaXplb2YAY2FzdABbAF0AKAAp");
base64DecodeToExistingUint8Array(bufferView, 3812, "Ww4AAAAAAABgDgAAAAIAAGIOAAAAAgAAZA4AAAACAABnDgAAAAIAAGoOAAAAAgAAbQ4AAAACAABwDgAAAAIAAHMOAAAAAgAAdw4AAAACAAB7DgAAAAIAAH4OAAAAAgAAgQ4AAAADAACEDgAAAAMAAIYOAAAABAAAiA4AAAAFAACLDgAAAAYAAI4OAAAABwAAkA4AAA4IAACSDgAAAAkAAJQOAAAACQAAlw4AAAAKAACaDgAAAAoAAJwOAAAACgAAng4AAAAKAAChDgAAAAsAAKQOAAAACwAApw4AAA4MAACqDgAADgwAAKwOAAAODQAArg4AAAANAACwDgAAAA0AALIOAAD+AAAAtA4AAP4AAAC3DgAADgAAALoOAAAOAAAAvA4AAA4AAAC+DgAADgAAAMUOAAAADwAAyg4AAPAAAADMDgAAAA8AAAQMAAAADwAABgwAAA8AAADODgAA8AAAANAOAABBZGRyID09IE5VTEwgfHwgcGMtPkhlYXBTdGFja1RvcCA9PSBBZGRyAGhlYXAuYwBIZWFwUG9wU3RhY2sAZGF0YSB0eXBlICclcycgaXMgYWxyZWFkeSBkZWZpbmVkAGRhdGEgdHlwZSAnJXQnIGlzIGFscmVhZHkgZGVmaW5lZABzdHJ1Y3QvdW5pb24gZGVmaW5pdGlvbnMgY2FuIG9ubHkgYmUgZ2xvYmFscwBpbnZhbGlkIHR5cGUgaW4gc3RydWN0AG1lbWJlciAnJXMnIGFscmVhZHkgZGVmaW5lZABzZW1pY29sb24gZXhwZWN0ZWQAZW51bSAnJXMnIGlzbid0IGRlZmluZWQAZW51bSBkZWZpbml0aW9ucyBjYW4gb25seSBiZSBnbG9iYWxzAGlkZW50aWZpZXIgZXhwZWN0ZWQAY29tbWEgZXhwZWN0ZWQAYmFkIHR5cGUgZGVjbGFyYXRpb24AJ10nIGV4cGVjdGVkACcpJyBleHBlY3RlZABvdXQgb2YgbWVtb3J5AFNpemUgPj0gMCB8fCBUeXAgPT0gJnBjLT5Wb2lkVHlwZQB2YXJpYWJsZS5jAFZhcmlhYmxlQWxsb2NWYWx1ZUZyb21UeXBlAENvcHlTaXplIDw9IE1BWF9UTVBfQ09QWV9CVUYAVmFyaWFibGVBbGxvY1ZhbHVlQW5kQ29weQAnJXMnIGlzIGFscmVhZHkgZGVmaW5lZAB0eXBlICcldCcgaXNuJ3QgZGVmaW5lZAAnJXMnIGlzIG91dCBvZiBzY29wZQAnJXMnIGlzIHVuZGVmaW5lZABzdGFjayB1bmRlcnJ1bgBzdGFjayBpcyBlbXB0eSAtIGNhbid0IGdvIGJhY2sAdjIuMiBiZXRhIHIyLjEAUElDT0NfVkVSU0lPTgBCSUdfRU5ESUFOAExJVFRMRV9FTkRJQU4AYyBsaWJyYXJ5AHZvaWQAaW50AHNob3J0AGNoYXIAbG9uZwB1bnNpZ25lZCBpbnQAdW5zaWduZWQgc2hvcnQAdW5zaWduZWQgbG9uZwB1bnNpZ25lZCBjaGFyAGRvdWJsZQBmdW5jdGlvbgBtYWNybwBzdHJ1Y3QgAHVuaW9uIABlbnVtIABnb3RvIGxhYmVsIAB0eXBlIABtYWluAG1haW4oKSBpcyBub3QgZGVmaW5lZABtYWluIGlzIG5vdCBhIGZ1bmN0aW9uIC0gY2FuJ3QgY2FsbCBpdABfX2FyZ2MAX19hcmd2AHN0YXJ0dXAAbWFpbigpOwBtYWluKF9fYXJnYyxfX2FyZ3YpOwBfX2V4aXRfdmFsdWUAX19leGl0X3ZhbHVlID0gbWFpbigpOwBfX2V4aXRfdmFsdWUgPSBtYWluKF9fYXJnYyxfX2FyZ3YpOwBeCiVzOiVkOiVkIAAKAGNhbid0ICVzIABhc3NpZ24Ac2V0ACBpbiBhcmd1bWVudCAlZCBvZiBjYWxsIHRvICVzKCkAY3R5cGUuaABlcnJuby5oAG1hdGguaABzdGRib29sLmgAc3RkaW8uaABzdGRsaWIuaABzdHJpbmcuaAB0aW1lLmgAdW5pc3RkLmgAYnJlYWsKAEhhbmRsaW5nIGEgYnJlYWsKACgpPDo6PnsgcmV0dXJuIE1vZHVsZS5pc0ludGVycnVwdGVkKCk7IH0AJXMAY2FuJ3QgcmVhZCBmaWxlICVzCgBvdXQgb2YgbWVtb3J5CgByAHRlc3QoJWQpCgB2b2lkIHRlc3QoaW50KTsAaW50IGxpbmVubygpOwBwaWNvY191bml4LmgAKCk8Ojo+eyByZXR1cm4gTW9kdWxlLmdldENoYXIoKTsgfQBbbnVsbCBmb3JtYXRdCgBYWFgAb3V0IG9mIG1lbW9yeQB0b28gbWFueSBhcmd1bWVudHMgdG8gc2NhbmYoKSAtICVkIG1heABub24tcG9pbnRlciBhcmd1bWVudCB0byBzY2FuZigpIC0gYXJndW1lbnQgJWQgYWZ0ZXIgZm9ybWF0AAAAAAAAdHlwZWRlZiBzdHJ1Y3QgX192YV9saXN0U3RydWN0IHZhX2xpc3Q7IHR5cGVkZWYgc3RydWN0IF9fRklMRVN0cnVjdCBGSUxFOwBGSUxFICpmb3BlbihjaGFyICosIGNoYXIgKik7AEZJTEUgKmZyZW9wZW4oY2hhciAqLCBjaGFyICosIEZJTEUgKik7AGludCBmY2xvc2UoRklMRSAqKTsAaW50IGZyZWFkKHZvaWQgKiwgaW50LCBpbnQsIEZJTEUgKik7AGludCBmd3JpdGUodm9pZCAqLCBpbnQsIGludCwgRklMRSAqKTsAaW50IGZnZXRjKEZJTEUgKik7AGludCBnZXRjKEZJTEUgKik7AGNoYXIgKmZnZXRzKGNoYXIgKiwgaW50LCBGSUxFICopOwBpbnQgZnB1dGMoaW50LCBGSUxFICopOwBpbnQgZnB1dHMoY2hhciAqLCBGSUxFICopOwBpbnQgcmVtb3ZlKGNoYXIgKik7AGludCByZW5hbWUoY2hhciAqLCBjaGFyICopOwB2b2lkIHJld2luZChGSUxFICopOwBGSUxFICp0bXBmaWxlKCk7AHZvaWQgY2xlYXJlcnIoRklMRSAqKTsAaW50IGZlb2YoRklMRSAqKTsAaW50IGZlcnJvcihGSUxFICopOwBpbnQgZmlsZW5vKEZJTEUgKik7AGludCBmZmx1c2goRklMRSAqKTsAaW50IGZnZXRwb3MoRklMRSAqLCBpbnQgKik7AGludCBmc2V0cG9zKEZJTEUgKiwgaW50ICopOwBpbnQgZnRlbGwoRklMRSAqKTsAaW50IGZzZWVrKEZJTEUgKiwgaW50LCBpbnQpOwB2b2lkIHBlcnJvcihjaGFyICopOwBpbnQgcHV0YyhjaGFyICosIEZJTEUgKik7AGludCBwdXRjaGFyKGludCk7AGludCBmcHV0Y2hhcihpbnQpOwB2b2lkIHNldGJ1ZihGSUxFICosIGNoYXIgKik7AHZvaWQgc2V0dmJ1ZihGSUxFICosIGNoYXIgKiwgaW50LCBpbnQpOwBpbnQgdW5nZXRjKGludCwgRklMRSAqKTsAaW50IHB1dHMoY2hhciAqKTsAY2hhciAqZ2V0cyhjaGFyICopOwBpbnQgZ2V0Y2hhcigpOwBpbnQgcHJpbnRmKGNoYXIgKiwgLi4uKTsAaW50IGZwcmludGYoRklMRSAqLCBjaGFyICosIC4uLik7AGludCBzcHJpbnRmKGNoYXIgKiwgY2hhciAqLCAuLi4pOwBpbnQgc25wcmludGYoY2hhciAqLCBpbnQsIGNoYXIgKiwgLi4uKTsAaW50IHNjYW5mKGNoYXIgKiwgLi4uKTsAaW50IGZzY2FuZihGSUxFICosIGNoYXIgKiwgLi4uKTsAaW50IHNzY2FuZihjaGFyICosIGNoYXIgKiwgLi4uKTsAaW50IHZwcmludGYoY2hhciAqLCB2YV9saXN0KTsAaW50IHZmcHJpbnRmKEZJTEUgKiwgY2hhciAqLCB2YV9saXN0KTsAaW50IHZzcHJpbnRmKGNoYXIgKiwgY2hhciAqLCB2YV9saXN0KTsAaW50IHZzbnByaW50ZihjaGFyICosIGludCwgY2hhciAqLCB2YV9saXN0KTsAaW50IHZzY2FuZihjaGFyICosIHZhX2xpc3QpOwBpbnQgdmZzY2FuZihGSUxFICosIGNoYXIgKiwgdmFfbGlzdCk7AGludCB2c3NjYW5mKGNoYXIgKiwgY2hhciAqLCB2YV9saXN0KTsAX19GSUxFU3RydWN0AF9fdmFfbGlzdFN0cnVjdABFT0YAU0VFS19TRVQAU0VFS19DVVIAU0VFS19FTkQAQlVGU0laAEZJTEVOQU1FX01BWABfSU9GQkYAX0lPTEJGAF9JT05CRgBMX3RtcG5hbQBHRVRTX01BWABzdGRpbgBzdGRvdXQAc3RkZXJyAE5VTEwAJWxkACVmAGZsb2F0IGFjb3MoZmxvYXQpOwBmbG9hdCBhc2luKGZsb2F0KTsAZmxvYXQgYXRhbihmbG9hdCk7AGZsb2F0IGF0YW4yKGZsb2F0LCBmbG9hdCk7AGZsb2F0IGNlaWwoZmxvYXQpOwBmbG9hdCBjb3MoZmxvYXQpOwBmbG9hdCBjb3NoKGZsb2F0KTsAZmxvYXQgZXhwKGZsb2F0KTsAZmxvYXQgZmFicyhmbG9hdCk7AGZsb2F0IGZsb29yKGZsb2F0KTsAZmxvYXQgZm1vZChmbG9hdCwgZmxvYXQpOwBmbG9hdCBmcmV4cChmbG9hdCwgaW50ICopOwBmbG9hdCBsZGV4cChmbG9hdCwgaW50KTsAZmxvYXQgbG9nKGZsb2F0KTsAZmxvYXQgbG9nMTAoZmxvYXQpOwBmbG9hdCBtb2RmKGZsb2F0LCBmbG9hdCAqKTsAZmxvYXQgcG93KGZsb2F0LGZsb2F0KTsAZmxvYXQgcm91bmQoZmxvYXQpOwBmbG9hdCBzaW4oZmxvYXQpOwBmbG9hdCBzaW5oKGZsb2F0KTsAZmxvYXQgc3FydChmbG9hdCk7AGZsb2F0IHRhbihmbG9hdCk7AGZsb2F0IHRhbmgoZmxvYXQpOwBNX0UATV9MT0cyRQBNX0xPRzEwRQBNX0xOMgBNX0xOMTAATV9QSQBNX1BJXzIATV9QSV80AE1fMV9QSQBNXzJfUEkATV8yX1NRUlRQSQBNX1NRUlQyAE1fU1FSVDFfMgBjaGFyICppbmRleChjaGFyICosaW50KTsAY2hhciAqcmluZGV4KGNoYXIgKixpbnQpOwB2b2lkICptZW1jcHkodm9pZCAqLHZvaWQgKixpbnQpOwB2b2lkICptZW1tb3ZlKHZvaWQgKix2b2lkICosaW50KTsAdm9pZCAqbWVtY2hyKGNoYXIgKixpbnQsaW50KTsAaW50IG1lbWNtcCh2b2lkICosdm9pZCAqLGludCk7AHZvaWQgKm1lbXNldCh2b2lkICosaW50LGludCk7AGNoYXIgKnN0cmNhdChjaGFyICosY2hhciAqKTsAY2hhciAqc3RybmNhdChjaGFyICosY2hhciAqLGludCk7AGNoYXIgKnN0cmNocihjaGFyICosaW50KTsAY2hhciAqc3RycmNocihjaGFyICosaW50KTsAaW50IHN0cmNtcChjaGFyICosY2hhciAqKTsAaW50IHN0cm5jbXAoY2hhciAqLGNoYXIgKixpbnQpOwBpbnQgc3RyY29sbChjaGFyICosY2hhciAqKTsAY2hhciAqc3RyY3B5KGNoYXIgKixjaGFyICopOwBjaGFyICpzdHJuY3B5KGNoYXIgKixjaGFyICosaW50KTsAY2hhciAqc3RyZXJyb3IoaW50KTsAaW50IHN0cmxlbihjaGFyICopOwBpbnQgc3Ryc3BuKGNoYXIgKixjaGFyICopOwBpbnQgc3RyY3NwbihjaGFyICosY2hhciAqKTsAY2hhciAqc3RycGJyayhjaGFyICosY2hhciAqKTsAY2hhciAqc3Ryc3RyKGNoYXIgKixjaGFyICopOwBjaGFyICpzdHJ0b2soY2hhciAqLGNoYXIgKik7AGludCBzdHJ4ZnJtKGNoYXIgKixjaGFyICosaW50KTsAY2hhciAqc3RyZHVwKGNoYXIgKik7AGNoYXIgKnN0cnRva19yKGNoYXIgKixjaGFyICosY2hhciAqKik7AE5VTEwAYWJvcnQAZmxvYXQgYXRvZihjaGFyICopOwBmbG9hdCBzdHJ0b2QoY2hhciAqLGNoYXIgKiopOwBpbnQgYXRvaShjaGFyICopOwBpbnQgYXRvbChjaGFyICopOwBpbnQgc3RydG9sKGNoYXIgKixjaGFyICoqLGludCk7AGludCBzdHJ0b3VsKGNoYXIgKixjaGFyICoqLGludCk7AHZvaWQgKm1hbGxvYyhpbnQpOwB2b2lkICpjYWxsb2MoaW50LGludCk7AHZvaWQgKnJlYWxsb2Modm9pZCAqLGludCk7AHZvaWQgZnJlZSh2b2lkICopOwBpbnQgcmFuZCgpOwB2b2lkIHNyYW5kKGludCk7AHZvaWQgYWJvcnQoKTsAdm9pZCBleGl0KGludCk7AGNoYXIgKmdldGVudihjaGFyICopOwBpbnQgc3lzdGVtKGNoYXIgKik7AGludCBhYnMoaW50KTsAaW50IGxhYnMoaW50KTsATlVMTA==");
base64DecodeToExistingUint8Array(bufferView, 8928, "dHlwZWRlZiBpbnQgdGltZV90OyB0eXBlZGVmIGludCBjbG9ja190OwBjaGFyICphc2N0aW1lKHN0cnVjdCB0bSAqKTsAdGltZV90IGNsb2NrKCk7AGNoYXIgKmN0aW1lKGludCAqKTsAZG91YmxlIGRpZmZ0aW1lKGludCwgaW50KTsAc3RydWN0IHRtICpnbXRpbWUoaW50ICopOwBzdHJ1Y3QgdG0gKmxvY2FsdGltZShpbnQgKik7AGludCBta3RpbWUoc3RydWN0IHRtICpwdG0pOwBpbnQgdGltZShpbnQgKik7AGludCBzdHJmdGltZShjaGFyICosIGludCwgY2hhciAqLCBzdHJ1Y3QgdG0gKik7AGNoYXIgKnN0cnB0aW1lKGNoYXIgKiwgY2hhciAqLCBzdHJ1Y3QgdG0gKik7AHN0cnVjdCB0bSAqZ210aW1lX3IoaW50ICosIHN0cnVjdCB0bSAqKTsAaW50IHRpbWVnbShzdHJ1Y3QgdG0gKik7AHRtAENMT0NLU19QRVJfU0VDAEVBQ0NFUwBFQUREUklOVVNFAEVBRERSTk9UQVZBSUwARUFGTk9TVVBQT1JUAEVBR0FJTgBFQUxSRUFEWQBFQkFERgBFQkFETVNHAEVCVVNZAEVDQU5DRUxFRABFQ0hJTEQARUNPTk5BQk9SVEVEAEVDT05OUkVGVVNFRABFQ09OTlJFU0VUAEVERUFETEsARURFU1RBRERSUkVRAEVET00ARURRVU9UAEVFWElTVABFRkFVTFQARUZCSUcARUhPU1RVTlJFQUNIAEVJRFJNAEVJTFNFUQBFSU5QUk9HUkVTUwBFSU5UUgBFSU5WQUwARUlPAEVJU0NPTk4ARUlTRElSAEVMT09QAEVNRklMRQBFTUxJTksARU1TR1NJWkUARU1VTFRJSE9QAEVOQU1FVE9PTE9ORwBFTkVURE9XTgBFTkVUUkVTRVQARU5FVFVOUkVBQ0gARU5GSUxFAEVOT0JVRlMARU5PREFUQQBFTk9ERVYARU5PRU5UAEVOT0VYRUMARU5PTENLAEVOT0xJTksARU5PTUVNAEVOT01TRwBFTk9QUk9UT09QVABFTk9TUEMARU5PU1IARU5PU1RSAEVOT1NZUwBFTk9UQ09OTgBFTk9URElSAEVOT1RFTVBUWQBFTk9UUkVDT1ZFUkFCTEUARU5PVFNPQ0sARU5PVFNVUABFTk9UVFkARU5YSU8ARU9QTk9UU1VQUABFT1ZFUkZMT1cARU9XTkVSREVBRABFUEVSTQBFUElQRQBFUFJPVE8ARVBST1RPTk9TVVBQT1JUAEVQUk9UT1RZUEUARVJBTkdFAEVST0ZTAEVTUElQRQBFU1JDSABFU1RBTEUARVRJTUUARVRJTUVET1VUAEVUWFRCU1kARVdPVUxEQkxPQ0sARVhERVYAZXJybm8AaW50IGlzYWxudW0oaW50KTsAaW50IGlzYWxwaGEoaW50KTsAaW50IGlzYmxhbmsoaW50KTsAaW50IGlzY250cmwoaW50KTsAaW50IGlzZGlnaXQoaW50KTsAaW50IGlzZ3JhcGgoaW50KTsAaW50IGlzbG93ZXIoaW50KTsAaW50IGlzcHJpbnQoaW50KTsAaW50IGlzcHVuY3QoaW50KTsAaW50IGlzc3BhY2UoaW50KTsAaW50IGlzdXBwZXIoaW50KTsAaW50IGlzeGRpZ2l0KGludCk7AGludCB0b2xvd2VyKGludCk7AGludCB0b3VwcGVyKGludCk7AGludCBpc2FzY2lpKGludCk7AGludCB0b2FzY2lpKGludCk7");
base64DecodeToExistingUint8Array(bufferView, 10320, "dHlwZWRlZiBpbnQgYm9vbDsAdHJ1ZQBmYWxzZQBfX2Jvb2xfdHJ1ZV9mYWxzZV9hcmVfZGVmaW5lZAAAAAAAAHR5cGVkZWYgaW50IHVpZF90OyB0eXBlZGVmIGludCBnaWRfdDsgdHlwZWRlZiBpbnQgcGlkX3Q7IHR5cGVkZWYgaW50IG9mZl90OyB0eXBlZGVmIGludCBzaXplX3Q7IHR5cGVkZWYgaW50IHNzaXplX3Q7IHR5cGVkZWYgaW50IHVzZWNvbmRzX3Q7dHlwZWRlZiBpbnQgaW50cHRyX3Q7AGludCBhY2Nlc3MoY2hhciAqLCBpbnQpOwB1bnNpZ25lZCBpbnQgYWxhcm0odW5zaWduZWQgaW50KTsAaW50IGNoZGlyKGNoYXIgKik7AGludCBjaHJvb3QoY2hhciAqKTsAaW50IGNob3duKGNoYXIgKiwgdWlkX3QsIGdpZF90KTsAaW50IGNsb3NlKGludCk7AHNpemVfdCBjb25mc3RyKGludCwgY2hhciAqLCBzaXplX3QpOwBjaGFyICpjdGVybWlkKGNoYXIgKik7AGludCBkdXAoaW50KTsAaW50IGR1cDIoaW50LCBpbnQpOwB2b2lkIF9leGl0KGludCk7AGludCBmY2hvd24oaW50LCB1aWRfdCwgZ2lkX3QpOwBpbnQgZmNoZGlyKGludCk7AGludCBmZGF0YXN5bmMoaW50KTsAcGlkX3QgZm9yayh2b2lkKTsAbG9uZyBmcGF0aGNvbmYoaW50LCBpbnQpOwBpbnQgZnN5bmMoaW50KTsAaW50IGZ0cnVuY2F0ZShpbnQsIG9mZl90KTsAY2hhciAqZ2V0Y3dkKGNoYXIgKiwgc2l6ZV90KTsAaW50IGdldGR0YWJsZXNpemUodm9pZCk7AGdpZF90IGdldGVnaWQodm9pZCk7AHVpZF90IGdldGV1aWQodm9pZCk7AGdpZF90IGdldGdpZCh2b2lkKTsAbG9uZyBnZXRob3N0aWQodm9pZCk7AGNoYXIgKmdldGxvZ2luKHZvaWQpOwBpbnQgZ2V0bG9naW5fcihjaGFyICosIHNpemVfdCk7AGludCBnZXRwYWdlc2l6ZSh2b2lkKTsAY2hhciAqZ2V0cGFzcyhjaGFyICopOwBwaWRfdCBnZXRwZ3JwKHZvaWQpOwBwaWRfdCBnZXRwaWQodm9pZCk7AHBpZF90IGdldHBwaWQodm9pZCk7AHVpZF90IGdldHVpZCh2b2lkKTsAY2hhciAqZ2V0d2QoY2hhciAqKTsAaW50IGlzYXR0eShpbnQpOwBpbnQgbGNob3duKGNoYXIgKiwgdWlkX3QsIGdpZF90KTsAaW50IGxpbmsoY2hhciAqLCBjaGFyICopOwBpbnQgbG9ja2YoaW50LCBpbnQsIG9mZl90KTsAb2ZmX3QgbHNlZWsoaW50LCBvZmZfdCwgaW50KTsAaW50IG5pY2UoaW50KTsAbG9uZyBwYXRoY29uZihjaGFyICosIGludCk7AGludCBwYXVzZSh2b2lkKTsAc3NpemVfdCByZWFkKGludCwgdm9pZCAqLCBzaXplX3QpOwBpbnQgcmVhZGxpbmsoY2hhciAqLCBjaGFyICosIHNpemVfdCk7AGludCBybWRpcihjaGFyICopOwB2b2lkICpzYnJrKGludHB0cl90KTsAaW50IHNldGdpZChnaWRfdCk7AGludCBzZXRwZ2lkKHBpZF90LCBwaWRfdCk7AHBpZF90IHNldHBncnAodm9pZCk7AGludCBzZXRyZWdpZChnaWRfdCwgZ2lkX3QpOwBpbnQgc2V0cmV1aWQodWlkX3QsIHVpZF90KTsAcGlkX3Qgc2V0c2lkKHZvaWQpOwBpbnQgc2V0dWlkKHVpZF90KTsAdW5zaWduZWQgaW50IHNsZWVwKHVuc2lnbmVkIGludCk7AGludCBzeW1saW5rKGNoYXIgKiwgY2hhciAqKTsAdm9pZCBzeW5jKHZvaWQpOwBsb25nIHN5c2NvbmYoaW50KTsAcGlkX3QgdGNnZXRwZ3JwKGludCk7AGludCB0Y3NldHBncnAoaW50LCBwaWRfdCk7AGludCB0cnVuY2F0ZShjaGFyICosIG9mZl90KTsAY2hhciAqdHR5bmFtZShpbnQpOwBpbnQgdHR5bmFtZV9yKGludCwgY2hhciAqLCBzaXplX3QpOwB1c2Vjb25kc190IHVhbGFybSh1c2Vjb25kc190LCB1c2Vjb25kc190KTsAaW50IHVubGluayhjaGFyICopOwBpbnQgdXNsZWVwKHVzZWNvbmRzX3QpOwBwaWRfdCB2Zm9yayh2b2lkKTsAc3NpemVfdCB3cml0ZShpbnQsIHZvaWQgKiwgc2l6ZV90KTsATlVMTABvcHRhcmcAb3B0aW5kAG9wdGVycgBvcHRvcHQAOFIAAMhSAAAtKyAgIDBYMHgAKG51bGwpAAAAABEACgAREREAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAEQAPChEREQMKBwABEwkLCwAACQYLAAALAAYRAAAAERER");
base64DecodeToExistingUint8Array(bufferView, 12289, "CwAAAAAAAAAAEQAKChEREQAKAAACAAkLAAAACQALAAAL");
base64DecodeToExistingUint8Array(bufferView, 12347, "DA==");
base64DecodeToExistingUint8Array(bufferView, 12359, "DAAAAAAMAAAAAAkMAAAAAAAMAAAM");
base64DecodeToExistingUint8Array(bufferView, 12405, "Dg==");
base64DecodeToExistingUint8Array(bufferView, 12417, "DQAAAAQNAAAAAAkOAAAAAAAOAAAO");
base64DecodeToExistingUint8Array(bufferView, 12463, "EA==");
base64DecodeToExistingUint8Array(bufferView, 12475, "DwAAAAAPAAAAAAkQAAAAAAAQAAAQAAASAAAAEhIS");
base64DecodeToExistingUint8Array(bufferView, 12530, "EgAAABISEgAAAAAAAAk=");
base64DecodeToExistingUint8Array(bufferView, 12579, "Cw==");
base64DecodeToExistingUint8Array(bufferView, 12591, "CgAAAAAKAAAAAAkLAAAAAAALAAAL");
base64DecodeToExistingUint8Array(bufferView, 12637, "DA==");
base64DecodeToExistingUint8Array(bufferView, 12649, "DAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAwMTIzNDU2Nzg5QUJDREVGLTBYKzBYIDBYLTB4KzB4IDB4AGluZgBJTkYAbmFuAE5BTgAu");
base64DecodeToExistingUint8Array(bufferView, 12764, "9g==");
base64DecodeToExistingUint8Array(bufferView, 12803, "//////8=");
base64DecodeToExistingUint8Array(bufferView, 12872, "cndhAAAAAAAvdG1wL3RtcGZpbGVfWFhYWFhYAHcrAABYUwAAcndhAP////////////////////////////////////////////////////////////////8AAQIDBAUGBwgJ/////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAECBAcDBgUAaW5maW5pdHkAbmFu");
base64DecodeToExistingUint8Array(bufferView, 13200, "0XSeAFedvSqAcFIP//8+JwoAAABkAAAA6AMAABAnAACghgEAQEIPAICWmAAA4fUFGAAAADUAAABxAAAAa////877//+Sv///AAAAAAAAAAAZEkQ7Aj8sRxQ9MzAKGwZGS0U3D0kOjhcDQB08aSs2H0otHAEgJSkhCAwVFiIuEDg+CzQxGGR0dXYvQQl/OREjQzJCiYqLBQQmKCcNKh41jAcaSJMTlJU=");
base64DecodeToExistingUint8Array(bufferView, 13376, "SWxsZWdhbCBieXRlIHNlcXVlbmNlAERvbWFpbiBlcnJvcgBSZXN1bHQgbm90IHJlcHJlc2VudGFibGUATm90IGEgdHR5AFBlcm1pc3Npb24gZGVuaWVkAE9wZXJhdGlvbiBub3QgcGVybWl0dGVkAE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNzAEZpbGUgZXhpc3RzAFZhbHVlIHRvbyBsYXJnZSBmb3IgZGF0YSB0eXBlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAE91dCBvZiBtZW1vcnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVkAFNvY2tldCBub3QgY29ubmVjdGVkAENhbm5vdCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93bgBPcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcwBPcGVyYXRpb24gaW4gcHJvZ3Jlc3MAU3RhbGUgZmlsZSBoYW5kbGUAUmVtb3RlIEkvTyBlcnJvcgBRdW90YSBleGNlZWRlZABObyBtZWRpdW0gZm91bmQAV3JvbmcgbWVkaXVtIHR5cGUATm8gZXJyb3IgaW5mb3JtYXRpb24AAAAAAAACAADAAwAAwAQAAMAFAADABgAAwAcAAMAIAADACQAAwAoAAMALAADADAAAwA0AAMAOAADADwAAwBAAAMARAADAEgAAwBMAAMAUAADAFQAAwBYAAMAXAADAGAAAwBkAAMAaAADAGwAAwBwAAMAdAADAHgAAwB8AAMAAAACzAQAAwwIAAMMDAADDBAAAwwUAAMMGAADDBwAAwwgAAMMJAADDCgAAwwsAAMMMAADDDQAA0w4AAMMPAADDAAAMuwEADMMCAAzDAwAMwwQADNMvcHJvYy9zZWxmL2ZkLwBMT0dOQU1FAC9kZXYvdHR5AAAAAAADAAAABAAAAAQAAAAGAAAAg/miAERObgD8KRUA0VcnAN009QBi28AAPJmVAEGQQwBjUf4Au96rALdhxQA6biQA0k1CAEkG4AAJ6i4AHJLRAOsd/gApsRwA6D6nAPU1ggBEuy4AnOmEALQmcABBfl8A1pE5AFODOQCc9DkAi1+EACj5vQD4HzsA3v+XAA+YBQARL+8AClqLAG0fbQDPfjYACcsnAEZPtwCeZj8ALepfALondQDl68cAPXvxAPc5BwCSUooA+2vqAB+xXwAIXY0AMANWAHv8RgDwq2sAILzPADb0mgDjqR0AXmGRAAgb5gCFmWUAoBRfAI1AaACA2P8AJ3NNAAYGMQDKVhUAyahzAHviYABrjMAAGcRHAM1nwwAJ6NwAWYMqAIt2xACmHJYARK/dABlX0QClPgUABQf/ADN+PwDCMugAmE/eALt9MgAmPcMAHmvvAJ/4XgA1HzoAf/LKAPGHHQB8kCEAaiR8ANVu+gAwLXcAFTtDALUUxgDDGZ0ArcTCACxNQQAMAF0Ahn1GAONxLQCbxpoAM2IAALTSfAC0p5cAN1XVANc+9gCjEBgATXb8AGSdKgBw16sAY3z4AHqwVwAXFecAwElWADvW2QCnhDgAJCPLANaKdwBaVCMAAB+5APEKGwAZzt8AnzH/AGYeagCZV2EArPtHAH5/2AAiZbcAMuiJAOa/YADvxM0AbDYJAF0/1AAW3tcAWDveAN6bkgDSIigAKIboAOJYTQDGyjIACOMWAOB9ywAXwFAA8x2nABjgWwAuEzQAgxJiAINIAQD1jlsArbB/AB7p8gBISkMAEGfTAKrd2ACuX0IAamHOAAoopADTmbQABqbyAFx3fwCjwoMAYTyIAIpzeACvjFoAb9e9AC2mYwD0v8sAjYHvACbBZwBVykUAytk2ACio0gDCYY0AEsl3AAQmFAASRpsAxFnEAMjFRABNspEAABfzANRDrQApSeUA/dUQAAC+/AAelMwAcM7uABM+9QDs8YAAs+fDAMf4KACTBZQAwXE+AC4JswALRfMAiBKcAKsgewAutZ8AR5LCAHsyLwAMVW0AcqeQAGvnHwAxy5YAeRZKAEF54gD034kA6JSXAOLmhACZMZcAiO1rAF9fNgC7/Q4ASJq0AGekbABxckIAjV0yAJ8VuAC85QkAjTElAPd0OQAwBRwADQwBAEsIaAAs7lgAR6qQAHTnAgC91iQA932mAG5IcgCfFu8AjpSmALSR9gDRU1EAzwryACCYMwD1S34AsmNoAN0+XwBAXQMAhYl/AFVSKQA3ZMAAbdgQADJIMgBbTHUATnHUAEVUbgALCcEAKvVpABRm1QAnB50AXQRQALQ72wDqdsUAh/kXAElrfQAdJ7oAlmkpAMbMrACtFFQAkOJqAIjZiQAsclAABKS+AHcHlADzMHAAAPwnAOpxqABmwkkAZOA9AJfdgwCjP5cAQ5T9AA2GjAAxQd4AkjmdAN1wjAAXt+cACN87ABU3KwBcgKAAWoCTABARkgAP6NgAbICvANv/SwA4kA8AWRh2AGKlFQBhy7sAx4m5ABBAvQDS8gQASXUnAOu29gDbIrsAChSqAIkmLwBkg3YACTszAA6UGgBROqoAHaPCAK/trgBcJhIAbcJNAC16nADAVpcAAz+DAAnw9gArQIwAbTGZADm0BwAMIBUA2MNbAPWSxADGrUsATsqlAKc3zQDmqTYAq5KUAN1CaAAZY94AdozvAGiLUgD82zcArqGrAN8VMQAArqEADPvaAGRNZgDtBbcAKWUwAFdWvwBH/zoAavm5AHW+8wAok98Aq4AwAGaM9gAEyxUA+iIGANnkHQA9s6QAVxuPADbNCQBOQukAE76kADMjtQDwqhoAT2WoANLBpQALPw8AW3jNACP5dgB7iwQAiRdyAMamUwBvbuIA7+sAAJtKWADE2rcAqma6AHbPzwDRAh0AsfEtAIyZwQDDrXcAhkjaAPddoADGgPQArPAvAN3smgA/XLwA0N5tAJDHHwAq27YAoyU6AACvmgCtU5MAtlcEACkttABLgH4A2genAHaqDgB7WaEAFhIqANy3LQD65f0Aidv+AIm+/QDkdmwABqn8AD6AcACFbhUA/Yf/ACg+BwBhZzMAKhiGAE296gCz568Aj21uAJVnOQAxv1sAhNdIADDfFgDHLUMAJWE1AMlwzgAwy7gAv2z9AKQAogAFbOQAWt2gACFvRwBiEtIAuVyEAHBhSQBrVuAAmVIBAFBVNwAe1bcAM/HEABNuXwBdMOQAhS6pAB2ywwChMjYACLekAOqx1AAW9yEAj2nkACf/dwAMA4AAjUAtAE/NoAAgpZkAs6LTAC9dCgC0+UIAEdrLAH2+0ACb28EAqxe9AMqigQAIalwALlUXACcAVQB/FPAA4QeGABQLZACWQY0Ah77eANr9KgBrJbYAe4k0AAXz/gC5v54AaGpPAEoqqABPxFoALfi8ANdamAD0x5UADU2NACA6pgCkV18AFD+xAIA4lQDMIAEAcd2GAMnetgC/YPUATWURAAEHawCMsKwAssDQAFFVSAAe+w4AlXLDAKMGOwDAQDUABtx7AOBFzABOKfoA1srIAOjzQQB8ZN4Am2TYANm+MQCkl8MAd1jUAGnjxQDw2hMAujo8AEYYRgBVdV8A0r31AG6SxgCsLl0ADkTtABw+QgBhxIcAKf3pAOfW8wAifMoAb5E1AAjgxQD/140AbmriALD9xgCTCMEAfF10AGutsgDNbp0APnJ7AMYRagD3z6kAKXPfALXJugC3AFEA4rINAHS6JADlfWAAdNiKAA0VLACBGAwAfmaUAAEpFgCfenYA/f2+AFZF7wDZfjYA7NkTAIu6uQDEl/wAMagnAPFuwwCUxTYA2KhWALSotQDPzA4AEoktAG9XNAAsVokAmc7jANYguQBrXqoAPiqcABFfzAD9C0oA4fT7AI47bQDihiwA6dSEAPy0qQDv7tEALjXJAC85YQA4IUQAG9nIAIH8CgD7SmoALxzYAFO0hABOmYwAVCLMACpV3ADAxtYACxmWABpwuABplWQAJlpgAD9S7gB/EQ8A9LURAPzL9QA0vC0ANLzuAOhdzADdXmAAZ46bAJIz7wDJF7gAYVibAOFXvABRg8YA2D4QAN1xSAAtHN0ArxihACEsRgBZ89cA2XqYAJ5UwABPhvoAVgb8AOV5rgCJIjYAOK0iAGeT3ABV6KoAgiY4AMrnmwBRDaQAmTOxAKnXDgBpBUgAZbLwAH+IpwCITJcA+dE2ACGSswB7gkoAmM8hAECf3ADcR1UA4XQ6AGfrQgD+nd8AXtRfAHtnpAC6rHoAVfaiACuIIwBBulUAWW4IACEqhgA5R4MAiePmAOWe1ABJ+0AA/1bpABwPygDFWYoAlPorANPBxQAPxc8A21quAEfFhgCFQ2IAIYY7ACx5lAAQYYcAKkx7AIAsGgBDvxIAiCaQAHg8iQCoxOQA5dt7AMQ6wgAm9OoA92eKAA2SvwBloysAPZOxAL18CwCkUdwAJ91jAGnh3QCalBkAqCmVAGjOKAAJ7bQARJ8gAE6YygBwgmMAfnwjAA+5MgCn9Y4AFFbnACHxCAC1nSoAb35NAKUZUQC1+asAgt/WAJbdYQAWNgIAxDqfAIOioQBy7W0AOY16AIK4qQBrMlwARidbAAA07QDSAHcA/PRVAAFZTQDgcYA=");
base64DecodeToExistingUint8Array(bufferView, 18211, "QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNU+7YQVnrN0/GC1EVPsh6T+b9oHSC3PvPxgtRFT7Ifk/4mUvIn8rejwHXBQzJqaBPL3L8HqIB3A8B1wUMyamkTwYLURU+yHpPxgtRFT7Iem/0iEzf3zZAkDSITN/fNkCwA==");
base64DecodeToExistingUint8Array(bufferView, 18383, "gBgtRFT7IQlAGC1EVPshCcAAAAAAAADgPwAAAAAAAOC/AAAAAAAA8D8AAAAAAAD4PwAAAAAAAAAABtDPQ+v9TD4=");
base64DecodeToExistingUint8Array(bufferView, 18459, "QAO44j8=");
base64DecodeToExistingUint8Array(bufferView, 18464, "tgYAAFMAAAC+BgAAWAAAAMQGAABZAAAAywYAAFUAAADPBgAAVgAAANYGAABXAAAA3gYAAFQAAADnBgAAQAAAAOwGAABOAAAA8gYAAFAAAAD3BgAANwAAAPwGAABHAAAABQcAAFEAAAANBwAAWwAAABQHAABIAAAAFwcAADkAAAAeBwAASQAAACMHAAA7AAAAKAcAAEIAAAAvBwAAOAAAADUHAABKAAAAOQcAAEsAAAA+BwAATAAAAEEHAAA2AAAARQcAADwAAABKBwAAWgAAAE4HAABBAAAAVwcAAFIAAABeBwAAPgAAAGQHAAA9AAAAawcAACUAAAByBwAAPwAAAHkHAABDAAAAgAcAAE8AAACHBwAARgAAAI8HAABEAAAAlQcAAEUAAACeBwAAOgAAAKMHAABNAAAAXnMwMDAwAF5lMDAwMA==");
base64DecodeToExistingUint8Array(bufferView, 18800, "IAAAAGoVAAAhAAAAehU=");
base64DecodeToExistingUint8Array(bufferView, 18824, "/wAAAAAAAAAiAAAAihYAACMAAACnFgAAJAAAAM4WAAAlAAAA4hYAACYAAAAHFwAAJwAAAC0XAAAnAAAAQBcAACgAAABSFwAAKQAAAHQXAAAqAAAAjBcAACsAAACnFwAALAAAALsXAAAtAAAA1xcAAC4AAADsFwAALwAAAP0XAAAwAAAAFBgAADEAAAAmGAAAMgAAADoYAAAzAAAAThgAADQAAABiGAAANQAAAH4YAAA2AAAAmhgAADcAAACtGAAAOAAAAMoYAAA5AAAA3xgAADoAAAD5GAAAOgAAAAsZAAA7AAAAHhkAADwAAAA7GQAAPQAAAGMZAAA+AAAAfBkAAD8AAACOGQAAQAAAAKIZAABBAAAAsRkAAEIAAADKGQAAQwAAAOwZAABEAAAADhoAAEUAAAA2GgAARgAAAE4aAABHAAAAbxoAAEgAAACQGgAASQAAAK4aAABKAAAA1RoAAEsAAAD8GgAATAAAACkbAABNAAAARhsAAE4AAABsGw==");
base64DecodeToExistingUint8Array(bufferView, 19216, "/////wEAAAACAAAAAAQAAAAQAAABAAAAAgAAABQAAABPAAAAKRwAAFAAAAA8HAAAUQAAAE8cAABSAAAAYhwAAFMAAAB9HAAAVAAAAJAcAABVAAAAohwAAFYAAAC1HAAAVwAAAMccAABYAAAA2hwAAFkAAADuHAAAWgAAAAgdAABbAAAAIx0AAFwAAAA8HQAAXQAAAE4dAABeAAAAYh0AAF8AAAB+HQAAYAAAAJYdAABhAAAAqh0AAGIAAAC8HQAAYwAAAM8dAABkAAAA4h0AAGUAAAD0HQ==");
base64DecodeToExistingUint8Array(bufferView, 19440, "aVcUiwq/BUD+gitlRxX3Pw7lJhV7y9s/7zn6/kIu5j8WVbW7sWsCQBgtRFT7IQlAGC1EVPsh+T8YLURU+yHpP4PIyW0wX9Q/g8jJbTBf5D9tm0JQ1w3yP807f2aeoPY/zTt/Zp6g5j8AAAAAAAAAAGYAAABnHgAAZwAAAIAeAABoAAAAmh4AAGkAAAC7HgAAagAAAN0eAABrAAAA+x4AAGwAAAAaHwAAbQAAADgfAABuAAAAVR8AAG8AAAB3HwAAcAAAAJEfAABxAAAArB8AAHIAAADHHwAAcwAAAOcfAAB0AAAAAyAAAHUAAAAgIAAAdgAAAEIgAAB3AAAAVyAAAHgAAABrIAAAeQAAAIYgAAB6AAAAoiAAAHsAAADAIAAAfAAAAN0gAAB9AAAA+iAAAH4AAAAaIQAAfwAAADAh");
base64DecodeToExistingUint8Array(bufferView, 19776, "gAAAAGIhAACBAAAAdiEAAIIAAACUIQAAgwAAAKYhAACEAAAAuCEAAIUAAADYIQAAhgAAAPkhAACHAAAADCIAAIgAAAAjIgAAiQAAAD4iAACKAAAAUSIAAIsAAABdIgAAjAAAAG4iAACNAAAAfCIAAI4AAACMIgAAjwAAAKIiAACQAAAAtiIAAJEAAADEIg==");
base64DecodeToExistingUint8Array(bufferView, 19936, "kgAAAAkjAACTAAAAJSMAAJQAAAA1IwAAlQAAAEkjAACWAAAAZCMAAJcAAAB+IwAAmAAAAJsjAACZAAAAtyMAAJoAAADIIwAAmwAAAPgjAACcAAAAJSQAAJ0AAABOJA==");
base64DecodeToExistingUint8Array(bufferView, 20040, "QEIPAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAhAAAAIgAAACMAAAAkAAAAJQAAACYAAAAnAAAAKAAAACkAAAAqAAAAdAAAACsAAAAsAAAALQAAAC4AAAAvAAAAMAAAADEAAAAyAAAAMwAAAHYAAABkAAAANAAAADUAAAA2AAAANwAAADgAAAA5AAAAigAAADsAAAA8AAAAigAAAD0AAAA+AAAAPwAAAEAAAABBAAAAQgAAAEMAAABEAAAARQAAAEYAAABHAAAASAAAAHUAAABJAAAASgAAAAYAAABLAAAAAAAAAJ4AAAAnJwAAnwAAADknAACgAAAASycAAKEAAABdJwAAogAAAG8nAACjAAAAgScAAKQAAACTJwAApQAAAKUnAACmAAAAtycAAKcAAADJJwAAqAAAANsnAACpAAAA7ScAAKoAAAAAKAAAqwAAABIoAACsAAAAJCgAAK0AAAA2KA==");
base64DecodeToExistingUint8Array(bufferView, 20504, "AQAAAAAAAACuAAAAMikAAK8AAABLKQAAsAAAAG0pAACxAAAAgCkAALIAAACUKQAAswAAALUpAAC0AAAAxSkAALUAAADqKQAAtgAAAAEqAAC3AAAADyoAALgAAAAjKgAAuQAAADQqAAC6AAAAUyoAALsAAABkKgAAvAAAAHgqAAC9AAAAiioAAL4AAACkKgAAvwAAALQqAADAAAAAzyoAAMEAAADtKgAAwgAAAAYrAADDAAAAGysAAMQAAAAwKwAAxQAAAEQrAADGAAAAWisAAMcAAABwKwAAyAAAAJArAADJAAAApysAAMoAAAC+KwAAywAAANMrAADMAAAA5ysAAM0AAAD8KwAAzgAAABAsAADPAAAAJSwAANAAAAA2LAAA0QAAAFgsAADSAAAAciwAANMAAACOLAAA1AAAAKwsAADVAAAAuywAANYAAADXLAAA1wAAAOgsAADYAAAACy0AANkAAAAxLQAA2gAAAEQtAADbAAAAWi0AANwAAABtLQAA3QAAAIgtAADeAAAAnS0AAN8AAAC5LQAA4AAAANUtAADhAAAA6S0AAOIAAAD8LQAA4wAAAB4uAADkAAAAOy4AAOUAAABMLgAA5gAAAF8uAADnAAAAdS4AAOgAAACQLgAA6QAAAK0uAADqAAAAwS4AAOsAAADlLgAA7AAAABAvAADtAAAAJC8AAO4AAAA8LwAA7wAAAE8v");
base64DecodeToExistingUint8Array(bufferView, 21048, "BQ==");
base64DecodeToExistingUint8Array(bufferView, 21060, "8A==");
base64DecodeToExistingUint8Array(bufferView, 21084, "8QAAAPIAAAAoVQ==");
base64DecodeToExistingUint8Array(bufferView, 21108, "Ag==");
base64DecodeToExistingUint8Array(bufferView, 21123, "//////8=");
base64DecodeToExistingUint8Array(bufferView, 21192, "CQ==");
base64DecodeToExistingUint8Array(bufferView, 21204, "8A==");
base64DecodeToExistingUint8Array(bufferView, 21224, "8wAAAAAAAADyAAAAOFUAAAAE");
base64DecodeToExistingUint8Array(bufferView, 21268, "/////w==");
base64DecodeToExistingUint8Array(bufferView, 21336, "BQ==");
base64DecodeToExistingUint8Array(bufferView, 21348, "9w==");
base64DecodeToExistingUint8Array(bufferView, 21372, "8QAAAPgAAABIWQAAAAQ=");
base64DecodeToExistingUint8Array(bufferView, 21396, "AQ==");
base64DecodeToExistingUint8Array(bufferView, 21411, "Cv////8=");
base64DecodeToExistingUint8Array(bufferView, 21480, "WFMAAAEAAAAB");
base64DecodeToExistingUint8Array(bufferView, 21668, "fF0=");
return asmFunc({
    'Int8Array': Int8Array,
    'Int16Array': Int16Array,
    'Int32Array': Int32Array,
    'Uint8Array': Uint8Array,
    'Uint16Array': Uint16Array,
    'Uint32Array': Uint32Array,
    'Float32Array': Float32Array,
    'Float64Array': Float64Array,
    'NaN': NaN,
    'Infinity': Infinity,
    'Math': Math
  },
  asmLibraryArg,
  wasmMemory.buffer
)

}
)(asmLibraryArg, wasmMemory, wasmTable);
    return {
      'exports': exports
    };
  },

  instantiate: /** @suppress{checkTypes} */ function(binary, info) {
    return {
      then: function(ok) {
        ok({
          'instance': new WebAssembly.Instance(new WebAssembly.Module(binary))
        });
      }
    };
  },

  RuntimeError: Error
};

// We don't need to actually download a wasm binary, mark it as present but empty.
wasmBinary = [];



if (typeof WebAssembly !== 'object') {
  err('no native wasm support detected');
}


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.
// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)

/** @param {number} ptr
    @param {number} value
    @param {string} type
    @param {number|boolean=} noSafe */
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[((ptr)>>0)]=value; break;
      case 'i8': HEAP8[((ptr)>>0)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}

/** @param {number} ptr
    @param {string} type
    @param {number|boolean=} noSafe */
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for getValue: ' + type);
    }
  return null;
}





// Wasm globals

var wasmMemory;

// In fastcomp asm.js, we don't need a wasm Table at all.
// In the wasm backend, we polyfill the WebAssembly object,
// so this creates a (non-native-wasm) table for us.
var wasmTable = new WebAssembly.Table({
  'initial': 251,
  'maximum': 251 + 0,
  'element': 'anyfunc'
});


//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS = 0;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

// C calling interface.
/** @param {string|null=} returnType
    @param {Array=} argTypes
    @param {Arguments|Array=} args
    @param {Object=} opts */
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') return UTF8ToString(ret);
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);
  var asyncMode = opts && opts.async;
  var runningAsync = typeof Asyncify === 'object' && Asyncify.currData;
  var prevRunningAsync = typeof Asyncify === 'object' && Asyncify.asyncFinalizers.length > 0;
  // Check if we started an async operation just now.
  if (runningAsync && !prevRunningAsync) {
    // If so, the WASM function ran asynchronous and unwound its stack.
    // We need to return a Promise that resolves the return value
    // once the stack is rewound and execution finishes.
    return new Promise(function(resolve) {
      Asyncify.asyncFinalizers.push(function(ret) {
        if (stack !== 0) stackRestore(stack);
        resolve(convertReturnValue(ret));
      });
    });
  }

  ret = convertReturnValue(ret);
  if (stack !== 0) stackRestore(stack);
  // If this is an async ccall, ensure we return a promise
  if (opts && opts.async) return Promise.resolve(ret);
  return ret;
}

/** @param {string=} returnType
    @param {Array=} argTypes
    @param {Object=} opts */
function cwrap(ident, returnType, argTypes, opts) {
  argTypes = argTypes || [];
  // When the function takes numbers and returns a number, we can just return
  // the original function
  var numericArgs = argTypes.every(function(type){ return type === 'number'});
  var numericRet = returnType !== 'string';
  if (numericRet && numericArgs && !opts) {
    return getCFunc(ident);
  }
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk
var ALLOC_NONE = 3; // Do not allocate

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc,
    stackAlloc,
    dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var stop;
    ptr = ret;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)>>0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}

// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready
function getMemory(size) {
  if (!runtimeInitialized) return dynamicAlloc(size);
  return _malloc(size);
}


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

/**
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(heap, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(heap.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = heap[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = heap[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = heap[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}



/**
 * @license
 * Copyright 2020 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;

function UTF16ToString(ptr) {
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  while (HEAP16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var i = 0;

    var str = '';
    while (1) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) return str;
      ++i;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)]=codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0) return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)]=codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated
    @param {boolean=} dontAddNull */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  HEAP8.set(array, buffer);
}

/** @param {boolean=} dontAddNull */
function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;
}



// Memory management

var PAGE_SIZE = 16384;
var WASM_PAGE_SIZE = 65536;
var ASMJS_PAGE_SIZE = 16777216;

function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}

var HEAP,
/** @type {ArrayBuffer} */
  buffer,
/** @type {Int8Array} */
  HEAP8,
/** @type {Uint8Array} */
  HEAPU8,
/** @type {Int16Array} */
  HEAP16,
/** @type {Uint16Array} */
  HEAPU16,
/** @type {Int32Array} */
  HEAP32,
/** @type {Uint32Array} */
  HEAPU32,
/** @type {Float32Array} */
  HEAPF32,
/** @type {Float64Array} */
  HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module['HEAP8'] = HEAP8 = new Int8Array(buf);
  Module['HEAP16'] = HEAP16 = new Int16Array(buf);
  Module['HEAP32'] = HEAP32 = new Int32Array(buf);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
}

var STATIC_BASE = 1024,
    STACK_BASE = 5267600,
    STACKTOP = STACK_BASE,
    STACK_MAX = 24720,
    DYNAMIC_BASE = 5267600,
    DYNAMICTOP_PTR = 24560;




var TOTAL_STACK = 5242880;

var INITIAL_INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;




/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */




// In standalone mode, the wasm creates the memory, and the user can't provide it.
// In non-standalone/normal mode, we create the memory here.

/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// Create the main memory. (Note: this isn't used in STANDALONE_WASM mode since the wasm
// memory is created in the wasm, not in JS.)

  if (Module['wasmMemory']) {
    wasmMemory = Module['wasmMemory'];
  } else
  {
    wasmMemory = new WebAssembly.Memory({
      'initial': INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE
      ,
      'maximum': INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE
    });
  }


if (wasmMemory) {
  buffer = wasmMemory.buffer;
}

// If the user provides an incorrect length, just use that length instead rather than providing the user to
// specifically provide the memory length with Module['INITIAL_MEMORY'].
INITIAL_INITIAL_MEMORY = buffer.byteLength;
updateGlobalBufferAndViews(buffer);

HEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;




/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */




/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */




function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback(Module); // Pass the module as the first argument.
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Module['dynCall_v'](func);
      } else {
        Module['dynCall_vi'](func, callback.arg);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;
var runtimeExited = false;


function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  runtimeInitialized = true;
  if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
TTY.init();
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  FS.ignorePermissions = false;
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  runtimeExited = true;
}

function postRun() {

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

/** @param {number|boolean=} ignore */
function unSign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
/** @param {number|boolean=} ignore */
function reSign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc


var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_round = Math.round;
var Math_min = Math.min;
var Math_max = Math.max;
var Math_clz32 = Math.clz32;
var Math_trunc = Math.trunc;



// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data


/** @param {string|number=} what */
function abort(what) {
  if (Module['onAbort']) {
    Module['onAbort'](what);
  }

  what += '';
  out(what);
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  what = 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.';

  // Throw a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  throw new WebAssembly.RuntimeError(what);
}


var memoryInitializer = null;


/**
 * @license
 * Copyright 2015 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */







/**
 * @license
 * Copyright 2017 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

function hasPrefix(str, prefix) {
  return String.prototype.startsWith ?
      str.startsWith(prefix) :
      str.indexOf(prefix) === 0;
}

// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  return hasPrefix(filename, dataURIPrefix);
}

var fileURIPrefix = "file://";

// Indicates whether filename is delivered via file protocol (as opposed to http/https)
function isFileURI(filename) {
  return hasPrefix(filename, fileURIPrefix);
}



var wasmBinaryFile = 'picoc.wasm';
if (!isDataURI(wasmBinaryFile)) {
  wasmBinaryFile = locateFile(wasmBinaryFile);
}

function getBinary() {
  try {
    if (wasmBinary) {
      return new Uint8Array(wasmBinary);
    }

    var binary = tryParseAsDataURI(wasmBinaryFile);
    if (binary) {
      return binary;
    }
    if (readBinary) {
      return readBinary(wasmBinaryFile);
    } else {
      throw "both async and sync fetching of the wasm failed";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // If we don't have the binary yet, and have the Fetch api, use that;
  // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function'
      // Let's not use fetch to get objects over file:// as it's most likely Cordova which doesn't support fetch for file://
      && !isFileURI(wasmBinaryFile)
      ) {
    return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
      if (!response['ok']) {
        throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
      }
      return response['arrayBuffer']();
    }).catch(function () {
      return getBinary();
    });
  }
  // Otherwise, getBinary should be able to get it synchronously
  return new Promise(function(resolve, reject) {
    resolve(getBinary());
  });
}



// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    var exports = instance.exports;
    exports = Asyncify.instrumentWasmExports(exports);
    Module['asm'] = exports;
    removeRunDependency('wasm-instantiate');
  }
  // we can't run yet (except in a pthread, where we have a custom sync instantiator)
  addRunDependency('wasm-instantiate');


  function receiveInstantiatedSource(output) {
    // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
    receiveInstance(output['instance']);
  }


  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);
      abort(reason);
    });
  }

  // Prefer streaming instantiation if available.
  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming === 'function' &&
        !isDataURI(wasmBinaryFile) &&
        // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
        !isFileURI(wasmBinaryFile) &&
        typeof fetch === 'function') {
      fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {
        var result = WebAssembly.instantiateStreaming(response, info);
        return result.then(receiveInstantiatedSource, function(reason) {
            // We expect the most common failure cause to be a bad MIME type for the binary,
            // in which case falling back to ArrayBuffer instantiation should work.
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            instantiateArrayBuffer(receiveInstantiatedSource);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiatedSource);
    }
  }
  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      exports = Asyncify.instrumentWasmExports(exports);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  instantiateAsync();
  return {}; // no exports yet; we'll fill them in later
}


// Globals used by JS i64 conversions
var tempDouble;
var tempI64;

// === Body ===

var ASM_CONSTS = {
  
};
function em_getchar_sync(){ return Module.getChar(); }
function em_exit(){ Module.onExitPicoc(); }
function em_stop(){ return Module.isInterrupted(); }



// STATICTOP = STATIC_BASE + 23696;
/* global initializers */  __ATINIT__.push({ func: function() { ___wasm_call_ctors() } });




/* no memory initializer */
// {{PRE_LIBRARY}}


  function demangle(func) {
      return func;
    }

  function demangleAll(text) {
      var regex =
        /\b_Z[\w\d_]+/g;
      return text.replace(regex,
        function(x) {
          var y = demangle(x);
          return x === y ? x : (y + ' [' + x + ']');
        });
    }

  function jsStackTrace() {
      var err = new Error();
      if (!err.stack) {
        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
        // so try that as a special-case.
        try {
          throw new Error();
        } catch(e) {
          err = e;
        }
        if (!err.stack) {
          return '(no stack trace available)';
        }
      }
      return err.stack.toString();
    }

  function stackTrace() {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return demangleAll(js);
    }

  function ___assert_fail(condition, filename, line, func) {
      abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);
    }

  
  
  var _emscripten_get_now;if (ENVIRONMENT_IS_NODE) {
    _emscripten_get_now = function() {
      var t = process['hrtime']();
      return t[0] * 1e3 + t[1] / 1e6;
    };
  } else if (typeof dateNow !== 'undefined') {
    _emscripten_get_now = dateNow;
  } else _emscripten_get_now = function() { return performance.now(); }
  ;
  
  var _emscripten_get_now_is_monotonic=true;;
  
  function setErrNo(value) {
      HEAP32[((___errno_location())>>2)]=value;
      return value;
    }function _clock_gettime(clk_id, tp) {
      // int clock_gettime(clockid_t clk_id, struct timespec *tp);
      var now;
      if (clk_id === 0) {
        now = Date.now();
      } else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) {
        now = _emscripten_get_now();
      } else {
        setErrNo(28);
        return -1;
      }
      HEAP32[((tp)>>2)]=(now/1000)|0; // seconds
      HEAP32[(((tp)+(4))>>2)]=((now % 1000)*1000*1000)|0; // nanoseconds
      return 0;
    }function ___clock_gettime(a0,a1
  ) {
  return _clock_gettime(a0,a1);
  }

  
  
  var PATH={splitPath:function(filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function(parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function(path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function(path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function(path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function(path) {
        return PATH.splitPath(path)[3];
      },join:function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function(l, r) {
        return PATH.normalize(l + '/' + r);
      }};
  
  
  var PATH_FS={resolve:function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function(from, to) {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  var TTY={ttys:[],init:function () {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function(stream) {
          // flush any pending line data
          stream.tty.ops.flush(stream.tty);
        },flush:function(stream) {
          stream.tty.ops.flush(stream.tty);
        },read:function(stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              // we will read data by chunks of BUFSIZE
              var BUFSIZE = 256;
              var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);
              var bytesRead = 0;
  
              try {
                bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
              } catch(e) {
                // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,
                // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.
                if (e.toString().indexOf('EOF') != -1) bytesRead = 0;
                else throw e;
              }
  
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString('utf-8');
              } else {
                result = null;
              }
            } else
            if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  var MEMFS={ops_table:null,mount:function(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },getFileDataAsRegularArray:function(node) {
        if (node.contents && node.contents.subarray) {
          var arr = [];
          for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
          return arr; // Returns a copy of the original data.
        }
        return node.contents; // No-op, the file contents are already in a JS array. Return as-is.
      },getFileDataAsTypedArray:function(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
        // avoid overshooting the allocation cap by a very large margin.
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); // Allocate new storage.
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
        return;
      },resizeFileStorage:function(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
          return;
        }
        if (!node.contents || node.contents.subarray) { // Resize a typed array if that is being used as the backing store.
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
          return;
        }
        // Backing with a JS array.
        if (!node.contents) node.contents = [];
        if (node.contents.length > newSize) node.contents.length = newSize;
        else while (node.contents.length < newSize) node.contents.push(0);
        node.usedBytes = newSize;
      },node_ops:{getattr:function(node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function(parent, name) {
          throw FS.genericErrors[44];
        },mknod:function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function(old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          old_node.parent = new_dir;
        },unlink:function(parent, name) {
          delete parent.contents[name];
        },rmdir:function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
        },readdir:function(node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }},stream_ops:{read:function(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function(stream, buffer, offset, length, position, canOwn) {
  
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); // Use typed array write if available.
          else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },llseek:function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },allocate:function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function(stream, buffer, offset, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if ( !(flags & 2) &&
                contents.buffer === buffer.buffer ) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            // malloc() can lead to growing the heap. If targeting the heap, we need to
            // re-acquire the heap buffer object in case growth had occurred.
            var fromHeap = (buffer.buffer == HEAP8.buffer);
            ptr = _malloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            (fromHeap ? HEAP8 : buffer).set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }
  
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        }}};var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:function(e) {
        if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace();
        return setErrNo(e.errno);
      },lookupPath:function(path, opts) {
        path = PATH_FS.resolve(FS.cwd(), path);
        opts = opts || {};
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        for (var key in defaults) {
          if (opts[key] === undefined) {
            opts[key] = defaults[key];
          }
        }
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(32);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:function(node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:function(parentid, name) {
        var hash = 0;
  
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:function(parent, name) {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:function(parent, name, mode, rdev) {
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:function(node) {
        FS.hashRemoveNode(node);
      },isRoot:function(node) {
        return node === node.parent;
      },isMountpoint:function(node) {
        return !!node.mounted;
      },isFile:function(mode) {
        return (mode & 61440) === 32768;
      },isDir:function(mode) {
        return (mode & 61440) === 16384;
      },isLink:function(mode) {
        return (mode & 61440) === 40960;
      },isChrdev:function(mode) {
        return (mode & 61440) === 8192;
      },isBlkdev:function(mode) {
        return (mode & 61440) === 24576;
      },isFIFO:function(mode) {
        return (mode & 61440) === 4096;
      },isSocket:function(mode) {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function(str) {
        var flags = FS.flagModes[str];
        if (typeof flags === 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:function(flag) {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:function(node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {
          return 2;
        } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {
          return 2;
        } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },mayLookup:function(dir) {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },mayCreate:function(dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:function(dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },mayOpen:function(node, flags) {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:function(fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },getStream:function(fd) {
        return FS.streams[fd];
      },createStream:function(stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = /** @constructor */ function(){};
          FS.FSStream.prototype = {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            }
          };
        }
        // clone it, so we can return an instance of FSStream
        var newStream = new FS.FSStream();
        for (var p in stream) {
          newStream[p] = stream[p];
        }
        stream = newStream;
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:function(fd) {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:function(stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:function() {
          throw new FS.ErrnoError(70);
        }},major:function(dev) {
        return ((dev) >> 8);
      },minor:function(dev) {
        return ((dev) & 0xff);
      },makedev:function(ma, mi) {
        return ((ma) << 8 | (mi));
      },registerDevice:function(dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:function(dev) {
        return FS.devices[dev];
      },getMounts:function(mount) {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:function(populate, callback) {
        if (typeof(populate) === 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach(function (mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:function(type, opts, mountpoint) {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:function (mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach(function (hash) {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.indexOf(current.mount) !== -1) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },lookup:function(parent, name) {
        return parent.node_ops.lookup(parent, name);
      },mknod:function(path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:function(path, mode) {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:function(path, mode) {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdirTree:function(path, mode) {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },mkdev:function(path, mode, dev) {
        if (typeof(dev) === 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:function(oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:function(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
        try {
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
        } catch (e) {
          throw new FS.ErrnoError(10);
        }
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        // new path should not be an ancestor of the old path
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        try {
          if (FS.trackingDelegate['willMovePath']) {
            FS.trackingDelegate['willMovePath'](old_path, new_path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
        try {
          if (FS.trackingDelegate['onMovePath']) FS.trackingDelegate['onMovePath'](old_path, new_path);
        } catch(e) {
          err("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
      },rmdir:function(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          err("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readdir:function(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },unlink:function(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          // According to POSIX, we should map EISDIR to EPERM, but
          // we instead do what Linux does (and we must, as we use
          // the musl linux libc).
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          err("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readlink:function(path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:function(path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },lstat:function(path) {
        return FS.stat(path, true);
      },chmod:function(path, mode, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:function(path, mode) {
        FS.chmod(path, mode, true);
      },fchmod:function(fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },chown:function(path, uid, gid, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:function(path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },fchown:function(fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:function(path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:function(fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },utime:function(path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:function(path, flags, mode, fd_start, fd_end) {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512 | 131072);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            err("FS.trackingDelegate error on read file: " + path);
          }
        }
        try {
          if (FS.trackingDelegate['onOpenFile']) {
            var trackingFlags = 0;
            if ((flags & 2097155) !== 1) {
              trackingFlags |= FS.tracking.openFlags.READ;
            }
            if ((flags & 2097155) !== 0) {
              trackingFlags |= FS.tracking.openFlags.WRITE;
            }
            FS.trackingDelegate['onOpenFile'](path, trackingFlags);
          }
        } catch(e) {
          err("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: " + e.message);
        }
        return stream;
      },close:function(stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },isClosed:function(stream) {
        return stream.fd === null;
      },llseek:function(stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:function(stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position !== 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:function(stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position !== 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        try {
          if (stream.path && FS.trackingDelegate['onWriteToFile']) FS.trackingDelegate['onWriteToFile'](stream.path);
        } catch(e) {
          err("FS.trackingDelegate['onWriteToFile']('"+stream.path+"') threw an exception: " + e.message);
        }
        return bytesWritten;
      },allocate:function(stream, offset, length) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:function(stream, buffer, offset, length, position, prot, flags) {
        // User requests writing to file (prot & PROT_WRITE != 0).
        // Checking if we have permissions to write to the file unless
        // MAP_PRIVATE flag is set. According to POSIX spec it is possible
        // to write to file opened in read-only mode with MAP_PRIVATE flag,
        // as all modifications will be visible only in the memory of
        // the current process.
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
      },msync:function(stream, buffer, offset, length, mmapFlags) {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:function(stream) {
        return 0;
      },ioctl:function(stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:function(path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'r';
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:function(path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'w';
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data === 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },cwd:function() {
        return FS.currentPath;
      },chdir:function(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:function() {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:function() {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: function() { return 0; },
          write: function(stream, buffer, offset, length, pos) { return length; }
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using Module['printErr']
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device;
        if (typeof crypto === 'object' && typeof crypto['getRandomValues'] === 'function') {
          // for modern web browsers
          var randomBuffer = new Uint8Array(1);
          random_device = function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
        } else
        if (ENVIRONMENT_IS_NODE) {
          // for nodejs with or without crypto support included
          try {
            var crypto_module = require('crypto');
            // nodejs has crypto support
            random_device = function() { return crypto_module['randomBytes'](1)[0]; };
          } catch (e) {
            // nodejs doesn't have crypto support
          }
        } else
        {}
        if (!random_device) {
          // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
          random_device = function() { abort("random_device"); };
        }
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:function() {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: function() {
            var node = FS.createNode('/proc/self', 'fd', 16384 | 511 /* 0777 */, 73);
            node.node_ops = {
              lookup: function(parent, name) {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: function() { return stream.path } }
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:function() {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 'r');
        var stdout = FS.open('/dev/stdout', 'w');
        var stderr = FS.open('/dev/stderr', 'w');
      },ensureErrnoError:function() {
        if (FS.ErrnoError) return;
        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = /** @this{Object} */ function(errno) {
            this.errno = errno;
          };
          this.setErrno(errno);
          this.message = 'FS error';
  
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [44].forEach(function(code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:function() {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
        };
      },init:function(input, output, error) {
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:function() {
        FS.init.initialized = false;
        // force-flush all streams, so we get musl std streams printed out
        var fflush = Module['_fflush'];
        if (fflush) fflush(0);
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:function(canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },joinPath:function(parts, forceRelative) {
        var path = PATH.join.apply(null, parts);
        if (forceRelative && path[0] == '/') path = path.substr(1);
        return path;
      },absolutePath:function(relative, base) {
        return PATH_FS.resolve(base, relative);
      },standardizePath:function(path) {
        return PATH.normalize(path);
      },findObject:function(path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          setErrNo(ret.error);
          return null;
        }
      },analyzePath:function(path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createFolder:function(parent, name, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path, mode);
      },createPath:function(parent, path, canRead, canWrite) {
        parent = typeof parent === 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:function(parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:function(parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 'w');
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:function(parent, name, input, output) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: function(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },createLink:function(parent, name, target, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path);
      },forceLoadFile:function(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
        if (!success) setErrNo(29);
        return success;
      },createLazyFile:function(parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        /** @constructor */
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (function(from, to) {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          });
          var lazyArray = this;
          lazyArray.setDataGetter(function(chunkNum) {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: /** @this{Object} */ function() {
                if(!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: /** @this{Object} */ function() {
                if(!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: /** @this {FSNode} */ function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(29);
            }
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          if (!FS.forceLoadFile(node)) {
            throw new FS.ErrnoError(29);
          }
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
        Browser.init(); // XXX perhaps this method should move onto Browser?
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency(dep);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },indexedDB:function() {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:function() {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function(paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:function(paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var getRequest = files.get(path);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};var SYSCALLS={mappings:{},DEFAULT_POLLMASK:5,umask:511,calculateAt:function(dirfd, path) {
        if (path[0] !== '/') {
          // relative path
          var dir;
          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = FS.getStream(dirfd);
            if (!dirstream) throw new FS.ErrnoError(8);
            dir = dirstream.path;
          }
          path = PATH.join2(dir, path);
        }
        return path;
      },doStat:function(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            // an error occurred while trying to look up the path; we should just report ENOTDIR
            return -54;
          }
          throw e;
        }
        HEAP32[((buf)>>2)]=stat.dev;
        HEAP32[(((buf)+(4))>>2)]=0;
        HEAP32[(((buf)+(8))>>2)]=stat.ino;
        HEAP32[(((buf)+(12))>>2)]=stat.mode;
        HEAP32[(((buf)+(16))>>2)]=stat.nlink;
        HEAP32[(((buf)+(20))>>2)]=stat.uid;
        HEAP32[(((buf)+(24))>>2)]=stat.gid;
        HEAP32[(((buf)+(28))>>2)]=stat.rdev;
        HEAP32[(((buf)+(32))>>2)]=0;
        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)]=tempI64[0],HEAP32[(((buf)+(44))>>2)]=tempI64[1]);
        HEAP32[(((buf)+(48))>>2)]=4096;
        HEAP32[(((buf)+(52))>>2)]=stat.blocks;
        HEAP32[(((buf)+(56))>>2)]=(stat.atime.getTime() / 1000)|0;
        HEAP32[(((buf)+(60))>>2)]=0;
        HEAP32[(((buf)+(64))>>2)]=(stat.mtime.getTime() / 1000)|0;
        HEAP32[(((buf)+(68))>>2)]=0;
        HEAP32[(((buf)+(72))>>2)]=(stat.ctime.getTime() / 1000)|0;
        HEAP32[(((buf)+(76))>>2)]=0;
        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(80))>>2)]=tempI64[0],HEAP32[(((buf)+(84))>>2)]=tempI64[1]);
        return 0;
      },doMsync:function(addr, stream, len, flags, offset) {
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },doMkdir:function(path, mode) {
        // remove a trailing slash, if one - /a/b/ has basename of '', but
        // we want to create b in the context of this function
        path = PATH.normalize(path);
        if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
        FS.mkdir(path, mode, 0);
        return 0;
      },doMknod:function(path, mode, dev) {
        // we don't want this in the JS API as it uses mknod to create all nodes.
        switch (mode & 61440) {
          case 32768:
          case 8192:
          case 24576:
          case 4096:
          case 49152:
            break;
          default: return -28;
        }
        FS.mknod(path, mode, dev);
        return 0;
      },doReadlink:function(path, buf, bufsize) {
        if (bufsize <= 0) return -28;
        var ret = FS.readlink(path);
  
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf+len];
        stringToUTF8(ret, buf, bufsize+1);
        // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)
        // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.
        HEAP8[buf+len] = endChar;
  
        return len;
      },doAccess:function(path, amode) {
        if (amode & ~7) {
          // need a valid mode
          return -28;
        }
        var node;
        var lookup = FS.lookupPath(path, { follow: true });
        node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = '';
        if (amode & 4) perms += 'r';
        if (amode & 2) perms += 'w';
        if (amode & 1) perms += 'x';
        if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      },doDup:function(path, flags, suggestFD) {
        var suggest = FS.getStream(suggestFD);
        if (suggest) FS.close(suggest);
        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
      },doReadv:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.read(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
          if (curr < len) break; // nothing more to read
        }
        return ret;
      },doWritev:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.write(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
        }
        return ret;
      },varargs:undefined,get:function() {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },getStreamFromFD:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      },get64:function(low, high) {
        return low;
      }};function ___sys_access(path, amode) {try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doAccess(path, amode);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_chdir(path) {try {
  
      path = SYSCALLS.getStr(path);
      FS.chdir(path);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_chown32(path, owner, group) {try {
  
      path = SYSCALLS.getStr(path);
      FS.chown(path, owner, group);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_dup(fd) {try {
  
      var old = SYSCALLS.getStreamFromFD(fd);
      return FS.open(old.path, old.flags, 0).fd;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_dup2(oldfd, suggestFD) {try {
  
      var old = SYSCALLS.getStreamFromFD(oldfd);
      if (old.fd === suggestFD) return suggestFD;
      return SYSCALLS.doDup(old.path, old.flags, suggestFD);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_dup3(fd, suggestFD, flags) {try {
  
      var old = SYSCALLS.getStreamFromFD(fd);
      if (old.fd === suggestFD) return -28;
      return SYSCALLS.doDup(old.path, old.flags, suggestFD);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_fchdir(fd) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.chdir(stream.path);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_fchown32(fd, owner, group) {try {
  
      FS.fchown(fd, owner, group);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_fcntl64(fd, cmd, varargs) {SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.open(stream.path, stream.flags, 0, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;  // FD_CLOEXEC makes no sense for a single process.
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 12:
        /* case 12: Currently in musl F_GETLK64 has same value as F_GETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */ {
          
          var arg = SYSCALLS.get();
          var offset = 0;
          // We're always unlocked.
          HEAP16[(((arg)+(offset))>>1)]=2;
          return 0;
        }
        case 13:
        case 14:
        /* case 13: Currently in musl F_SETLK64 has same value as F_SETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
        /* case 14: Currently in musl F_SETLKW64 has same value as F_SETLKW, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
          
          
          return 0; // Pretend that the locking is successful.
        case 16:
        case 8:
          return -28; // These are for sockets. We don't have them fully implemented yet.
        case 9:
          // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves.
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_fdatasync(fd) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return 0; // we can't do anything synchronously; the in-memory FS is already synced to
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_ftruncate64(fd, zero, low, high) {try {
  
      var length = SYSCALLS.get64(low, high);
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_getcwd(buf, size) {try {
  
      if (size === 0) return -28;
      var cwd = FS.cwd();
      var cwdLengthInBytes = lengthBytesUTF8(cwd);
      if (size < cwdLengthInBytes + 1) return -68;
      stringToUTF8(cwd, buf, size);
      return buf;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_getegid32() {
      return 0;
    }

  function ___sys_geteuid32(
  ) {
  return ___sys_getegid32();
  }

  function ___sys_getgid32(
  ) {
  return ___sys_getegid32();
  }

  function ___sys_getpgid(pid) {
      if (pid && pid !== 42) return -71;
      return 42;
    }

  function ___sys_getpid() {
      return 42;
    }

  function ___sys_getppid() {
      return 1;
    }

  function ___sys_getuid32(
  ) {
  return ___sys_getegid32();
  }

  function ___sys_ioctl(fd, op, varargs) {SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509:
        case 21505: {
          if (!stream.tty) return -59;
          return 0;
        }
        case 21510:
        case 21511:
        case 21512:
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty) return -59;
          return 0; // no-op, not actually adjusting terminal settings
        }
        case 21519: {
          if (!stream.tty) return -59;
          var argp = SYSCALLS.get();
          HEAP32[((argp)>>2)]=0;
          return 0;
        }
        case 21520: {
          if (!stream.tty) return -59;
          return -28; // not supported
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          // TODO: in theory we should write to the winsize struct that gets
          // passed in, but for now musl doesn't read anything on it
          if (!stream.tty) return -59;
          return 0;
        }
        case 21524: {
          // TODO: technically, this ioctl call should change the window size.
          // but, since emscripten doesn't have any concept of a terminal window
          // yet, we'll just silently throw it away as we do TIOCGWINSZ
          if (!stream.tty) return -59;
          return 0;
        }
        default: abort('bad ioctl syscall ' + op);
      }
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_lchown32(path, owner, group) {try {
  
      path = SYSCALLS.getStr(path);
      FS.chown(path, owner, group); // XXX we ignore the 'l' aspect, and do the same as chown
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_link(oldpath, newpath) {
      return -34; // no hardlinks for us
    }

  function ___sys_nice(inc) {
      return -63; // no meaning to nice for our single-process environment
    }

  function ___sys_open(path, flags, varargs) {SYSCALLS.varargs = varargs;
  try {
  
      var pathname = SYSCALLS.getStr(path);
      var mode = SYSCALLS.get();
      var stream = FS.open(pathname, flags, mode);
      return stream.fd;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_pause() {
      return -27; // we can't pause
    }

  function ___sys_read(fd, buf, count) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return FS.read(stream, HEAP8,buf, count);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_readlink(path, buf, bufsize) {try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doReadlink(path, buf, bufsize);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_rename(old_path, new_path) {try {
  
      old_path = SYSCALLS.getStr(old_path);
      new_path = SYSCALLS.getStr(new_path);
      FS.rename(old_path, new_path);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_rmdir(path) {try {
  
      path = SYSCALLS.getStr(path);
      FS.rmdir(path);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_setpgid(pid, pgid) {
      if (pid && pid !== 42) return -71;
      if (pgid && pgid !== 42) return -63;
      return 0;
    }

  function ___sys_setsid() {
      return 0; // no-op
    }

  function ___sys_stat64(path, buf) {try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_symlink(target, linkpath) {try {
  
      target = SYSCALLS.getStr(target);
      linkpath = SYSCALLS.getStr(linkpath);
      FS.symlink(target, linkpath);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_sync() {
      return 0;
    }

  function ___sys_truncate64(path, zero, low, high) {try {
  
      path = SYSCALLS.getStr(path);
      var length = SYSCALLS.get64(low, high);
      FS.truncate(path, length);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_unlink(path) {try {
  
      path = SYSCALLS.getStr(path);
      FS.unlink(path);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  
  function _exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
      exit(status);
    }function __exit(a0
  ) {
  return _exit(a0);
  }

  function _abort() {
      abort();
    }

  
  var __sigalrm_handler=0;function _alarm(seconds) {
      setTimeout(function() {
        if (__sigalrm_handler) dynCall_vi(__sigalrm_handler, 0);
      }, seconds*1000);
    }

  
  var ___tm_formatted=24640;
  
  
  
  function _tzset() {
      // TODO: Use (malleable) environment variables instead of system settings.
      if (_tzset.called) return;
      _tzset.called = true;
  
      // timezone is specified as seconds west of UTC ("The external variable
      // `timezone` shall be set to the difference, in seconds, between
      // Coordinated Universal Time (UTC) and local standard time."), the same
      // as returned by getTimezoneOffset().
      // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html
      HEAP32[((__get_timezone())>>2)]=(new Date()).getTimezoneOffset() * 60;
  
      var currentYear = new Date().getFullYear();
      var winter = new Date(currentYear, 0, 1);
      var summer = new Date(currentYear, 6, 1);
      HEAP32[((__get_daylight())>>2)]=Number(winter.getTimezoneOffset() != summer.getTimezoneOffset());
  
      function extractZone(date) {
        var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/);
        return match ? match[1] : "GMT";
      };
      var winterName = extractZone(winter);
      var summerName = extractZone(summer);
      var winterNamePtr = allocateUTF8(winterName);
      var summerNamePtr = allocateUTF8(summerName);
      if (summer.getTimezoneOffset() < winter.getTimezoneOffset()) {
        // Northern hemisphere
        HEAP32[((__get_tzname())>>2)]=winterNamePtr;
        HEAP32[(((__get_tzname())+(4))>>2)]=summerNamePtr;
      } else {
        HEAP32[((__get_tzname())>>2)]=summerNamePtr;
        HEAP32[(((__get_tzname())+(4))>>2)]=winterNamePtr;
      }
    }function _mktime(tmPtr) {
      _tzset();
      var date = new Date(HEAP32[(((tmPtr)+(20))>>2)] + 1900,
                          HEAP32[(((tmPtr)+(16))>>2)],
                          HEAP32[(((tmPtr)+(12))>>2)],
                          HEAP32[(((tmPtr)+(8))>>2)],
                          HEAP32[(((tmPtr)+(4))>>2)],
                          HEAP32[((tmPtr)>>2)],
                          0);
  
      // There's an ambiguous hour when the time goes back; the tm_isdst field is
      // used to disambiguate it.  Date() basically guesses, so we fix it up if it
      // guessed wrong, or fill in tm_isdst with the guess if it's -1.
      var dst = HEAP32[(((tmPtr)+(32))>>2)];
      var guessedOffset = date.getTimezoneOffset();
      var start = new Date(date.getFullYear(), 0, 1);
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dstOffset = Math.min(winterOffset, summerOffset); // DST is in December in South
      if (dst < 0) {
        // Attention: some regions don't have DST at all.
        HEAP32[(((tmPtr)+(32))>>2)]=Number(summerOffset != winterOffset && dstOffset == guessedOffset);
      } else if ((dst > 0) != (dstOffset == guessedOffset)) {
        var nonDstOffset = Math.max(winterOffset, summerOffset);
        var trueOffset = dst > 0 ? dstOffset : nonDstOffset;
        // Don't try setMinutes(date.getMinutes() + ...) -- it's messed up.
        date.setTime(date.getTime() + (trueOffset - guessedOffset)*60000);
      }
  
      HEAP32[(((tmPtr)+(24))>>2)]=date.getDay();
      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)]=yday;
  
      return (date.getTime() / 1000)|0;
    }function _asctime_r(tmPtr, buf) {
      var date = {
        tm_sec: HEAP32[((tmPtr)>>2)],
        tm_min: HEAP32[(((tmPtr)+(4))>>2)],
        tm_hour: HEAP32[(((tmPtr)+(8))>>2)],
        tm_mday: HEAP32[(((tmPtr)+(12))>>2)],
        tm_mon: HEAP32[(((tmPtr)+(16))>>2)],
        tm_year: HEAP32[(((tmPtr)+(20))>>2)],
        tm_wday: HEAP32[(((tmPtr)+(24))>>2)]
      };
      var days = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ];
      var months = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                     "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
      var s = days[date.tm_wday] + ' ' + months[date.tm_mon] +
          (date.tm_mday < 10 ? '  ' : ' ') + date.tm_mday +
          (date.tm_hour < 10 ? ' 0' : ' ') + date.tm_hour +
          (date.tm_min < 10 ? ':0' : ':') + date.tm_min +
          (date.tm_sec < 10 ? ':0' : ':') + date.tm_sec +
          ' ' + (1900 + date.tm_year) + "\n";
  
      // asctime_r is specced to behave in an undefined manner if the algorithm would attempt
      // to write out more than 26 bytes (including the null terminator).
      // See http://pubs.opengroup.org/onlinepubs/9699919799/functions/asctime.html
      // Our undefined behavior is to truncate the write to at most 26 bytes, including null terminator.
      stringToUTF8(s, buf, 26);
      return buf;
    }function _asctime(tmPtr) {
      return _asctime_r(tmPtr, ___tm_formatted);
    }

  function _chroot(path) {
      // int chroot(const char *path);
      // http://pubs.opengroup.org/onlinepubs/7908799/xsh/chroot.html
      setErrNo(2);
      return -1;
    }

  function _clock() {
      if (_clock.start === undefined) _clock.start = Date.now();
      return ((Date.now() - _clock.start) * (1000000 / 1000))|0;
    }

  
  var ENV={};function _confstr(name, buf, len) {
      // size_t confstr(int name, char *buf, size_t len);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/confstr.html
      var value;
      switch (name) {
        case 0:
          value = ENV['PATH'] || '/';
          break;
        case 1:
          // Mimicking glibc.
          value = 'POSIX_V6_ILP32_OFF32\nPOSIX_V6_ILP32_OFFBIG';
          break;
        case 2:
          // This JS implementation was tested against this glibc version.
          value = 'glibc 2.14';
          break;
        case 3:
          // We don't support pthreads.
          value = '';
          break;
        case 1118:
        case 1122:
        case 1124:
        case 1125:
        case 1126:
        case 1128:
        case 1129:
        case 1130:
          value = '';
          break;
        case 1116:
        case 1117:
        case 1121:
          value = '-m32';
          break;
        case 1120:
          value = '-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64';
          break;
        default:
          setErrNo(28);
          return 0;
      }
      if (len == 0 || buf == 0) {
        return value.length + 1;
      } else {
        var length = Math.min(len, value.length);
        for (var i = 0; i < length; i++) {
          HEAP8[(((buf)+(i))>>0)]=value.charCodeAt(i);
        }
        if (len > length) HEAP8[(((buf)+(i++))>>0)]=0;
        return i;
      }
    }

  
  var ___tm_current=24576;
  
  
  
  var ___tm_timezone=(stringToUTF8("GMT", 24624, 4), 24624);function _localtime_r(time, tmPtr) {
      _tzset();
      var date = new Date(HEAP32[((time)>>2)]*1000);
      HEAP32[((tmPtr)>>2)]=date.getSeconds();
      HEAP32[(((tmPtr)+(4))>>2)]=date.getMinutes();
      HEAP32[(((tmPtr)+(8))>>2)]=date.getHours();
      HEAP32[(((tmPtr)+(12))>>2)]=date.getDate();
      HEAP32[(((tmPtr)+(16))>>2)]=date.getMonth();
      HEAP32[(((tmPtr)+(20))>>2)]=date.getFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)]=date.getDay();
  
      var start = new Date(date.getFullYear(), 0, 1);
      var yday = ((date.getTime() - start.getTime()) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)]=yday;
      HEAP32[(((tmPtr)+(36))>>2)]=-(date.getTimezoneOffset() * 60);
  
      // Attention: DST is in December in South, and some regions don't have DST at all.
      var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
      var winterOffset = start.getTimezoneOffset();
      var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset))|0;
      HEAP32[(((tmPtr)+(32))>>2)]=dst;
  
      var zonePtr = HEAP32[(((__get_tzname())+(dst ? 4 : 0))>>2)];
      HEAP32[(((tmPtr)+(40))>>2)]=zonePtr;
  
      return tmPtr;
    }function _ctime_r(time, buf) {
      var stack = stackSave();
      var rv = _asctime_r(_localtime_r(time, stackAlloc(44)), buf);
      stackRestore(stack);
      return rv;
    }function _ctime(timer) {
      return _ctime_r(timer, ___tm_current);
    }

  function _difftime(time1, time0) {
      return time1 - time0;
    }

  function _emscripten_get_sbrk_ptr() {
      return 24560;
    }

  
  
  
  var setjmpId=0;function _saveSetjmp(env, label, table, size) {
      // Not particularly fast: slow table lookup of setjmpId to label. But setjmp
      // prevents relooping anyhow, so slowness is to be expected. And typical case
      // is 1 setjmp per invocation, or less.
      env = env|0;
      label = label|0;
      table = table|0;
      size = size|0;
      var i = 0;
      setjmpId = (setjmpId+1)|0;
      HEAP32[((env)>>2)]=setjmpId;
      while ((i|0) < (size|0)) {
        if (((HEAP32[(((table)+((i<<3)))>>2)])|0) == 0) {
          HEAP32[(((table)+((i<<3)))>>2)]=setjmpId;
          HEAP32[(((table)+((i<<3)+4))>>2)]=label;
          // prepare next slot
          HEAP32[(((table)+((i<<3)+8))>>2)]=0;
          setTempRet0((size) | 0);
          return table | 0;
        }
        i = i+1|0;
      }
      // grow the table
      size = (size*2)|0;
      table = _realloc(table|0, 8*(size+1|0)|0) | 0;
      table = _saveSetjmp(env|0, label|0, table|0, size|0) | 0;
      setTempRet0((size) | 0);
      return table | 0;
    }
  
  function _testSetjmp(id, table, size) {
      id = id|0;
      table = table|0;
      size = size|0;
      var i = 0, curr = 0;
      while ((i|0) < (size|0)) {
        curr = ((HEAP32[(((table)+((i<<3)))>>2)])|0);
        if ((curr|0) == 0) break;
        if ((curr|0) == (id|0)) {
          return ((HEAP32[(((table)+((i<<3)+4))>>2)])|0);
        }
        i = i+1|0;
      }
      return 0;
    }function _longjmp(env, value) {
      _setThrew(env, value || 1);
      throw 'longjmp';
    }function _emscripten_longjmp(env, value) {
      _longjmp(env, value);
    }

  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }

  
  function _emscripten_get_heap_size() {
      return HEAPU8.length;
    }
  
  function abortOnCannotGrowMemory(requestedSize) {
      abort('OOM');
    }function _emscripten_resize_heap(requestedSize) {
      abortOnCannotGrowMemory(requestedSize);
    }

  function _emscripten_sleep(ms) {
      Asyncify.handleSleep(function(wakeUp) {
        Browser.safeSetTimeout(wakeUp, ms);
      });
    }

  
  
  function __getExecutableName() {
      return thisProgram || './this.program';
    }function getEnvStrings() {
      if (!getEnvStrings.strings) {
        // Default values.
        var env = {
          'USER': 'web_user',
          'LOGNAME': 'web_user',
          'PATH': '/',
          'PWD': '/',
          'HOME': '/home/web_user',
          // Browser language detection #8751
          'LANG': ((typeof navigator === 'object' && navigator.languages && navigator.languages[0]) || 'C').replace('-', '_') + '.UTF-8',
          '_': __getExecutableName()
        };
        // Apply the user-provided values, if any.
        for (var x in ENV) {
          env[x] = ENV[x];
        }
        var strings = [];
        for (var x in env) {
          strings.push(x + '=' + env[x]);
        }
        getEnvStrings.strings = strings;
      }
      return getEnvStrings.strings;
    }function _environ_get(__environ, environ_buf) {
      var bufSize = 0;
      getEnvStrings().forEach(function(string, i) {
        var ptr = environ_buf + bufSize;
        HEAP32[(((__environ)+(i * 4))>>2)]=ptr;
        writeAsciiToMemory(string, ptr);
        bufSize += string.length + 1;
      });
      return 0;
    }

  function _environ_sizes_get(penviron_count, penviron_buf_size) {
      var strings = getEnvStrings();
      HEAP32[((penviron_count)>>2)]=strings.length;
      var bufSize = 0;
      strings.forEach(function(string) {
        bufSize += string.length + 1;
      });
      HEAP32[((penviron_buf_size)>>2)]=bufSize;
      return 0;
    }


  function _fd_close(fd) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_fdstat_get(fd, pbuf) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      // All character devices are terminals (other things a Linux system would
      // assume is a character device, like the mouse, we have special APIs for).
      var type = stream.tty ? 2 :
                 FS.isDir(stream.mode) ? 3 :
                 FS.isLink(stream.mode) ? 7 :
                 4;
      HEAP8[((pbuf)>>0)]=type;
      // TODO HEAP16[(((pbuf)+(2))>>1)]=?;
      // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(8))>>2)]=tempI64[0],HEAP32[(((pbuf)+(12))>>2)]=tempI64[1]);
      // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(16))>>2)]=tempI64[0],HEAP32[(((pbuf)+(20))>>2)]=tempI64[1]);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_read(fd, iov, iovcnt, pnum) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doReadv(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)]=num
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {try {
  
      
      var stream = SYSCALLS.getStreamFromFD(fd);
      var HIGH_OFFSET = 0x100000000; // 2^32
      // use an unsigned operator on low and shift high by 32-bits
      var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
  
      var DOUBLE_LIMIT = 0x20000000000000; // 2^53
      // we also check for equality since DOUBLE_LIMIT + 1 == DOUBLE_LIMIT
      if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
        return -61;
      }
  
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)]=tempI64[0],HEAP32[(((newOffset)+(4))>>2)]=tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_sync(fd) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return Asyncify.handleSleep(function(wakeUp) {
        var mount = stream.node.mount;
        if (!mount.type.syncfs) {
          // We write directly to the file system, so there's nothing to do here.
          wakeUp(0);
          return;
        }
        mount.type.syncfs(mount, false, function(err) {
          if (err) {
            wakeUp(function() { return 29 });
            return;
          }
          wakeUp(0);
        });
      });
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_write(fd, iov, iovcnt, pnum) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doWritev(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)]=num
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fork() {
      // pid_t fork(void);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fork.html
      // We don't support multiple processes.
      setErrNo(6);
      return -1;
    }

  function _fpathconf(fildes, name) {
      // long fpathconf(int fildes, int name);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/encrypt.html
      // NOTE: The first parameter is ignored, so pathconf == fpathconf.
      // The constants here aren't real values. Just mimicking glibc.
      switch (name) {
        case 0:
          return 32000;
        case 1:
        case 2:
        case 3:
          return 255;
        case 4:
        case 5:
        case 16:
        case 17:
        case 18:
          return 4096;
        case 6:
        case 7:
        case 20:
          return 1;
        case 8:
          return 0;
        case 9:
        case 10:
        case 11:
        case 12:
        case 14:
        case 15:
        case 19:
          return -1;
        case 13:
          return 64;
      }
      setErrNo(28);
      return -1;
    }

  function _getTempRet0() {
      return (getTempRet0() | 0);
    }

  
  function _gmtime_r(time, tmPtr) {
      var date = new Date(HEAP32[((time)>>2)]*1000);
      HEAP32[((tmPtr)>>2)]=date.getUTCSeconds();
      HEAP32[(((tmPtr)+(4))>>2)]=date.getUTCMinutes();
      HEAP32[(((tmPtr)+(8))>>2)]=date.getUTCHours();
      HEAP32[(((tmPtr)+(12))>>2)]=date.getUTCDate();
      HEAP32[(((tmPtr)+(16))>>2)]=date.getUTCMonth();
      HEAP32[(((tmPtr)+(20))>>2)]=date.getUTCFullYear()-1900;
      HEAP32[(((tmPtr)+(24))>>2)]=date.getUTCDay();
      HEAP32[(((tmPtr)+(36))>>2)]=0;
      HEAP32[(((tmPtr)+(32))>>2)]=0;
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)]=yday;
      HEAP32[(((tmPtr)+(40))>>2)]=___tm_timezone;
  
      return tmPtr;
    }function _gmtime(time) {
      return _gmtime_r(time, ___tm_current);
    }


  function _localtime(time) {
      return _localtime_r(time, ___tm_current);
    }


  
  function _usleep(useconds) {
      // int usleep(useconds_t useconds);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/usleep.html
      // We're single-threaded, so use a busy loop. Super-ugly.
      var start = _emscripten_get_now();
      while (_emscripten_get_now() - start < useconds / 1000) {
        // Do nothing.
      }
    }
  Module["_usleep"] = _usleep;function _nanosleep(rqtp, rmtp) {
      // int nanosleep(const struct timespec  *rqtp, struct timespec *rmtp);
      if (rqtp === 0) {
        setErrNo(28);
        return -1;
      }
      var seconds = HEAP32[((rqtp)>>2)];
      var nanoseconds = HEAP32[(((rqtp)+(4))>>2)];
      if (nanoseconds < 0 || nanoseconds > 999999999 || seconds < 0) {
        setErrNo(28);
        return -1;
      }
      if (rmtp !== 0) {
        HEAP32[((rmtp)>>2)]=0;
        HEAP32[(((rmtp)+(4))>>2)]=0;
      }
      return _usleep((seconds * 1e6) + (nanoseconds / 1000));
    }

  function _pathconf(a0,a1
  ) {
  return _fpathconf(a0,a1);
  }


  function _setTempRet0($i) {
      setTempRet0(($i) | 0);
    }

  function _setitimer() {
      throw 'setitimer() is not implemented yet';
    }

  function _signal(sig, func) {
      if (sig == 14 /*SIGALRM*/) {
        __sigalrm_handler = func;
      } else {
      }
      return 0;
    }

  
  function __isLeapYear(year) {
        return year%4 === 0 && (year%100 !== 0 || year%400 === 0);
    }
  
  function __arraySum(array, index) {
      var sum = 0;
      for (var i = 0; i <= index; sum += array[i++]) {
        // no-op
      }
      return sum;
    }
  
  
  var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];
  
  var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date, days) {
      var newDate = new Date(date.getTime());
      while(days > 0) {
        var leap = __isLeapYear(newDate.getFullYear());
        var currentMonth = newDate.getMonth();
        var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
  
        if (days > daysInCurrentMonth-newDate.getDate()) {
          // we spill over to next month
          days -= (daysInCurrentMonth-newDate.getDate()+1);
          newDate.setDate(1);
          if (currentMonth < 11) {
            newDate.setMonth(currentMonth+1)
          } else {
            newDate.setMonth(0);
            newDate.setFullYear(newDate.getFullYear()+1);
          }
        } else {
          // we stay in current month
          newDate.setDate(newDate.getDate()+days);
          return newDate;
        }
      }
  
      return newDate;
    }function _strftime(s, maxsize, format, tm) {
      // size_t strftime(char *restrict s, size_t maxsize, const char *restrict format, const struct tm *restrict timeptr);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/strftime.html
  
      var tm_zone = HEAP32[(((tm)+(40))>>2)];
  
      var date = {
        tm_sec: HEAP32[((tm)>>2)],
        tm_min: HEAP32[(((tm)+(4))>>2)],
        tm_hour: HEAP32[(((tm)+(8))>>2)],
        tm_mday: HEAP32[(((tm)+(12))>>2)],
        tm_mon: HEAP32[(((tm)+(16))>>2)],
        tm_year: HEAP32[(((tm)+(20))>>2)],
        tm_wday: HEAP32[(((tm)+(24))>>2)],
        tm_yday: HEAP32[(((tm)+(28))>>2)],
        tm_isdst: HEAP32[(((tm)+(32))>>2)],
        tm_gmtoff: HEAP32[(((tm)+(36))>>2)],
        tm_zone: tm_zone ? UTF8ToString(tm_zone) : ''
      };
  
      var pattern = UTF8ToString(format);
  
      // expand format
      var EXPANSION_RULES_1 = {
        '%c': '%a %b %d %H:%M:%S %Y',     // Replaced by the locale's appropriate date and time representation - e.g., Mon Aug  3 14:02:01 2013
        '%D': '%m/%d/%y',                 // Equivalent to %m / %d / %y
        '%F': '%Y-%m-%d',                 // Equivalent to %Y - %m - %d
        '%h': '%b',                       // Equivalent to %b
        '%r': '%I:%M:%S %p',              // Replaced by the time in a.m. and p.m. notation
        '%R': '%H:%M',                    // Replaced by the time in 24-hour notation
        '%T': '%H:%M:%S',                 // Replaced by the time
        '%x': '%m/%d/%y',                 // Replaced by the locale's appropriate date representation
        '%X': '%H:%M:%S',                 // Replaced by the locale's appropriate time representation
        // Modified Conversion Specifiers
        '%Ec': '%c',                      // Replaced by the locale's alternative appropriate date and time representation.
        '%EC': '%C',                      // Replaced by the name of the base year (period) in the locale's alternative representation.
        '%Ex': '%m/%d/%y',                // Replaced by the locale's alternative date representation.
        '%EX': '%H:%M:%S',                // Replaced by the locale's alternative time representation.
        '%Ey': '%y',                      // Replaced by the offset from %EC (year only) in the locale's alternative representation.
        '%EY': '%Y',                      // Replaced by the full alternative year representation.
        '%Od': '%d',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading zeros if there is any alternative symbol for zero; otherwise, with leading <space> characters.
        '%Oe': '%e',                      // Replaced by the day of the month, using the locale's alternative numeric symbols, filled as needed with leading <space> characters.
        '%OH': '%H',                      // Replaced by the hour (24-hour clock) using the locale's alternative numeric symbols.
        '%OI': '%I',                      // Replaced by the hour (12-hour clock) using the locale's alternative numeric symbols.
        '%Om': '%m',                      // Replaced by the month using the locale's alternative numeric symbols.
        '%OM': '%M',                      // Replaced by the minutes using the locale's alternative numeric symbols.
        '%OS': '%S',                      // Replaced by the seconds using the locale's alternative numeric symbols.
        '%Ou': '%u',                      // Replaced by the weekday as a number in the locale's alternative representation (Monday=1).
        '%OU': '%U',                      // Replaced by the week number of the year (Sunday as the first day of the week, rules corresponding to %U ) using the locale's alternative numeric symbols.
        '%OV': '%V',                      // Replaced by the week number of the year (Monday as the first day of the week, rules corresponding to %V ) using the locale's alternative numeric symbols.
        '%Ow': '%w',                      // Replaced by the number of the weekday (Sunday=0) using the locale's alternative numeric symbols.
        '%OW': '%W',                      // Replaced by the week number of the year (Monday as the first day of the week) using the locale's alternative numeric symbols.
        '%Oy': '%y',                      // Replaced by the year (offset from %C ) using the locale's alternative numeric symbols.
      };
      for (var rule in EXPANSION_RULES_1) {
        pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_1[rule]);
      }
  
      var WEEKDAYS = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      var MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  
      function leadingSomething(value, digits, character) {
        var str = typeof value === 'number' ? value.toString() : (value || '');
        while (str.length < digits) {
          str = character[0]+str;
        }
        return str;
      }
  
      function leadingNulls(value, digits) {
        return leadingSomething(value, digits, '0');
      }
  
      function compareByDay(date1, date2) {
        function sgn(value) {
          return value < 0 ? -1 : (value > 0 ? 1 : 0);
        }
  
        var compare;
        if ((compare = sgn(date1.getFullYear()-date2.getFullYear())) === 0) {
          if ((compare = sgn(date1.getMonth()-date2.getMonth())) === 0) {
            compare = sgn(date1.getDate()-date2.getDate());
          }
        }
        return compare;
      }
  
      function getFirstWeekStartDate(janFourth) {
          switch (janFourth.getDay()) {
            case 0: // Sunday
              return new Date(janFourth.getFullYear()-1, 11, 29);
            case 1: // Monday
              return janFourth;
            case 2: // Tuesday
              return new Date(janFourth.getFullYear(), 0, 3);
            case 3: // Wednesday
              return new Date(janFourth.getFullYear(), 0, 2);
            case 4: // Thursday
              return new Date(janFourth.getFullYear(), 0, 1);
            case 5: // Friday
              return new Date(janFourth.getFullYear()-1, 11, 31);
            case 6: // Saturday
              return new Date(janFourth.getFullYear()-1, 11, 30);
          }
      }
  
      function getWeekBasedYear(date) {
          var thisDate = __addDays(new Date(date.tm_year+1900, 0, 1), date.tm_yday);
  
          var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
          var janFourthNextYear = new Date(thisDate.getFullYear()+1, 0, 4);
  
          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
  
          if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
            // this date is after the start of the first week of this year
            if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
              return thisDate.getFullYear()+1;
            } else {
              return thisDate.getFullYear();
            }
          } else {
            return thisDate.getFullYear()-1;
          }
      }
  
      var EXPANSION_RULES_2 = {
        '%a': function(date) {
          return WEEKDAYS[date.tm_wday].substring(0,3);
        },
        '%A': function(date) {
          return WEEKDAYS[date.tm_wday];
        },
        '%b': function(date) {
          return MONTHS[date.tm_mon].substring(0,3);
        },
        '%B': function(date) {
          return MONTHS[date.tm_mon];
        },
        '%C': function(date) {
          var year = date.tm_year+1900;
          return leadingNulls((year/100)|0,2);
        },
        '%d': function(date) {
          return leadingNulls(date.tm_mday, 2);
        },
        '%e': function(date) {
          return leadingSomething(date.tm_mday, 2, ' ');
        },
        '%g': function(date) {
          // %g, %G, and %V give values according to the ISO 8601:2000 standard week-based year.
          // In this system, weeks begin on a Monday and week 1 of the year is the week that includes
          // January 4th, which is also the week that includes the first Thursday of the year, and
          // is also the first week that contains at least four days in the year.
          // If the first Monday of January is the 2nd, 3rd, or 4th, the preceding days are part of
          // the last week of the preceding year; thus, for Saturday 2nd January 1999,
          // %G is replaced by 1998 and %V is replaced by 53. If December 29th, 30th,
          // or 31st is a Monday, it and any following days are part of week 1 of the following year.
          // Thus, for Tuesday 30th December 1997, %G is replaced by 1998 and %V is replaced by 01.
  
          return getWeekBasedYear(date).toString().substring(2);
        },
        '%G': function(date) {
          return getWeekBasedYear(date);
        },
        '%H': function(date) {
          return leadingNulls(date.tm_hour, 2);
        },
        '%I': function(date) {
          var twelveHour = date.tm_hour;
          if (twelveHour == 0) twelveHour = 12;
          else if (twelveHour > 12) twelveHour -= 12;
          return leadingNulls(twelveHour, 2);
        },
        '%j': function(date) {
          // Day of the year (001-366)
          return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon-1), 3);
        },
        '%m': function(date) {
          return leadingNulls(date.tm_mon+1, 2);
        },
        '%M': function(date) {
          return leadingNulls(date.tm_min, 2);
        },
        '%n': function() {
          return '\n';
        },
        '%p': function(date) {
          if (date.tm_hour >= 0 && date.tm_hour < 12) {
            return 'AM';
          } else {
            return 'PM';
          }
        },
        '%S': function(date) {
          return leadingNulls(date.tm_sec, 2);
        },
        '%t': function() {
          return '\t';
        },
        '%u': function(date) {
          return date.tm_wday || 7;
        },
        '%U': function(date) {
          // Replaced by the week number of the year as a decimal number [00,53].
          // The first Sunday of January is the first day of week 1;
          // days in the new year before this are in week 0. [ tm_year, tm_wday, tm_yday]
          var janFirst = new Date(date.tm_year+1900, 0, 1);
          var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7-janFirst.getDay());
          var endDate = new Date(date.tm_year+1900, date.tm_mon, date.tm_mday);
  
          // is target date after the first Sunday?
          if (compareByDay(firstSunday, endDate) < 0) {
            // calculate difference in days between first Sunday and endDate
            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth()-1)-31;
            var firstSundayUntilEndJanuary = 31-firstSunday.getDate();
            var days = firstSundayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();
            return leadingNulls(Math.ceil(days/7), 2);
          }
  
          return compareByDay(firstSunday, janFirst) === 0 ? '01': '00';
        },
        '%V': function(date) {
          // Replaced by the week number of the year (Monday as the first day of the week)
          // as a decimal number [01,53]. If the week containing 1 January has four
          // or more days in the new year, then it is considered week 1.
          // Otherwise, it is the last week of the previous year, and the next week is week 1.
          // Both January 4th and the first Thursday of January are always in week 1. [ tm_year, tm_wday, tm_yday]
          var janFourthThisYear = new Date(date.tm_year+1900, 0, 4);
          var janFourthNextYear = new Date(date.tm_year+1901, 0, 4);
  
          var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
          var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
  
          var endDate = __addDays(new Date(date.tm_year+1900, 0, 1), date.tm_yday);
  
          if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
            // if given date is before this years first week, then it belongs to the 53rd week of last year
            return '53';
          }
  
          if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
            // if given date is after next years first week, then it belongs to the 01th week of next year
            return '01';
          }
  
          // given date is in between CW 01..53 of this calendar year
          var daysDifference;
          if (firstWeekStartThisYear.getFullYear() < date.tm_year+1900) {
            // first CW of this year starts last year
            daysDifference = date.tm_yday+32-firstWeekStartThisYear.getDate()
          } else {
            // first CW of this year starts this year
            daysDifference = date.tm_yday+1-firstWeekStartThisYear.getDate();
          }
          return leadingNulls(Math.ceil(daysDifference/7), 2);
        },
        '%w': function(date) {
          return date.tm_wday;
        },
        '%W': function(date) {
          // Replaced by the week number of the year as a decimal number [00,53].
          // The first Monday of January is the first day of week 1;
          // days in the new year before this are in week 0. [ tm_year, tm_wday, tm_yday]
          var janFirst = new Date(date.tm_year, 0, 1);
          var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7-janFirst.getDay()+1);
          var endDate = new Date(date.tm_year+1900, date.tm_mon, date.tm_mday);
  
          // is target date after the first Monday?
          if (compareByDay(firstMonday, endDate) < 0) {
            var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth()-1)-31;
            var firstMondayUntilEndJanuary = 31-firstMonday.getDate();
            var days = firstMondayUntilEndJanuary+februaryFirstUntilEndMonth+endDate.getDate();
            return leadingNulls(Math.ceil(days/7), 2);
          }
          return compareByDay(firstMonday, janFirst) === 0 ? '01': '00';
        },
        '%y': function(date) {
          // Replaced by the last two digits of the year as a decimal number [00,99]. [ tm_year]
          return (date.tm_year+1900).toString().substring(2);
        },
        '%Y': function(date) {
          // Replaced by the year as a decimal number (for example, 1997). [ tm_year]
          return date.tm_year+1900;
        },
        '%z': function(date) {
          // Replaced by the offset from UTC in the ISO 8601:2000 standard format ( +hhmm or -hhmm ).
          // For example, "-0430" means 4 hours 30 minutes behind UTC (west of Greenwich).
          var off = date.tm_gmtoff;
          var ahead = off >= 0;
          off = Math.abs(off) / 60;
          // convert from minutes into hhmm format (which means 60 minutes = 100 units)
          off = (off / 60)*100 + (off % 60);
          return (ahead ? '+' : '-') + String("0000" + off).slice(-4);
        },
        '%Z': function(date) {
          return date.tm_zone;
        },
        '%%': function() {
          return '%';
        }
      };
      for (var rule in EXPANSION_RULES_2) {
        if (pattern.indexOf(rule) >= 0) {
          pattern = pattern.replace(new RegExp(rule, 'g'), EXPANSION_RULES_2[rule](date));
        }
      }
  
      var bytes = intArrayFromString(pattern, false);
      if (bytes.length > maxsize) {
        return 0;
      }
  
      writeArrayToMemory(bytes, s);
      return bytes.length-1;
    }

  
  /** @suppress {checkTypes} */
  function jstoi_q(str) {
      return parseInt(str);
    }function _strptime(buf, format, tm) {
      // char *strptime(const char *restrict buf, const char *restrict format, struct tm *restrict tm);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html
      var pattern = UTF8ToString(format);
  
      // escape special characters
      // TODO: not sure we really need to escape all of these in JS regexps
      var SPECIAL_CHARS = '\\!@#$^&*()+=-[]/{}|:<>?,.';
      for (var i=0, ii=SPECIAL_CHARS.length; i<ii; ++i) {
        pattern = pattern.replace(new RegExp('\\'+SPECIAL_CHARS[i], 'g'), '\\'+SPECIAL_CHARS[i]);
      }
  
      // reduce number of matchers
      var EQUIVALENT_MATCHERS = {
        '%A':  '%a',
        '%B':  '%b',
        '%c':  '%a %b %d %H:%M:%S %Y',
        '%D':  '%m\\/%d\\/%y',
        '%e':  '%d',
        '%F':  '%Y-%m-%d',
        '%h':  '%b',
        '%R':  '%H\\:%M',
        '%r':  '%I\\:%M\\:%S\\s%p',
        '%T':  '%H\\:%M\\:%S',
        '%x':  '%m\\/%d\\/(?:%y|%Y)',
        '%X':  '%H\\:%M\\:%S'
      };
      for (var matcher in EQUIVALENT_MATCHERS) {
        pattern = pattern.replace(matcher, EQUIVALENT_MATCHERS[matcher]);
      }
  
      // TODO: take care of locale
  
      var DATE_PATTERNS = {
        /* weeday name */     '%a': '(?:Sun(?:day)?)|(?:Mon(?:day)?)|(?:Tue(?:sday)?)|(?:Wed(?:nesday)?)|(?:Thu(?:rsday)?)|(?:Fri(?:day)?)|(?:Sat(?:urday)?)',
        /* month name */      '%b': '(?:Jan(?:uary)?)|(?:Feb(?:ruary)?)|(?:Mar(?:ch)?)|(?:Apr(?:il)?)|May|(?:Jun(?:e)?)|(?:Jul(?:y)?)|(?:Aug(?:ust)?)|(?:Sep(?:tember)?)|(?:Oct(?:ober)?)|(?:Nov(?:ember)?)|(?:Dec(?:ember)?)',
        /* century */         '%C': '\\d\\d',
        /* day of month */    '%d': '0[1-9]|[1-9](?!\\d)|1\\d|2\\d|30|31',
        /* hour (24hr) */     '%H': '\\d(?!\\d)|[0,1]\\d|20|21|22|23',
        /* hour (12hr) */     '%I': '\\d(?!\\d)|0\\d|10|11|12',
        /* day of year */     '%j': '00[1-9]|0?[1-9](?!\\d)|0?[1-9]\\d(?!\\d)|[1,2]\\d\\d|3[0-6]\\d',
        /* month */           '%m': '0[1-9]|[1-9](?!\\d)|10|11|12',
        /* minutes */         '%M': '0\\d|\\d(?!\\d)|[1-5]\\d',
        /* whitespace */      '%n': '\\s',
        /* AM/PM */           '%p': 'AM|am|PM|pm|A\\.M\\.|a\\.m\\.|P\\.M\\.|p\\.m\\.',
        /* seconds */         '%S': '0\\d|\\d(?!\\d)|[1-5]\\d|60',
        /* week number */     '%U': '0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53',
        /* week number */     '%W': '0\\d|\\d(?!\\d)|[1-4]\\d|50|51|52|53',
        /* weekday number */  '%w': '[0-6]',
        /* 2-digit year */    '%y': '\\d\\d',
        /* 4-digit year */    '%Y': '\\d\\d\\d\\d',
        /* % */               '%%': '%',
        /* whitespace */      '%t': '\\s',
      };
  
      var MONTH_NUMBERS = {JAN: 0, FEB: 1, MAR: 2, APR: 3, MAY: 4, JUN: 5, JUL: 6, AUG: 7, SEP: 8, OCT: 9, NOV: 10, DEC: 11};
      var DAY_NUMBERS_SUN_FIRST = {SUN: 0, MON: 1, TUE: 2, WED: 3, THU: 4, FRI: 5, SAT: 6};
      var DAY_NUMBERS_MON_FIRST = {MON: 0, TUE: 1, WED: 2, THU: 3, FRI: 4, SAT: 5, SUN: 6};
  
      for (var datePattern in DATE_PATTERNS) {
        pattern = pattern.replace(datePattern, '('+datePattern+DATE_PATTERNS[datePattern]+')');
      }
  
      // take care of capturing groups
      var capture = [];
      for (var i=pattern.indexOf('%'); i>=0; i=pattern.indexOf('%')) {
        capture.push(pattern[i+1]);
        pattern = pattern.replace(new RegExp('\\%'+pattern[i+1], 'g'), '');
      }
  
      var matches = new RegExp('^'+pattern, "i").exec(UTF8ToString(buf))
      // out(UTF8ToString(buf)+ ' is matched by '+((new RegExp('^'+pattern)).source)+' into: '+JSON.stringify(matches));
  
      function initDate() {
        function fixup(value, min, max) {
          return (typeof value !== 'number' || isNaN(value)) ? min : (value>=min ? (value<=max ? value: max): min);
        };
        return {
          year: fixup(HEAP32[(((tm)+(20))>>2)] + 1900 , 1970, 9999),
          month: fixup(HEAP32[(((tm)+(16))>>2)], 0, 11),
          day: fixup(HEAP32[(((tm)+(12))>>2)], 1, 31),
          hour: fixup(HEAP32[(((tm)+(8))>>2)], 0, 23),
          min: fixup(HEAP32[(((tm)+(4))>>2)], 0, 59),
          sec: fixup(HEAP32[((tm)>>2)], 0, 59)
        };
      };
  
      if (matches) {
        var date = initDate();
        var value;
  
        var getMatch = function(symbol) {
          var pos = capture.indexOf(symbol);
          // check if symbol appears in regexp
          if (pos >= 0) {
            // return matched value or null (falsy!) for non-matches
            return matches[pos+1];
          }
          return;
        };
  
        // seconds
        if ((value=getMatch('S'))) {
          date.sec = jstoi_q(value);
        }
  
        // minutes
        if ((value=getMatch('M'))) {
          date.min = jstoi_q(value);
        }
  
        // hours
        if ((value=getMatch('H'))) {
          // 24h clock
          date.hour = jstoi_q(value);
        } else if ((value = getMatch('I'))) {
          // AM/PM clock
          var hour = jstoi_q(value);
          if ((value=getMatch('p'))) {
            hour += value.toUpperCase()[0] === 'P' ? 12 : 0;
          }
          date.hour = hour;
        }
  
        // year
        if ((value=getMatch('Y'))) {
          // parse from four-digit year
          date.year = jstoi_q(value);
        } else if ((value=getMatch('y'))) {
          // parse from two-digit year...
          var year = jstoi_q(value);
          if ((value=getMatch('C'))) {
            // ...and century
            year += jstoi_q(value)*100;
          } else {
            // ...and rule-of-thumb
            year += year<69 ? 2000 : 1900;
          }
          date.year = year;
        }
  
        // month
        if ((value=getMatch('m'))) {
          // parse from month number
          date.month = jstoi_q(value)-1;
        } else if ((value=getMatch('b'))) {
          // parse from month name
          date.month = MONTH_NUMBERS[value.substring(0,3).toUpperCase()] || 0;
          // TODO: derive month from day in year+year, week number+day of week+year
        }
  
        // day
        if ((value=getMatch('d'))) {
          // get day of month directly
          date.day = jstoi_q(value);
        } else if ((value=getMatch('j'))) {
          // get day of month from day of year ...
          var day = jstoi_q(value);
          var leapYear = __isLeapYear(date.year);
          for (var month=0; month<12; ++month) {
            var daysUntilMonth = __arraySum(leapYear ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, month-1);
            if (day<=daysUntilMonth+(leapYear ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[month]) {
              date.day = day-daysUntilMonth;
            }
          }
        } else if ((value=getMatch('a'))) {
          // get day of month from weekday ...
          var weekDay = value.substring(0,3).toUpperCase();
          if ((value=getMatch('U'))) {
            // ... and week number (Sunday being first day of week)
            // Week number of the year (Sunday as the first day of the week) as a decimal number [00,53].
            // All days in a new year preceding the first Sunday are considered to be in week 0.
            var weekDayNumber = DAY_NUMBERS_SUN_FIRST[weekDay];
            var weekNumber = jstoi_q(value);
  
            // January 1st
            var janFirst = new Date(date.year, 0, 1);
            var endDate;
            if (janFirst.getDay() === 0) {
              // Jan 1st is a Sunday, and, hence in the 1st CW
              endDate = __addDays(janFirst, weekDayNumber+7*(weekNumber-1));
            } else {
              // Jan 1st is not a Sunday, and, hence still in the 0th CW
              endDate = __addDays(janFirst, 7-janFirst.getDay()+weekDayNumber+7*(weekNumber-1));
            }
            date.day = endDate.getDate();
            date.month = endDate.getMonth();
          } else if ((value=getMatch('W'))) {
            // ... and week number (Monday being first day of week)
            // Week number of the year (Monday as the first day of the week) as a decimal number [00,53].
            // All days in a new year preceding the first Monday are considered to be in week 0.
            var weekDayNumber = DAY_NUMBERS_MON_FIRST[weekDay];
            var weekNumber = jstoi_q(value);
  
            // January 1st
            var janFirst = new Date(date.year, 0, 1);
            var endDate;
            if (janFirst.getDay()===1) {
              // Jan 1st is a Monday, and, hence in the 1st CW
               endDate = __addDays(janFirst, weekDayNumber+7*(weekNumber-1));
            } else {
              // Jan 1st is not a Monday, and, hence still in the 0th CW
              endDate = __addDays(janFirst, 7-janFirst.getDay()+1+weekDayNumber+7*(weekNumber-1));
            }
  
            date.day = endDate.getDate();
            date.month = endDate.getMonth();
          }
        }
  
        /*
        tm_sec  int seconds after the minute  0-61*
        tm_min  int minutes after the hour  0-59
        tm_hour int hours since midnight  0-23
        tm_mday int day of the month  1-31
        tm_mon  int months since January  0-11
        tm_year int years since 1900
        tm_wday int days since Sunday 0-6
        tm_yday int days since January 1  0-365
        tm_isdst  int Daylight Saving Time flag
        */
  
        var fullDate = new Date(date.year, date.month, date.day, date.hour, date.min, date.sec, 0);
        HEAP32[((tm)>>2)]=fullDate.getSeconds();
        HEAP32[(((tm)+(4))>>2)]=fullDate.getMinutes();
        HEAP32[(((tm)+(8))>>2)]=fullDate.getHours();
        HEAP32[(((tm)+(12))>>2)]=fullDate.getDate();
        HEAP32[(((tm)+(16))>>2)]=fullDate.getMonth();
        HEAP32[(((tm)+(20))>>2)]=fullDate.getFullYear()-1900;
        HEAP32[(((tm)+(24))>>2)]=fullDate.getDay();
        HEAP32[(((tm)+(28))>>2)]=__arraySum(__isLeapYear(fullDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, fullDate.getMonth()-1)+fullDate.getDate()-1;
        HEAP32[(((tm)+(32))>>2)]=0;
  
        // we need to convert the matched sequence into an integer array to take care of UTF-8 characters > 0x7F
        // TODO: not sure that intArrayFromString handles all unicode characters correctly
        return buf+intArrayFromString(matches[0]).length-1;
      }
  
      return 0;
    }

  function _sysconf(name) {
      // long sysconf(int name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
      switch(name) {
        case 30: return 16384;
        case 85:
          var maxHeapSize = HEAPU8.length;
          return maxHeapSize / 16384;
        case 132:
        case 133:
        case 12:
        case 137:
        case 138:
        case 15:
        case 235:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 149:
        case 13:
        case 10:
        case 236:
        case 153:
        case 9:
        case 21:
        case 22:
        case 159:
        case 154:
        case 14:
        case 77:
        case 78:
        case 139:
        case 80:
        case 81:
        case 82:
        case 68:
        case 67:
        case 164:
        case 11:
        case 29:
        case 47:
        case 48:
        case 95:
        case 52:
        case 51:
        case 46:
        case 79:
          return 200809;
        case 27:
        case 246:
        case 127:
        case 128:
        case 23:
        case 24:
        case 160:
        case 161:
        case 181:
        case 182:
        case 242:
        case 183:
        case 184:
        case 243:
        case 244:
        case 245:
        case 165:
        case 178:
        case 179:
        case 49:
        case 50:
        case 168:
        case 169:
        case 175:
        case 170:
        case 171:
        case 172:
        case 97:
        case 76:
        case 32:
        case 173:
        case 35:
          return -1;
        case 176:
        case 177:
        case 7:
        case 155:
        case 8:
        case 157:
        case 125:
        case 126:
        case 92:
        case 93:
        case 129:
        case 130:
        case 131:
        case 94:
        case 91:
          return 1;
        case 74:
        case 60:
        case 69:
        case 70:
        case 4:
          return 1024;
        case 31:
        case 42:
        case 72:
          return 32;
        case 87:
        case 26:
        case 33:
          return 2147483647;
        case 34:
        case 1:
          return 47839;
        case 38:
        case 36:
          return 99;
        case 43:
        case 37:
          return 2048;
        case 0: return 2097152;
        case 3: return 65536;
        case 28: return 32768;
        case 44: return 32767;
        case 75: return 16384;
        case 39: return 1000;
        case 89: return 700;
        case 71: return 256;
        case 40: return 255;
        case 2: return 100;
        case 180: return 64;
        case 25: return 20;
        case 5: return 16;
        case 6: return 6;
        case 73: return 4;
        case 84: {
          if (typeof navigator === 'object') return navigator['hardwareConcurrency'] || 1;
          return 1;
        }
      }
      setErrNo(28);
      return -1;
    }

  function _system(command) {
      if (ENVIRONMENT_IS_NODE) {
        if (!command) return 1; // shell is available
  
        var cmdstr = UTF8ToString(command);
        if (!cmdstr.length) return 0; // this is what glibc seems to do (shell works test?)
  
        var cp = require('child_process');
        var ret = cp.spawnSync(cmdstr, [], {shell:true, stdio:'inherit'});
  
        var _W_EXITCODE = function(ret, sig) {
          return ((ret) << 8 | (sig));
        }
  
        // this really only can happen if process is killed by signal
        if (ret.status === null) {
          // sadly node doesn't expose such function
          var signalToNumber = function(sig) {
            // implement only the most common ones, and fallback to SIGINT
            switch (sig) {
              case 'SIGHUP': return 1;
              case 'SIGINT': return 2;
              case 'SIGQUIT': return 3;
              case 'SIGFPE': return 8;
              case 'SIGKILL': return 9;
              case 'SIGALRM': return 14;
              case 'SIGTERM': return 15;
            }
            return 2; // SIGINT
          }
          return _W_EXITCODE(0, signalToNumber(ret.signal));
        }
  
        return _W_EXITCODE(ret.status, 0);
      }
      // int system(const char *command);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/system.html
      // Can't call external programs.
      if (!command) return 0; // no shell available
      setErrNo(6);
      return -1;
    }


  function _time(ptr) {
      var ret = (Date.now()/1000)|0;
      if (ptr) {
        HEAP32[((ptr)>>2)]=ret;
      }
      return ret;
    }

  function _timegm(tmPtr) {
      _tzset();
      var time = Date.UTC(HEAP32[(((tmPtr)+(20))>>2)] + 1900,
                          HEAP32[(((tmPtr)+(16))>>2)],
                          HEAP32[(((tmPtr)+(12))>>2)],
                          HEAP32[(((tmPtr)+(8))>>2)],
                          HEAP32[(((tmPtr)+(4))>>2)],
                          HEAP32[((tmPtr)>>2)],
                          0);
      var date = new Date(time);
  
      HEAP32[(((tmPtr)+(24))>>2)]=date.getUTCDay();
      var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0);
      var yday = ((date.getTime() - start) / (1000 * 60 * 60 * 24))|0;
      HEAP32[(((tmPtr)+(28))>>2)]=yday;
  
      return (date.getTime() / 1000)|0;
    }


  function _vfork(
  ) {
  return _fork();
  }

  
  
  
  function _emscripten_set_main_loop_timing(mode, value) {
      Browser.mainLoop.timingMode = mode;
      Browser.mainLoop.timingValue = value;
  
      if (!Browser.mainLoop.func) {
        return 1; // Return non-zero on failure, can't set timing mode when there is no main loop.
      }
  
      if (mode == 0 /*EM_TIMING_SETTIMEOUT*/) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setTimeout() {
          var timeUntilNextTick = Math.max(0, Browser.mainLoop.tickStartTime + value - _emscripten_get_now())|0;
          setTimeout(Browser.mainLoop.runner, timeUntilNextTick); // doing this each time means that on exception, we stop
        };
        Browser.mainLoop.method = 'timeout';
      } else if (mode == 1 /*EM_TIMING_RAF*/) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_rAF() {
          Browser.requestAnimationFrame(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'rAF';
      } else if (mode == 2 /*EM_TIMING_SETIMMEDIATE*/) {
        if (typeof setImmediate === 'undefined') {
          // Emulate setImmediate. (note: not a complete polyfill, we don't emulate clearImmediate() to keep code size to minimum, since not needed)
          var setImmediates = [];
          var emscriptenMainLoopMessageId = 'setimmediate';
          var Browser_setImmediate_messageHandler = function(event) {
            // When called in current thread or Worker, the main loop ID is structured slightly different to accommodate for --proxy-to-worker runtime listening to Worker events,
            // so check for both cases.
            if (event.data === emscriptenMainLoopMessageId || event.data.target === emscriptenMainLoopMessageId) {
              event.stopPropagation();
              setImmediates.shift()();
            }
          }
          addEventListener("message", Browser_setImmediate_messageHandler, true);
          setImmediate = /** @type{function(function(): ?, ...?): number} */(function Browser_emulated_setImmediate(func) {
            setImmediates.push(func);
            if (ENVIRONMENT_IS_WORKER) {
              if (Module['setImmediates'] === undefined) Module['setImmediates'] = [];
              Module['setImmediates'].push(func);
              postMessage({target: emscriptenMainLoopMessageId}); // In --proxy-to-worker, route the message via proxyClient.js
            } else postMessage(emscriptenMainLoopMessageId, "*"); // On the main thread, can just send the message to itself.
          })
        }
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setImmediate() {
          setImmediate(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'immediate';
      }
      return 0;
    }/** @param {number|boolean=} noSetTiming */
  function _emscripten_set_main_loop(func, fps, simulateInfiniteLoop, arg, noSetTiming) {
      noExitRuntime = true;
  
      assert(!Browser.mainLoop.func, 'emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.');
  
      Browser.mainLoop.func = func;
      Browser.mainLoop.arg = arg;
  
      var browserIterationFunc;
      if (typeof arg !== 'undefined') {
        browserIterationFunc = function() {
          Module['dynCall_vi'](func, arg);
        };
      } else {
        browserIterationFunc = function() {
          Module['dynCall_v'](func);
        };
      }
  
      var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop;
  
      Browser.mainLoop.runner = function Browser_mainLoop_runner() {
        if (ABORT) return;
        if (Browser.mainLoop.queue.length > 0) {
          var start = Date.now();
          var blocker = Browser.mainLoop.queue.shift();
          blocker.func(blocker.arg);
          if (Browser.mainLoop.remainingBlockers) {
            var remaining = Browser.mainLoop.remainingBlockers;
            var next = remaining%1 == 0 ? remaining-1 : Math.floor(remaining);
            if (blocker.counted) {
              Browser.mainLoop.remainingBlockers = next;
            } else {
              // not counted, but move the progress along a tiny bit
              next = next + 0.5; // do not steal all the next one's progress
              Browser.mainLoop.remainingBlockers = (8*remaining + next)/9;
            }
          }
          console.log('main loop blocker "' + blocker.name + '" took ' + (Date.now() - start) + ' ms'); //, left: ' + Browser.mainLoop.remainingBlockers);
          Browser.mainLoop.updateStatus();
  
          // catches pause/resume main loop from blocker execution
          if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;
  
          setTimeout(Browser.mainLoop.runner, 0);
          return;
        }
  
        // catch pauses from non-main loop sources
        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;
  
        // Implement very basic swap interval control
        Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0;
        if (Browser.mainLoop.timingMode == 1/*EM_TIMING_RAF*/ && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {
          // Not the scheduled time to render this frame - skip.
          Browser.mainLoop.scheduler();
          return;
        } else if (Browser.mainLoop.timingMode == 0/*EM_TIMING_SETTIMEOUT*/) {
          Browser.mainLoop.tickStartTime = _emscripten_get_now();
        }
  
        // Signal GL rendering layer that processing of a new frame is about to start. This helps it optimize
        // VBO double-buffering and reduce GPU stalls.
  
  
  
  
        Browser.mainLoop.runIter(browserIterationFunc);
  
  
        // catch pauses from the main loop itself
        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;
  
        // Queue new audio data. This is important to be right after the main loop invocation, so that we will immediately be able
        // to queue the newest produced audio samples.
        // TODO: Consider adding pre- and post- rAF callbacks so that GL.newRenderingFrameStarted() and SDL.audio.queueNewAudioData()
        //       do not need to be hardcoded into this function, but can be more generic.
        if (typeof SDL === 'object' && SDL.audio && SDL.audio.queueNewAudioData) SDL.audio.queueNewAudioData();
  
        Browser.mainLoop.scheduler();
      }
  
      if (!noSetTiming) {
        if (fps && fps > 0) _emscripten_set_main_loop_timing(0/*EM_TIMING_SETTIMEOUT*/, 1000.0 / fps);
        else _emscripten_set_main_loop_timing(1/*EM_TIMING_RAF*/, 1); // Do rAF by rendering each frame (no decimating)
  
        Browser.mainLoop.scheduler();
      }
  
      if (simulateInfiniteLoop) {
        throw 'unwind';
      }
    }var Browser={mainLoop:{scheduler:null,method:"",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause:function() {
          Browser.mainLoop.scheduler = null;
          Browser.mainLoop.currentlyRunningMainloop++; // Incrementing this signals the previous main loop that it's now become old, and it must return.
        },resume:function() {
          Browser.mainLoop.currentlyRunningMainloop++;
          var timingMode = Browser.mainLoop.timingMode;
          var timingValue = Browser.mainLoop.timingValue;
          var func = Browser.mainLoop.func;
          Browser.mainLoop.func = null;
          _emscripten_set_main_loop(func, 0, false, Browser.mainLoop.arg, true /* do not set timing and call scheduler, we will do it on the next lines */);
          _emscripten_set_main_loop_timing(timingMode, timingValue);
          Browser.mainLoop.scheduler();
        },updateStatus:function() {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        },runIter:function(func) {
          if (ABORT) return;
          if (Module['preMainLoop']) {
            var preRet = Module['preMainLoop']();
            if (preRet === false) {
              return; // |return false| skips a frame
            }
          }
          try {
            func();
          } catch (e) {
            if (e instanceof ExitStatus) {
              return;
            } else {
              if (e && typeof e === 'object' && e.stack) err('exception thrown: ' + [e, e.stack]);
              throw e;
            }
          }
          if (Module['postMainLoop']) Module['postMainLoop']();
        }},isFullscreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:function() {
        if (!Module["preloadPlugins"]) Module["preloadPlugins"] = []; // needs to exist even in workers
  
        if (Browser.initted) return;
        Browser.initted = true;
  
        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch(e) {
          Browser.hasBlobConstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? console.log("warning: no BlobBuilder") : null));
        Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : undefined;
        if (!Module.noImageDecoding && typeof Browser.URLObject === 'undefined') {
          console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");
          Module.noImageDecoding = true;
        }
  
        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to Module.preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).
  
        var imagePlugin = {};
        imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {
          return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
        };
        imagePlugin['handle'] = function imagePlugin_handle(byteArray, name, onload, onerror) {
          var b = null;
          if (Browser.hasBlobConstructor) {
            try {
              b = new Blob([byteArray], { type: Browser.getMimetype(name) });
              if (b.size !== byteArray.length) { // Safari bug #118630
                // Safari's Blob can only take an ArrayBuffer
                b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });
              }
            } catch(e) {
              warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new Browser.BlobBuilder();
            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getBlob();
          }
          var url = Browser.URLObject.createObjectURL(b);
          var img = new Image();
          img.onload = function img_onload() {
            assert(img.complete, 'Image ' + name + ' could not be decoded');
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas;
            Browser.URLObject.revokeObjectURL(url);
            if (onload) onload(byteArray);
          };
          img.onerror = function img_onerror(event) {
            console.log('Image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        Module['preloadPlugins'].push(imagePlugin);
  
        var audioPlugin = {};
        audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {
          return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function audioPlugin_handle(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = audio;
            if (onload) onload(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = new Audio(); // empty shim
            if (onerror) onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
            var audio = new Audio();
            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926
            audio.onerror = function audio_onerror(event) {
              if (done) return;
              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var PAD = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar&3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar&0xf) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            Browser.safeSetTimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        Module['preloadPlugins'].push(audioPlugin);
  
  
        // Canvas event setup
  
        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === Module['canvas'] ||
                                document['mozPointerLockElement'] === Module['canvas'] ||
                                document['webkitPointerLockElement'] === Module['canvas'] ||
                                document['msPointerLockElement'] === Module['canvas'];
        }
        var canvas = Module['canvas'];
        if (canvas) {
          // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
          // Module['forcedAspectRatio'] = 4 / 3;
  
          canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                      canvas['mozRequestPointerLock'] ||
                                      canvas['webkitRequestPointerLock'] ||
                                      canvas['msRequestPointerLock'] ||
                                      function(){};
          canvas.exitPointerLock = document['exitPointerLock'] ||
                                   document['mozExitPointerLock'] ||
                                   document['webkitExitPointerLock'] ||
                                   document['msExitPointerLock'] ||
                                   function(){}; // no-op if function does not exist
          canvas.exitPointerLock = canvas.exitPointerLock.bind(document);
  
          document.addEventListener('pointerlockchange', pointerLockChange, false);
          document.addEventListener('mozpointerlockchange', pointerLockChange, false);
          document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
          document.addEventListener('mspointerlockchange', pointerLockChange, false);
  
          if (Module['elementPointerLock']) {
            canvas.addEventListener("click", function(ev) {
              if (!Browser.pointerLock && Module['canvas'].requestPointerLock) {
                Module['canvas'].requestPointerLock();
                ev.preventDefault();
              }
            }, false);
          }
        }
      },createContext:function(canvas, useWebGL, setInModule, webGLContextAttributes) {
        if (useWebGL && Module.ctx && canvas == Module.canvas) return Module.ctx; // no need to recreate GL context if it's already been created for this canvas.
  
        var ctx;
        var contextHandle;
        if (useWebGL) {
          // For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.
          var contextAttributes = {
            antialias: false,
            alpha: false,
            majorVersion: 1,
          };
  
          if (webGLContextAttributes) {
            for (var attribute in webGLContextAttributes) {
              contextAttributes[attribute] = webGLContextAttributes[attribute];
            }
          }
  
          // This check of existence of GL is here to satisfy Closure compiler, which yells if variable GL is referenced below but GL object is not
          // actually compiled in because application is not doing any GL operations. TODO: Ideally if GL is not being used, this function
          // Browser.createContext() should not even be emitted.
          if (typeof GL !== 'undefined') {
            contextHandle = GL.createContext(canvas, contextAttributes);
            if (contextHandle) {
              ctx = GL.getContext(contextHandle).GLctx;
            }
          }
        } else {
          ctx = canvas.getContext('2d');
        }
  
        if (!ctx) return null;
  
        if (setInModule) {
          if (!useWebGL) assert(typeof GLctx === 'undefined', 'cannot set in module if GLctx is used, but we are a non-GL context that would replace it');
  
          Module.ctx = ctx;
          if (useWebGL) GL.makeContextCurrent(contextHandle);
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
          Browser.init();
        }
        return ctx;
      },destroyContext:function(canvas, useWebGL, setInModule) {},fullscreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullscreen:function(lockPointer, resizeCanvas) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        if (typeof Browser.lockPointer === 'undefined') Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas === 'undefined') Browser.resizeCanvas = false;
  
        var canvas = Module['canvas'];
        function fullscreenChange() {
          Browser.isFullscreen = false;
          var canvasContainer = canvas.parentNode;
          if ((document['fullscreenElement'] || document['mozFullScreenElement'] ||
               document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
               document['webkitCurrentFullScreenElement']) === canvasContainer) {
            canvas.exitFullscreen = Browser.exitFullscreen;
            if (Browser.lockPointer) canvas.requestPointerLock();
            Browser.isFullscreen = true;
            if (Browser.resizeCanvas) {
              Browser.setFullscreenCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
            }
          } else {
            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);
            canvasContainer.parentNode.removeChild(canvasContainer);
  
            if (Browser.resizeCanvas) {
              Browser.setWindowedCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
            }
          }
          if (Module['onFullScreen']) Module['onFullScreen'](Browser.isFullscreen);
          if (Module['onFullscreen']) Module['onFullscreen'](Browser.isFullscreen);
        }
  
        if (!Browser.fullscreenHandlersInstalled) {
          Browser.fullscreenHandlersInstalled = true;
          document.addEventListener('fullscreenchange', fullscreenChange, false);
          document.addEventListener('mozfullscreenchange', fullscreenChange, false);
          document.addEventListener('webkitfullscreenchange', fullscreenChange, false);
          document.addEventListener('MSFullscreenChange', fullscreenChange, false);
        }
  
        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
        var canvasContainer = document.createElement("div");
        canvas.parentNode.insertBefore(canvasContainer, canvas);
        canvasContainer.appendChild(canvas);
  
        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
        canvasContainer.requestFullscreen = canvasContainer['requestFullscreen'] ||
                                            canvasContainer['mozRequestFullScreen'] ||
                                            canvasContainer['msRequestFullscreen'] ||
                                           (canvasContainer['webkitRequestFullscreen'] ? function() { canvasContainer['webkitRequestFullscreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null) ||
                                           (canvasContainer['webkitRequestFullScreen'] ? function() { canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);
  
        canvasContainer.requestFullscreen();
      },exitFullscreen:function() {
        // This is workaround for chrome. Trying to exit from fullscreen
        // not in fullscreen state will cause "TypeError: Document not active"
        // in chrome. See https://github.com/emscripten-core/emscripten/pull/8236
        if (!Browser.isFullscreen) {
          return false;
        }
  
        var CFS = document['exitFullscreen'] ||
                  document['cancelFullScreen'] ||
                  document['mozCancelFullScreen'] ||
                  document['msExitFullscreen'] ||
                  document['webkitCancelFullScreen'] ||
            (function() {});
        CFS.apply(document, []);
        return true;
      },nextRAF:0,fakeRequestAnimationFrame:function(func) {
        // try to keep 60fps between calls to here
        var now = Date.now();
        if (Browser.nextRAF === 0) {
          Browser.nextRAF = now + 1000/60;
        } else {
          while (now + 2 >= Browser.nextRAF) { // fudge a little, to avoid timer jitter causing us to do lots of delay:0
            Browser.nextRAF += 1000/60;
          }
        }
        var delay = Math.max(Browser.nextRAF - now, 0);
        setTimeout(func, delay);
      },requestAnimationFrame:function(func) {
        if (typeof requestAnimationFrame === 'function') {
          requestAnimationFrame(func);
          return;
        }
        var RAF = Browser.fakeRequestAnimationFrame;
        RAF(func);
      },safeCallback:function(func) {
        return function() {
          if (!ABORT) return func.apply(null, arguments);
        };
      },allowAsyncCallbacks:true,queuedAsyncCallbacks:[],pauseAsyncCallbacks:function() {
        Browser.allowAsyncCallbacks = false;
      },resumeAsyncCallbacks:function() { // marks future callbacks as ok to execute, and synchronously runs any remaining ones right now
        Browser.allowAsyncCallbacks = true;
        if (Browser.queuedAsyncCallbacks.length > 0) {
          var callbacks = Browser.queuedAsyncCallbacks;
          Browser.queuedAsyncCallbacks = [];
          callbacks.forEach(function(func) {
            func();
          });
        }
      },safeRequestAnimationFrame:function(func) {
        return Browser.requestAnimationFrame(function() {
          if (ABORT) return;
          if (Browser.allowAsyncCallbacks) {
            func();
          } else {
            Browser.queuedAsyncCallbacks.push(func);
          }
        });
      },safeSetTimeout:function(func, timeout) {
        noExitRuntime = true;
        return setTimeout(function() {
          if (ABORT) return;
          if (Browser.allowAsyncCallbacks) {
            func();
          } else {
            Browser.queuedAsyncCallbacks.push(func);
          }
        }, timeout);
      },safeSetInterval:function(func, timeout) {
        noExitRuntime = true;
        return setInterval(function() {
          if (ABORT) return;
          if (Browser.allowAsyncCallbacks) {
            func();
          } // drop it on the floor otherwise, next interval will kick in
        }, timeout);
      },getMimetype:function(name) {
        return {
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'bmp': 'image/bmp',
          'ogg': 'audio/ogg',
          'wav': 'audio/wav',
          'mp3': 'audio/mpeg'
        }[name.substr(name.lastIndexOf('.')+1)];
      },getUserMedia:function(func) {
        if(!window.getUserMedia) {
          window.getUserMedia = navigator['getUserMedia'] ||
                                navigator['mozGetUserMedia'];
        }
        window.getUserMedia(func);
      },getMovementX:function(event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },getMovementY:function(event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },getMouseWheelDelta:function(event) {
        var delta = 0;
        switch (event.type) {
          case 'DOMMouseScroll':
            // 3 lines make up a step
            delta = event.detail / 3;
            break;
          case 'mousewheel':
            // 120 units make up a step
            delta = event.wheelDelta / 120;
            break;
          case 'wheel':
            delta = event.deltaY
            switch(event.deltaMode) {
              case 0:
                // DOM_DELTA_PIXEL: 100 pixels make up a step
                delta /= 100;
                break;
              case 1:
                // DOM_DELTA_LINE: 3 lines make up a step
                delta /= 3;
                break;
              case 2:
                // DOM_DELTA_PAGE: A page makes up 80 steps
                delta *= 80;
                break;
              default:
                throw 'unrecognized mouse wheel delta mode: ' + event.deltaMode;
            }
            break;
          default:
            throw 'unrecognized mouse wheel event: ' + event.type;
        }
        return delta;
      },mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:function(event) { // event should be mousemove, mousedown or mouseup
        if (Browser.pointerLock) {
          // When the pointer is locked, calculate the coordinates
          // based on the movement of the mouse.
          // Workaround for Firefox bug 764498
          if (event.type != 'mousemove' &&
              ('mozMovementX' in event)) {
            Browser.mouseMovementX = Browser.mouseMovementY = 0;
          } else {
            Browser.mouseMovementX = Browser.getMovementX(event);
            Browser.mouseMovementY = Browser.getMovementY(event);
          }
  
          // check if SDL is available
          if (typeof SDL != "undefined") {
            Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
            Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
          } else {
            // just add the mouse delta to the current absolut mouse position
            // FIXME: ideally this should be clamped against the canvas size and zero
            Browser.mouseX += Browser.mouseMovementX;
            Browser.mouseY += Browser.mouseMovementY;
          }
        } else {
          // Otherwise, calculate the movement based on the changes
          // in the coordinates.
          var rect = Module["canvas"].getBoundingClientRect();
          var cw = Module["canvas"].width;
          var ch = Module["canvas"].height;
  
          // Neither .scrollX or .pageXOffset are defined in a spec, but
          // we prefer .scrollX because it is currently in a spec draft.
          // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
          var scrollX = ((typeof window.scrollX !== 'undefined') ? window.scrollX : window.pageXOffset);
          var scrollY = ((typeof window.scrollY !== 'undefined') ? window.scrollY : window.pageYOffset);
  
          if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
            var touch = event.touch;
            if (touch === undefined) {
              return; // the "touch" property is only defined in SDL
  
            }
            var adjustedX = touch.pageX - (scrollX + rect.left);
            var adjustedY = touch.pageY - (scrollY + rect.top);
  
            adjustedX = adjustedX * (cw / rect.width);
            adjustedY = adjustedY * (ch / rect.height);
  
            var coords = { x: adjustedX, y: adjustedY };
  
            if (event.type === 'touchstart') {
              Browser.lastTouches[touch.identifier] = coords;
              Browser.touches[touch.identifier] = coords;
            } else if (event.type === 'touchend' || event.type === 'touchmove') {
              var last = Browser.touches[touch.identifier];
              if (!last) last = coords;
              Browser.lastTouches[touch.identifier] = last;
              Browser.touches[touch.identifier] = coords;
            }
            return;
          }
  
          var x = event.pageX - (scrollX + rect.left);
          var y = event.pageY - (scrollY + rect.top);
  
          // the canvas might be CSS-scaled compared to its backbuffer;
          // SDL-using content will want mouse coordinates in terms
          // of backbuffer units.
          x = x * (cw / rect.width);
          y = y * (ch / rect.height);
  
          Browser.mouseMovementX = x - Browser.mouseX;
          Browser.mouseMovementY = y - Browser.mouseY;
          Browser.mouseX = x;
          Browser.mouseY = y;
        }
      },asyncLoad:function(url, onload, onerror, noRunDep) {
        var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
        readAsync(url, function(arrayBuffer) {
          assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
          onload(new Uint8Array(arrayBuffer));
          if (dep) removeRunDependency(dep);
        }, function(event) {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        });
        if (dep) addRunDependency(dep);
      },resizeListeners:[],updateResizeListeners:function() {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setCanvasSize:function(width, height, noUpdates) {
        var canvas = Module['canvas'];
        Browser.updateCanvasDimensions(canvas, width, height);
        if (!noUpdates) Browser.updateResizeListeners();
      },windowedWidth:0,windowedHeight:0,setFullscreenCanvasSize:function() {
        // check if SDL is available
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[((SDL.screen)>>2)];
          flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
          HEAP32[((SDL.screen)>>2)]=flags
        }
        Browser.updateCanvasDimensions(Module['canvas']);
        Browser.updateResizeListeners();
      },setWindowedCanvasSize:function() {
        // check if SDL is available
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[((SDL.screen)>>2)];
          flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
          HEAP32[((SDL.screen)>>2)]=flags
        }
        Browser.updateCanvasDimensions(Module['canvas']);
        Browser.updateResizeListeners();
      },updateCanvasDimensions:function(canvas, wNative, hNative) {
        if (wNative && hNative) {
          canvas.widthNative = wNative;
          canvas.heightNative = hNative;
        } else {
          wNative = canvas.widthNative;
          hNative = canvas.heightNative;
        }
        var w = wNative;
        var h = hNative;
        if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {
          if (w/h < Module['forcedAspectRatio']) {
            w = Math.round(h * Module['forcedAspectRatio']);
          } else {
            h = Math.round(w / Module['forcedAspectRatio']);
          }
        }
        if (((document['fullscreenElement'] || document['mozFullScreenElement'] ||
             document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
             document['webkitCurrentFullScreenElement']) === canvas.parentNode) && (typeof screen != 'undefined')) {
           var factor = Math.min(screen.width / w, screen.height / h);
           w = Math.round(w * factor);
           h = Math.round(h * factor);
        }
        if (Browser.resizeCanvas) {
          if (canvas.width  != w) canvas.width  = w;
          if (canvas.height != h) canvas.height = h;
          if (typeof canvas.style != 'undefined') {
            canvas.style.removeProperty( "width");
            canvas.style.removeProperty("height");
          }
        } else {
          if (canvas.width  != wNative) canvas.width  = wNative;
          if (canvas.height != hNative) canvas.height = hNative;
          if (typeof canvas.style != 'undefined') {
            if (w != wNative || h != hNative) {
              canvas.style.setProperty( "width", w + "px", "important");
              canvas.style.setProperty("height", h + "px", "important");
            } else {
              canvas.style.removeProperty( "width");
              canvas.style.removeProperty("height");
            }
          }
        }
      },wgetRequests:{},nextWgetRequestHandle:0,getNextWgetRequestHandle:function() {
        var handle = Browser.nextWgetRequestHandle;
        Browser.nextWgetRequestHandle++;
        return handle;
      }};
  
  function runAndAbortIfError(func) {
      try {
        return func();
      } catch (e) {
        abort(e);
      }
    }var Asyncify={State:{Normal:0,Unwinding:1,Rewinding:2},state:0,StackSize:4096,currData:null,handleSleepReturnValue:0,exportCallStack:[],callStackNameToId:{},callStackIdToFunc:{},callStackId:0,afterUnwind:null,asyncFinalizers:[],sleepCallbacks:[],getCallStackId:function(funcName) {
        var id = Asyncify.callStackNameToId[funcName];
        if (id === undefined) {
          id = Asyncify.callStackId++;
          Asyncify.callStackNameToId[funcName] = id;
          Asyncify.callStackIdToFunc[id] = Module['asm'][funcName];
        }
        return id;
      },instrumentWasmExports:function(exports) {
        var ret = {};
        for (var x in exports) {
          (function(x) {
            var original = exports[x];
            if (typeof original === 'function') {
              ret[x] = function() {
                Asyncify.exportCallStack.push(x);
                try {
                  return original.apply(null, arguments);
                } finally {
                  if (ABORT) return;
                  var y = Asyncify.exportCallStack.pop(x);
                  assert(y === x);
                  if (Asyncify.currData &&
                      Asyncify.state === Asyncify.State.Unwinding &&
                      Asyncify.exportCallStack.length === 0) {
                    // We just finished unwinding.
                    Asyncify.state = Asyncify.State.Normal;
                    runAndAbortIfError(Module['_asyncify_stop_unwind']);
                    if (typeof Fibers !== 'undefined') {
                      Fibers.trampoline();
                    }
                    if (Asyncify.afterUnwind) {
                      Asyncify.afterUnwind();
                      Asyncify.afterUnwind = null;
                    }
                  }
                }
              };
            } else {
              ret[x] = original;
            }
          })(x);
        }
        return ret;
      },allocateData:function() {
        // An asyncify data structure has three fields:
        //  0  current stack pos
        //  4  max stack pos
        //  8  id of function at bottom of the call stack (callStackIdToFunc[id] == js function)
        //
        // The Asyncify ABI only interprets the first two fields, the rest is for the runtime.
        // We also embed a stack in the same memory region here, right next to the structure.
        // This struct is also defined as asyncify_data_t in emscripten/fiber.h
        var ptr = _malloc(12 + Asyncify.StackSize);
        Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
        Asyncify.setDataRewindFunc(ptr);
        return ptr;
      },setDataHeader:function(ptr, stack, stackSize) {
        HEAP32[((ptr)>>2)]=stack;
        HEAP32[(((ptr)+(4))>>2)]=stack + stackSize;
      },setDataRewindFunc:function(ptr) {
        var bottomOfCallStack = Asyncify.exportCallStack[0];
        var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
        HEAP32[(((ptr)+(8))>>2)]=rewindId;
      },getDataRewindFunc:function(ptr) {
        var id = HEAP32[(((ptr)+(8))>>2)];
        var func = Asyncify.callStackIdToFunc[id];
  
  
        return func;
      },handleSleep:function(startAsync) {
        if (ABORT) return;
        noExitRuntime = true;
        if (Asyncify.state === Asyncify.State.Normal) {
          // Prepare to sleep. Call startAsync, and see what happens:
          // if the code decided to call our callback synchronously,
          // then no async operation was in fact begun, and we don't
          // need to do anything.
          var reachedCallback = false;
          var reachedAfterCallback = false;
          startAsync(function(handleSleepReturnValue) {
            if (ABORT) return;
            Asyncify.handleSleepReturnValue = handleSleepReturnValue || 0;
            reachedCallback = true;
            if (!reachedAfterCallback) {
              // We are happening synchronously, so no need for async.
              return;
            }
            Asyncify.state = Asyncify.State.Rewinding;
            runAndAbortIfError(function() { Module['_asyncify_start_rewind'](Asyncify.currData) });
            if (Browser.mainLoop.func) {
              Browser.mainLoop.resume();
            }
            var start = Asyncify.getDataRewindFunc(Asyncify.currData);
            var asyncWasmReturnValue = start();
            if (!Asyncify.currData) {
              // All asynchronous execution has finished.
              // `asyncWasmReturnValue` now contains the final
              // return value of the exported async WASM function.
              //
              // Note: `asyncWasmReturnValue` is distinct from
              // `Asyncify.handleSleepReturnValue`.
              // `Asyncify.handleSleepReturnValue` contains the return
              // value of the last C function to have executed
              // `Asyncify.handleSleep()`, where as `asyncWasmReturnValue`
              // contains the return value of the exported WASM function
              // that may have called C functions that
              // call `Asyncify.handleSleep()`.
              var asyncFinalizers = Asyncify.asyncFinalizers;
              Asyncify.asyncFinalizers = [];
              asyncFinalizers.forEach(function(func) {
                func(asyncWasmReturnValue);
              });
            }
          });
          reachedAfterCallback = true;
          if (!reachedCallback) {
            // A true async operation was begun; start a sleep.
            Asyncify.state = Asyncify.State.Unwinding;
            // TODO: reuse, don't alloc/free every sleep
            Asyncify.currData = Asyncify.allocateData();
            runAndAbortIfError(function() { Module['_asyncify_start_unwind'](Asyncify.currData) });
            if (Browser.mainLoop.func) {
              Browser.mainLoop.pause();
            }
          }
        } else if (Asyncify.state === Asyncify.State.Rewinding) {
          // Stop a resume.
          Asyncify.state = Asyncify.State.Normal;
          runAndAbortIfError(Module['_asyncify_stop_rewind']);
          _free(Asyncify.currData);
          Asyncify.currData = null;
          // Call all sleep callbacks now that the sleep-resume is all done.
          Asyncify.sleepCallbacks.forEach(function(func) {
            func();
          });
        } else {
          abort('invalid state: ' + Asyncify.state);
        }
        return Asyncify.handleSleepReturnValue;
      }};
var FSNode = /** @constructor */ function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;  // root node sets parent to itself
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292/*292*/ | 73/*73*/;
  var writeMode = 146/*146*/;
  Object.defineProperties(FSNode.prototype, {
   read: {
    get: /** @this{FSNode} */function() {
     return (this.mode & readMode) === readMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= readMode : this.mode &= ~readMode;
    }
   },
   write: {
    get: /** @this{FSNode} */function() {
     return (this.mode & writeMode) === writeMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
   },
   isFolder: {
    get: /** @this{FSNode} */function() {
     return FS.isDir(this.mode);
    }
   },
   isDevice: {
    get: /** @this{FSNode} */function() {
     return FS.isChrdev(this.mode);
    }
   }
  });
  FS.FSNode = FSNode;
  FS.staticInit();;
Module["requestFullscreen"] = function Module_requestFullscreen(lockPointer, resizeCanvas) { Browser.requestFullscreen(lockPointer, resizeCanvas) };
  Module["requestAnimationFrame"] = function Module_requestAnimationFrame(func) { Browser.requestAnimationFrame(func) };
  Module["setCanvasSize"] = function Module_setCanvasSize(width, height, noUpdates) { Browser.setCanvasSize(width, height, noUpdates) };
  Module["pauseMainLoop"] = function Module_pauseMainLoop() { Browser.mainLoop.pause() };
  Module["resumeMainLoop"] = function Module_resumeMainLoop() { Browser.mainLoop.resume() };
  Module["getUserMedia"] = function Module_getUserMedia() { Browser.getUserMedia() }
  Module["createContext"] = function Module_createContext(canvas, useWebGL, setInModule, webGLContextAttributes) { return Browser.createContext(canvas, useWebGL, setInModule, webGLContextAttributes) };
var ASSERTIONS = false;

/**
 * @license
 * Copyright 2017 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

/**
 * Decodes a base64 string.
 * @param {string} input The string to decode.
 */
var decodeBase64 = typeof atob === 'function' ? atob : function (input) {
  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  var output = '';
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0;
  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  do {
    enc1 = keyStr.indexOf(input.charAt(i++));
    enc2 = keyStr.indexOf(input.charAt(i++));
    enc3 = keyStr.indexOf(input.charAt(i++));
    enc4 = keyStr.indexOf(input.charAt(i++));

    chr1 = (enc1 << 2) | (enc2 >> 4);
    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
    chr3 = ((enc3 & 3) << 6) | enc4;

    output = output + String.fromCharCode(chr1);

    if (enc3 !== 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 !== 64) {
      output = output + String.fromCharCode(chr3);
    }
  } while (i < input.length);
  return output;
};

// Converts a string of base64 into a byte array.
// Throws error on invalid input.
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE) {
    var buf;
    try {
      // TODO: Update Node.js externs, Closure does not recognize the following Buffer.from()
      /**@suppress{checkTypes}*/
      buf = Buffer.from(s, 'base64');
    } catch (_) {
      buf = new Buffer(s, 'base64');
    }
    return new Uint8Array(buf['buffer'], buf['byteOffset'], buf['byteLength']);
  }

  try {
    var decoded = decodeBase64(s);
    var bytes = new Uint8Array(decoded.length);
    for (var i = 0 ; i < decoded.length ; ++i) {
      bytes[i] = decoded.charCodeAt(i);
    }
    return bytes;
  } catch (_) {
    throw new Error('Converting base64 string to bytes failed.');
  }
}

// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }

  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}


var asmGlobalArg = {};
var asmLibraryArg = { "__assert_fail": ___assert_fail, "__clock_gettime": ___clock_gettime, "__sys_access": ___sys_access, "__sys_chdir": ___sys_chdir, "__sys_chown32": ___sys_chown32, "__sys_dup": ___sys_dup, "__sys_dup2": ___sys_dup2, "__sys_dup3": ___sys_dup3, "__sys_fchdir": ___sys_fchdir, "__sys_fchown32": ___sys_fchown32, "__sys_fcntl64": ___sys_fcntl64, "__sys_fdatasync": ___sys_fdatasync, "__sys_ftruncate64": ___sys_ftruncate64, "__sys_getcwd": ___sys_getcwd, "__sys_getegid32": ___sys_getegid32, "__sys_geteuid32": ___sys_geteuid32, "__sys_getgid32": ___sys_getgid32, "__sys_getpgid": ___sys_getpgid, "__sys_getpid": ___sys_getpid, "__sys_getppid": ___sys_getppid, "__sys_getuid32": ___sys_getuid32, "__sys_ioctl": ___sys_ioctl, "__sys_lchown32": ___sys_lchown32, "__sys_link": ___sys_link, "__sys_nice": ___sys_nice, "__sys_open": ___sys_open, "__sys_pause": ___sys_pause, "__sys_read": ___sys_read, "__sys_readlink": ___sys_readlink, "__sys_rename": ___sys_rename, "__sys_rmdir": ___sys_rmdir, "__sys_setpgid": ___sys_setpgid, "__sys_setsid": ___sys_setsid, "__sys_stat64": ___sys_stat64, "__sys_symlink": ___sys_symlink, "__sys_sync": ___sys_sync, "__sys_truncate64": ___sys_truncate64, "__sys_unlink": ___sys_unlink, "_exit": __exit, "abort": _abort, "alarm": _alarm, "asctime": _asctime, "chroot": _chroot, "clock": _clock, "confstr": _confstr, "ctime": _ctime, "difftime": _difftime, "em_exit": em_exit, "em_getchar_sync": em_getchar_sync, "em_stop": em_stop, "emscripten_get_sbrk_ptr": _emscripten_get_sbrk_ptr, "emscripten_longjmp": _emscripten_longjmp, "emscripten_memcpy_big": _emscripten_memcpy_big, "emscripten_resize_heap": _emscripten_resize_heap, "emscripten_sleep": _emscripten_sleep, "environ_get": _environ_get, "environ_sizes_get": _environ_sizes_get, "exit": _exit, "fd_close": _fd_close, "fd_fdstat_get": _fd_fdstat_get, "fd_read": _fd_read, "fd_seek": _fd_seek, "fd_sync": _fd_sync, "fd_write": _fd_write, "fork": _fork, "fpathconf": _fpathconf, "getTempRet0": getTempRet0, "gmtime": _gmtime, "gmtime_r": _gmtime_r, "invoke_ii": invoke_ii, "invoke_iii": invoke_iii, "invoke_v": invoke_v, "invoke_vi": invoke_vi, "invoke_vii": invoke_vii, "invoke_viii": invoke_viii, "invoke_viiiiiii": invoke_viiiiiii, "localtime": _localtime, "memory": wasmMemory, "mktime": _mktime, "nanosleep": _nanosleep, "pathconf": _pathconf, "saveSetjmp": _saveSetjmp, "setTempRet0": setTempRet0, "setitimer": _setitimer, "signal": _signal, "strftime": _strftime, "strptime": _strptime, "sysconf": _sysconf, "system": _system, "table": wasmTable, "testSetjmp": _testSetjmp, "time": _time, "timegm": _timegm, "usleep": _usleep, "vfork": _vfork };
var asm = createWasm();
Module["asm"] = asm;
/** @type {function(...*):?} */
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
  return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _main = Module["_main"] = function() {
  return (_main = Module["_main"] = Module["asm"]["main"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _malloc = Module["_malloc"] = function() {
  return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _free = Module["_free"] = function() {
  return (_free = Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var ___errno_location = Module["___errno_location"] = function() {
  return (___errno_location = Module["___errno_location"] = Module["asm"]["__errno_location"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _realloc = Module["_realloc"] = function() {
  return (_realloc = Module["_realloc"] = Module["asm"]["realloc"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var __get_tzname = Module["__get_tzname"] = function() {
  return (__get_tzname = Module["__get_tzname"] = Module["asm"]["_get_tzname"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var __get_daylight = Module["__get_daylight"] = function() {
  return (__get_daylight = Module["__get_daylight"] = Module["asm"]["_get_daylight"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var __get_timezone = Module["__get_timezone"] = function() {
  return (__get_timezone = Module["__get_timezone"] = Module["asm"]["_get_timezone"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _setThrew = Module["_setThrew"] = function() {
  return (_setThrew = Module["_setThrew"] = Module["asm"]["setThrew"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_v = Module["dynCall_v"] = function() {
  return (dynCall_v = Module["dynCall_v"] = Module["asm"]["dynCall_v"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_vi = Module["dynCall_vi"] = function() {
  return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["dynCall_vi"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_vii = Module["dynCall_vii"] = function() {
  return (dynCall_vii = Module["dynCall_vii"] = Module["asm"]["dynCall_vii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_viii = Module["dynCall_viii"] = function() {
  return (dynCall_viii = Module["dynCall_viii"] = Module["asm"]["dynCall_viii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_viiiiiii = Module["dynCall_viiiiiii"] = function() {
  return (dynCall_viiiiiii = Module["dynCall_viiiiiii"] = Module["asm"]["dynCall_viiiiiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_ii = Module["dynCall_ii"] = function() {
  return (dynCall_ii = Module["dynCall_ii"] = Module["asm"]["dynCall_ii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iii = Module["dynCall_iii"] = function() {
  return (dynCall_iii = Module["dynCall_iii"] = Module["asm"]["dynCall_iii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackSave = Module["stackSave"] = function() {
  return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackAlloc = Module["stackAlloc"] = function() {
  return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackRestore = Module["stackRestore"] = function() {
  return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var __growWasmMemory = Module["__growWasmMemory"] = function() {
  return (__growWasmMemory = Module["__growWasmMemory"] = Module["asm"]["__growWasmMemory"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_viiii = Module["dynCall_viiii"] = function() {
  return (dynCall_viiii = Module["dynCall_viiii"] = Module["asm"]["dynCall_viiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiii = Module["dynCall_iiii"] = function() {
  return (dynCall_iiii = Module["dynCall_iiii"] = Module["asm"]["dynCall_iiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_jiji = Module["dynCall_jiji"] = function() {
  return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["dynCall_jiji"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iidiiii = Module["dynCall_iidiiii"] = function() {
  return (dynCall_iidiiii = Module["dynCall_iidiiii"] = Module["asm"]["dynCall_iidiiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _asyncify_start_unwind = Module["_asyncify_start_unwind"] = function() {
  return (_asyncify_start_unwind = Module["_asyncify_start_unwind"] = Module["asm"]["asyncify_start_unwind"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _asyncify_stop_unwind = Module["_asyncify_stop_unwind"] = function() {
  return (_asyncify_stop_unwind = Module["_asyncify_stop_unwind"] = Module["asm"]["asyncify_stop_unwind"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _asyncify_start_rewind = Module["_asyncify_start_rewind"] = function() {
  return (_asyncify_start_rewind = Module["_asyncify_start_rewind"] = Module["asm"]["asyncify_start_rewind"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _asyncify_stop_rewind = Module["_asyncify_stop_rewind"] = function() {
  return (_asyncify_stop_rewind = Module["_asyncify_stop_rewind"] = Module["asm"]["asyncify_stop_rewind"]).apply(null, arguments);
};


function invoke_ii(index,a1) {
  var sp = stackSave();
  try {
    return dynCall_ii(index,a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_vii(index,a1,a2) {
  var sp = stackSave();
  try {
    dynCall_vii(index,a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_iii(index,a1,a2) {
  var sp = stackSave();
  try {
    return dynCall_iii(index,a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_vi(index,a1) {
  var sp = stackSave();
  try {
    dynCall_vi(index,a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_viii(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    dynCall_viii(index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_v(index) {
  var sp = stackSave();
  try {
    dynCall_v(index);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7) {
  var sp = stackSave();
  try {
    dynCall_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}


/**
 * @license
 * Copyright 2010 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// === Auto-generated postamble setup entry stuff ===

Module['asm'] = asm;









































































































































var calledRun;


/**
 * @constructor
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
}

var calledMain = false;


dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

function callMain(args) {

  var entryFunction = Module['_main'];


  args = args || [];

  var argc = args.length+1;
  var argv = stackAlloc((argc + 1) * 4);
  HEAP32[argv >> 2] = allocateUTF8OnStack(thisProgram);
  for (var i = 1; i < argc; i++) {
    HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]);
  }
  HEAP32[(argv >> 2) + argc] = 0;


  try {


    var ret = entryFunction(argc, argv);


    // In PROXY_TO_PTHREAD builds, we should never exit the runtime below, as execution is asynchronously handed
    // off to a pthread.
    // if we are saving the stack, then do not call exit, we are not
    // really exiting now, just unwinding the JS stack
    if (!noExitRuntime) {
    // if we're not running an evented main loop, it's time to exit
      exit(ret, /* implicit = */ true);
    }
  }
  catch(e) {
    if (e instanceof ExitStatus) {
      // exit() throws this once it's done to make sure execution
      // has been stopped completely
      return;
    } else if (e == 'unwind') {
      // running an evented main loop, don't immediately exit
      noExitRuntime = true;
      return;
    } else {
      var toLog = e;
      if (e && typeof e === 'object' && e.stack) {
        toLog = [e, e.stack];
      }
      err('exception thrown: ' + toLog);
      quit_(1, e);
    }
  } finally {
    calledMain = true;
  }
}




/** @type {function(Array=)} */
function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }


  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    preMain();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    if (shouldRunNow) callMain(args);

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
}
Module['run'] = run;


/** @param {boolean|number=} implicit */
function exit(status, implicit) {

  // if this is just main exit-ing implicitly, and the status is 0, then we
  // don't need to do anything here and can just leave. if the status is
  // non-zero, though, then we need to report it.
  // (we may have warned about this earlier, if a situation justifies doing so)
  if (implicit && noExitRuntime && status === 0) {
    return;
  }

  if (noExitRuntime) {
  } else {

    ABORT = true;
    EXITSTATUS = status;

    exitRuntime();

    if (Module['onExit']) Module['onExit'](status);
  }

  quit_(status, new ExitStatus(status));
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;

if (Module['noInitialRun']) shouldRunNow = false;


  noExitRuntime = true;

run();





// {{MODULE_ADDITIONS}}



